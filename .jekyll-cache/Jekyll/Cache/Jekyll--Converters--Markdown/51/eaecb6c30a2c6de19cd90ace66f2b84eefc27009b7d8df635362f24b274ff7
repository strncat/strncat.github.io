I"S0<p>The prime \(41\), can be written as the sum of six consecutive primes \(2 + 3 + 5 + 7 + 11 + 13\). The goal of this problem is to find the prime below one-million that can be written as the sum of the most consecutive primes. 
<br />
<!------------------------------------------------------------------------------------></p>
<h3>Solution&lt;/b&gt;&lt;/h4&gt;
It took me a few attempts to get this one right. The first few recurrences that I was trying to build didn't go anywhere and one of them was this two dimensional table that included every sum of the primes between any pair of prime numbers $$i$$ and $$j$$. But that was too much. After a few more attempts on paper, I noticed one critical pattern that led to a reasonable solution. To see this, write down the first few consecutive sums below
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>Prime</td>
    <td>\(2\)</td>
    <td>\(3\)</td>
    <td>\(5\)</td>
	<td>\(7\)</td>
	<td>\(11\)</td>
	<td>\(13\)</td>
	<td>\(17\)</td>
	<td>\(...\)</td>
  </tr>
  <tr>
    <td>Sum</td>
    <td>\(2\)</td>
    <td>\(5\)</td>
    <td>\(10\)</td>
	<td>\(17\)</td>
	<td>\(28\)</td>
	<td>\(41\)</td>
	<td>\(58\)</td>
	<td>\(...\)</td>
  </tr>
</table>
</div>
Now notice that if we wanted to find the sum of primes between $$3$$ and $$11$$ not including $$3$$, then we can use the table above to see that it is 
<div>
	$$
	\begin{align*}
	 sum(11) - sum(3) &amp;= 28 - 5 = 23
	\end{align*}
	$$
</div>
which is exactly the sum of primes $$5 + 7 + 11$$. So for any two primes $$i$$ and $$j$$, the sum of the primes between them (while including $$j$$ and not $$i$$) is 
<div>
	$$
	\begin{align*}
	 sum(j) - sum(i)
	\end{align*}
	$$
</div>
This idea is crucial. Because all we have to do now is try all prime pairs below 1 million and we'll get an $$O(n^2)$$ algorithm instead of an exponential one. All we need to do is to pre-compute that table with all the sums and then write a double loop to find the prime that can be written as the sum of the most consecutive primes.
<!------------------------------------------------------------------------------------>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">cons_sum</span> <span class="o">=</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">-</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">second</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">cons_sum</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cons_sum</span><span class="p">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span></code></pre></figure>

<br />
<!------------------------------------------------------------------------------------>
But checking every pair below one million is a lot. Does prime_numbers above need to have all the prime numbers below 1 million? No! Another critical hint to this problem that I completely missed is that the prime we're trying to find has to be below a million. In fact, the sum of the first $$546$$ primes will already exceed a million! Therefore, we can limit the search to a much smaller range of prime numbers.
<!------------------------------------------------------------------------------------>
<br />

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prime_numbers</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">consecutive_sums</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">prime_sums</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// fake prime</span>
    <span class="n">consecutive_sums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span>  <span class="mi">546</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c1">// we don't need more than that!</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<br />
<!------------------------------------------------------------------------------------>
Finally, the method to precompute the prime_numbers array is the usual sieve method that we've used over and over again before. Adding it below for completion.
<!------------------------------------------------------------------------------------>
<br />

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">prime</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0050-consecutive-prime-sum.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------>
<h3>References&lt;/b&gt;&lt;/h4&gt;
<a href="https://projecteuler.net/problem=50">Project Euler - 50</a>
<br />
<br />


</h3></h3>
:ET