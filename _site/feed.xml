<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-07T15:25:02-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">10003 - Cutting Sticks</title><link href="http://localhost:4000/jekyll/update/2020/05/05/10003-cutting-sticks.html" rel="alternate" type="text/html" title="10003 - Cutting Sticks" /><published>2020-05-05T12:01:36-07:00</published><updated>2020-05-05T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/05/10003-cutting-sticks</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/05/10003-cutting-sticks.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry><entry><title type="html">B-Trees</title><link href="http://localhost:4000/jekyll/update/2020/05/04/b-trees.html" rel="alternate" type="text/html" title="B-Trees" /><published>2020-05-04T01:01:36-07:00</published><updated>2020-05-04T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/04/b-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/04/b-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/b-trees/b-tree.png&quot; width=&quot;100%&quot; /&gt;
B-trees are balanced search trees. While red-black trees are also balanced search trees, their branching factor is only 2. B-trees differ in that their branching factor can be really large. The number of keys in a B-tree node determines the number of its children. A node with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; keys have &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; children. This way, each child handles a specific range of keys in its parent. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Motivation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;But why do we need a large branching factor? The motivation behind this idea has to do with minimizing disk I/O operations. Data on disk can be read in &lt;i&gt;pages&lt;/i&gt; and so if each node’s size is a whole page in which we pack a lot of keys in, we can then minimize the number of read operations. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Specifications&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; be an internal node and let &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; be the number of keys stored at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; must have &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; children. Furthermore, the keys are stored in non-decreasing order. Leaf nodes on the other hand have no children. No restrictions on the number of children of the root.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The minimum degree of a b-tree is an integer, &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;t \geq 2&lt;/script&gt;. Every node besides the root must have between &lt;script type=&quot;math/tex&quot;&gt;t-1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;2t-1&lt;/script&gt; keys. This also implies that it must have at least &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; children and at most &lt;script type=&quot;math/tex&quot;&gt;2t&lt;/script&gt; children. If the tree is not empty, the root must be at least have 1 key.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The keys in each node are stored in non-decreasing order. The keys also define the range of keys stored in the children subtrees below. In the above figure, We see the range [0,23] defines the range for the child keys below [11,19]. Similarly [23,53] defines the range for the next child’s keys [29,43].
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;Why are B-trees balanced?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;To see why B-trees balanced, we will prove that the maximum height of a b-tree of degree &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; keys is &lt;script type=&quot;math/tex&quot;&gt;O(\log_t(n))&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Proof: We know the tree is not empty and so at level 0, the root must at least have 1 key. At level 1 we must have two children, each of which must have at least &lt;script type=&quot;math/tex&quot;&gt;t-1&lt;/script&gt; keys, so the total number of keys is &lt;script type=&quot;math/tex&quot;&gt;2(t-1)&lt;/script&gt;. Each of these children will have at least &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; children and so at level 2, we should have &lt;script type=&quot;math/tex&quot;&gt;2t(t-1)&lt;/script&gt; keys. Therefore, the total number of keys is at least&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n &amp;amp;\geq 1 + 2(t-1) + 2t(t-1) + 2t^2(t-1) + ... + 2t^{h-1}(t-1) \\
&amp;amp;= 1 + 2(t-1)(1 + t + t^2 + ... t^{h-1}) \\
&amp;amp;= 1 + 2(t-1)\frac{t^h - 1}{t - 1} \text{ (using } \sum_{k=0}^{n}x^k = \frac{x^{n+1} - 1}{x - 1} ) \\
&amp;amp;= 1 + 2(t^h - 1) \\
&amp;amp;= 2t^h - 1 \\
\log_t(\frac{n + 1}{2}) &amp;amp;\geq \log_t(h) \\
h &amp;amp;\leq \log_t(\frac{n + 1}{2}). \blacksquare
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Search&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similar searching in a binary tree, we descend down the tree and select the right branch based on the key value. If the current node has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; keys then we will have &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; branches that might be a possible match.
&lt;img src=&quot;http://localhost:4000/assets/trees/b-trees/search.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
In the figure above, suppose we’re searching for &lt;script type=&quot;math/tex&quot;&gt;k = 84&lt;/script&gt;. Each node stores an array of its keys. We first find the smallest index such that &lt;script type=&quot;math/tex&quot;&gt;k \leq keys[i]&lt;/script&gt;. We then find &lt;script type=&quot;math/tex&quot;&gt;i = 3&lt;/script&gt;. We have several cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;k = keys[i]&lt;/script&gt;. This is great, we just return that node with the index.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; keys[i] %]]&gt;&lt;/script&gt;. This means the &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; falls somewhere between the key at index &lt;script type=&quot;math/tex&quot;&gt;i-1&lt;/script&gt; and index &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. This range corresponds to the child at index &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;The node we’re searching is a leaf node. We just return NULL.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// search a b-tree of degree t &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// search for the smallest index such that k &amp;lt;= keys[i]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// this means k will be in the range (keys[i-1], keys[i])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// three possible cases&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) we found the right key&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no more possible matches&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Delete&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CLRS&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.stanford.edu/class/cs166/lectures/05/Small05.pdf&quot;&gt;Stanford CS166&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">B-trees are balanced search trees. While red-black trees are also balanced search trees, their branching factor is only 2. B-trees differ in that their branching factor can be really large. The number of keys in a B-tree node determines the number of its children. A node with keys have children. This way, each child handles a specific range of keys in its parent. Motivation But why do we need a large branching factor? The motivation behind this idea has to do with minimizing disk I/O operations. Data on disk can be read in pages and so if each node’s size is a whole page in which we pack a lot of keys in, we can then minimize the number of read operations. Specifications Let be an internal node and let be the number of keys stored at . must have children. Furthermore, the keys are stored in non-decreasing order. Leaf nodes on the other hand have no children. No restrictions on the number of children of the root.</summary></entry><entry><title type="html">Eulerian Paths and Tours</title><link href="http://localhost:4000/jekyll/update/2020/05/02/euler.html" rel="alternate" type="text/html" title="Eulerian Paths and Tours" /><published>2020-05-02T12:01:36-07:00</published><updated>2020-05-02T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/02/euler</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/02/euler.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/euler.png&quot; width=&quot;100%&quot; /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a connected undirected a graph. An &lt;b&gt;Eulerian path&lt;/b&gt; is a path in a graph that traverses each edge exactly once and an &lt;b&gt;Eulerian tour, circuit or cycle&lt;/b&gt; is an Eulerian path that starts and ends at the same vertex. Note that in both definitions, we can traverse any vertex more than once. It is named after Euler because in 1736 Euler proved that crossing all the seven bridges in Königsberg without crossing any bridge more than once is impossible (left figure). For more details, refer to &lt;a href=&quot;https://en.wikipedia.org/wiki/Seven_Bridges_of_Königsberg&quot;&gt;this Wikipedia article&lt;/a&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;When do we have an Eulerian tour?&lt;/b&gt;&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a connected undirected graph. &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an Eulerian tour if and only if every vertex in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an even degree.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In the left figure above, it’s impossible to have an Eulerian tour since not every node has an even degree. However, the right figure has an Eulerian cycle and every node is of even degree.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Proof:&lt;/i&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be an undirected graph. We’ll prove both directions below,&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(\Rightarrow)&lt;/script&gt;: Since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an Eulerian cycle, we must traverse at least two edges every time we pass through a vertex except for the start and end vertex. This means that degree of these vertices must be even. Since the start and the end vertex are the same, then this vertex must also have an even degree.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(\Leftarrow)&lt;/script&gt;: Start traversing at an arbitrary vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. Since all vertices are of even degree and &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected, then we are guaranteed to return to &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and we cannot get stuck at any other vertex. Let &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; be any other vertex than &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. Suppose we get stuck at &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;. We claim that it is impossible, since &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and the node we get stuck at will both be of odd degree and this is a contradiction to our assumption of all nodes having even degrees. After we return, we would have constructed a cycle in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, call it &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. if every edge in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; was in &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;, then we are done. Otherwise, we must have some vertices in &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; that still have edges which were not traversed because &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected. Choose a vertex and start traversing the remaining edges. We are again guaranteed to return to the same vertex because of the even degree property. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/proof.png&quot; width=&quot;100%&quot; /&gt;
We can combine both cycles to form a bigger cycle. We can then repeat the same steps until no edges are left in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. We are able to find all cycles and merge them since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected. Therefore, the cycle must be an Eulerian cycle as we wanted to show.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Assuming every node is of even degree, from the proof above, it is clear that the way to discover an Eulerian cycle is by discovering the cycles one at a time and then merging all cycles together. This sounds hard. Fortunately, there is really smart idea of using two stacks, one to traverse the current cycle and one that collects all the nodes in the final big cycle. This makes the algorithm run in only &lt;script type=&quot;math/tex&quot;&gt;O(E+V)&lt;/script&gt; time, which is fantastic! 
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// pick some node&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// now traverse it's edges&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (a) consider an edge between the current node and any of its neighbors&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Edge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 

        &lt;span class=&quot;c1&quot;&gt;// (b) if it's used then we'll check another. If it's not then mark it used&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// mark it used&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// (c) push current_node back on the stack so we can go back to it (backtrack to it)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// push current_node&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// (d) move to the other end of edge to process it&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// this node is now part of the big final cycle&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The best way to proceed with this algorithm is with an example.
&lt;br /&gt;
&lt;br /&gt;
We initially push any node of choice on “stack”, we pick &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. We then pop a node from the stack and set the current node to &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. We then proceed to traverse the cycle starting at &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. We do so by selecting one of its unvisited edges. We pick the edge &lt;script type=&quot;math/tex&quot;&gt;a-b&lt;/script&gt; and mark it as used. We then push &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; on “stack”. We switch the current node to the other end of the edge which is &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. We traverse an unvisited edge incident to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. This time it’s &lt;script type=&quot;math/tex&quot;&gt;b-f&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We repeat the above steps and set the current node to &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and pick &lt;script type=&quot;math/tex&quot;&gt;f-d&lt;/script&gt;. We then move to &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; and pick &lt;script type=&quot;math/tex&quot;&gt;d-a&lt;/script&gt;, show in the figures below,
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When setting the current node to &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;, this time we don’t have edges to traverse. At this point it means that we reached a cycle. This cycle is “a-b-d-f”. So now we want to push this cycle onto “cycle”. We push &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and then pop &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; and push it as well. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We next pop &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; in order to push it as well. However, this is where the magic happens. &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; has unvisited edges. This means that there must be a new cycle that starts at &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;. Instead of pushing &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; to complete the original cycle “a-d-b-f”, we explore this new cycle first, push it and then go back to complete pushing the original cycle! We set the current node to &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and start traversing this new cycle by traversing &lt;script type=&quot;math/tex&quot;&gt;f-e&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We repeat the same steps by pushing &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; back on “stack” and setting the current node to &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;. We then explore &lt;script type=&quot;math/tex&quot;&gt;e-c&lt;/script&gt; and push &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; on “stack”. We then explore &lt;script type=&quot;math/tex&quot;&gt;b-c&lt;/script&gt; and push $$c$ on “stack”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/5.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We set the current node to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; below and explore &lt;script type=&quot;math/tex&quot;&gt;b-f&lt;/script&gt;. Finally we set the current node to &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and this is where no longer have unvisited edges, meaning that we reach the end of the cycle we’re traversing. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/6.png&quot; width=&quot;100%&quot; /&gt;
We start popping the nodes from “stack” and pushing them onto “cycle”. We stop this process if we arrive at any node with unvisited edges. However, this time we don’t see any more unvisited edges and we end up pushing the whole cycle plus the original cycle on “cycle”. And we’re done!
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/7.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;What about directed graphs?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similar to the undirected case. Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a strongly connected graph. An &lt;b&gt;Eulerian path&lt;/b&gt; is a path in a graph that traverses each edge exactly once and an &lt;b&gt;Eulerian tour&lt;/b&gt; is an Eulerian path that starts and ends at the same vertex. Moreover,&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an Eulerian tour if and only if for every vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, in-degree(&lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;) = out-degree(&lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;).&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt;
TODO&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.math.caltech.edu/~2014-15/1term/ma006a/class8.pdf&quot;&gt;Proof&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://algs4.cs.princeton.edu/41graph/EulerianCycle.java&quot;&gt;Implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Let be a connected undirected a graph. An Eulerian path is a path in a graph that traverses each edge exactly once and an Eulerian tour, circuit or cycle is an Eulerian path that starts and ends at the same vertex. Note that in both definitions, we can traverse any vertex more than once. It is named after Euler because in 1736 Euler proved that crossing all the seven bridges in Königsberg without crossing any bridge more than once is impossible (left figure). For more details, refer to this Wikipedia article. When do we have an Eulerian tour?</summary></entry><entry><title type="html">Red Black Trees</title><link href="http://localhost:4000/jekyll/update/2020/05/01/red-black-trees.html" rel="alternate" type="text/html" title="Red Black Trees" /><published>2020-05-01T12:01:36-07:00</published><updated>2020-05-01T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/01/red-black-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/01/red-black-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/red-black-trees/red-black-tree.png&quot; width=&quot;100%&quot; /&gt;
We previously discussed binary search trees and how the binary search tree property allows us to do tree operations such as insert and delete in just &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; time. However, if the tree height is of order &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;, then we end up with a worse data structure than just a linked list or a sorted array. What we need is a guarantee that the height is &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. How can we achieve this?
&lt;br /&gt;&lt;br /&gt;
A red-black tree is a binary search tree that is balanced. By only adding one extra bit to store the color of the node (red or black) and some restrictions on how to insert and delete nodes, we can have a balanced binary search tree that guarantees the height to be &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Red-black tree specifications&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;A red-black tree must satisfy the following properties:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Every node is either red or black.&lt;/li&gt;
  &lt;li&gt;The root is black.&lt;/li&gt;
  &lt;li&gt;Every leaf node is black.&lt;/li&gt;
  &lt;li&gt;If a node is red, then its children are black.&lt;/li&gt;
  &lt;li&gt;The number of black nodes must be the same across all simple paths from any node to a leaf node.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;Why are red-black trees balanced?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Why do the above properties guarantee anything about the tree being balanced? Intuitively, just restricting the number of black nodes to be the same across all simple paths means that we will have a balanced tree. The red nodes are there to give us some buffer. We could have extra “red” nodes but not a lot in order to keep the height at &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. 
&lt;br /&gt;&lt;br /&gt;
To show a formal proof, we first need to define the black height of a node. Let &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt; be the &lt;b&gt;black height&lt;/b&gt; of a node. &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt; is number of black nodes from a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; to a leaf but &lt;i&gt;not including &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; itself&lt;/i&gt;. In the above tree, we see that the black height of the root is 2 as every simple path includes exactly 2 black nodes. To show that the height is at most &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;, we want to prove somehow that we have “enough” internal nodes at every node such that the height can’t exceed &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. Formally, we’ll prove&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Given a red-black tree $t$ and a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;, The subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;  contains at least &lt;script type=&quot;math/tex&quot;&gt;2^{bh(x)}-1&lt;/script&gt; internal nodes (including x itself)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Looking at the figure below, we see in the first figure we have &lt;script type=&quot;math/tex&quot;&gt;bh(root)=3&lt;/script&gt; and we have at least &lt;script type=&quot;math/tex&quot;&gt;2^{3}-1=7&lt;/script&gt; nodes. In the second figure, we have &lt;script type=&quot;math/tex&quot;&gt;bh(root)=2&lt;/script&gt; and at least &lt;script type=&quot;math/tex&quot;&gt;2^2-1=3&lt;/script&gt; internal nodes. Similarly, in the third figure, we have &lt;script type=&quot;math/tex&quot;&gt;2^2-1&lt;/script&gt; internal nodes.
&lt;img src=&quot;http://localhost:4000/assets/trees/red-black-trees/internal-nodes.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Proof: By Induction on the height of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. For the base case, consider when the height is 0, then we know that &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is NIL. Therefore, &lt;script type=&quot;math/tex&quot;&gt;2^{bh(x)} - 1 = 1 - 1 = 0&lt;/script&gt;. For the inductive step, suppose &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has some positive height &amp;gt; 0 and has two internal children (why 2?). Each child must have either &lt;script type=&quot;math/tex&quot;&gt;bh(x)-1&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt; black height depending on its color. If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; was red, then both children must be black and the black height of both children is  &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; was black, then both its children must have black height &lt;script type=&quot;math/tex&quot;&gt;bh(x)-1&lt;/script&gt;. Since the height of both children is less than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, then we can apply the inductive hypothesis and conclude that each child must have at least &lt;script type=&quot;math/tex&quot;&gt;2^{bh(x)-1}-1&lt;/script&gt; internal nodes. Therefore, &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has at least &lt;script type=&quot;math/tex&quot;&gt;1 + 2^{bh(x)-1} - 1 + 2^{bh(x)-1} - 1 = 2^{bh(x)} -1&lt;/script&gt; internal nodes which completes the proof. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; 
&lt;br /&gt;
&lt;br /&gt;
To prove that the height of the tree is at most &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;, . The next thing we want to use is that we know that every red node in a red-black tree must have black children. Therefore, half the nodes on any path must be black. Therefore, if the height of the tree is &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;bh(root) \geq h/2&lt;/script&gt;. Using what we proved earlier, we see that&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n &amp;amp;\geq 2^{bh(root))} - 1 \text{ (using the earlier lemma we proved) }\\
n &amp;amp;\geq 2^{h/2} - 1  \text { (using the fact that red nodes must have black children) }\\ 
\log(n-1) &amp;amp;\geq h/2 \\
h/2 &amp;amp;\leq \log(n-1) \\
h &amp;amp;\leq 2\log(n-1). \blacksquare
\end{align*}
$$
&lt;/div&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Rotations&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Operations on red-black trees such as insert and delete modify the tree such that we might violate the red-black tree properties. To restore these properties we perform an essential operation called a rotation. Rotations maintain the binary search property. More on rotations are 
&lt;a href=&quot;https://strncat.github.io/jekyll/update/2019/05/02/binary-tree-rotation.html&quot;&gt;here&lt;/a&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Delete&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/red-black-tree.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">We previously discussed binary search trees and how the binary search tree property allows us to do tree operations such as insert and delete in just time. However, if the tree height is of order , then we end up with a worse data structure than just a linked list or a sorted array. What we need is a guarantee that the height is . How can we achieve this? A red-black tree is a binary search tree that is balanced. By only adding one extra bit to store the color of the node (red or black) and some restrictions on how to insert and delete nodes, we can have a balanced binary search tree that guarantees the height to be . Red-black tree specifications A red-black tree must satisfy the following properties: Every node is either red or black. The root is black. Every leaf node is black. If a node is red, then its children are black. The number of black nodes must be the same across all simple paths from any node to a leaf node. Why are red-black trees balanced? Why do the above properties guarantee anything about the tree being balanced? Intuitively, just restricting the number of black nodes to be the same across all simple paths means that we will have a balanced tree. The red nodes are there to give us some buffer. We could have extra “red” nodes but not a lot in order to keep the height at . To show a formal proof, we first need to define the black height of a node. Let be the black height of a node. is number of black nodes from a node to a leaf but not including itself. In the above tree, we see that the black height of the root is 2 as every simple path includes exactly 2 black nodes. To show that the height is at most , we want to prove somehow that we have “enough” internal nodes at every node such that the height can’t exceed . Formally, we’ll prove</summary></entry><entry><title type="html">Binary Search Trees</title><link href="http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees.html" rel="alternate" type="text/html" title="Binary Search Trees" /><published>2020-04-28T12:01:36-07:00</published><updated>2020-04-28T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/binary-search-tree.png&quot; width=&quot;100%&quot; /&gt;
A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The &lt;b&gt;binary-search-tree property&lt;/b&gt; states that given a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in the tree, every node in the left subtree has a key less than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s key and every node in the right subtree has a key greater than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s key.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Motivation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;But why invent another data structure? Let’s take a look at sorted arrays. We can search a sorted array for keys in just &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time with binary search. However, inserting and deleting elements takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. Similarly, while inserting elements in a linked list takes only &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; time, searching a linked list takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time in the worst case. Can we do better with binary search trees? yes!
&lt;br /&gt;&lt;br /&gt;
The binary search tree property is really great at allowing us to insert/search and delete in just &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; where is &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists!
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;In Order Walk&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. 
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!----------------------&gt;
&lt;p&gt;Proving that it takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof)
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Search&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similar to the in-order walk, we can simply perform a search by using the following
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Minimum, Maximum, Predecessor and Successor&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, we have two cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has a right subtree, then the most left element (tree minimum) of the right subtree is the successor.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; doesn’t have a right subtree, then the next element would be the first ancestor such that &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a left child of it. 
&lt;!----------------------&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;successor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise, find the closest parent where t is a left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Inserting a node into a binary search tree is pretty simple. We need to follow the following steps:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Create a new node and assign both the left and right pointers to NULL.&lt;/li&gt;
  &lt;li&gt;Similar to search, descend in the tree with pointer &lt;script type=&quot;math/tex&quot;&gt;current&lt;/script&gt; based on the key value, while keeping a trailing pointer &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; to its parent. Once we hit NULL, we know that the &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; will be the parent of our node.
The figure below illustrates the process:
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/insert.png&quot; width=&quot;100%&quot; /&gt;
&lt;!----------------------&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// create a new node x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x is now the root!&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Delete&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Before discussing delete, we’ll present a helper function that we will use in deleting a node in a binary search three. &lt;i&gt;transplant&lt;/i&gt; replaces a subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; with another subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, illustrated below, 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/transplant.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// replace subtree u with subtree v&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is the root &lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fix v's parent pointer&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, suppose we’re about to delete node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and that are given a pointer to it
We have four different cases that we need to handle:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has no children. We then can simply delete that node and return. This case could be handled implicitly in the next case. 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has only one child. We then just transplant its child at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s parent and remove &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// one child case&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// delete node x if x has only one child&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its right child&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its left child&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// we're good to remove x's memory using &quot;free&quot; or &quot;delete&quot; or whatever we need&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has two children. The idea here is that the successor of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; will take &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s place to maintain the binary search tree property and then we can just delete &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We do know that the successor is the most left child (minimum node) in &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right subtree. Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be the successor of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. It is also important to note that &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; can’t have left children since it is the most left node by definition. We now break deleting &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; into two sub-cases:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(1) &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is the right child of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.  In this case, we transplant &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s parent. We also move &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s left subtree to be &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;’s left subtree. We then we remove &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// two children first sub-case (s is a right child of x)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is x's immediate right child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree = x's left subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is in the left subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right child. In this case, it’s a little more complicated. We first want to replace &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; (21 in the example) with its right subtree (25 in the example) (remember &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; can’t have a left subtree). We then assign &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right subtree to be &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;’s right subtree. So now the subtree 29 is the right child of 21. Finally just like in the earlier case, simply replace &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; with its right subtree. In this example, it means to replace 19 with 21!
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// two children second sub-case (s is not right child of x)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is not x's immediate right child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace s with its right subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's right subtree = x's right subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// repeat steps from above to replace x with its right child (s)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree is now x's left subtree&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
Finally putting everything together in one place:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// one child case&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its right child&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its left child&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// two children second sub-case (s is not right child of x)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is not x's immediate right child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace s with its right subtree&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's right subtree = x's right subtree&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree is now x's left subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/binary-search-tree.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The binary-search-tree property states that given a node in the tree, every node in the left subtree has a key less than ’s key and every node in the right subtree has a key greater than ’s key. Motivation But why invent another data structure? Let’s take a look at sorted arrays. We can search a sorted array for keys in just time with binary search. However, inserting and deleting elements takes time. Similarly, while inserting elements in a linked list takes only time, searching a linked list takes time in the worst case. Can we do better with binary search trees? yes! The binary search tree property is really great at allowing us to insert/search and delete in just time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be where is is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists! In Order Walk Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. void in_order_walk(tree *t) { if (t == NULL) { return; } in_order_walk(t-&amp;gt;left); print key in_order_walk(t-&amp;gt;right); } Proving that it takes time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof) Search Similar to the in-order walk, we can simply perform a search by using the following tree* search(tree *t, key) { while (t != NULL &amp;amp;&amp;amp; k != t-&amp;gt;key) { if (key &amp;lt; t-&amp;gt;key) { t = t-&amp;gt;left; } else { t = t-&amp;gt;right; } } return t; } Minimum, Maximum, Predecessor and Successor Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node , we have two cases: If has a right subtree, then the most left element (tree minimum) of the right subtree is the successor. If doesn’t have a right subtree, then the next element would be the first ancestor such that is a left child of it. tree* successor(tree *t) { if (t-&amp;gt;right != NULL) { return tree_minimum(t-&amp;gt;right); }; // otherwise, find the closest parent where t is a left child tree *p = t-&amp;gt;parent; while (p != NULL &amp;amp;&amp;amp; p-&amp;gt;right == t) { t = p; p = t-&amp;gt;parent; } return p; } Insert Inserting a node into a binary search tree is pretty simple. We need to follow the following steps: Create a new node and assign both the left and right pointers to NULL. Similar to search, descend in the tree with pointer based on the key value, while keeping a trailing pointer to its parent. Once we hit NULL, we know that the will be the parent of our node. The figure below illustrates the process: void insert(tree **t, key) { // create a new node x p = NULL; current = *t; while (current != NULL) { p = current; if (x-&amp;gt;key &amp;lt; current-&amp;gt;key) { current = current-&amp;gt;left; } else { current = current-&amp;gt;right; } } x.parent = p; if (p == NULL) { // x is now the root! *t = x; } else if (p-&amp;gt;key &amp;gt; x-&amp;gt;key) { p-&amp;gt;left = x; } else { p-&amp;gt;right = x; } } Delete Before discussing delete, we’ll present a helper function that we will use in deleting a node in a binary search three. transplant replaces a subtree rooted at with another subtree rooted at , illustrated below, // replace subtree u with subtree v void transplant(tree **t, tree *u, tree *v) { if (u.parent == NULL) { // u is the root *t = v; } else if (u == u.parent.left) { // u is a left child u.parent.left = v; } else if (u == u.parent.right) { u.parent.right = v; } if (v != NULL) { // fix v's parent pointer v.parent = u.parent } }</summary></entry><entry><title type="html">Floyd-Warshall’s Shortest Paths</title><link href="http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall.html" rel="alternate" type="text/html" title="Floyd-Warshall's Shortest Paths" /><published>2020-04-24T07:01:36-07:00</published><updated>2020-04-24T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall.html">&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a directed weighted graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. Floyd-Warshall’s algorithm is a dynamic programming algorithm that solves the all-pairs shortest paths problem in $O(V^3)$ time given that we don’t have negative-weight cycles in the $G$.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Optimal Substructure&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;V = \{1,2,3,...,n\}&lt;/script&gt; and consider a subset &lt;script type=&quot;math/tex&quot;&gt;S = \{1,2,3,...,k\}&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;S \subseteq V&lt;/script&gt; for some &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; be two vertices in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;. Now, consider all the paths from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; whose intermediate vertices are in &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Intermediate vertices on a path are all the vertices on the path except for the start and end vertex. Let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be a shortest path among the paths from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that are drawn from &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/floyd-warshall/path.png&quot; width=&quot;100%&quot; /&gt;
This is where it gets interesting. There are two cases here. Either &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; or it’s not.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is not on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; then we claim that all the intermediate vertices of &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; are drawn from the set &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can decompose &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; into two shortest paths. A shortest path &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; with intermediate vertices &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt; and a shortest path &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; with intermediate vertices &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt;.
Therefore, we can derive the following:&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 d_{ij}^{k} =\Big\{ \begin{array}{@{}lr@{}}
        w_{ij} \text{ $\quad \quad \quad \quad \quad \quad \quad$ if $k = 0$}\\
        \min (d_{ij}^{k-1}, d_{ik}^{k-1}+d_{jk}^{k-1}) \text{ if $k \geq 0$}\\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Simple Implementation&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;floyd_warshall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// O(n^3)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the shortest path between i and j contains some internal nodes (none repeated, simple path)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// let k be an internal node, either node k is on the optimal path or it's not&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is on the path =&amp;gt; the shortest distance is d[i][k] + d[k][j]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is not on the optimal path =&amp;gt; the shortest distance is dij&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is zero, then the shortest distance is just wij (if it exist) otherwise infinity&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) initialize the distance matrix&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// distance from node to itself is zero&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_ij&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_ij&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// current edge weight&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this edge doesn't exist, set it to infinity&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) apply floyd-warshall&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// number of internal nodes on the path&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                 &lt;span class=&quot;c1&quot;&gt;// current distance vs distance though k (from i to k then k to j)&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Also,
&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/floyd-warshall.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">Let be a directed weighted graph with vertices and edges. Floyd-Warshall’s algorithm is a dynamic programming algorithm that solves the all-pairs shortest paths problem in $O(V^3)$ time given that we don’t have negative-weight cycles in the $G$. Optimal Substructure Let and consider a subset such that for some . Let and be two vertices in . Now, consider all the paths from to whose intermediate vertices are in . Intermediate vertices on a path are all the vertices on the path except for the start and end vertex. Let be a shortest path among the paths from to that are drawn from . This is where it gets interesting. There are two cases here. Either is on or it’s not. If is not on then we claim that all the intermediate vertices of are drawn from the set . If is on , then we can decompose into two shortest paths. A shortest path from to with intermediate vertices and a shortest path from to with intermediate vertices . Therefore, we can derive the following: $$ \begin{align*} d_{ij}^{k} =\Big\{ \begin{array}{@{}lr@{}} w_{ij} \text{ $\quad \quad \quad \quad \quad \quad \quad$ if $k = 0$}\\ \min (d_{ij}^{k-1}, d_{ik}^{k-1}+d_{jk}^{k-1}) \text{ if $k \geq 0$}\\ \end{array} \end{align*} $$ Simple Implementation void floyd_warshall(int n) { // O(n^3) // the shortest path between i and j contains some internal nodes (none repeated, simple path) // let k be an internal node, either node k is on the optimal path or it's not // if k is on the path =&amp;gt; the shortest distance is d[i][k] + d[k][j] // if k is not on the optimal path =&amp;gt; the shortest distance is dij // if k is zero, then the shortest distance is just wij (if it exist) otherwise infinity // (1) initialize the distance matrix int distance[N][N]; for (int i = 1; i &amp;lt;= vertices; i++) { for (int j = 1; j &amp;lt;= vertices; j++) { if (i == j) { distance[i][j] = 0; // distance from node to itself is zero } else if (w_ij exists) { distance[i][j] = w_ij; // current edge weight } else { distance[i][j] = INT_MAX; // this edge doesn't exist, set it to infinity } } } // (2) apply floyd-warshall for (int k = 1; k &amp;lt;= n; k++) { // number of internal nodes on the path for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (distance[i][k] == INT_MAX || distance[k][j] == INT_MAX) { continue; } // current distance vs distance though k (from i to k then k to j) distance[i][j] = std::min(distance[i][j], distance[i][k] + distance[k][j]); } } } } Also, Source Code References CLRS</summary></entry><entry><title type="html">Line Segment Intersection</title><link href="http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection.html" rel="alternate" type="text/html" title="Line Segment Intersection" /><published>2020-04-08T12:01:36-07:00</published><updated>2020-04-08T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/segments.png&quot; width=&quot;100%&quot; /&gt;
Suppose we have two line segments in two dimensions. Each line segment is determined by two given points. How can we determine if the two line segments intersect? Before answering this question, let’s review some concepts.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;What is a line segment?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Given two points &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. A line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; is the set of convex combinations of &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. That is for any point &lt;script type=&quot;math/tex&quot;&gt;p_3&lt;/script&gt; on the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
x_{p_3} = \alpha x_{p_1} + (1-\alpha)x_{p_2} \\
y_{p_3} = \alpha y_{p_1} + (1-\alpha)y_{p_2}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;0 \leq \alpha \leq 1&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are the end points of the line segment.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Straddling&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The algorithm CLRS presents is based on the idea of checking whether each line segment &lt;b&gt;straddles&lt;/b&gt; the line containing the other line segment.
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle.png&quot; width=&quot;100%&quot; /&gt;
In the above figure, consider the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; and the line containing the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We say that &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; straddles the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are on opposite sides of the line. Should this check be enough to guarantee the intersection of both segments? No. Consider the following figure,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-not-crossing-segment.png&quot; width=&quot;100%&quot; /&gt;
In this case, segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; straddles the line but it does intersect the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_4p_3}&lt;/script&gt;. We could fix this by also checking whether &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; straddles the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt;. Should this be enough now to handle everything? Unfortunately, we are still missing a case. Consider the following,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-end-point.png&quot; width=&quot;100%&quot; /&gt;
In this case, one of the end points is on the line and so we’re not exactly on opposite sides of the line. Therefore, we need to check whether &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; falls on the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_4p_3}&lt;/script&gt;. 
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Pseudocode&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// line 1 = p1,p2 and line 2 = p3,p4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;segment_intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// first check whether each segment straddles the line&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// containing the other segment&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_segment_straddling_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;is_segment_straddling_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise check the boundary conditions&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// on_line_segment(px, py, pz) determines if px is &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// on the line segment pypz&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next questions would be how to check whether a line segment is straddling a line and how to check whether a point falls on a line segment. Both of these questions can be answered utilizing cross product.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Cross Product&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/cross-product.png&quot; width=&quot;100%&quot; /&gt;
Given two vectors &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt;. If the cross product &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1} \times \vec{p_2}&lt;/script&gt; is positive, then we say that &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; is clockwise from/relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt; and we turn right at &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. Similarly, if the cross product is negative then we say that &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; is anti-clockwise from/relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt; and we turn left at &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Proof&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;(This is also exercise &lt;script type=&quot;math/tex&quot;&gt;33.1-1&lt;/script&gt;)
&lt;br /&gt;
If the cross product is positive then we know that &lt;script type=&quot;math/tex&quot;&gt;x_1y_2 - x_2y_1 &gt; 0&lt;/script&gt;.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
x_1y_2 - x_2y_1 &amp;gt; 0 \\
x_1y_2 &amp;gt; x_2y_1  \\
\frac{y_2}{x_2} &amp;gt; \frac{y_1}{x_1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Consider now the angle that both vectors make with the positive &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; axis. In the below figure,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/cross-product-proof.png&quot; width=&quot;100%&quot; /&gt;
we see that this angle is given by &lt;script type=&quot;math/tex&quot;&gt;\tan^{-1}{y/x}&lt;/script&gt;. We also know that &lt;script type=&quot;math/tex&quot;&gt;\arctan&lt;/script&gt; is monotone and so since &lt;script type=&quot;math/tex&quot;&gt;\frac{y_2}{x_2} &gt; \frac{y_1}{x_1}&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;\theta_2 &gt; \theta_1&lt;/script&gt;. Therefore, &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; must be clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. Similarly, when the cross product is negative, we will see that &lt;script type=&quot;math/tex&quot;&gt;\frac{y_1}{x_1} &gt; \frac{y_2}{x_2}&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; must be anti-clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt;. (Ref (2)).&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Checking whether a segment is straddling a line&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-vectors.png&quot; width=&quot;100%&quot; /&gt;
Using the above idea, it becomes straight forward to determine whether a segment is straddling a line. Suppose we’re determining if segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; is straddling the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We first find the result of the cross product &lt;script type=&quot;math/tex&quot;&gt;(p_1-p_3) \times (p_4-p_3)&lt;/script&gt;. This will tell us whether &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1-p_3}&lt;/script&gt; is clockwise or anti-clockwise relative to  &lt;script type=&quot;math/tex&quot;&gt;\vec{p_4-p_3}&lt;/script&gt; (left figure). Next, we find &lt;script type=&quot;math/tex&quot;&gt;(p_2-p_3) \times (p_4-p_3)&lt;/script&gt; to determine if &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2-p_3}&lt;/script&gt; is clockwise or anti-clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_4-p_3}&lt;/script&gt; (right figure). Finally, we check if the products have different signs to rule out that &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are on different sides of the line.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Checking whether a point falls on a line segment&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we’re determining if point &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls on the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We first need to determine if all three points &lt;script type=&quot;math/tex&quot;&gt;p_1, p_3&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_4&lt;/script&gt; are colinear. To do so, we can check the cross product we’ve computed previously, namely, &lt;script type=&quot;math/tex&quot;&gt;(p_1-p_3) \times (p_4-p_3)&lt;/script&gt;. If this product is 0, then we know that the three points are colinear. 
&lt;br /&gt;&lt;br /&gt;
Next, we need to determine if the point &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls between the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; or on one of its end points. To do so, we need to check that the x-coordinate of &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls in the range of &lt;script type=&quot;math/tex&quot;&gt;min(x_3,x_4), max(x_3,x_4)&lt;/script&gt; and the y-coordinate falls in the range &lt;script type=&quot;math/tex&quot;&gt;min(y_3,y_4),max(y_3,y_4)&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/geometry/intersection-two-line-segments-clrs.cpp&quot;&gt;Full Implementation&lt;/a&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS Chapter 33
&lt;br /&gt;
&lt;a href=&quot;https://sites.math.rutgers.edu/~ajl213/CLRS/Ch33.pdf&quot;&gt;Cross Product Proof&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Suppose we have two line segments in two dimensions. Each line segment is determined by two given points. How can we determine if the two line segments intersect? Before answering this question, let’s review some concepts. What is a line segment? Given two points and . A line segment is the set of convex combinations of and . That is for any point on the line segment , we have $$ \begin{align*} x_{p_3} = \alpha x_{p_1} + (1-\alpha)x_{p_2} \\ y_{p_3} = \alpha y_{p_1} + (1-\alpha)y_{p_2} \end{align*} $$ where . and are the end points of the line segment. Straddling The algorithm CLRS presents is based on the idea of checking whether each line segment straddles the line containing the other line segment. In the above figure, consider the line segment and the line containing the segment . We say that straddles the line containing if and are on opposite sides of the line. Should this check be enough to guarantee the intersection of both segments? No. Consider the following figure, In this case, segment straddles the line but it does intersect the segment . We could fix this by also checking whether straddles the line containing . Should this be enough now to handle everything? Unfortunately, we are still missing a case. Consider the following, In this case, one of the end points is on the line and so we’re not exactly on opposite sides of the line. Therefore, we need to check whether or falls on the line segment . Pseudocode // line 1 = p1,p2 and line 2 = p3,p4 segment_intersection(p1,p2,p3,p4) { // first check whether each segment straddles the line // containing the other segment if (is_segment_straddling_line(p1,p2,p3,p4) &amp;amp;&amp;amp; is_segment_straddling_line(p3,p4,p1,p2)) { return true; } // otherwise check the boundary conditions // on_line_segment(px, py, pz) determines if px is // on the line segment pypz if (on_line_segment(p1, p3, p4) || on_line_segment(p2, p3, p4) || on_line_segment(p3, p1, p2) || on_line_segment(p4, p1, p2)) { return true; } return false; } The next questions would be how to check whether a line segment is straddling a line and how to check whether a point falls on a line segment. Both of these questions can be answered utilizing cross product. Cross Product Given two vectors and . If the cross product is positive, then we say that is clockwise from/relative to and we turn right at . Similarly, if the cross product is negative then we say that is anti-clockwise from/relative to and we turn left at . Proof (This is also exercise ) If the cross product is positive then we know that . $$ \begin{align*} x_1y_2 - x_2y_1 &amp;gt; 0 \\ x_1y_2 &amp;gt; x_2y_1 \\ \frac{y_2}{x_2} &amp;gt; \frac{y_1}{x_1} \end{align*} $$ Consider now the angle that both vectors make with the positive axis. In the below figure, we see that this angle is given by . We also know that is monotone and so since then we must have . Therefore, must be clockwise relative to . Similarly, when the cross product is negative, we will see that and so must be anti-clockwise relative to . (Ref (2)).</summary></entry><entry><title type="html">Groups</title><link href="http://localhost:4000/jekyll/update/2019/09/07/groups.html" rel="alternate" type="text/html" title="Groups" /><published>2019-09-07T07:01:36-07:00</published><updated>2019-09-07T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/07/groups</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/07/groups.html">&lt;!-------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abstract Algebra: An Introduction, 3rd Edition by Thomas W. Hungerford.&lt;/li&gt;
  &lt;li&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Definition&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A group is a nonempty set of elements with a binary operation that satisfies four properties&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;i&gt;Closure&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a, b \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * b \in G&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Associativity&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a, b, c \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * (b * c) = (a * b) * c&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Identity&lt;/i&gt;: There exists an identity element &lt;script type=&quot;math/tex&quot;&gt;e \in G&lt;/script&gt; such that for any &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * e = e * a = a&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Inverse&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, there exists an inverse element &lt;script type=&quot;math/tex&quot;&gt;a^{-1} \in G&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a * a^{-1} = a^{-1} * a = e&lt;/script&gt;.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Moreover, if the group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; satisfies commutativity so that for all &lt;script type=&quot;math/tex&quot;&gt;a, b \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * b = b * a&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; is an &lt;b&gt;abelian&lt;/b&gt; group. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Order of an Element&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Given a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and an element &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, the order of the element &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;|a|&lt;/script&gt;, is the smallest positive integer &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a^k = e&lt;/script&gt;. If there is no such element then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; has an infinite order.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Example:&lt;/i&gt; 
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Properties of Groups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Given a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, we must have the following&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has a unique identity element.&lt;/li&gt;
  &lt;li&gt;For every &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, there exists a unique inverse &lt;script type=&quot;math/tex&quot;&gt;a^{-1}&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a * a^{-1} = a^{-1} * a = e&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!-------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Subgroups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A subset &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; of a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a &lt;b&gt;subgroup&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is a group under &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;’s operation. We write it as &lt;script type=&quot;math/tex&quot;&gt;H \subseteq G&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;H \neq G&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is a &lt;b&gt;proper subgroup&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and we write &lt;script type=&quot;math/tex&quot;&gt;H \subset G&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Example:&lt;/i&gt; The set &lt;script type=&quot;math/tex&quot;&gt;L=\{1,-1,i,-i\}&lt;/script&gt; is a proper subgroup of &lt;script type=&quot;math/tex&quot;&gt;C^*&lt;/script&gt;, the multiplicative group of complex numbers.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Theorem:&lt;/i&gt; A nonempty subset &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; of a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a subgroup if &lt;br /&gt;
(i) for all &lt;script type=&quot;math/tex&quot;&gt;a, b \in H&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;ab \in H&lt;/script&gt;. &lt;br /&gt;
(ii) for all &lt;script type=&quot;math/tex&quot;&gt;a \in H&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a^{-1} \in H&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Proof: &lt;br /&gt;
The closure property is satisfied by (i). Since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a group then we know associativity holds for all elements including elements in &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt;. The inverse exists by (ii). For the identity element, since &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is not empty then we must have some element &lt;script type=&quot;math/tex&quot;&gt;a \in H&lt;/script&gt;. We also must have &lt;script type=&quot;math/tex&quot;&gt;a^{\prime} \in H&lt;/script&gt; by the inverse property. Therefore, we must have &lt;script type=&quot;math/tex&quot;&gt;aa^{-1} = e \in H&lt;/script&gt; by the closure property. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Subgroups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">References Abstract Algebra: An Introduction, 3rd Edition by Thomas W. Hungerford. Definition A group is a nonempty set of elements with a binary operation that satisfies four properties Closure: For all , we have . Associativity: For all , we have . Identity: There exists an identity element such that for any , we have . Inverse: For all , there exists an inverse element such that .</summary></entry><entry><title type="html">Expectation</title><link href="http://localhost:4000/jekyll/update/2019/09/06/expectation.html" rel="alternate" type="text/html" title="Expectation" /><published>2019-09-06T07:01:36-07:00</published><updated>2019-09-06T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/06/expectation</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/06/expectation.html">&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Expectation&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Recall that the expectation or expected value of a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is defined as:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the expected value is a weighted average of the value of the random variable (weighted by their probabilities). We also studied important properties of expectation&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Linearity of expectation:&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c
\end{align*}
$$
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a random variable, then for any real-valued function &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;,&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[g(X)] &amp;amp;= \sum_ig(x_i)p(x_i)
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Nth Moment&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Define the &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;th moment of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[X^n] &amp;amp;= \sum_{x:p(x)&amp;gt;0} x^np(x)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;From this, we see that the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the first moment of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Variance&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
While the expected value is really useful, we also want to study the spread of the values of random variables. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable with expected value &lt;script type=&quot;math/tex&quot;&gt;E[X]=\mu&lt;/script&gt; and define the variance of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) = E[(X - \mu)^2]
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Expanding this&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) &amp;amp;= E[(X - \mu)^2] \\
&amp;amp;= \sum_i (x_i - \mu)^2p(x_i) \\
&amp;amp;= \sum_i (x_i^2 - 2\mu x_i + \mu^2)p(x_i) \\
&amp;amp;= \sum_i x_i^2p(x_i) - 2\mu x_ip(x_i) + \mu^2p(x_i) \\
&amp;amp;= \sum_i x_i^2p(x_i) - 2\mu \sum_i x_ip(x_i) + \mu^2 \sum_ip(x_i) \\
&amp;amp;= E[X^2] - 2\mu^2 + \mu^2 \\
&amp;amp;= E[X^2] - (E[X])^2 \\
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ Expectation Recall that the expectation or expected value of a random variable is defined as: $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ In other words, the expected value is a weighted average of the value of the random variable (weighted by their probabilities). We also studied important properties of expectation Linearity of expectation: $$ \begin{align*} E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c \end{align*} $$ If is a random variable, then for any real-valued function , $$ \begin{align*} E[g(X)] &amp;amp;= \sum_ig(x_i)p(x_i) \end{align*} $$ Nth Moment Define the th moment of to be $$ \begin{align*} E[X^n] &amp;amp;= \sum_{x:p(x)&amp;gt;0} x^np(x) \end{align*} $$ From this, we see that the expected value of is the first moment of . Variance While the expected value is really useful, we also want to study the spread of the values of random variables. Let be a random variable with expected value and define the variance of to be $$ \begin{align*} Var(X) = E[(X - \mu)^2] \end{align*} $$ Expanding this $$ \begin{align*} Var(X) &amp;amp;= E[(X - \mu)^2] \\ &amp;amp;= \sum_i (x_i - \mu)^2p(x_i) \\ &amp;amp;= \sum_i (x_i^2 - 2\mu x_i + \mu^2)p(x_i) \\ &amp;amp;= \sum_i x_i^2p(x_i) - 2\mu x_ip(x_i) + \mu^2p(x_i) \\ &amp;amp;= \sum_i x_i^2p(x_i) - 2\mu \sum_i x_ip(x_i) + \mu^2 \sum_ip(x_i) \\ &amp;amp;= E[X^2] - 2\mu^2 + \mu^2 \\ &amp;amp;= E[X^2] - (E[X])^2 \\ \end{align*} $$</summary></entry><entry><title type="html">Counting Distinguishable and Indistinguishable Objects</title><link href="http://localhost:4000/jekyll/update/2019/09/05/counting-dist.html" rel="alternate" type="text/html" title="Counting Distinguishable and Indistinguishable Objects" /><published>2019-09-05T07:01:36-07:00</published><updated>2019-09-05T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/05/counting-dist</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/05/counting-dist.html">&lt;h4&gt;&lt;b&gt;(1) k distinguishable strings and n distinguishable buckets&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Label the strings &lt;script type=&quot;math/tex&quot;&gt;s_1, s_2,...,s_k&lt;/script&gt; and label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from. &lt;script type=&quot;math/tex&quot;&gt;s_2&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from and so. Therefore, the total number of choices is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n^k
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;(2) k distinguishable strings and n distinguishable buckets with at most 1 string in each bucket&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Assuming &lt;script type=&quot;math/tex&quot;&gt;k \leq n&lt;/script&gt; (otherwise it is impossible). Label the strings &lt;script type=&quot;math/tex&quot;&gt;s_1, s_2,...,s_k&lt;/script&gt; and label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from. &lt;script type=&quot;math/tex&quot;&gt;s_2&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; choices of buckets to choose from because it can’t go to the bucket that &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; chose. Similarly, &lt;script type=&quot;math/tex&quot;&gt;s_3&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; and so on. Therefore, the total number of choices is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n(n-1) ... (n-k+1) = \binom{n}{k} * k!
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;(3) k indistinguishable strings and n distinguishable buckets&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt; and line them up below:
&lt;img src=&quot;http://localhost:4000/assets/counting/0a.png&quot; alt=&quot;my photo&quot; /&gt;
The strings are indistinguishable. We want to distribute them among the buckets so for example we could have the following:
&lt;img src=&quot;http://localhost:4000/assets/counting/0b.png&quot; alt=&quot;my photo&quot; /&gt;
To simplify the problem, let’s pretend that they are distinguishable and instead of buckets we’ll use dividers to separate the strings into different buckets. This way the first set of strings are in bucket 1, the second set after the first divider are in bucket 2 and so on. We’ll use colors to distinguish them. We will only need &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; dividers to create &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; groups.
&lt;br /&gt;
&lt;br /&gt;
To visualize this, suppose &lt;script type=&quot;math/tex&quot;&gt;n=4&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;k=5&lt;/script&gt;. In the below figure, we have &lt;script type=&quot;math/tex&quot;&gt;\{s_1,s_2\}&lt;/script&gt; in the first bucket. &lt;script type=&quot;math/tex&quot;&gt;\{s_3\}&lt;/script&gt; in the second bucket. &lt;script type=&quot;math/tex&quot;&gt;\{s_4,s_5\}&lt;/script&gt; in the third bucket. The forth bucket is empty.
&lt;img src=&quot;http://localhost:4000/assets/counting/1.png&quot; alt=&quot;my photo&quot; /&gt;
How many possible permutions are there? We have &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; dividers and &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings so&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
(n+k-1)!
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Now, since strings are really indistinguishable, let’s remove the labels. We also don’t need the colors because we’re assuming the first set of strings goes to the first bucket, the second set goes to the second bucket and so on. So we’ll have something like this:
&lt;img src=&quot;http://localhost:4000/assets/counting/2.png&quot; alt=&quot;my photo&quot; /&gt;
To remove the unnecessary ordering, we divide by &lt;script type=&quot;math/tex&quot;&gt;k!&lt;/script&gt; and also divide by &lt;script type=&quot;math/tex&quot;&gt;(n-1)!&lt;/script&gt;. Therefore, the final answer is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\frac{(n+k-1)!}{k!(n-1)!} = \binom{n+k-1}{n-1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Note that solution can be applied to other interesting examples like finding the number of integer solutions to &lt;script type=&quot;math/tex&quot;&gt;x_1+x_2+...+x_k=n&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;(4) k indistinguishable strings and n distinguishable buckets with at most 1 string in each bucket&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;In case (2), we saw that the number of ways to put &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; distinguishable strings into &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; distinguishable buckets with at most 1 string in each bucket is &lt;script type=&quot;math/tex&quot;&gt;\binom{n}{k} * k!&lt;/script&gt;. In this case, the strings are indistinguishable so we don’t care about the order of strings and so we divide by &lt;script type=&quot;math/tex&quot;&gt;k!&lt;/script&gt;. The final answer therefore is simply&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\binom{n}{k}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">(1) k distinguishable strings and n distinguishable buckets Label the strings and label the buckets . has choices of buckets to choose from. has choices of buckets to choose from and so. Therefore, the total number of choices is $$ \begin{align*} n^k \end{align*} $$ (2) k distinguishable strings and n distinguishable buckets with at most 1 string in each bucket Assuming (otherwise it is impossible). Label the strings and label the buckets . has choices of buckets to choose from. has choices of buckets to choose from because it can’t go to the bucket that chose. Similarly, has and so on. Therefore, the total number of choices is $$ \begin{align*} n(n-1) ... (n-k+1) = \binom{n}{k} * k! \end{align*} $$ (3) k indistinguishable strings and n distinguishable buckets Label the buckets and line them up below: The strings are indistinguishable. We want to distribute them among the buckets so for example we could have the following: To simplify the problem, let’s pretend that they are distinguishable and instead of buckets we’ll use dividers to separate the strings into different buckets. This way the first set of strings are in bucket 1, the second set after the first divider are in bucket 2 and so on. We’ll use colors to distinguish them. We will only need dividers to create groups. To visualize this, suppose and . In the below figure, we have in the first bucket. in the second bucket. in the third bucket. The forth bucket is empty. How many possible permutions are there? We have dividers and strings so $$ \begin{align*} (n+k-1)! \end{align*} $$ Now, since strings are really indistinguishable, let’s remove the labels. We also don’t need the colors because we’re assuming the first set of strings goes to the first bucket, the second set goes to the second bucket and so on. So we’ll have something like this: To remove the unnecessary ordering, we divide by and also divide by . Therefore, the final answer is $$ \begin{align*} \frac{(n+k-1)!}{k!(n-1)!} = \binom{n+k-1}{n-1} \end{align*} $$ Note that solution can be applied to other interesting examples like finding the number of integer solutions to . (4) k indistinguishable strings and n distinguishable buckets with at most 1 string in each bucket In case (2), we saw that the number of ways to put distinguishable strings into distinguishable buckets with at most 1 string in each bucket is . In this case, the strings are indistinguishable so we don’t care about the order of strings and so we divide by . The final answer therefore is simply $$ \begin{align*} \binom{n}{k} \end{align*} $$ References Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/</summary></entry></feed>