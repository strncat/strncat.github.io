---
layout: post
title:  "Kosaraju's Strongly Connected Components Algorithm"
date:   2019-04-01 12:01:36 -0700
categories: jekyll update
mathjax: true
---
Let $$G=(V,E)$$ be a graph with $$V$$ vertices and $$E$$ edges. 

$$G$$ is strongly connected if for all $$u,v$$ in $$V$$:<br>
(1) There is a path from $$u$$ to $$v$$.<br>
(2) There is a path from $$v$$ to $$u$$.<br>

Based on this definition, we can decompose a graph into strongly connected components. To find these strongly connected components, we describe Kosaraju's amazing algorithm.
<br>
<br>
<!---------------------------------------------------------------------------------------->
<h4><b>Algorithm</b></h4>
{% highlight c++ %}
(1) Run DFS to create a DFS forest and keep track of finishing times.
(2) Reverse all the edges in G.
(3) Run DFS again in the reversed graph from the node with the largest finishing time.
Return the connected components from (3) (these are the SCCS)
{% endhighlight %}
<br>
<!---------------------------------------------------------------------------------------->
<h4><b>Example</b></h4>
<img src="{{ site.url }}/assets/graphs/scc/1.png" width="100%">
Let's apply Kosaraju's algorithm on the above graph. First we need to run DFS while keeping tracking of the finishing times of vertices. We start by visiting $$a$$ and mark the start time as 0. We will continue to visit $$f$$ and then $$b$$ marking their start times below.
<img src="{{ site.url }}/assets/graphs/scc/2.png" width="100%">
Now $$b$$ doesn't have any more neighbors to visit and so we mark it as finished with finish time = 3. We then visit $$e$$ and $$f$$ and mark them as finished when there are no more neighbors to visit. Below is the result so far.
<img src="{{ site.url }}/assets/graphs/scc/3.png" width="100%">
Next we see that $$f$$ is finished and we return to $$a$$ but $$a$$ doesn't have more neighbors and so we mark it finished as well.
<img src="{{ site.url }}/assets/graphs/scc/4.png" width="100%">
We finally visit $$c$$ and mark it as finished as well.
<img src="{{ site.url }}/assets/graphs/scc/5.png" width="100%">
Great! Now we run the second step of Kosaraju's algorithm and reverse all the edges in $$G$$.
<img src="{{ site.url }}/assets/graphs/scc/6.png" width="100%">
Now to the last step of running a second pass of dfs in the reversed graph starting with the node with the largest finishing time. We therefore start with $$c$$. We notice that $$c$$ can't reach any vertices and so $$c$$ is the first strongly connected component!
<img src="{{ site.url }}/assets/graphs/scc/7.png" width="100%">
We next visit $$a$$, $$f$$ and $$b$$ and that's our second strongly connected component. 
<img src="{{ site.url }}/assets/graphs/scc/8.png" width="100%">
We finally visit $$d$$ and $$e$$ and that's our third and final strongly connected component as expected.
<img src="{{ site.url }}/assets/graphs/scc/9.png" width="100%">
<br>
<br>
<!---------------------------------------------------------------------------------------->
<h4><b>Correctness Proof</b></h4>
Why does this algorithm find the SCCs? To show how, we'll first prove two important lemmas that we'll use in proving that the algorithm is correct.
<br>
<br>

| Lemma 1: The SCC graph is a DAG |

<i>Proof:</i> Suppose that the SCC graph is not a DAG and let $$A$$ and $$B$$ be two components where there is an edge from $$A$$ to $$B$$ and an edge from $$B$$ to $$A$$. Let $$u$$ be a vertex in $$A$$ and let $$v$$ be a vertex in $$B$$. By the connected component definition, we know there is a path between $$v$$ and every vertex in $$A$$. Similarly, there is a path between $$u$$ and any vertex in $$B$$. Since there is an edge from $$A$$ to $$B$$ then there is a path from $$v$$ to any vertex in $$B$$ and Similarly, there is a path between $$u$$ and any vertex in $$A$$. Therefore, the vertices in $$A$$ and $$B$$ must be in the same strongly connected component. This is a contradiction, since we assumed $$A$$ and $$B$$ two strongly connected components. Therefore, the SCC graph must be a DAG. $$\blacksquare$$
<br>
<br>

| Lemma 2: In the SCC DAG, if there is an edge from component $$A$$ to component $$B$$ then $$A.finish > B.finish$$ |


<i>Proof:</i> There are two cases: <br>
Case 1: We reached $$A$$ before $$B$$ in our first DFS: <br>
Let $$x$$ have the largest finish time in $$A$$ and $$y$$ have the largest finish time in $$B$$. Let $$z$$ be the first node discovered in $$A$$ then we will reach $$A$$ and discover $$z$$ then at some point we will reach $$B$$ and discover $$y$$. This means that $$y$$ is a descendant of $$z$$. By the parentheses theorem, this means that $$z$$ has a larger finish time. Since $$x$$ has the largest finish time in $$A$$, then $$x.finish > z.finish$$ and since $$.z.finish > y.finish$$ then we have $$A.finish > B.finish$$, as required.


<br>
Case 2: We reached $$B$$ before $$A$$ in our first DFS: <br>
Since we assumed that there is an edge from $$A$$ to $$B$$ then by Lemma 1, we don't have an edge from $$B$$ to $$A$$.Therefore, we will explore $$B$$ completely first and then $$A$$ will be explored later after we restart the DFS, this means that $$A.finish > B.finish$$, as we wanted to show. $$\blacksquare$$
<br>
<br>

| Corollary 1: In the SCC DAG, if there is an edge from component $$B$$ to component $$A$$ in the reversed graph, then $$A.finish > B.finish$$ |

We can now combine the previous results to prove the following theorem:

| Theorem: The algorithm we saw before will correctly identify strongly connected components |

<i>Proof:</i> <br>
<b>Inductive Hypothesis: </b> The first $$t$$ trees found in the second (reversed) DFS
forest are the $$t$$ SCCs with the largest finish times. Moreover, what’s left unvisited after these $$t$$ trees have been explored is a DAG on the un-found SCCs.
<br>

<b>Base Case:</b> It is vacuously true that the first 0 trees found in the reversed DFS forest are the 0 SCCs with the largest finish times. Moreover, what’s left unvisited after 0 trees have been explored is a DAG on all the SCCs by Lemma 1.
<br>

<b>Inductive Step:</b> Assume by induction that the first $$t$$ trees are the last-finishing SCCs, and the remaining SCCs form a DAG. 
<br>
Now, consider the $$t+1$$st tree produced and let $$x$$ be the root of the tree. Let $$x$$ be in SCC $$A$$. We know that $$A.finish > B.finish$$ for the remaining SCCs $$B$$. This is because we chose $$x$$ in the second DFS to have the largest finish time. 
<br>
Also since $$A.finish > B.finish$$, then there are no edges going from $$A$$ to $$B$$ because suppose there was an edge to some component $$C$$ then $$C.finish > A.finish$$ by Corollary 1 which is a contradiction since $$A$$ has the largest finish time. 
<br>
Therefore, we will only discover vertices in $$A$$ in the second DFS started from $$x$$. So the $$t+1$$st tree is the SCC with the (t+1)st biggest finish time. Also the remaining SCCs still form a DAG, since removing a vertex won't create a cycle.

<b>Conclusion:</b> The second (reversed) DFS forest contains all the SCCs as its trees. $$\blacksquare$$
<br>
<br>
<!---------------------------------------------------------------------------------------->
<h4><b>Running Time</b></h4>
What are we doing in this algorithm algorithm? Two passes of DFS that we know run in $$O(n+m)$$. Therefore, the running time is astonishingly $$O(n+m)$$. 
<br>
<br>
<!---------------------------------------------------------------------------------------->
<h4><b>Implementation</b></h4>
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/connected-components/strongly-connected-components-directed-kosaraju.cpp
<br>
<br>
<!---------------------------------------------------------------------------------------->
<h4><b>Practice Problems</b></h4>
<a href="https://uva.onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&category=24&page=show_problem&problem=2499">11504 - Dominos (Almost Kosaraju but not quite)</a>
<br>
<br>
<!---------------------------------------------------------------------------------------->
<h4><b>References</b></h4>
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
<br>
<br>