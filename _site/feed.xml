<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-25T21:03:48-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Matrix Multiplication As Composition</title><link href="http://localhost:4000/jekyll/update/2023/09/25/determinants.html" rel="alternate" type="text/html" title="Matrix Multiplication As Composition" /><published>2023-09-25T01:01:36-07:00</published><updated>2023-09-25T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/09/25/determinants</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/09/25/determinants.html"><![CDATA[<p>This post is just me taking notes while watching <a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a> which is the best reference on Linear Algebra ever. I might add other notes from other places as I go.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Linear Transformations Recap</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-combinations/vector-3.png" width="60%" class="center" /></p>
<p>We’ve talked about linear transformations previously. Some squish the space and some strech the space (while of course keeping the grid lines parallel and evenly spaced and the origin in the same place). How can we measure the amount of streching? Given an the area bounded by some region before applying the transformation, how much did it grow by?</p>

<!------------------------------------------------------------------------------------>
<h4><b>References</b></h4>
<p><a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This post is just me taking notes while watching Essence of Linear Algebra by 3Blue1Brown which is the best reference on Linear Algebra ever. I might add other notes from other places as I go. Linear Transformations Recap We’ve talked about linear transformations previously. Some squish the space and some strech the space (while of course keeping the grid lines parallel and evenly spaced and the origin in the same place). How can we measure the amount of streching? Given an the area bounded by some region before applying the transformation, how much did it grow by?]]></summary></entry><entry><title type="html">Matrix Multiplication As Composition</title><link href="http://localhost:4000/jekyll/update/2023/09/25/matrix-multiplication-as-composition.html" rel="alternate" type="text/html" title="Matrix Multiplication As Composition" /><published>2023-09-25T01:01:36-07:00</published><updated>2023-09-25T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/09/25/matrix-multiplication-as-composition</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/09/25/matrix-multiplication-as-composition.html"><![CDATA[<p>This post is just me taking notes while watching <a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a> which is the best reference on Linear Algebra ever. I might add other notes from other places as I go.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Linear Transformations Recap</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/00.png" width="50%" class="center" /></p>
<p>Linear transformations are functions with vectors as inputs and vectors as outputs. We described them visually and saw how they change the vector space such that grid lines remain parallel and evenly spaced and where the origin remains fixed. We also saw that a linear transformation is completely determined by where the besis vectors of the space. For two dimensions, this means that we just need to know where $\widehat{i}$ and $\widehat{j}$ land in order to figure out where any other vector will land. And this is because any vector in two dimensions can be written as a linear combination of the two basis vectors $\widehat{i}$ and $\widehat{j}$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/01a.png" width="40%" class="center" /></p>
<p>Suppose we want to find out where the vector $v=(3,2)$ will land after some linear transformation. We can multiply the x-coordinate of $v$ by the transformed $\widehat{i}$ coordinates and similarly, multiply the y-coordinate of $v$ by the coordinates of the transformed $\widehat{j}$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/01.png" width="65%" class="center" /></p>
<p>To write things numerically, the convection is to arrange the coordinates of these vectors as columns in a 2x2 matrix and then to put the matrix to the left of the vector (just like functions!)</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/02.png" width="100%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Multiple Linear Transformations</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/03.png" width="100%" class="center" /></p>
<p>What if we wanted to apply not just one linear transformations but multiple linear transformations? For example, suppose we want to apply a rotation followed by a shear transformation (see above). It turns out that the end result is still another linear transformation recorded in the following matrix,</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/04.png" width="25%" class="center" /></p>
<p>This new linear transformations is called the <b>composition</b> of the two transformations that we applied (rotation + shear).
One way to think about the new matrix is as follows: if we were to take some vector and then pump it through the rotation and then the shear. The long way to compute where it ends up is first to multiply this vector by the rotation matrix on the left and then whatever you get and multiply that on the left by the shear matrix.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/05.png" width="60%" class="center" /></p>
<p>This is what it means to apply a rotation then a shear to a given victor and whatever we get should exactly the same as applying this vector by the new composition matrix.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/06.png" width="90%" class="center" /></p>
<p>Since this new matrix is supposed to capture this overall effect of applying a rotation and then a shear, it should be reasonable to call this new matrix as the “product” of the original two matrices.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/07.png" width="60%" class="center" /></p>
<p>One thing to always remember is that the multiplying two matrices like the above has the geometric meaning of applying one transformation then another. And the reason why we apply the most right matrix first is just following the function notation In $f(g(x))$, we apply g and then $f$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Multiplying Matrices Numerically</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/08.png" width="60%" class="center" /></p>
<p>Let’s carry out the multiplication numerically without visualizing it. First we will need to know where $\widehat{i}$ will land. By definition we know that after applying $M_1$ above, the new coordinates of $\widehat{i}$ are captured by the first column of the $M_1$ matrix and similarly for $\widehat{j}$. (Recall that the linear transformation matrix records the coordinates of where the two basis vectors have landed).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/09.png" width="60%" class="center" /></p>
<p>Let’s see what happens after applying the transformation $M_2$ on the vector (0,1). This can be done by multiplying the x-coordinate of that vector by the first column of $M_2$ and then similarly multiply the y-coordinate by the second column. (similar to what we learned in the previous video/post)</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/10.png" width="60%" class="center" /></p>
<p>The resulting vector is the first column of the composition matrix below!</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/11.png" width="60%" class="center" /></p>
<p>Next, we will apply $M_2$ on the transformed $\widehat{j}$ vector similar to what we did above for $\widehat{i}$</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/12.png" width="60%" class="center" /></p>
<p>And the resulting vector will be the second column of the new composition matrix!</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/4-matrix-compsition/13.png" width="60%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Properties of Matrix Multiplication</b></h4>
<p>Does the order matter? Does $M_1M_2 = M_2M_1$? We can see this by visualizing the transformations. Take a vector and rotate it with the rotation from the above example and then apply the shear from the previous example as well. Take the same vector and apply shear transformation this time before applying the rotation. Do we get the same vector? no. It is so easy to see this with transformations rathar than figuring out this numerically!
<br />
<br />
What about associativity? Does $(AB)C=A(BC)$? Carrying this out numerically, it is not intuitive and messy! Visualizing this with transformations, it is actually really easy to see that it is true!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>3D</b></h4>
<p>The same concept applies to 3 dimesions and the video “chapter 5: Three dimensional linear transformations” has really great animations to show different transformations in 3D.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This post is just me taking notes while watching Essence of Linear Algebra by 3Blue1Brown which is the best reference on Linear Algebra ever. I might add other notes from other places as I go. Linear Transformations Recap Linear transformations are functions with vectors as inputs and vectors as outputs. We described them visually and saw how they change the vector space such that grid lines remain parallel and evenly spaced and where the origin remains fixed. We also saw that a linear transformation is completely determined by where the besis vectors of the space. For two dimensions, this means that we just need to know where $\widehat{i}$ and $\widehat{j}$ land in order to figure out where any other vector will land. And this is because any vector in two dimensions can be written as a linear combination of the two basis vectors $\widehat{i}$ and $\widehat{j}$. Suppose we want to find out where the vector $v=(3,2)$ will land after some linear transformation. We can multiply the x-coordinate of $v$ by the transformed $\widehat{i}$ coordinates and similarly, multiply the y-coordinate of $v$ by the coordinates of the transformed $\widehat{j}$. To write things numerically, the convection is to arrange the coordinates of these vectors as columns in a 2x2 matrix and then to put the matrix to the left of the vector (just like functions!) Multiple Linear Transformations What if we wanted to apply not just one linear transformations but multiple linear transformations? For example, suppose we want to apply a rotation followed by a shear transformation (see above). It turns out that the end result is still another linear transformation recorded in the following matrix, This new linear transformations is called the composition of the two transformations that we applied (rotation + shear). One way to think about the new matrix is as follows: if we were to take some vector and then pump it through the rotation and then the shear. The long way to compute where it ends up is first to multiply this vector by the rotation matrix on the left and then whatever you get and multiply that on the left by the shear matrix. This is what it means to apply a rotation then a shear to a given victor and whatever we get should exactly the same as applying this vector by the new composition matrix. Since this new matrix is supposed to capture this overall effect of applying a rotation and then a shear, it should be reasonable to call this new matrix as the “product” of the original two matrices. One thing to always remember is that the multiplying two matrices like the above has the geometric meaning of applying one transformation then another. And the reason why we apply the most right matrix first is just following the function notation In $f(g(x))$, we apply g and then $f$. Multiplying Matrices Numerically Let’s carry out the multiplication numerically without visualizing it. First we will need to know where $\widehat{i}$ will land. By definition we know that after applying $M_1$ above, the new coordinates of $\widehat{i}$ are captured by the first column of the $M_1$ matrix and similarly for $\widehat{j}$. (Recall that the linear transformation matrix records the coordinates of where the two basis vectors have landed). Let’s see what happens after applying the transformation $M_2$ on the vector (0,1). This can be done by multiplying the x-coordinate of that vector by the first column of $M_2$ and then similarly multiply the y-coordinate by the second column. (similar to what we learned in the previous video/post) The resulting vector is the first column of the composition matrix below! Next, we will apply $M_2$ on the transformed $\widehat{j}$ vector similar to what we did above for $\widehat{i}$ And the resulting vector will be the second column of the new composition matrix! Properties of Matrix Multiplication Does the order matter? Does $M_1M_2 = M_2M_1$? We can see this by visualizing the transformations. Take a vector and rotate it with the rotation from the above example and then apply the shear from the previous example as well. Take the same vector and apply shear transformation this time before applying the rotation. Do we get the same vector? no. It is so easy to see this with transformations rathar than figuring out this numerically! What about associativity? Does $(AB)C=A(BC)$? Carrying this out numerically, it is not intuitive and messy! Visualizing this with transformations, it is actually really easy to see that it is true! 3D The same concept applies to 3 dimesions and the video “chapter 5: Three dimensional linear transformations” has really great animations to show different transformations in 3D. References Essence of Linear Algebra by 3Blue1Brown]]></summary></entry><entry><title type="html">Linear Transformations</title><link href="http://localhost:4000/jekyll/update/2023/09/22/linear-transformations.html" rel="alternate" type="text/html" title="Linear Transformations" /><published>2023-09-22T01:01:36-07:00</published><updated>2023-09-22T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/09/22/linear-transformations</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/09/22/linear-transformations.html"><![CDATA[<p>This post is just me taking notes while watching <a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a> which is the best reference on Linear Algebra ever. I might add other notes from other places as I go.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Transformations</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-transformations/01.png" width="60%" class="center" /></p>
<p>So what does transformation mean? A transformation takes a vector as an input and outputs another vector so it’s just a function. So why didn’t we call it a function? This is because the word transformation suggests movement. We’re imagining that this input vector is moving over to the output vector. Of course, when transforming vectors, it is much nicer to use the trick from last time where we think of the vector as the point where its tip sits on. This way it is easier to visulize transforming many vectors all at once.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Linear Transformations</b></h4>
<p>Transformations can be pretty complex but Linear Algebra is restricted to only linear transformations. Visually speaking a transformation is linear if it has two properties:</p>
<ul>
	<li>All lines must remain lines without getting curved.</li>
	<li>The origin is fixed in place.</li>
</ul>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Describing Linear Transformations Numerically</b></h4>
<p>How do we describe a linear transformation? It turns out that all we need to do is to record where the basis vectors will land and then everything else will just follow. Why is this? From the previous post, we know can write any vector as a linear combination of the basis vector of the vector space. Suppose $v = \begin{bmatrix}3 &amp; -2\end{bmatrix}$, then we know that we can write $v$ in terms of $\widehat{i}$ and $\widehat{j}$ as shown below.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-transformations/02.png" width="45%" class="center" /></p>
<p>Writing this again, we have</p>
<div>
$$
\begin{align*}
v &amp;= 3\widehat{i} - 2\widehat{j} \\
\begin{bmatrix}
3 \\ -2
\end{bmatrix}
&amp;=
3
\begin{bmatrix}
1 \\ 0
\end{bmatrix}
-
2
\begin{bmatrix}
0 \\ 1
\end{bmatrix}
\end{align*}
$$
</div>
<p>After applying the transformation on $\widehat{i}$ and $\widehat{j}$, we can now find out where $v$ will land by writing $v$ as a linear combination of the transformed vectors $\widehat{i}$ and $\widehat{j}$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-transformations/03.png" width="60%" class="center" /></p>
<p>and now we can just know where $v$ will land based on where $\widehat{i}$ and $\widehat{j}$ landed after the tranformation. We can write,</p>
<div>
$$
\begin{align*}
\text{transformed (} v) &amp;= 3\text{ (transformed }\widehat{i}) - 2 \text{ (transformed }\widehat{j}) \\
&amp;=
3
\begin{bmatrix}
1 \\ -1
\end{bmatrix}
-
2
\begin{bmatrix}
1 \\ 1
\end{bmatrix} \\
&amp;=
\begin{bmatrix}
1 \\ -5
\end{bmatrix}
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Representing the transformation with a Matrix</b></h4>
<p>So from the above we saw how a two dimensional linear transformation is completely described by four numbers. The two coordinates for where $\widehat{i}$ lands and the two coordinates for where $\widehat{j}$ lands and this is pretty cool! Here is a cooler thing. We can package these coordinates into a two-by-two grid of numbers (a Matrix!)</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-transformations/04.png" width="40%" class="center" /></p>
<p>The first column will be where $\widehat{i}$ landed and the second column will be where $\widehat{j}$ landed. So now when we apply the transformation to some vector $v=(x,y)$, what do we get?</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-transformations/05.png" width="40%" class="center" /></p>
<p>We’ll multiply the $x$ coordinate with the transformed $\widehat{i}$ vector and similary multiply the $y$ coordinate with the transformed $\widehat{j}$ coordinate.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-transformations/06.png" width="70%" class="center" /></p>

<p>and now we can re-arrange the matrix position to put it on the left of the vector below,</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-transformations/07.png" width="100%" class="center" /></p>
<p>And this is way more fun than just memeorizing how matrix multipcation works. These matrix columns are just the transformed versions of your basis vectors and the resulting vector is just a linear combinations of these two vectors. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>More Example Transformations</b></h4>
<p>TODO: Rotations and Shear. (the video shows really beatiful animation for the examples)
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This post is just me taking notes while watching Essence of Linear Algebra by 3Blue1Brown which is the best reference on Linear Algebra ever. I might add other notes from other places as I go. Transformations So what does transformation mean? A transformation takes a vector as an input and outputs another vector so it’s just a function. So why didn’t we call it a function? This is because the word transformation suggests movement. We’re imagining that this input vector is moving over to the output vector. Of course, when transforming vectors, it is much nicer to use the trick from last time where we think of the vector as the point where its tip sits on. This way it is easier to visulize transforming many vectors all at once. Linear Transformations Transformations can be pretty complex but Linear Algebra is restricted to only linear transformations. Visually speaking a transformation is linear if it has two properties: All lines must remain lines without getting curved. The origin is fixed in place. Describing Linear Transformations Numerically How do we describe a linear transformation? It turns out that all we need to do is to record where the basis vectors will land and then everything else will just follow. Why is this? From the previous post, we know can write any vector as a linear combination of the basis vector of the vector space. Suppose $v = \begin{bmatrix}3 &amp; -2\end{bmatrix}$, then we know that we can write $v$ in terms of $\widehat{i}$ and $\widehat{j}$ as shown below. Writing this again, we have $$ \begin{align*} v &amp;= 3\widehat{i} - 2\widehat{j} \\ \begin{bmatrix} 3 \\ -2 \end{bmatrix} &amp;= 3 \begin{bmatrix} 1 \\ 0 \end{bmatrix} - 2 \begin{bmatrix} 0 \\ 1 \end{bmatrix} \end{align*} $$ After applying the transformation on $\widehat{i}$ and $\widehat{j}$, we can now find out where $v$ will land by writing $v$ as a linear combination of the transformed vectors $\widehat{i}$ and $\widehat{j}$. and now we can just know where $v$ will land based on where $\widehat{i}$ and $\widehat{j}$ landed after the tranformation. We can write, $$ \begin{align*} \text{transformed (} v) &amp;= 3\text{ (transformed }\widehat{i}) - 2 \text{ (transformed }\widehat{j}) \\ &amp;= 3 \begin{bmatrix} 1 \\ -1 \end{bmatrix} - 2 \begin{bmatrix} 1 \\ 1 \end{bmatrix} \\ &amp;= \begin{bmatrix} 1 \\ -5 \end{bmatrix} \end{align*} $$ Representing the transformation with a Matrix So from the above we saw how a two dimensional linear transformation is completely described by four numbers. The two coordinates for where $\widehat{i}$ lands and the two coordinates for where $\widehat{j}$ lands and this is pretty cool! Here is a cooler thing. We can package these coordinates into a two-by-two grid of numbers (a Matrix!) The first column will be where $\widehat{i}$ landed and the second column will be where $\widehat{j}$ landed. So now when we apply the transformation to some vector $v=(x,y)$, what do we get? We’ll multiply the $x$ coordinate with the transformed $\widehat{i}$ vector and similary multiply the $y$ coordinate with the transformed $\widehat{j}$ coordinate.]]></summary></entry><entry><title type="html">Linear Combinations</title><link href="http://localhost:4000/jekyll/update/2023/09/12/linear-combinations.html" rel="alternate" type="text/html" title="Linear Combinations" /><published>2023-09-12T01:01:36-07:00</published><updated>2023-09-12T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/09/12/linear-combinations</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/09/12/linear-combinations.html"><![CDATA[<p>This post is just me taking notes while watching Essence of Linear Algebra by 3Blue1Brown which is the best reference on Linear Algebra ever. I might add other notes from other places as I go.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Vector Coordinates</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-combinations/vector-3.png" width="60%" class="center" /></p>

<p>We studied vectors in the previous post and learned about vectors and vector coordinates. The x-coordinate represented the movement from this vector’s tail at the origin along the x-axis to its tip and the y-coordinate represented the movement of this vector along the y-axis. We saw how addition and multiplication were defined and what they meant. This time, we want to think about these vector coordinates differently.
<br /></p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-combinations/linear-comb-2.png" width="60%" class="center" /></p>
<p>In the xy-coordinate system, we have two special vectors. $\widehat{i}$ which is a unit vector pointing to the right in the x-direction. $\widehat{j}$ is a unit vector pointing straight up in the y-direction. Now, given a vector’s coordinate (green vector in the figure above), we will think of each coordinate as a scalar where the x-coordinate scales $\widehat{i}$ streching it by 3 and the y-coordinate scales $\widehat{j}$ by a factor of 2 and also flipping it in the other direction. $\widehat{i}$ and $\widehat{j}$ are called the <b>basis</b> vectors of the $xy$ coordinate system. So when we think about coordinates as scalars, these scalars scale the basis vectors.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-combinations/linear-comb-3.png" width="60%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Linear Combination</b></h4>
<p>So here the important observation, this means that the vectors that these coordinates describe is really the sum of two scaled vectors $3\widehat{i} + (-2)\widehat{j}$. (Addition of two scaled vectors!). This sum is also called a <b>linear combination</b> of $\widehat{i}$ and $\widehat{j}$. Why did we call it linear? This is really interesting. Grant said to imagine fixing one of the scalars, then changing the other scalar will result in the tip of the resulting vector drawing a straight line. The animation in the video is so great at showing this.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/linear-combinations/linear-comb-4.png" width="100%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Span of Vectors</b></h4>
<p>Now, if we change both scalars at the same time, then the resulting set is the set of all possible linear combinations of these two vectors and it is formally called the <b>span</b> of these vectors. Morever, we’ll have three possible sets:</p>
<ul>
	<li>For most pairs of vectors, we'll reach every possible vector in the plane so their span will be the all vectors of the 2D space</li>
	<li>For the case when both vectors line up, then the tip of the resulting vector is limited to just this single line passing through the origin. So their span is the set of all vectors whose tip sit on that line.</li>
	<li>Both vectors are the zero vector and in this case, we'll be stuck at the origin. So their span is just the zero vector</li>
</ul>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Vectors vs. Points</b></h4>
<p>Grant said that it gets too crowded thinking about a collection of vectors sitting on a line or all vectors in a plane. So it is common to think of each of these vectors as a point that sits exactly at the tip of each vector where it’s tail is at the origin. So for example previously, we said that the span of two vectors that sit line up is the set of all vectors whose tip sit on that line. But now with the point notation, we can just think of the line itself. In general, it is easier to refer to a collection of vectors by the points that sit at their tips and just think of these points.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Span of Two Vectors in 3D Space</b></h4>
<p>What does the span of two 3d vectors look like? It is a plane cutting through the origin as you would expect. Their span is the set of all possible vectors whose tip sit on that plane. And what happens if we add a third vector? Then we’re back to having three possibilites, the span can be the whole 3D space. If two of the vectors are linearly dependent, then the span is a plane. If all three vectors sit on each other so all of them are linearly dependent, then their span is the line that goes through the origin. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Linear Independence</b></h4>
<p>Formally when two vectors in 2D space sit on top of each other and their span isn’t the whole 2D space, these vectors are called <b>linearly dependent</b> vectors, meaning that one vector can expressed as a <b>linear combination</b> of the other vector. On the other hand, if each vector adds another dimension to the span, then they’re called <b>linearly independent</b>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Basis of a Vector Space</b></h4>
<p>Also formally, the <b>basis</b> of a vector space is a set of <b>linearly indepedent</b> vectors that <b>span</b> the full space.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This post is just me taking notes while watching Essence of Linear Algebra by 3Blue1Brown which is the best reference on Linear Algebra ever. I might add other notes from other places as I go. Vector Coordinates]]></summary></entry><entry><title type="html">Vectors</title><link href="http://localhost:4000/jekyll/update/2023/09/11/vectors.html" rel="alternate" type="text/html" title="Vectors" /><published>2023-09-11T01:01:36-07:00</published><updated>2023-09-11T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/09/11/vectors</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/09/11/vectors.html"><![CDATA[<p>There isn’t a better reference on the internet than the <a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a> but this post is about me taking notes and summarizing what I’ve learned from the above resource. I will tweak and add more stuff from other references as I go.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>What are Vectors?</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-1.png" width="100%" class="center" /></p>
<p>So what are vectors exactly? To a physics student, it is an arrow pointing in space that has a given length and a direction. A vector with a given length and a direction remains the same vector even when moved freely in the space. For a computer science student, a vector is an ordered list of numbers. The vector can be a list of features, a house’s properties, for example. The order matters and so in figure (2), the two vectors are not equal. To a mathematics student, a vector is a more abstract concept. A vector can be anything as long as the operations addition and multiplication are defined. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>From Physics to Computer Science</b></h4>
<p>Let’s take the physics student’s idea of a vector being an arrow with a given length and a direction but instead of having it move freely in space, we’ll think of this arrow in a coordinate system with its tail at the origin. See below.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-2.png" width="60%" class="center" /></p>

<p>Now that we have the arrow at the origin, we can translate it over to the list of numbers (computer science student’s) point of view by considering taking into account the coordinates of the vector in the coordinate system. What do these coordinates represent? They represent how we can move from the tail of the vector sitting on the origin to its tip. In the example below, 3 tells us how far to walk along the x-axis with positive numbers indicating rightward motion and negative numbers indicate leftward motion. Similarly, 2 tells us how far to walk along the y-axis with positive numbers indicating upward motion and negative numbers indicating downward motion.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-3.png" width="60%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>From Computer Science to Mathematics</b></h4>
<p>Now that we’ve connected the physics student’s prespective to the computer science student’s prepective. Let’s connect what we’ve developed to the mathematics student’s prespective. Let’s define the two required operations addition and multiplication. Let’s start with addition. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Addition</b></h4>
<p>Suppose we have the following two vectors. To add these two vectors, we will move the second vector so that its tail sits at the tip of the first vector.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-4.png" width="100%" class="center" /></p>
<p>After we do that, now we can draw a vector from the tail of the first vector to the tip of the second vector. This new green vector is the sum of the two vectors. (This is the only time in Linear Algebra where we’re moving a vector away from the origin! interesting!)</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-5.png" width="100%" class="center" /></p>
<p>Why was addition defined this way? A vector represents a movement or a step with a direction and a distance in space. So here, if we take a step along the first vector and then take another step in the direction of the second vector and by the amount equal to the distance of the second vector, then the overall movement would be the same as moving alone the vector that represents their sum above. You can see this in the second figure below. The green vector is really the sum of the amount the first vector moved in the x-axis’s direction plus the amount that the second vector moved in the x-axis’s direction. Similarly, we add the movements in the y-axis’s direction from both vectors.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-7.png" width="100%" class="center" /></p>
<p>Moreover, If you think about addition of numbers on a number line, we kind of do a similar thing!</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-6.png" width="70%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Multiplication</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/linear-algebra/vectors/vector-multi.png" width="70%" class="center" /></p>
<p>Multiplication scales a vector by the magnitude you multiply with. The magnitude is the scaler. When the sign of the vector becomes different as a result of this scaling operation, then the direction of the vector is reversed.<br />
<br />
<br />
<!--------Linear Algebra tends to focus on these two fundamental operations. Why do mathematicans think these operations only independently and abstracted away from how vectors are represented? It doesn't matter whether you think about vectors as fundamentally being arrows in space that happen to have a nice numerical representations or fundamentally as lists of numbers that happen to have a nice geometric interpretation. The usefulness of linear algebra comes from the ability to translate back and forth between them.
 ----------------------------------------></p>

<!------------------------------------------------------------------------------------>
<h4><b>References</b></h4>
<p><a href="https://www.youtube.com/watch?v=fNk_zzaMoSs&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab">Essence of Linear Algebra by 3Blue1Brown</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[There isn’t a better reference on the internet than the Essence of Linear Algebra by 3Blue1Brown but this post is about me taking notes and summarizing what I’ve learned from the above resource. I will tweak and add more stuff from other references as I go. What are Vectors? So what are vectors exactly? To a physics student, it is an arrow pointing in space that has a given length and a direction. A vector with a given length and a direction remains the same vector even when moved freely in the space. For a computer science student, a vector is an ordered list of numbers. The vector can be a list of features, a house’s properties, for example. The order matters and so in figure (2), the two vectors are not equal. To a mathematics student, a vector is a more abstract concept. A vector can be anything as long as the operations addition and multiplication are defined. From Physics to Computer Science Let’s take the physics student’s idea of a vector being an arrow with a given length and a direction but instead of having it move freely in space, we’ll think of this arrow in a coordinate system with its tail at the origin. See below.]]></summary></entry><entry><title type="html">Line Segment Intersection (Intersection Point)</title><link href="http://localhost:4000/jekyll/update/2023/09/05/line-segment-interesection-point.html" rel="alternate" type="text/html" title="Line Segment Intersection (Intersection Point)" /><published>2023-09-05T01:01:36-07:00</published><updated>2023-09-05T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/09/05/line-segment-interesection-point</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/09/05/line-segment-interesection-point.html"><![CDATA[<p>Suppose we have two line segments $\overline{ab}$ and $\overline{cd}$. How can we determine their intersection? We previously developed a method to determine the existence of the intersection without having to compute the actual intersection point. We did this using the orientation test by basically testing if $c$ and $d$ are on opposite sides of the line that goes through  $\overline{ab}$ and then again if $a$ and $b$ are on opposite sides of the line that goes through $\overline{cd}$. This was neat and we avoided having to deal with floating point values. But what if we wanted to find the actual intersection point, if any?
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Parametric Representation</b></h4>
<p>Let $\vec{A} = b - a$ and let $\vec{B} = d - c$. A point on the line that goes through $\overline{ab}$ can be represented using</p>
<div>
$$
\begin{align*}
    p(s) = a + sA.
\end{align*}
$$
</div>

<p>Plugging 0 for $s$ results in the point $a$ and plugging 1 on the other hand will result in the point $b$ so when $s \in [0,1]$, the equation represents all the points that fall on the line segment $\overline{ab}$. Similarly, a point on the line that goes through $\overline{cd}$ can be represented using</p>
<div>
$$
\begin{align*}
    q(t) = c + tB.
\end{align*}
$$
</div>

<p>To find the intersection point, we will need to find the values of $s$ and $t$ that will make $p(s)$ equal to $q(t)$. Moreover, $s$ and $t$ will need to be in the range $[0,1]$ for the intersection point to be within the segments.</p>
<div>
$$
\begin{align*}
    a + sA = c + tB.
\end{align*}
$$
</div>

<p>Let $a=(a_0,a_1), b=(b_0,b_1), c=(c_0,c_1), d=(d_0, d_1)$. The solution turns out to be</p>
<div>
$$
\begin{align*}
    s &amp;= [a_0(d_1-c_1)+c_0(a_1-d_1)+d_0(c_1-a_1)]/D, \\
    t &amp;= [a_0(c_1-b_1)+b_0(a_1-c_1)+c_0(b_1-a_1)]/D, \\
    D &amp;= a_0(d_1-c_1)+b_0(c_1-d_1)+d_0(b_1-a_1)+c_0(a_1-b_1)
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b></b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">while</span> <span class="p">(</span><span class="n">hull_candidate</span> <span class="o">!=</span> <span class="n">first_convex_hull_point</span><span class="p">)</span></code></pre></figure>

<p>Source Code <a href="?">TODO</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://jeffe.cs.illinois.edu/teaching/compgeom/schedule.html">CS 498: Computational Geometry</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Suppose we have two line segments $\overline{ab}$ and $\overline{cd}$. How can we determine their intersection? We previously developed a method to determine the existence of the intersection without having to compute the actual intersection point. We did this using the orientation test by basically testing if $c$ and $d$ are on opposite sides of the line that goes through $\overline{ab}$ and then again if $a$ and $b$ are on opposite sides of the line that goes through $\overline{cd}$. This was neat and we avoided having to deal with floating point values. But what if we wanted to find the actual intersection point, if any? Parametric Representation Let $\vec{A} = b - a$ and let $\vec{B} = d - c$. A point on the line that goes through $\overline{ab}$ can be represented using $$ \begin{align*} p(s) = a + sA. \end{align*} $$]]></summary></entry><entry><title type="html">Graham’s Scan</title><link href="http://localhost:4000/jekyll/update/2023/09/03/convex-hull-graham-scan.html" rel="alternate" type="text/html" title="Graham’s Scan" /><published>2023-09-03T01:01:36-07:00</published><updated>2023-09-03T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/09/03/convex-hull-graham-scan</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/09/03/convex-hull-graham-scan.html"><![CDATA[<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-1.png" width="60%" class="center" /></p>
<p>A set of points $S$ is convex if for any two points $a \in S$ and $b \in S$, then the line segment connecting these two points is also in $S$ ($\overline{ab} \subseteq S$). The convex hull of $S$ is the smallest convex set that contains all the points in $S$. In the previous post we discussed Jarvis’s algorithm which picked an initial vertex and added it to the convex hull and then iterated over the remaining vertices. In each iteration, we picked and added to the hull the furthest to the right vertex relative to the last added vertex to the hull. The running time of Jarvis’ March is $O(nh)$ where $n$ is the size of the given set of points and $h$ is the size of the convex hull. In this post, we will learn a faster algorithm that runs in time $O(n\log n)$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Graham's Scan</b></h4>
<p>Given a set of points $S$ of size $n$, the idea is to pick a point $p_0$ from the set that is known to be in the convex hull and then sort the remaining points by their angle anticlockwise relative to $p_0$. Graham gave a linear-time algorithm to find vertex that is interior to the hull but this isn’t needed at all since we can just pick the lowest or left most vertex and know that all the remaining vertices will be on one side of the line that goes through the point. After picking an initial point, the algorithm will sort the remaining points anitclockwise around the initial point by their angle. The core of the algorithm then is to use a stack to maintain the convex hull. We’ll iterate over the vertices keeping the invariant that for any three consective vertices on the stack $p$, $q$ and $r$, the point $r$ is on the left of the line that goes through the segment $\overline{pq}$. In other words, the angle at $q$ is a convex angle and not a reflex one. In the next few sections we’ll study each step through an example. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 1: Pick the Left Most Point</b></h4>
<p>The best way to learn this algorithm is by following an example. Suppose we are given the below 7 points,</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-2.png" width="60%" class="center" /></p>
<p>The first thing that the algorithm does is pick the left most point breaking ties by choosing the point with the lowest y-coordinate. This turns out to be point $(1,1)$ below</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-3.png" width="60%" class="center" /></p>
<p>In the implementation, we do something like this</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="n">Point</span> <span class="n">left_most</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">left_most</span><span class="p">.</span><span class="n">x</span> <span class="o">||</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">x</span> <span class="o">==</span> <span class="n">left_most</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">left_most</span><span class="p">.</span><span class="n">y</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">left_most</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 2: Sort the Points</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-4.png" width="60%" class="center" /></p>
<p>Next we will sort the points by their angle (anticlockwise) around $(1,1)$. What does this mean? We’re not changing where the points are. We’re just changing the order in which we will process these points. What we want is to traverse the points in an anti-clockwise direction around $(1,1)$. So we want to start with the point that is furthest to the right from $(1,1)$ (remember that this is the left most point and there won’t be points anymore on the left). Therefore, if you imagine $(1,1)$ connected with line segments to each of the remaining points, then what we want is to sort these by the angles they make around $(1,1)$.
<br />
<br />
How do we sort by their angels? We will use the famous orientation test we’ve studied in (<a href="https://strncat.github.io/jekyll/update/2023/08/25/orientation-of-three-points.html">Orientation of Three Points</a>). To recap, Suppose we’re given three ordered points $p, q, r$, then the expression (derived from slopes) $(q_x-p_x)(r_y-p_y) - (r_x-p_x)(q_y-p_y)$ is</p>
<ul>
    <li>Greater than zero when the slope of $pq$ is smaller than the slope of $pr$ and so the ordered points $p, q$ and $r$ are in anti-clockwise orientation and $r$ is on the left of the line $pq$</li>
    <li>Equal to zero if they're collinear</li>
    <li>Less than zero when the slope of $pq$ is greater than the slop of $pr$ and so the ordered points $p, q$ and $r$ in a counter clockwise orientation and $r$ is on the left of the line $pq$</li>
</ul>
<p>This means that if we take the points $(1,1), (7,0)$ and $(4,2)$ and we want to know if $(4,2)$ comes before $(7,0)$ in the sorted order, then we’ll ask the question: “Is $(4,2)$ on the left of the line that goes through $(1,1)$ and $(7,0)$ ? if the answer is yes then $(4,2)$ should instead come after $(7,0)$. Evaluating the expression for $p=(1,1), q=(7,2)$ and $r=(4,2)$, we see that \((7-1)*(2-1) - (4-1)*(0-1) = 6 - (-3) &gt; 0\). Therefore, then we know that $(4,2)$ is on the left and in the sorted order, $(7,0)$ must come first. 
<br />
<br />
How do we break ties? One example would be to choose the closest point between the two based on their distances to “left_most”. The final output will be the following (sorted points from $a$ to $f$).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-4-sorted.png" width="60%" class="center" /></p>
<p>In the implementation, this is an example of how one might write the orientation function.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">orientation</span><span class="p">(</span><span class="n">Point</span> <span class="n">a</span><span class="p">,</span> <span class="n">Point</span> <span class="n">b</span><span class="p">,</span> <span class="n">Point</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">long</span> <span class="n">area</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">area</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// cw</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// ccw</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>And this is how we can sort the array using $std::sort$,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="n">sort</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">left_most</span><span class="p">](</span><span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">orientation</span><span class="p">(</span><span class="n">left_most</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ccw</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// collinear</span>
            <span class="k">return</span> <span class="n">distance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">left_most</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">(</span><span class="n">left_most</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">});</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 3: The Main Loop</b></h4>
<p>So now we have an initial point picked and we have the points sorted around it. Next, we will use a stack $s$ to hold the hull points. Initially, $s$ will hold the first two vertices in the sorted list of points, $(1,1)$ and $(7,0)$. Notice that $(1,1)$ and $(7,0)$ will be on the convex hull. $(1,1)$ is the left most point and $(7,0)$ is the point furthest to the right from $(1,1)$. (proof?).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-step1.png" width="60%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 3: (Iteration 1)</b></h4>
<p>Next we’ll iterate over the remaining points. In the first iteration we will test $(4,2)$. Let the last vertex added to the stack be $q$ and the vertex that was added before that be $p$. Let $r=(4,2)$. We need to test if $q$ is a convex vertex or in other words that $r$ is on the left of the line that goes through $\overline{pq}$ (we are making a left turn on $q$). How can test this? by performing yet another orientation test! Since $(4,2)$ is indeed on the left of the line, then it is safe to add it to the stack.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-step2.png" width="120%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 3: (Iteration 2)</b></h4>
<p>Next we will test $(6,4)$ against the last two vertices added to the stack. This time they are $q=(4,2)$ and $p=(7,0)$. Is $r=(6,4)$ on the left of the line that goes through $(7,0)$ and then $(4,2)$. No! it is not. In this case, Graham will pop the last vertex we added to the stack which was $q=(4,2)$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-step3.png" width="60%" class="center" /></p>
<p>But now we not exit this iteration yet because we want to give the new point $(6,4)$ another chance. This time however, we will test $(6,4)$ against the current last two points on the stack which are $(7,0)$ and $(1,1)$. We will find that $(6,4)$ is on the left of the line that goes through $(1,1)$ and $(7,0)$ and we will add it to the stack. At this point, we can exit the iteration.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-step4.png" width="120%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 3: (Iteration 3)</b></h4>
<p>In the next iteration, we will test $(3,5)$. The last two points in the stack are $(6,4)$ and $(7,0)$. Is $(3,5)$ on the left of the line that goes through $(7,0)$ and $(6,4)$? Yes! so we add $(3,5)$ to the stack.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-step5.png" width="120%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 3: (Iteration 4)</b></h4>
<p>Next, we will test $(5,6)$. Is $(5,6)$ on the left of the line that goes through $(6,4)$ and then $(3,5)$? No! $(5,6)$ is on the right and therefore, we now pop $(3,5)$ from the stack.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-step6.png" width="60%" class="center" /></p>
<p>After popping $(3,5)$, we remain in the same iteration but now we test $(5,6)$ with current last two points on the stack $(6,4)$ and $(7,0)$. We will see that $(5,6)$ does validate the invariant and the vertex is still convex at $(6,4)$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/graham-step7.png" width="120%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 3: (Iteration 5)</b></h4>
<p>The last remaining point left in the array is $(2,7)$. We will perform the same test and find that indeed $(2,7)$ can be added to the stack.</p>
<p>style="text-align:center;"&gt;<img src="http://localhost:4000/assets/geometry/graham/graham-step8.png" width="120%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Step 3: Recap</b></h4>
<p>Let’s summarize what we did so far. In each iteration, we will test vertex $i$ with the last two vertices in the stack. Let the top most vertex be $q$ and the second top most vertex be $p$. We will then use the orientation test on $p, q$ and $r$.</p>
<ul>
    <li>If test is positive and $r$ is indeed on the left, then we'll push $r$ on the stack and move to the next iteration.</li>
    <li>If the test is negative and $r$ on the right, then we'll pop $q$ from the stack and repeat the same test (though now we'll have different $q$ and $p$ vertices).</li>
</ul>
<p>One possible implementation is the following</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">stack</span><span class="p">;</span>
    <span class="c1">// The first two vertices are guaranteed to be on the hull</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">left_most</span><span class="p">);</span>
    <span class="n">stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="c1">// starting from the 3rd point,</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// let p = stack[stack.size()-2], q = stack[stack.size()-1], r = points[i]</span>
        <span class="c1">// if r is on the right, of the line pq, then pop q and repeat the same test</span>
        <span class="c1">// though now with a different p and q points</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">stack</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">strict_right</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">stack</span><span class="p">[</span><span class="n">stack</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// otherwise, r is on the left so just push it on the stack</span>
        <span class="n">stack</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Collinear Points</b></h4>
<p>What do we do with the collinear points? It depends. If we don’t care about collinear points and don’t want to output them, then instead of using “strict_right” above, we will use “right” to disallow collinear points from getting added to the stack. If we care and want to output all collinear points, then we’ll need to do some additional processing. I really struggled with understanding this myself so let’s show this with an example. 
<br />
<br />
Suppose we are given the following points. We know per the algorithm we designed that no points are going to be located either on the left of “left_most” nor directly beneath it and this is because we break ties with picking the lowest y-coordinate.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/col-1.png" width="120%" class="center" /></p>

<p>Next, we sort the points around “left_most” so that we will traverse the points from the most right point (smallest angle) to the most left point. I labeled the points with their traversal order. Also note here that we break ties based on the distance to “left_most”. The 9th and 10th points have the same angle but the 9th point is closer to “left_most” than the 10th point.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/col-2.png" width="120%" class="center" /></p>

<p>Next, we will proceed with the main loop, adding one vertex to the stack each iteration.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/col-3.png" width="120%" class="center" /></p>

<p>When we add the 10th point to the stack, notice that the 10th point is now on the right of the line that goes through the 8th and 9th points and therefore we don’t add it and exit the loop.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/graham/col-4.png" width="120%" class="center" /></p>

<p>How do we fix this? We fix this by reverse sort the very last collinear points in the sorted array such that the closest point to “left_most” is actually the last point in the sorted order. This will allow us to test the 10th point first before the 9th point. We can simply do this using:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">collinear</span><span class="p">(</span><span class="n">left_most</span><span class="p">,</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">points</span><span class="p">.</span><span class="n">back</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">i</span><span class="o">--</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">reverse</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">points</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Full Source Code</b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">while</span> <span class="p">(</span><span class="n">hull_candidate</span> <span class="o">!=</span> <span class="n">first_convex_hull_point</span><span class="p">)</span></code></pre></figure>

<p>Source Code <a href="?">11626 - Convex Hull</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Practice Problems</b></h4>
<p><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=2673">11626 Convex Hull</a>
<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=622">681 Convex Hull Finding</a>
<a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=24&amp;page=show_problem&amp;problem=2037">11096 - Nails</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li><a href="https://www.cambridge.org/core/books/computational-geometry-in-c/22A04E03A4BB10C382A1257F64477E1B">Computational Geometry in C</a></li>
<li><a href="https://jeffe.cs.illinois.edu/teaching/compgeom/schedule.html">CS 498: Computational Geometry</a></li>
<li><a href="https://cp-algorithms.com/geometry/convex-hull.html">Convex Hull Graham Scan Implementation</a></li>
</ul>
<p><br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[A set of points $S$ is convex if for any two points $a \in S$ and $b \in S$, then the line segment connecting these two points is also in $S$ ($\overline{ab} \subseteq S$). The convex hull of $S$ is the smallest convex set that contains all the points in $S$. In the previous post we discussed Jarvis’s algorithm which picked an initial vertex and added it to the convex hull and then iterated over the remaining vertices. In each iteration, we picked and added to the hull the furthest to the right vertex relative to the last added vertex to the hull. The running time of Jarvis’ March is $O(nh)$ where $n$ is the size of the given set of points and $h$ is the size of the convex hull. In this post, we will learn a faster algorithm that runs in time $O(n\log n)$. Graham's Scan Given a set of points $S$ of size $n$, the idea is to pick a point $p_0$ from the set that is known to be in the convex hull and then sort the remaining points by their angle anticlockwise relative to $p_0$. Graham gave a linear-time algorithm to find vertex that is interior to the hull but this isn’t needed at all since we can just pick the lowest or left most vertex and know that all the remaining vertices will be on one side of the line that goes through the point. After picking an initial point, the algorithm will sort the remaining points anitclockwise around the initial point by their angle. The core of the algorithm then is to use a stack to maintain the convex hull. We’ll iterate over the vertices keeping the invariant that for any three consective vertices on the stack $p$, $q$ and $r$, the point $r$ is on the left of the line that goes through the segment $\overline{pq}$. In other words, the angle at $q$ is a convex angle and not a reflex one. In the next few sections we’ll study each step through an example. Step 1: Pick the Left Most Point The best way to learn this algorithm is by following an example. Suppose we are given the below 7 points, The first thing that the algorithm does is pick the left most point breaking ties by choosing the point with the lowest y-coordinate. This turns out to be point $(1,1)$ below In the implementation, we do something like this Point left_most = points[0]; for (int i = 1; i &lt; points.size(); i++) { if (points[i].x &lt; left_most.x || (points[i].x == left_most.x &amp;&amp; points[i].y &lt; left_most.y)) { left_most = points[i]; } } Step 2: Sort the Points Next we will sort the points by their angle (anticlockwise) around $(1,1)$. What does this mean? We’re not changing where the points are. We’re just changing the order in which we will process these points. What we want is to traverse the points in an anti-clockwise direction around $(1,1)$. So we want to start with the point that is furthest to the right from $(1,1)$ (remember that this is the left most point and there won’t be points anymore on the left). Therefore, if you imagine $(1,1)$ connected with line segments to each of the remaining points, then what we want is to sort these by the angles they make around $(1,1)$. How do we sort by their angels? We will use the famous orientation test we’ve studied in (Orientation of Three Points). To recap, Suppose we’re given three ordered points $p, q, r$, then the expression (derived from slopes) $(q_x-p_x)(r_y-p_y) - (r_x-p_x)(q_y-p_y)$ is Greater than zero when the slope of $pq$ is smaller than the slope of $pr$ and so the ordered points $p, q$ and $r$ are in anti-clockwise orientation and $r$ is on the left of the line $pq$ Equal to zero if they're collinear Less than zero when the slope of $pq$ is greater than the slop of $pr$ and so the ordered points $p, q$ and $r$ in a counter clockwise orientation and $r$ is on the left of the line $pq$ This means that if we take the points $(1,1), (7,0)$ and $(4,2)$ and we want to know if $(4,2)$ comes before $(7,0)$ in the sorted order, then we’ll ask the question: “Is $(4,2)$ on the left of the line that goes through $(1,1)$ and $(7,0)$ ? if the answer is yes then $(4,2)$ should instead come after $(7,0)$. Evaluating the expression for $p=(1,1), q=(7,2)$ and $r=(4,2)$, we see that \((7-1)*(2-1) - (4-1)*(0-1) = 6 - (-3) &gt; 0\). Therefore, then we know that $(4,2)$ is on the left and in the sorted order, $(7,0)$ must come first. How do we break ties? One example would be to choose the closest point between the two based on their distances to “left_most”. The final output will be the following (sorted points from $a$ to $f$). In the implementation, this is an example of how one might write the orientation function. int orientation(Point a, Point b, Point c) { long long area = (b.x - a.x)*(c.y - a.y) - (c.x - a.x)*(b.y - a.y); if (area &lt; 0) { return -1; // cw } else if (area &gt; 0) { return 1; // ccw } return 0; } And this is how we can sort the array using $std::sort$, sort(points.begin(), points.end(), [&amp;left_most](const Point&amp; a, const Point&amp; b) { int d = orientation(left_most, a, b); if (d &gt; 0) { // ccw return true; } else if (d == 0) { // collinear return distance(a, left_most) &lt; distance(left_most, b); } return false; }); Step 3: The Main Loop So now we have an initial point picked and we have the points sorted around it. Next, we will use a stack $s$ to hold the hull points. Initially, $s$ will hold the first two vertices in the sorted list of points, $(1,1)$ and $(7,0)$. Notice that $(1,1)$ and $(7,0)$ will be on the convex hull. $(1,1)$ is the left most point and $(7,0)$ is the point furthest to the right from $(1,1)$. (proof?). Step 3: (Iteration 1) Next we’ll iterate over the remaining points. In the first iteration we will test $(4,2)$. Let the last vertex added to the stack be $q$ and the vertex that was added before that be $p$. Let $r=(4,2)$. We need to test if $q$ is a convex vertex or in other words that $r$ is on the left of the line that goes through $\overline{pq}$ (we are making a left turn on $q$). How can test this? by performing yet another orientation test! Since $(4,2)$ is indeed on the left of the line, then it is safe to add it to the stack.]]></summary></entry><entry><title type="html">Jarvis’s March (Gift Wrapping)</title><link href="http://localhost:4000/jekyll/update/2023/08/30/convex-hull.html" rel="alternate" type="text/html" title="Jarvis’s March (Gift Wrapping)" /><published>2023-08-30T01:01:36-07:00</published><updated>2023-08-30T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/08/30/convex-hull</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/08/30/convex-hull.html"><![CDATA[<!------------------------------------------------------------------------------------>
<h4><b>Convexity</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/conv-0.png" width="100%" class="center" /></p>
<p>A set of points $S$ is <b>convex</b> if for any two points $p$ and $q$ in $S$, the line segment connecting these two points is also in $S$ ($\overline{pq} \subseteq S$). A convex polygon is a polygon that is the boundary of a convex set. The left figure is a convex polygon while the right figure is not per our definition.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Convex Hull</b></h4>
<p>Given a set of points $S$, the <b>convex hull</b> of $S$ is the smallest <b>convex</b> set that contains all the points in $S$. This naturally implies that if we take the intersection of all convex sets of $S$, then the result will be the convex hull of $S$.</p>
<div>
$$
\begin{align*}
conv(S) = \text{ Intersection of all convex sets containing $S$ }
\end{align*}
$$
</div>
<p>There are infinitely many convex sets that will contain all the points in $S$. It turns out that this definition also works for a special kind of convex sets, called half-planes.</p>
<div>
$$
\begin{align*}
conv(S) = \text{ Intersection of all "half planes" containing $S$ }
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Finding the Convex Hull</b></h4>
<p>Finding the convex hull is a classic computatioal geometry problem and many algorithms have been developed to solve it. Next, we discuss one of the simplest algorithms that is used to find the convex hull of a set of points.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Jarvis's March (Gift Wrapping Algorithm)</b></h4>
<p>Jarvis’s March is similar to Selection Sort. In each iteration of Selection Sort, we pick the smallest element in the array and then move it to the front. Once we’re done, we’ll have a sorted array. In Jarvis’s algorithm, the smallest element in each iteration is the vertex that is furthest to the right from the last vertex that was added to the convex hull. There are two main steps.</p>
<ol>
	<li>Find the left most vertex</li>
	<li>Find the next vertex in the hull and repeat this until we're done.</li>
	
</ol>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>1. Pick the Left Most Vertex</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-1.png" width="60%" class="center" /></p>
<p>Initially, we will pick a vertex that we know will be in the hull. We can pick the left most vertex or the bottom most vertex or any vertex where all the points will be on one side (half plane). Let’s pick the left most vertex and let it be $p_0$.</p>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>2. Pick the Next Vertex in the Convex Hull</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2.png" width="70%" class="center" /></p>
<p>Step two is about picking the next vertex in the hull and doing so until we find all of them. To do so, imagine shooting a ray from $p_0$ to each of the remaining vertices (figure above). The next vertex in the hull is the vertex that is furthest to the right relative to $p_0$. How do we determine which vertex is furthest to the right?. Before exploring this, let’s define two variables:</p>
<ul>
	<li> $p$ will track the last point that was added to the hull. $p$ is initially $p_0$.</li>
	<li> $q$ will track the current right most vertex relative to $p$. $q$ will be initialized to $p + 1$ at the begining of each iteration.</li>
	
</ul>
<p>We will iterate through the vertices while updating $q$ whenever we come across a vertex that is furthest to the right from $p$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2a.png" width="85%" class="center" /></p>
<p>To test if vertex $i$ is furthest to the right than $q$, we will use the orientation test that we previously developed when triagulating a polygon. (See Orientation of Three Points). Precisely, we’ve derived an expression to find out whether a point $r$ is on the left or right of the line that goes through two given points $p$ and $q$. We can wrap this expression in the function below.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// determines if r is on the left of the line pq</span>
<span class="kt">int</span> <span class="nf">direction</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">r_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">q_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// anti-clockwise</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// clockwise</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// collinear</span>
<span class="p">}</span></code></pre></figure>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2b.png" width="85%" class="center" /></p>
<p>We can see above that $i$ is indeed more to the right of the line and hence furthest to the right from $p$. So now we set $q$ to $i$ and move on to test the next vertex.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2c.png" width="75%" class="center" /></p>
<p>After we’re done testing all the vertices, $q$ will be the right most vertex relative to $p$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2final.png" width="80%" class="center" /></p>
<p>At this point we will</p>
<ul>
	<li>Add $q$ above to the convex hull. </li>
	<li>Set $p$ to $q$. (the last vertex added to the convex hull is $q$) </li>
	<li>Set $q$ to $p + 1$. (The next vertex in the set of vertices not on the hull yet). </li>
</ul>
<p>The pesudo code below shows an outline of what we’re doing each step or iteration. The outer loop sets the initial $q$ to $p+1$ later on adds it to the convex hull when we’re done with the inner loop. The inner loop will test all the vertices and update $q$ whenever we find a better vertex.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">first_point_on_hull</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// (1) initialize q</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1">// (2) iterate through each vertex i and update q if necessary </span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mf">1.</span><span class="p">..</span><span class="n">size</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">orientation</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">q</span> <span class="o">=</span> <span class="n">i</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// (3) add q to the convex hull and set p to q</span>
    <span class="n">convex_hull</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">q</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>3. Termination</b></h4>
<p>When do we terminate? We terminate when the next vertex that we want to add to the convex hull is actually the first vertex that we added to the hull. Once we get to this point, then we terminate and return the convex hull points.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-4.png" width="65%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Running Time</b></h4>
<p>How fast is Jarvis’s March? The inner loop goes over $O(n)$ vertices. The outerloop really depends on the size of the convex hull. If we have $h$ points in the hull, then the running time is $O(h)$. Therefore, the overall running time is $O(hn)$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://jeffe.cs.illinois.edu/teaching/compgeom/schedule.html">CS 498: Computational Geometry</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Convexity A set of points $S$ is convex if for any two points $p$ and $q$ in $S$, the line segment connecting these two points is also in $S$ ($\overline{pq} \subseteq S$). A convex polygon is a polygon that is the boundary of a convex set. The left figure is a convex polygon while the right figure is not per our definition. Convex Hull Given a set of points $S$, the convex hull of $S$ is the smallest convex set that contains all the points in $S$. This naturally implies that if we take the intersection of all convex sets of $S$, then the result will be the convex hull of $S$. $$ \begin{align*} conv(S) = \text{ Intersection of all convex sets containing $S$ } \end{align*} $$ There are infinitely many convex sets that will contain all the points in $S$. It turns out that this definition also works for a special kind of convex sets, called half-planes. $$ \begin{align*} conv(S) = \text{ Intersection of all "half planes" containing $S$ } \end{align*} $$ Finding the Convex Hull Finding the convex hull is a classic computatioal geometry problem and many algorithms have been developed to solve it. Next, we discuss one of the simplest algorithms that is used to find the convex hull of a set of points. Jarvis's March (Gift Wrapping Algorithm) Jarvis’s March is similar to Selection Sort. In each iteration of Selection Sort, we pick the smallest element in the array and then move it to the front. Once we’re done, we’ll have a sorted array. In Jarvis’s algorithm, the smallest element in each iteration is the vertex that is furthest to the right from the last vertex that was added to the convex hull. There are two main steps. Find the left most vertex Find the next vertex in the hull and repeat this until we're done. 1. Pick the Left Most Vertex Initially, we will pick a vertex that we know will be in the hull. We can pick the left most vertex or the bottom most vertex or any vertex where all the points will be on one side (half plane). Let’s pick the left most vertex and let it be $p_0$.]]></summary></entry><entry><title type="html">Triangulation (Algorithm)</title><link href="http://localhost:4000/jekyll/update/2023/08/29/triangulation-algorithm.html" rel="alternate" type="text/html" title="Triangulation (Algorithm)" /><published>2023-08-29T01:01:36-07:00</published><updated>2023-08-29T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/08/29/triangulation-algorithm</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/08/29/triangulation-algorithm.html"><![CDATA[<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-0.png" width="80%" class="center" /></p>
<p>So far we discussed some theory behind triangultion. We proved the existence of a diagonal and triagulation for simple polygons. We also wrote code to verify for a given polygon $p$ and a given line segment $d$, whether $d$ is an internal diagonal or not. So where do we go from here to actually triangulate $p$?
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>The Naive Solution: Test All Candidates</b></h4>
<p>How many potentional cadidates for a diagonal do we have in a given polygon $p$ with $n$ vertices? Since the diagonal must intersect $p$ at its end points, then we know that the diagonal’s start and end points must be from the $n$ vertices. This means that we have ${n \choose 2} = O(n^2)$ possible segments to test. The test we developed in the previous post (Triangulation (Finding a Diagonal) costs $O(n)$ time since we iterate over all vertices to test for intersection Moreover, we know that since $p$ has $n$ vertices then the triagulation of $p$ will use $n-3$ diagonals. Therefore, we will end up with an $O(n^4)$ total cost if we naively test every possible diagonal to triangulate $p$. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>The Naive Solution: Test All Candidates</b></h4>
<p>How many potentional cadidates for a diagonal do we have in a given polygon $p$ with $n$ vertices? Since the diagonal must intersect $p$ at its end points, then we know that the diagonal’s start and end points must be from the $n$ vertices. This means that we have ${n \choose 2} = O(n^2)$ possible segments to test. The test we developed in the previous post (Triangulation (Finding a Diagonal) costs $O(n)$ time since we iterate over all vertices to test for intersection Moreover, we know that since $p$ has $n$ vertices then the triagulation of $p$ will use $n-3$ diagonals. Therefore, we will end up with an $O(n^4)$ total cost if we naively test every possible diagonal to triangulate $p$. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.cambridge.org/core/books/computational-geometry-in-c/22A04E03A4BB10C382A1257F64477E1B">Computational Geometry in C</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[So far we discussed some theory behind triangultion. We proved the existence of a diagonal and triagulation for simple polygons. We also wrote code to verify for a given polygon $p$ and a given line segment $d$, whether $d$ is an internal diagonal or not. So where do we go from here to actually triangulate $p$? The Naive Solution: Test All Candidates How many potentional cadidates for a diagonal do we have in a given polygon $p$ with $n$ vertices? Since the diagonal must intersect $p$ at its end points, then we know that the diagonal’s start and end points must be from the $n$ vertices. This means that we have ${n \choose 2} = O(n^2)$ possible segments to test. The test we developed in the previous post (Triangulation (Finding a Diagonal) costs $O(n)$ time since we iterate over all vertices to test for intersection Moreover, we know that since $p$ has $n$ vertices then the triagulation of $p$ will use $n-3$ diagonals. Therefore, we will end up with an $O(n^4)$ total cost if we naively test every possible diagonal to triangulate $p$. The Naive Solution: Test All Candidates How many potentional cadidates for a diagonal do we have in a given polygon $p$ with $n$ vertices? Since the diagonal must intersect $p$ at its end points, then we know that the diagonal’s start and end points must be from the $n$ vertices. This means that we have ${n \choose 2} = O(n^2)$ possible segments to test. The test we developed in the previous post (Triangulation (Finding a Diagonal) costs $O(n)$ time since we iterate over all vertices to test for intersection Moreover, we know that since $p$ has $n$ vertices then the triagulation of $p$ will use $n-3$ diagonals. Therefore, we will end up with an $O(n^4)$ total cost if we naively test every possible diagonal to triangulate $p$. References Computational Geometry in C]]></summary></entry><entry><title type="html">Triangulation (Finding a Diagonal)</title><link href="http://localhost:4000/jekyll/update/2023/08/28/triangulation-diagonal.html" rel="alternate" type="text/html" title="Triangulation (Finding a Diagonal)" /><published>2023-08-28T01:01:36-07:00</published><updated>2023-08-28T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/08/28/triangulation-diagonal</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/08/28/triangulation-diagonal.html"><![CDATA[<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-0.png" width="80%" class="center" /></p>
<p>So now that we know that every polygon $p$ has a triangulation, how are we going to triangulate $p$? The key to proving that triangulation exists was finding a diagonal. Similarly, the first step in triangulation is to find an internal diagonal. Given a diagonal candidate we need to verify two conditions:</p>
<ul>
	<li> $\overline{ab}$'s itersection with the boundary of $P$ is exactly its end points $a$ and $b$ and nothing else. </li>
	<li> $\overline{ab}$ is an an internal diagonal. </li>
</ul>
<p>How can we verify the above conditions? In this post, we’ll develop procedures to verify these two conditions.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Condition 1: Intersection of the diagonal $d$ with the boundary of $p$</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-1.png" width="60%" class="center" /></p>
<p>So given a diagonal candidate $d$ with end points $a$ and $b$, how do we go about testing its intersection with the boundary of $p$. The boundary consists of the edges of the polygon. The diagonal is incident to at most 4 of these edges. If we keep this case seperately and focus on the rest of edges, then we simply want to know if this candidate doesn’t intersect ANY of these edges besides the special 4. In other words, for all other edges that are not incident to $a$ or $b$, their intersection with $d=ab$ is empty.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Segment Intersection</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-2.png" width="60%" class="center" /></p>
<p>Since we only care about the existence of an intersection rathar than the intersection point itself, then we can go back to what we studided before about the orientation of three ordered points (see Orientation of Three Points post and also Segment Intersection (CLRS)). Suppose we’re given three ordered points $p, q, r$, then the expression $(q_x-p_x)(r_y-p_y) - (r_x-p_x)(q_y-p_y)$ is</p>
<ul>
    <li>Greater than zero when the slope of $pq$ is smaller than the slope of $pr$ and so the ordered points $p, q$ and $r$ are in anti-clockwise orientation and $r$ is on the left of the line $pq$</li>
    <li>Equal to zero if they're collinear</li>
    <li>Less than zero when the slope of $pq$ is greater than the slop of $pr$ and so the ordered points $p, q$ and $r$ in a counter clockwise orientation and $r$ is on the left of the line $pq$</li>
</ul>
<p>We can write a little helper to compute this</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// determines if r is on the left of the line pq</span>
<span class="kt">int</span> <span class="nf">direction</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">r_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">q_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// anti-clockwise</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// clockwise</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// collinear</span>
<span class="p">}</span></code></pre></figure>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-3.png" width="40%" class="center" /></p>
<p>How do we use this test to determine if $\overline{ab}$ and $\overline{cd}$ intersect? We can use it to test if the points $a$ and $b$ are on opposite sides of the line that goes through $\over{cd}$ above. But is this enough? No! Consider the following figure.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-4.png" width="40%" class="center" /></p>
<p>$a$ and the $b$ are in fact on opposite sides of the line that goes through $c$ and $d$ but the segment from $a$ to $b$ doesn’t intersect the segment that goes through $c$ and $d$! To fix this, we also need to ask whether the points $c$ and $d$ are on opposite sides of the line that goes through $\overline{ab}$ and the answer is clearly not! $c$ and $d$ are on the same side. This is great but there is one more condition to consider. Consider the following:</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-5.png" width="40%" class="center" /></p>
<p>Here, the points $a$, $d$ and $b$ are collinear. So $c$ and $d$ are not exactly on opposite sides but they still intersect! So what do we do here? In the book that I’ve been studying “Computational Geometry in C”, the intersection function is split into two to handle the case of improper intersection (when the points are collinear) and the case of proper intersection (when the points are not collinear). I personally found the CLRS way of computing the intersection all at once was easier to understand (likely due to the fact that I studied it first!). In CLRS, we test for proper intersection and in the same function later on, we handle the case when the points are collinear to additionally verify that they indeed intersect.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"> 
<span class="kt">bool</span> <span class="nf">interesect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span> <span class="c1">// which side is c on?</span>
    <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span> <span class="c1">// same for d</span>
    <span class="kt">int</span> <span class="n">d3</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">d4</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
    <span class="c1">// proper interesection</span>
    <span class="k">if</span>  <span class="p">((</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">d2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> 
         <span class="p">(</span><span class="n">d3</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d4</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">d4</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">d3</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
         <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// improper intersection</span>
    <span class="c1">// check if c sits between the end two points</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">between_line_segment</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// check if d sits between the end two points</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d2</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">between_line_segment</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// check if a sits between the end two points</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d3</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">between_line_segment</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// check if b sits between the end two points</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d4</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">between_line_segment</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>So now we have a function that will test if a given candidate $d$ intersects the boundary of $P$ except for the special edges that are incident to $d$ itself.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"> 
<span class="kt">bool</span> <span class="nf">diagonalie</span><span class="p">(</span><span class="n">tVertex</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">tVertex</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">tVertex</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">c1</span><span class="p">;</span>
   <span class="cm">/* For each edge (c,c1) of P */</span>
   <span class="n">c</span> <span class="o">=</span> <span class="n">vertices</span><span class="p">;</span>
   <span class="k">do</span> <span class="p">{</span>
      <span class="n">c1</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
      <span class="cm">/* Skip edges incident to a or b */</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">c</span> <span class="o">!=</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c1</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span>
          <span class="o">&amp;&amp;</span> <span class="n">intersect</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">c1</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="n">vertices</span><span class="p">);</span>
   <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Next we will study condition 2 which will handle both testing to see if $d$ is internal and testing the special edges that we didn’t consider this round.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Condition 2: $d$ is an internal diagonal (and more) </b></h4>
<p>Suppose that $d$ indeed doesn’t intersect the boundary (minus the special edges). $d$ has two vertices $a$ and $b$. We will perform the following test on both vertices but just for demonstration, let’s choose vertex $a$. Suppose that vertex $a$ is a convex vertex (this can be determined by checking if $a$ is on the (left or on) of the line that goes through $\overline{aa_0}$). Let’s consider the following cases:</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-convex.png" width="100%" class="center" /></p>
<ul>
	<li>In figure (1), $a_0$ is the left of the line that goes through $d$ and $a_1$ is on the right of the line that goes through $d$ so we satisfy both conditions and $d$ is indeed internal</li>
	<li> In figure (2), both $a_0$ and $a_1$ are on the left of the line that goes through $\overline{ab}$</li>
	<li> In figure (3), $a, a_1$ and $b$ are all collinear. So testing whether $a_1$ is on the right of $d$ will fail immediately. </li>
</ul>
<p>So it seems like we can conclude that $d$ is internal when:</p>
<ul>
	<li>$a_0$ is on the left of the line that goes through $d=\overline{ab}$.</li>
	<li>$a_1$ is on the right of the line that goes through $d=\overline{ab}$.</li>
</ul>
<p>(TODO: Actual proof?). Now let’s look at the concave vertex case and see some cases:</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/triangulation-algorithm/tri-concave.png" width="100%" class="center" /></p>
<ul>
	<li>In figure (1), $a_0$ is the right of the line that goes through $d$ and $a_1$ is on the left of the line that goes through $d$ and $d$ is not internal.</li>
	<li> In figure (2), both $a_0$ and $a_1$ are on the left of the line that goes through $\overline{ab}$. In fact we can draw $ab$ to the right of the two points or between the two points</li>
	<li> In figure (3), $a, a_1$ and $b$ are all collinear. $d$ is not internal. </li>
</ul>
<p>So the diagonal can really be anywhere. But the clever observation here is that if you compare the concave vertex figures to the convex vertex figures, you’ll see that the only difference is the shaded region is now on the opposite side. In fact, when I drew the second set of cases, I just copied the first 3 figures and changed the shaded areas to be the opposite. This means that we can take the same conditions above for the convex vertex and just conclude that if these conditions are NOT present, then we have an internal diagonal. There is one tiny detail though! instead of left and right, we need to check for (left and on) and (right and on) since we don’t want the case when the points are collinear.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"> 
<span class="kt">bool</span> <span class="nf">in_cone</span><span class="p">(</span><span class="n">tVertex</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">tVertex</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">tVertex</span> <span class="o">*</span><span class="n">a0</span><span class="p">,</span> <span class="o">*</span><span class="n">a1</span><span class="p">;</span>    <span class="cm">/* a0,a,a1 are consecutive vertices. */</span>
   <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
   <span class="n">a0</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
   <span class="cm">/* If a is a convex vertex */</span>
   <span class="cm">/* right(a-&gt;v, b-&gt;v, a1-&gt;v) is the same as left(b-&gt;v, a-&gt;v, a1-&gt;v) */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">left_on</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a0</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">left</span><span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a0</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">left</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
   <span class="cm">/* else a is reflex: */</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">left_on</span><span class="p">(</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a1</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">left_on</span><span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">,</span> <span class="n">a0</span><span class="o">-&gt;</span><span class="n">v</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>And finally we can write a function to test if a candidate segment is an internal diagonal below,</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"> 
<span class="kt">bool</span> <span class="nf">is_diagonal</span><span class="p">(</span><span class="n">tVertex</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">tVertex</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">return</span> <span class="n">in_cone</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">in_cone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">diagonalie</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.cambridge.org/core/books/computational-geometry-in-c/22A04E03A4BB10C382A1257F64477E1B">Computational Geometry in C</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[So now that we know that every polygon $p$ has a triangulation, how are we going to triangulate $p$? The key to proving that triangulation exists was finding a diagonal. Similarly, the first step in triangulation is to find an internal diagonal. Given a diagonal candidate we need to verify two conditions: $\overline{ab}$'s itersection with the boundary of $P$ is exactly its end points $a$ and $b$ and nothing else. $\overline{ab}$ is an an internal diagonal. How can we verify the above conditions? In this post, we’ll develop procedures to verify these two conditions. Condition 1: Intersection of the diagonal $d$ with the boundary of $p$ So given a diagonal candidate $d$ with end points $a$ and $b$, how do we go about testing its intersection with the boundary of $p$. The boundary consists of the edges of the polygon. The diagonal is incident to at most 4 of these edges. If we keep this case seperately and focus on the rest of edges, then we simply want to know if this candidate doesn’t intersect ANY of these edges besides the special 4. In other words, for all other edges that are not incident to $a$ or $b$, their intersection with $d=ab$ is empty. Segment Intersection Since we only care about the existence of an intersection rathar than the intersection point itself, then we can go back to what we studided before about the orientation of three ordered points (see Orientation of Three Points post and also Segment Intersection (CLRS)). Suppose we’re given three ordered points $p, q, r$, then the expression $(q_x-p_x)(r_y-p_y) - (r_x-p_x)(q_y-p_y)$ is Greater than zero when the slope of $pq$ is smaller than the slope of $pr$ and so the ordered points $p, q$ and $r$ are in anti-clockwise orientation and $r$ is on the left of the line $pq$ Equal to zero if they're collinear Less than zero when the slope of $pq$ is greater than the slop of $pr$ and so the ordered points $p, q$ and $r$ in a counter clockwise orientation and $r$ is on the left of the line $pq$ We can write a little helper to compute this // determines if r is on the left of the line pq int direction(p, q, r) { int product = (q_x-p_x)(r_y-p_y) - (r_x-p_x)(q_y-p_y); if (product &gt; 0) { return 1; // anti-clockwise } else if (product &lt; 0) { return -1; // clockwise } return 0; // collinear } How do we use this test to determine if $\overline{ab}$ and $\overline{cd}$ intersect? We can use it to test if the points $a$ and $b$ are on opposite sides of the line that goes through $\over{cd}$ above. But is this enough? No! Consider the following figure. $a$ and the $b$ are in fact on opposite sides of the line that goes through $c$ and $d$ but the segment from $a$ to $b$ doesn’t intersect the segment that goes through $c$ and $d$! To fix this, we also need to ask whether the points $c$ and $d$ are on opposite sides of the line that goes through $\overline{ab}$ and the answer is clearly not! $c$ and $d$ are on the same side. This is great but there is one more condition to consider. Consider the following: Here, the points $a$, $d$ and $b$ are collinear. So $c$ and $d$ are not exactly on opposite sides but they still intersect! So what do we do here? In the book that I’ve been studying “Computational Geometry in C”, the intersection function is split into two to handle the case of improper intersection (when the points are collinear) and the case of proper intersection (when the points are not collinear). I personally found the CLRS way of computing the intersection all at once was easier to understand (likely due to the fact that I studied it first!). In CLRS, we test for proper intersection and in the same function later on, we handle the case when the points are collinear to additionally verify that they indeed intersect. bool interesect(a, b, c, d) { int d1 = direction(a, b, c); // which side is c on? int d2 = direction(a, b, d); // same for d int d3 = direction(c, d, a); int d4 = direction(c, d, b); // proper interesection if ((d1 &lt; 0 &amp;&amp; d2 &gt; 0) || (d2 &lt; 0 &amp;&amp; d1 &gt; 0) || (d3 &lt; 0 &amp;&amp; d4 &gt; 0) || (d4 &lt; 0 &amp;&amp; d3 &gt; 0)) { return true; } // improper intersection // check if c sits between the end two points if (d1 == 0 &amp;&amp; between_line_segment(a, b, c)) return true; // check if d sits between the end two points if (d2 == 0 &amp;&amp; between_line_segment(a, b, d)) return true; // check if a sits between the end two points if (d3 == 0 &amp;&amp; between_line_segment(c, d, a)) return true; // check if b sits between the end two points if (d4 == 0 &amp;&amp; between_line_segment(c, d, b)) return true; } So now we have a function that will test if a given candidate $d$ intersects the boundary of $P$ except for the special edges that are incident to $d$ itself. bool diagonalie(tVertex *a, tVertex *b) { tVertex *c, *c1; /* For each edge (c,c1) of P */ c = vertices; do { c1 = c-&gt;next; /* Skip edges incident to a or b */ if ((c != a) &amp;&amp; (c1 != a) &amp;&amp; (c != b) &amp;&amp; (c1 != b) &amp;&amp; intersect(a-&gt;v, b-&gt;v, c-&gt;v, c1-&gt;v)) { return false; } c = c-&gt;next; } while (c != vertices); return true; } Next we will study condition 2 which will handle both testing to see if $d$ is internal and testing the special edges that we didn’t consider this round. Condition 2: $d$ is an internal diagonal (and more) Suppose that $d$ indeed doesn’t intersect the boundary (minus the special edges). $d$ has two vertices $a$ and $b$. We will perform the following test on both vertices but just for demonstration, let’s choose vertex $a$. Suppose that vertex $a$ is a convex vertex (this can be determined by checking if $a$ is on the (left or on) of the line that goes through $\overline{aa_0}$). Let’s consider the following cases: In figure (1), $a_0$ is the left of the line that goes through $d$ and $a_1$ is on the right of the line that goes through $d$ so we satisfy both conditions and $d$ is indeed internal In figure (2), both $a_0$ and $a_1$ are on the left of the line that goes through $\overline{ab}$ In figure (3), $a, a_1$ and $b$ are all collinear. So testing whether $a_1$ is on the right of $d$ will fail immediately. So it seems like we can conclude that $d$ is internal when: $a_0$ is on the left of the line that goes through $d=\overline{ab}$. $a_1$ is on the right of the line that goes through $d=\overline{ab}$. (TODO: Actual proof?). Now let’s look at the concave vertex case and see some cases: In figure (1), $a_0$ is the right of the line that goes through $d$ and $a_1$ is on the left of the line that goes through $d$ and $d$ is not internal. In figure (2), both $a_0$ and $a_1$ are on the left of the line that goes through $\overline{ab}$. In fact we can draw $ab$ to the right of the two points or between the two points In figure (3), $a, a_1$ and $b$ are all collinear. $d$ is not internal. So the diagonal can really be anywhere. But the clever observation here is that if you compare the concave vertex figures to the convex vertex figures, you’ll see that the only difference is the shaded region is now on the opposite side. In fact, when I drew the second set of cases, I just copied the first 3 figures and changed the shaded areas to be the opposite. This means that we can take the same conditions above for the convex vertex and just conclude that if these conditions are NOT present, then we have an internal diagonal. There is one tiny detail though! instead of left and right, we need to check for (left and on) and (right and on) since we don’t want the case when the points are collinear. bool in_cone(tVertex *a, tVertex *b) { tVertex *a0, *a1; /* a0,a,a1 are consecutive vertices. */ a1 = a-&gt;next; a0 = a-&gt;prev; /* If a is a convex vertex */ /* right(a-&gt;v, b-&gt;v, a1-&gt;v) is the same as left(b-&gt;v, a-&gt;v, a1-&gt;v) */ if (left_on(a-&gt;v, a1-&gt;v, a0-&gt;v)) { return left(a-&gt;v, b-&gt;v, a0-&gt;v) &amp;&amp; left(b-&gt;v, a-&gt;v, a1-&gt;v); } /* else a is reflex: */ return !(left_on( a-&gt;v, b-&gt;v, a1-&gt;v) &amp;&amp; left_on(b-&gt;v, a-&gt;v, a0-&gt;v)); } And finally we can write a function to test if a candidate segment is an internal diagonal below, bool is_diagonal(tVertex *a, tVertex *b) { return in_cone(a, b) &amp;&amp; in_cone(b, a) &amp;&amp; diagonalie(a, b); }]]></summary></entry></feed>