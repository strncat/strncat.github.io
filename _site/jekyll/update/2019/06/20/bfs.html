<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Breadth First Search | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Breadth First Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction" />
<meta property="og:description" content="0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/06/20/bfs.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/06/20/bfs.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-20T12:01:36-07:00" />
<script type="application/ld+json">
{"description":"0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/06/20/bfs.html","headline":"Breadth First Search","dateModified":"2019-06-20T12:01:36-07:00","datePublished":"2019-06-20T12:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/06/20/bfs.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Breadth First Search</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-06-20T12:01:36-07:00" itemprop="datePublished">Jun 20, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><b>0 References</b><br />
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>1 Introduction</b>
<br />
<img src="http://localhost:4000/assets/bfs/bfs1.png" alt="my photo" /></p>

<p>Breadth first search is a useful and widely used algorithm in graph traversal problems. Let <script type="math/tex">G = (V, E)</script> be a graph consisting of <script type="math/tex">V</script> vertices and <script type="math/tex">E</script> edges and let <script type="math/tex">s</script> be the source vertex where we will start the traversal from. The key thing about breadth first search is that it explores the vertices closest (in terms of the number of edges) to the source vertex first. We start by looking at <script type="math/tex">s</script>’s neighbors. These vertices are the closest vertices to <script type="math/tex">s</script> and have distance 1 from <script type="math/tex">s</script>. We then explore each adjacent vertex to all the neighbors. Any vertex adjacent to these vertices will have distance 2 and so on.
<br /><br />
In other words, breadth first search explores the graph in layers. The immediate neighbors are in layer 1 and have distance 1 to the source vertex. The vertices in layer 2 have distance 2 to the source vertex and so on. Given a layer, all the vertices in that layer have the same distance to the source vertex. It turns out that breadth first search also finds the the shortest paths from the <script type="math/tex">s</script> to every other vertex in the graph in terms of the number of edges between <script type="math/tex">s</script> and each vertex. We’ll prove this more formally later!
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2 Data Structures</b>
<br />
To perform a breadth first search, we will maintain the following data structures:
<br />
(1) A queue. We want to explore the nodes closest to <script type="math/tex">s</script> first. We know that a queue maintains the property that a node inserted first will be popped/explored first. We will also use the queue to keep track of the distance of each vertex to <script type="math/tex">s</script>. Initially we will enqueue <script type="math/tex">s</script> with distance 0. When we enqueue new nodes, we will also enqueue their distance to <script type="math/tex">s</script> which is just their parent’s distance plus 1.
<br /><br />
(2) A set or an array that keeps track of the visited nodes. Remember that <script type="math/tex">G</script> might contain cycles and so we want to make sure that we explore each node once only.
<br /><br />
(3) A set or an array that keeps track of the parent nodes. This is optional and only needed if we want to recover the path from <script type="math/tex">s</script> to every other node in <script type="math/tex">G</script>.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3 Example</b>
<br />
Let’s explore the graph above. We will start by popping <script type="math/tex">s</script> from the queue with its distance 0. We will then enqueue the neighbors of <script type="math/tex">s</script> along with distance 1 and also mark them visited. We could also use the parent array to indicate that <script type="math/tex">s</script> is the parent of <script type="math/tex">a</script> and <script type="math/tex">b</script>. At this point, we have <script type="math/tex">a</script> and <script type="math/tex">b</script> in layer 1 with distance 1. We also marked their parent <script type="math/tex">s</script> correctly. This information will not change in any future iteration.</p>

<p><img src="http://localhost:4000/assets/bfs/bfs2.png" alt="my photo" /></p>

<p>Next we will we will pop <script type="math/tex">a</script> from the queue. We will traverse <script type="math/tex">a</script>’s neighbors <script type="math/tex">s</script> and <script type="math/tex">c</script> but <script type="math/tex">s</script> will be ignored since it was visited before. When we add <script type="math/tex">c</script> to the queue, we will also push distance 2 which indicates that <script type="math/tex">c</script> is in layer 2 or is two steps away from <script type="math/tex">s</script>. We also mark <script type="math/tex">c</script>’s parent as <script type="math/tex">a</script>. Next we will we will pop <script type="math/tex">b</script> from the queue and repeat the same process and push <script type="math/tex">d</script> on the queue with distance 2. <script type="math/tex">c</script> and <script type="math/tex">d</script> are colored in green below to indicate that they are in a new layer (distance = 2).</p>

<p><img src="http://localhost:4000/assets/bfs/bfs3.png" alt="my photo" /></p>

<p>We will repeat the same process until the queue is empty and we have reached every node reachable from <script type="math/tex">s</script>.</p>

<p><img src="http://localhost:4000/assets/bfs/bfs4.png" alt="my photo" /></p>

<p>Notice now how the nodes are organized in layers in terms of the distance from <script type="math/tex">s</script> (number of edges).</p>

<p><img src="http://localhost:4000/assets/bfs/bfs5.png" alt="my photo" />
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>4 Implementation</b>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="c1">// another queue to push the distances down (bfs works in layers)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">qd</span><span class="p">;</span>
    <span class="n">qd</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="c1">// visited array so we don't revisit nodes</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="c1">// parent array to print the path</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">parent</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">qd</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">qd</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
                <span class="n">parent</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="n">qd</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// print path (reversed)</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">end</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>5 Proof</b>
<br />
Why does BFS find the shortest paths from <script type="math/tex">s</script> to every other vertex in <script type="math/tex">G</script>? Intuitively, we know that we explore the vertices in layers starting at <script type="math/tex">s</script>. So if we have a vertex <script type="math/tex">x</script> in layer <script type="math/tex">j</script> then we know the distance to <script type="math/tex">s</script> is just <script type="math/tex">j</script> and that <script type="math/tex">x</script> can’t have a shorter path to <script type="math/tex">s</script> simply because we would have found <script type="math/tex">x</script> in an earlier layer, right? Let’s make this formal.
<br />
<br />
<b>Inductive Hypothesis:</b><br />
Let <script type="math/tex">G = (V,E)</script> be a graph and <script type="math/tex">s</script> be the source vertex. Let <script type="math/tex">i</script> and <script type="math/tex">j</script> be natural numbers. For all <script type="math/tex">% <![CDATA[
i < j %]]></script>, the vertices in layer <script type="math/tex">L_i</script> have distance <script type="math/tex">i</script> from <script type="math/tex">s</script>. 
<br />
<br />
<b>Base Case:</b><br />
For <script type="math/tex">j=0</script>, we know that <script type="math/tex">L_0=\{s\}</script> and we know that <script type="math/tex">s</script> has distance 0 from <script type="math/tex">s</script> so we’re done.
<br />
<br />
<b>Inductive Step:</b><br />
Let <script type="math/tex">i</script> and <script type="math/tex">k</script> be natural numbers and suppose that for all <script type="math/tex">% <![CDATA[
i < k %]]></script>, the vertices in layer <script type="math/tex">L_i</script> have distance <script type="math/tex">i</script> from <script type="math/tex">s</script>. We want to prove that all vertices in layer <script type="math/tex">L_{k}</script> have distance <script type="math/tex">i+1=k</script> from <script type="math/tex">s</script>.
<br /><br />
Let <script type="math/tex">w</script> be a vertex in <script type="math/tex">L_k</script>. We must have <script type="math/tex">dist(s,w) \leq k</script>. This is because by the inductive hypothesis, we know that <script type="math/tex">w</script>’s parent is in <script type="math/tex">L_{k-1}</script> and therefore has distance <script type="math/tex">k-1</script> from <script type="math/tex">s</script>. Therefore, we know there is a path from <script type="math/tex">s</script> to <script type="math/tex">w</script> of length <script type="math/tex">k</script>.
<br /><br />
Next we need to prove that <script type="math/tex">dist(s,w) \geq k</script>. Suppose not and that <script type="math/tex">% <![CDATA[
dist(s,w) < k %]]></script>. This means that <script type="math/tex">w</script> must have show up in an earlier layer but we know that it’s impossible and <script type="math/tex">w</script> was only discovered after its parent was discovered in layer <script type="math/tex">k-1</script>. 
<br /><br />
Since <script type="math/tex">dist(s,w) \leq k</script> and <script type="math/tex">dist(s,w) \geq k</script> then we must have <script type="math/tex">dist(s,w)=k</script> as we wanted to show.
<br />
<br />
<b>Conclusion:</b><br />
For all vertices <script type="math/tex">w \in V</script>, if <script type="math/tex">w \in L_j</script>, then <script type="math/tex">dist(s,w) = j</script>.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>6 Proof (Take 2) (The CLRS Way)</b>
<br />
 I really really really want to go through the CLRS way of doing this proof formally. This is a TODO! (starts in page 598)
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>6 Running Time</b>
<br />
We visit each vertex at most once only because of the visited array we’re maintaining. That’s <script type="math/tex">O(V)</script> time. As a result, we also visit the adjacency list of each vertex at most once and that’s <script type="math/tex">O(E)</script>. Therefore, the total time is <script type="math/tex">O(V+E)</script>.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>7 Full Implementation:</b> 
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/breadth-first-search
<br />
<br /></p>


  </div><!--
  
--><a class="u-url" href="/jekyll/update/2019/06/20/bfs.html" hidden></a>
</article>
		 
      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
