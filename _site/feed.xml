<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-29T20:37:18-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">nemo’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Lecture 05: Greatest Common Divisor</title><link href="http://localhost:4000/jekyll/update/2025/01/28/math417-05-gcd.html" rel="alternate" type="text/html" title="Lecture 05: Greatest Common Divisor" /><published>2025-01-28T00:01:36-08:00</published><updated>2025-01-28T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/28/math417-05-gcd</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/28/math417-05-gcd.html"><![CDATA[<div class="mintheaderdiv">
Definition 1.6.8
</div>
<div class="mintbodydiv">
A natural number \(d\) is the greatest common divisor of integers \(a\) and \(b\) if
<ol type="a">
	<li>\(d\) is a common divisor. So \(d\) divides \(a\) and \(b\)</li>
	<li>Every common divisor \(e\) also divides \(d\). In other words, if \(e \ | \ a\) and \(e \ | \ b\), then \(e \ | \ d\)</li>
</ol>
</div>
<!------------------------------------------------------------------------>
<p><br />
If the greatest common exists, then it is unique. Why? suppose \(d\) and \(d'\) are both greatest common divisors. Then by definition, \(d \ | \ d'\) and \(d' \ | \ d\) because every common divisor divides the gcd and they each must divide each other. But this means that \(d = \pm 'd\) by the divisibility properties from last lecture. But also by definition, \(d\) is non-negative and so \(d = 'd\). \(\ \blacksquare\)
<br />
<br />
Note that in the book \(a\) and \(b\) are nonzero in the definition. With this definition, the set of divisors of \(0\) is \(\mathbf{Z}\). If \(a = 0\) and \(b \neq 0\), then \(|a|\) is the gcd of \(a\) and \(0\). If both \(a\) and \(b\) are zero, then \(0\) is the gcd of \(0\) and \(0\). 
<br />
<br />
<!------------------------------------------------------------------------>
Before addressing the question of whether the greatest common divisor exists, we’ll to define one more thing
<br /></p>
<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Let \(a, b \in \mathbf{Z}\). An integer combination of \(a\) and \(b\) is any integer of the form
$$
\begin{align*}
I(a,b) = \{ra + sb \ | \ r, s \in \mathbf{Z}\}.
\end{align*}
$$
</div>
<!------------------------------------------------------------------------>
<p><br />
For example \(I(4,6) = \{4s + 6t \ | \ s, t \in \mathbf{Z}\}\). If we let \(s = -1\) and \(t = 1\), then \(2 \in I(4,6)\). In fact, this set produces all of the even integers. It includes all multiples of 2. In other words, we can also write that \(I(4,6) = \mathbf{Z}2\). In fact, this turns out to always be true, the set of integer combinations of two integers is also the set of multiples of a number and that number is the greatest common divisor! even when one of the integers is \(0\). So yes the GCD exists and can even be computed. Before formally proving its existence, we’ll present the way it can be computed next.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>The Euclidean Algorithm</b></h4>
<p>Let \(\mathbf{Z}^2 = \{(a,b), a,b \in \mathbf{Z}\}\). 
<br />
Define \(F: \mathbf{Z}^2 \rightarrow \mathbf{Z}^2\) by</p>
<div class="ediv">
  $$
  \begin{equation*}
  F(m,n) = \begin{cases} (n,r), r = rem_n(m) \quad &amp;\text{if } n \neq 0 \\ (|m|,0) \quad \quad &amp;\text{if } n = 0\end{cases}
  \end{equation*}
  $$
</div>
<p><br />
\(rem_n(m)\) is the remainder of \(m \div n\) (recall that we can write \(m = qn + r\) where \(0 \leq r &lt; |n|)\)).
<br />
<br />
<b>Euclidean Algorithm:</b> Iterate \(F\) until stable.
<br />
<br />
Example:</p>
<div>
  $$
  \begin{align*}
  (42, -24) \xrightarrow{F} (-24, 18) \xrightarrow{F} (18, 12) \xrightarrow{F} (12, 6) \xrightarrow{F} (6, 0) \xrightarrow{F} (6, 0)
  \end{align*}
  $$
</div>
<p><br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>The GCD Theorem</b></h4>
<p>So now we have an algorithm to compute the GCD algorithm. Next, we will prove that it does compute the GCD and so the GCD does exist.
<br />
<!-------------------------------------------------------------------------></p>
<div class="yellowheaderdiv">
Theorem
</div>
<div class="yellowbodydiv">
Let \(a, b \in \mathbf{Z}\). Then
<ol>
	<li>For \(a, b\) have a GCD \(d \geq 0\).</li>
	<li>\(I(a,b) = \mathbf{Z}d\).</li>
	<li>\(d\) is computed by the Euclidean algorithm.</li>
</ol>
</div>
<p><br />
We’ll start from (3) and then prove that the answer produced by the algorithm is in fact an integer combination of the original input (statement 2). Finally, we’ll show that this just means that we have computed the GCD (statement). To do all of this we will also need the following lemmas
<br />
<br />
<!-------------------------------------------------------------------------></p>
<div class="yellowheaderdiv">
Lemma
</div>
<div class="yellowbodydiv">
If \(a, b \in I(c,d)\), then \(I(a,b) \subseteq I(c,d)\)
</div>
<p><br />
<b>Proof</b>: Homework Problem
<br />
<br />
<!-------------------------------------------------------------------------></p>
<div class="yellowheaderdiv">
Lemma
</div>
<div class="yellowbodydiv">
If \(F(m,n) = (a,b)\), then \(I(m,n) = I(a,b)\)
</div>
<p><br />
<b>Proof</b>:
<br />
We have two cases:
<br />
<br />
Case 1: \(n \neq 0\). In this case, \(F(m,n) = (n, r)\) where \(r\) is the remainder after dividing \(m\) by \(n\). So \(m = qn + r\) where \(0 \leq r &lt; |n|\). We want to show that the integer combinations of \(m\) and \(n\) is the same as the integer combinations of \(n\) and \(r\), that is, \(I(m,n) = I(n,r)\). To do this, we will show that \(I(m,n) \subseteq I(n,r)\) and \(I(n,r) \subseteq I(m,n)\). To show that \(I(m,n) \subseteq I(n,r)\), observe that \(m\) is an integer combination of \(n\) and \(r\) because we can write \(m\) as</p>
<div>
  $$
  \begin{align*}
  m &amp;= qn + 1r.  
  \end{align*}
  $$
</div>
<p>Similarly, \(n\) is also an integer combination of \(n\) and \(r\) because we can write \(n\) as</p>
<div>
  $$
  \begin{align*}
  n &amp;= 1n + 0r.
  \end{align*}
  $$
</div>
<p>Since \(m\) and \(n\) can both be written as integer combinations of \(n\) and \(r\), that is \(m \in I(n,r)\) and \(n \in I(n,r)\), then by the previous lemma,  \(I(m,n) \subseteq I(n,r)\). To see that \(I(m,n) \subseteq I(n,r)\), observe that we can write \(n\) as \(n = 0m + 1n\) so \(n \in I(m,n)\). Similarly, \(r = 1m + (-q)m\) so \(r \in I(m,n)\). Then, by the previous lemma, \(I(m,n) \subseteq I(n,r)\). Therefore, \(I(m,n) = I(n,r)\). 
<br />
<br />
Case 2: \(n = 0\). In this case, \(F(m,n) = F(m,0) = (|m|,0)\). In this case the integer combinations of \(0\) and \(m\) are just multiples of \(m\) so \(I(m,0) = \mathbf{Z}m\). But this is the same as the integer combinations of \(|m|\) and \(0\) so \(\mathbf{Z}m = I(|m|,0) = I(m,0)\) which is what we wanted to show. \(\blacksquare\)
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Proof of the GCD Theorem</b></h4>
<p>We iterate the algorithm until \(n = 0\) and \(F(m,n) = (|m|,0)\). By the previous lemma we saw that \(I(m,n) = \mathbf{Z}d\) for some \(d \geq 0\). 
<br />
<br />
<b>Claim:</b> \(d\) is a GCD.<br /></p>
<ol>
	<li>\(m,n \in I(m,n) = \mathbf{Z}d\). So \(m\) and \(n\) are both multiples of \(d\) and d divides both of them. \(d \ | \ m\) and \(d \ | \ n\).</li>
	<li>So now for condition 2, suppose \(e\) is a common divisor of \(m\) and \(n\). We want to show that \(e\) divides \(d\). Since \(e \ | \ m\) and \(e \ | \ n\), then \(m\) and \(n\) are both multiples of \(e\). So we can write \(m = eu\) and \(n = ev\) for some \(u,v \in \mathbf{Z}\). 
	<br />
	<br />
	But we know that any integer combination of \(m\) and \(n\) is a multiple of \(d\). So we can write for some \(r, s \in \mathbf{Z}\) 
	<div>
	  $$
	  \begin{align*}
	  d &amp;= rm + sn \\
	   &amp;= reu + sev \\
	   &amp;= e(ru + sv).
	  \end{align*}
	  $$
	</div>
	So \(e\) must divide \(d\).
</li>
</ol>
<p>Therefore, \(d = gcd(m,n)\) as desired. \(\ \blacksquare\) 
<br />
Note that the Euclidean Algorithm gives a method for computing \(r, s \in \mathbf{Z}\), so \(d = rm + sn\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>GCD Example</b></h4>

<p><br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>MATH417 by Charles Rezk</li>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition 1.6.8 A natural number \(d\) is the greatest common divisor of integers \(a\) and \(b\) if \(d\) is a common divisor. So \(d\) divides \(a\) and \(b\) Every common divisor \(e\) also divides \(d\). In other words, if \(e \ | \ a\) and \(e \ | \ b\), then \(e \ | \ d\) If the greatest common exists, then it is unique. Why? suppose \(d\) and \(d'\) are both greatest common divisors. Then by definition, \(d \ | \ d'\) and \(d' \ | \ d\) because every common divisor divides the gcd and they each must divide each other. But this means that \(d = \pm 'd\) by the divisibility properties from last lecture. But also by definition, \(d\) is non-negative and so \(d = 'd\). \(\ \blacksquare\) Note that in the book \(a\) and \(b\) are nonzero in the definition. With this definition, the set of divisors of \(0\) is \(\mathbf{Z}\). If \(a = 0\) and \(b \neq 0\), then \(|a|\) is the gcd of \(a\) and \(0\). If both \(a\) and \(b\) are zero, then \(0\) is the gcd of \(0\) and \(0\). Before addressing the question of whether the greatest common divisor exists, we’ll to define one more thing Definition Let \(a, b \in \mathbf{Z}\). An integer combination of \(a\) and \(b\) is any integer of the form $$ \begin{align*} I(a,b) = \{ra + sb \ | \ r, s \in \mathbf{Z}\}. \end{align*} $$ For example \(I(4,6) = \{4s + 6t \ | \ s, t \in \mathbf{Z}\}\). If we let \(s = -1\) and \(t = 1\), then \(2 \in I(4,6)\). In fact, this set produces all of the even integers. It includes all multiples of 2. In other words, we can also write that \(I(4,6) = \mathbf{Z}2\). In fact, this turns out to always be true, the set of integer combinations of two integers is also the set of multiples of a number and that number is the greatest common divisor! even when one of the integers is \(0\). So yes the GCD exists and can even be computed. Before formally proving its existence, we’ll present the way it can be computed next. The Euclidean Algorithm Let \(\mathbf{Z}^2 = \{(a,b), a,b \in \mathbf{Z}\}\). Define \(F: \mathbf{Z}^2 \rightarrow \mathbf{Z}^2\) by $$ \begin{equation*} F(m,n) = \begin{cases} (n,r), r = rem_n(m) \quad &amp;\text{if } n \neq 0 \\ (|m|,0) \quad \quad &amp;\text{if } n = 0\end{cases} \end{equation*} $$ \(rem_n(m)\) is the remainder of \(m \div n\) (recall that we can write \(m = qn + r\) where \(0 \leq r &lt; |n|)\)). Euclidean Algorithm: Iterate \(F\) until stable. Example: $$ \begin{align*} (42, -24) \xrightarrow{F} (-24, 18) \xrightarrow{F} (18, 12) \xrightarrow{F} (12, 6) \xrightarrow{F} (6, 0) \xrightarrow{F} (6, 0) \end{align*} $$ The GCD Theorem So now we have an algorithm to compute the GCD algorithm. Next, we will prove that it does compute the GCD and so the GCD does exist. Theorem Let \(a, b \in \mathbf{Z}\). Then For \(a, b\) have a GCD \(d \geq 0\). \(I(a,b) = \mathbf{Z}d\). \(d\) is computed by the Euclidean algorithm. We’ll start from (3) and then prove that the answer produced by the algorithm is in fact an integer combination of the original input (statement 2). Finally, we’ll show that this just means that we have computed the GCD (statement). To do all of this we will also need the following lemmas Lemma If \(a, b \in I(c,d)\), then \(I(a,b) \subseteq I(c,d)\) Proof: Homework Problem Lemma If \(F(m,n) = (a,b)\), then \(I(m,n) = I(a,b)\) Proof: We have two cases: Case 1: \(n \neq 0\). In this case, \(F(m,n) = (n, r)\) where \(r\) is the remainder after dividing \(m\) by \(n\). So \(m = qn + r\) where \(0 \leq r &lt; |n|\). We want to show that the integer combinations of \(m\) and \(n\) is the same as the integer combinations of \(n\) and \(r\), that is, \(I(m,n) = I(n,r)\). To do this, we will show that \(I(m,n) \subseteq I(n,r)\) and \(I(n,r) \subseteq I(m,n)\). To show that \(I(m,n) \subseteq I(n,r)\), observe that \(m\) is an integer combination of \(n\) and \(r\) because we can write \(m\) as $$ \begin{align*} m &amp;= qn + 1r. \end{align*} $$ Similarly, \(n\) is also an integer combination of \(n\) and \(r\) because we can write \(n\) as $$ \begin{align*} n &amp;= 1n + 0r. \end{align*} $$ Since \(m\) and \(n\) can both be written as integer combinations of \(n\) and \(r\), that is \(m \in I(n,r)\) and \(n \in I(n,r)\), then by the previous lemma, \(I(m,n) \subseteq I(n,r)\). To see that \(I(m,n) \subseteq I(n,r)\), observe that we can write \(n\) as \(n = 0m + 1n\) so \(n \in I(m,n)\). Similarly, \(r = 1m + (-q)m\) so \(r \in I(m,n)\). Then, by the previous lemma, \(I(m,n) \subseteq I(n,r)\). Therefore, \(I(m,n) = I(n,r)\). Case 2: \(n = 0\). In this case, \(F(m,n) = F(m,0) = (|m|,0)\). In this case the integer combinations of \(0\) and \(m\) are just multiples of \(m\) so \(I(m,0) = \mathbf{Z}m\). But this is the same as the integer combinations of \(|m|\) and \(0\) so \(\mathbf{Z}m = I(|m|,0) = I(m,0)\) which is what we wanted to show. \(\blacksquare\) Proof of the GCD Theorem We iterate the algorithm until \(n = 0\) and \(F(m,n) = (|m|,0)\). By the previous lemma we saw that \(I(m,n) = \mathbf{Z}d\) for some \(d \geq 0\). Claim: \(d\) is a GCD. \(m,n \in I(m,n) = \mathbf{Z}d\). So \(m\) and \(n\) are both multiples of \(d\) and d divides both of them. \(d \ | \ m\) and \(d \ | \ n\). So now for condition 2, suppose \(e\) is a common divisor of \(m\) and \(n\). We want to show that \(e\) divides \(d\). Since \(e \ | \ m\) and \(e \ | \ n\), then \(m\) and \(n\) are both multiples of \(e\). So we can write \(m = eu\) and \(n = ev\) for some \(u,v \in \mathbf{Z}\). But we know that any integer combination of \(m\) and \(n\) is a multiple of \(d\). So we can write for some \(r, s \in \mathbf{Z}\) $$ \begin{align*} d &amp;= rm + sn \\ &amp;= reu + sev \\ &amp;= e(ru + sv). \end{align*} $$ So \(e\) must divide \(d\). Therefore, \(d = gcd(m,n)\) as desired. \(\ \blacksquare\) Note that the Euclidean Algorithm gives a method for computing \(r, s \in \mathbf{Z}\), so \(d = rm + sn\). GCD Example]]></summary></entry><entry><title type="html">Lecture 04: Integers</title><link href="http://localhost:4000/jekyll/update/2025/01/27/math417-04-integers.html" rel="alternate" type="text/html" title="Lecture 04: Integers" /><published>2025-01-27T00:01:36-08:00</published><updated>2025-01-27T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/27/math417-04-integers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/27/math417-04-integers.html"><![CDATA[<p>Some facts about the integers</p>
<ul>
	<li>\((\mathbf{Z}, +)\) is a commutative group. \(+\) is associative and commutative. The identity element is \(0\) and each element \(a\)'s inverse is \(-a\).</li>
	<li>\((\mathbf{Z}, \cdot)\) is a commutative monoid. \(\cdot\) is associative and commutative. The identity element is \(1\). (No inverses required)</li>
	<li>Distributive Law: \(a(b+c) = (ab) + (ac), \forall a,b,c \in \mathbf{Z}\). (side note: the list of properties so far for reference imply that \(\mathbf{Z}\) is a commutative ring with unit.</li>
	<li>\(\mathbf{Z} / \{0\}\) is closed under multiplication. In other words, if \(a \neq, b \neq 0\), then \(ab \neq 0\) We can also re-write this by taking its contrapositive so \(ab = 0\) implies that \(a = 0\) or \(b = 0\).</li>
	<li>\(\mathbf{N} = \mathbf{Z}_{&gt;0}\) is closed under \(+\) and \(\cdot\).</li>
	<li>If \(a, b \in \mathbf{Z} / \{0\}\), then \( |ab| \geq \max\{|a|,|b|\} \). (Note that \(a &gt; b\) means that \(a - b \in \mathbf{Z}_{&gt;0}\).)</li>
</ul>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Divisibility</b></h4>
<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Let \(a, b \in \mathbf{Z}\). \(a\) <b>divides</b> \(b\) (write \(a | b\)) if there exists \(m \in \mathbf{Z}\) such that \(am = b\).
<br />
(We also say that \(a\) is a factor of \(b\) or \(b\) is a multiple of \(a\)).
<br />
In fact, \(a|b\) if and only if \(\frac{b}{a} \in \mathbf{Z} \text{if $a \neq 0$}\).
</div>
<p><br />
The factors or divisors of \(6\) for example are \(\{\pm 1, \pm 2, \pm 3, \pm 6\}\) while the divisors of \(0\) are all of \(\mathbf{Z}\). We also have the set of all multiplies of integer \(a\) so if \(a\) is 7, then the set is \(\{...,-14,-7,0,7,14,21,...\}\). Notation: we will denote the set of all multiples as</p>
<div> 
$$
\begin{align*}
\mathbf{Z}a = \{na \ | \ n \in \mathbf{Z}\}
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Divisibility Properties</b></h4>
<p>The following are some well known propositions about divisibility.</p>
<ol>
	<li>If \(a | b\) and \(b | a\), then \(b \in \{\pm a\}\)</li>
	<li>If \(a | 1\), then \(a \in \{\pm 1\}\)</li>
	<li>If \(a | b\) and \(b | c\), then \(a | c\)</li>
	<li>If \(a | b\) and \(a | c\), then \(a | (b + c)\)</li>
	<li>If \(a | b\) and \(a | c\), then \(a | (mb + nc) \quad \forall m, n \in \mathbf{Z}\)</li>
</ol>
<p>Note that</p>
<div> 
$$
\begin{align*}
a | b \Leftrightarrow b \in \mathbf{Z}a \Leftrightarrow \mathbf{Z}b \subseteq \mathbf{Z}c
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Prime Numbers</b></h4>
<div class="mintheaderdiv">
Definition 1.6.3
</div>
<div class="mintbodydiv">
A natural number is prime if (i) \(n &lt; 1\) and (ii) the only positive divisors of \(n\) are \(\{1, n\}\).
</div>
<p><br />
<br />
<!-------------------------------------------------------------------------------></p>
<div class="peachheaderdiv">
Proposition 1.6.4
</div>
<div class="peachbodydiv">
Every \(n \in \mathbf{N}\) greater than 1 is equal to a product of primes (at least one).
</div>
<p><br />
<!------------------------------------------------------------------------------->
<b>Proof</b><br />
By Induction on \(n \geq 2\). 
<br />
Base Case: \(n = 2:\) 2 is a prime so it’s a product of one prime.
<br />
<br />
Inductive Case \(n &gt; 2\): 
<br />
Suppose that inductive hypothesis is true for any number \(r\) where \(2 \leq r &lt; n\). Now, take \(n\). We have two cases. If \(n\) is a prime number, then \(n\) is a product of primes and we’re done. Otherwise, \(n\) is not a prime and has divisors other than \(1\) or itself. Let these divisors be \(a\) and \(b\) so that \(n = ab\). \(a\) and \(b\) are not \(n\) or \(1\) so we know that \(1 &lt; a &lt; n\) and \(1 &lt; b &lt; n\). We can now apply the inductive hypothesis to conclude that both \(a\) and \(b\) can be written as a product of primes. Therefore, \(n = ab\) is also a product of primes. \(\ \blacksquare\) 
<br />
<br />
<!------------------------------------------------------------------------------></p>
<div class="yellowheaderdiv">
Theorem 1.6.6 (Euclid)
</div>
<div class="yellowbodydiv">
There are infinitely many prime numbers.
</div>
<p><br />
<b>Proof</b>
<br />
Suppose for the sake of contradiction that there are finitely many primes \(p_1,p_2,...,p_k\). Consider \(p = p_1p_2...p_k + 1 \in \mathbf{N}\). We know that \(p\) is greater than any of the primes \(p_1,p_2,...,p_k\). Observe now that none of these primes \(p_1, p_2,...,p_k\) can divide \(p\). Why? because if any of these primes did (say it was \(p_i\)), then this means that \(p_i \ | \ n\). But \(p_i\) also divides the product \(p_1p_2...p_k\). By the last fact of integers above, then \(p_i \ | \ (n - p_1p_2...p_k)\). So \(p_i \ | \ 1\). But that’s impossible so \(p_i\) can’t divide \(n\). But by Proposition 1.6.4, \(p\) must be a product of primes. Therefore, there must be another prime or \(p\) itself is a prime. This is a contradiction and so we can conclude that there are infinitely many primes. \(\ \blacksquare\)
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Divison with Remainder</b></h4>
<p>The way we learn division is this. Given \(a, d \in \mathbf{Z}, d &gt; 0\), then \(\frac{a}{d} = q + \frac{r}{d}\). The quotient, \(q \in \mathbf{Z}\) and the remainder \(r \in \mathbf{Z}\). Moreover, \(\frac{r}{d} \in [0,1)\). Stated differently,
<br /></p>
<div class="peachheaderdiv">
Proposition 1.6.7
</div>
<div class="peachbodydiv">
Given integers \(a\) and \(d \in \mathbf{Z}\) with \(d \geq 1\), there exists unique integers \(q\) and \(r\) such that 
$$
\begin{align*}
a = qd + r
\end{align*}
$$
where \(0 \leq r &lt; d\). 
</div>
<!------------------------------------------------------------------------>
<p><br />
<br />
<b>Proof: (from my own notes (reading the book))</b>
<br />
<br />
We are given \(a\) and \(d\) such that \(d \geq 1\). <br />
We want to find unique integers \(q\) and \(r\) such that \(r &lt; d\).
<br />
<br />
We have two cases:
<br />
\(a \geq 0\): If \(d &gt; a\), then we just take \(q = 0\) and \(r = a\).<br />
Otherwise, suppose that \(d \leq a\). By Induction on a. Assume that for all non-negative integers smaller than \(a\), we can find such integers. In particular, suppose it holds for \(a - d\), then there exists integers \(q'\) and \(r\) such that</p>
<div> 
$$
\begin{align*}
(a - d) &amp;= q'd + r \quad (\text{where } 0 \leq r &lt; d) \\
a &amp;= q'd + d + r \\
a &amp;= q'(d + 1) + r 
\end{align*}
$$
</div>
<p>And we are done.
<br />
<br />
Case \(a &gt; 0\): If \(a\) is divisible by \(d\), then there exists integer \(q\) such that \(a = qd\). So we can set \(r = 0\) and we are done.
<br />
Otherwise, \(-a &gt; 0\) so by the first case (\(a \geq 0\)) there exists integers \(q'\) and \(r'\) such that \(-a = q'd + r'\) with \(0 &lt; r' &lt; d\). So</p>
<div> 
$$
\begin{align*}
-a &amp;= q'd + r' \\
a &amp;= -q'd - r' \\
a &amp;= -q'd - d + d - r' \\
a &amp;= (-q' - 1)d + (d - r') \\
  &amp;= (-q' - 1)d + (d - r').
\end{align*}
$$
</div>
<p>So \(q = (-q' - 1)\) and \(r = d - r'\) with \(0 &lt; d - r' &lt; d\) and we are done.
<br />
<br />
To show that \(q\) and \(r\) are unique, suppose for the sake of contradiction that they are not. Therefore suppose that \(a = qd + r = q'd + r'\) where \(0 \leq r,r' &lt; d\). Subtracting the equations, we see that</p>
<div> 
$$
\begin{align*}
(q - q')d = r - r'
\end{align*}
$$
</div>
<p>But this means that \(r - r'\) is divisible by d. However \(|r - r'| \leq \max\{r,r'\} &lt; d\), so we must have \(|r - r'| = 0\). This implies that \((q' - q)d = 0\) and so \(q' = q\) as we wanted to show. \(\ \blacksquare\)
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>MATH417 by Charles Rezk</li>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Some facts about the integers \((\mathbf{Z}, +)\) is a commutative group. \(+\) is associative and commutative. The identity element is \(0\) and each element \(a\)'s inverse is \(-a\). \((\mathbf{Z}, \cdot)\) is a commutative monoid. \(\cdot\) is associative and commutative. The identity element is \(1\). (No inverses required) Distributive Law: \(a(b+c) = (ab) + (ac), \forall a,b,c \in \mathbf{Z}\). (side note: the list of properties so far for reference imply that \(\mathbf{Z}\) is a commutative ring with unit. \(\mathbf{Z} / \{0\}\) is closed under multiplication. In other words, if \(a \neq, b \neq 0\), then \(ab \neq 0\) We can also re-write this by taking its contrapositive so \(ab = 0\) implies that \(a = 0\) or \(b = 0\). \(\mathbf{N} = \mathbf{Z}_{&gt;0}\) is closed under \(+\) and \(\cdot\). If \(a, b \in \mathbf{Z} / \{0\}\), then \( |ab| \geq \max\{|a|,|b|\} \). (Note that \(a &gt; b\) means that \(a - b \in \mathbf{Z}_{&gt;0}\).) Divisibility Definition Let \(a, b \in \mathbf{Z}\). \(a\) divides \(b\) (write \(a | b\)) if there exists \(m \in \mathbf{Z}\) such that \(am = b\). (We also say that \(a\) is a factor of \(b\) or \(b\) is a multiple of \(a\)). In fact, \(a|b\) if and only if \(\frac{b}{a} \in \mathbf{Z} \text{if $a \neq 0$}\). The factors or divisors of \(6\) for example are \(\{\pm 1, \pm 2, \pm 3, \pm 6\}\) while the divisors of \(0\) are all of \(\mathbf{Z}\). We also have the set of all multiplies of integer \(a\) so if \(a\) is 7, then the set is \(\{...,-14,-7,0,7,14,21,...\}\). Notation: we will denote the set of all multiples as $$ \begin{align*} \mathbf{Z}a = \{na \ | \ n \in \mathbf{Z}\} \end{align*} $$ Divisibility Properties The following are some well known propositions about divisibility. If \(a | b\) and \(b | a\), then \(b \in \{\pm a\}\) If \(a | 1\), then \(a \in \{\pm 1\}\) If \(a | b\) and \(b | c\), then \(a | c\) If \(a | b\) and \(a | c\), then \(a | (b + c)\) If \(a | b\) and \(a | c\), then \(a | (mb + nc) \quad \forall m, n \in \mathbf{Z}\) Note that $$ \begin{align*} a | b \Leftrightarrow b \in \mathbf{Z}a \Leftrightarrow \mathbf{Z}b \subseteq \mathbf{Z}c \end{align*} $$ Prime Numbers Definition 1.6.3 A natural number is prime if (i) \(n &lt; 1\) and (ii) the only positive divisors of \(n\) are \(\{1, n\}\). Proposition 1.6.4 Every \(n \in \mathbf{N}\) greater than 1 is equal to a product of primes (at least one). Proof By Induction on \(n \geq 2\). Base Case: \(n = 2:\) 2 is a prime so it’s a product of one prime. Inductive Case \(n &gt; 2\): Suppose that inductive hypothesis is true for any number \(r\) where \(2 \leq r &lt; n\). Now, take \(n\). We have two cases. If \(n\) is a prime number, then \(n\) is a product of primes and we’re done. Otherwise, \(n\) is not a prime and has divisors other than \(1\) or itself. Let these divisors be \(a\) and \(b\) so that \(n = ab\). \(a\) and \(b\) are not \(n\) or \(1\) so we know that \(1 &lt; a &lt; n\) and \(1 &lt; b &lt; n\). We can now apply the inductive hypothesis to conclude that both \(a\) and \(b\) can be written as a product of primes. Therefore, \(n = ab\) is also a product of primes. \(\ \blacksquare\) Theorem 1.6.6 (Euclid) There are infinitely many prime numbers. Proof Suppose for the sake of contradiction that there are finitely many primes \(p_1,p_2,...,p_k\). Consider \(p = p_1p_2...p_k + 1 \in \mathbf{N}\). We know that \(p\) is greater than any of the primes \(p_1,p_2,...,p_k\). Observe now that none of these primes \(p_1, p_2,...,p_k\) can divide \(p\). Why? because if any of these primes did (say it was \(p_i\)), then this means that \(p_i \ | \ n\). But \(p_i\) also divides the product \(p_1p_2...p_k\). By the last fact of integers above, then \(p_i \ | \ (n - p_1p_2...p_k)\). So \(p_i \ | \ 1\). But that’s impossible so \(p_i\) can’t divide \(n\). But by Proposition 1.6.4, \(p\) must be a product of primes. Therefore, there must be another prime or \(p\) itself is a prime. This is a contradiction and so we can conclude that there are infinitely many primes. \(\ \blacksquare\) Divison with Remainder The way we learn division is this. Given \(a, d \in \mathbf{Z}, d &gt; 0\), then \(\frac{a}{d} = q + \frac{r}{d}\). The quotient, \(q \in \mathbf{Z}\) and the remainder \(r \in \mathbf{Z}\). Moreover, \(\frac{r}{d} \in [0,1)\). Stated differently, Proposition 1.6.7 Given integers \(a\) and \(d \in \mathbf{Z}\) with \(d \geq 1\), there exists unique integers \(q\) and \(r\) such that $$ \begin{align*} a = qd + r \end{align*} $$ where \(0 \leq r &lt; d\). Proof: (from my own notes (reading the book)) We are given \(a\) and \(d\) such that \(d \geq 1\). We want to find unique integers \(q\) and \(r\) such that \(r &lt; d\). We have two cases: \(a \geq 0\): If \(d &gt; a\), then we just take \(q = 0\) and \(r = a\). Otherwise, suppose that \(d \leq a\). By Induction on a. Assume that for all non-negative integers smaller than \(a\), we can find such integers. In particular, suppose it holds for \(a - d\), then there exists integers \(q'\) and \(r\) such that $$ \begin{align*} (a - d) &amp;= q'd + r \quad (\text{where } 0 \leq r &lt; d) \\ a &amp;= q'd + d + r \\ a &amp;= q'(d + 1) + r \end{align*} $$ And we are done. Case \(a &gt; 0\): If \(a\) is divisible by \(d\), then there exists integer \(q\) such that \(a = qd\). So we can set \(r = 0\) and we are done. Otherwise, \(-a &gt; 0\) so by the first case (\(a \geq 0\)) there exists integers \(q'\) and \(r'\) such that \(-a = q'd + r'\) with \(0 &lt; r' &lt; d\). So $$ \begin{align*} -a &amp;= q'd + r' \\ a &amp;= -q'd - r' \\ a &amp;= -q'd - d + d - r' \\ a &amp;= (-q' - 1)d + (d - r') \\ &amp;= (-q' - 1)d + (d - r'). \end{align*} $$ So \(q = (-q' - 1)\) and \(r = d - r'\) with \(0 &lt; d - r' &lt; d\) and we are done. To show that \(q\) and \(r\) are unique, suppose for the sake of contradiction that they are not. Therefore suppose that \(a = qd + r = q'd + r'\) where \(0 \leq r,r' &lt; d\). Subtracting the equations, we see that $$ \begin{align*} (q - q')d = r - r' \end{align*} $$ But this means that \(r - r'\) is divisible by d. However \(|r - r'| \leq \max\{r,r'\} &lt; d\), so we must have \(|r - r'| = 0\). This implies that \((q' - q)d = 0\) and so \(q' = q\) as we wanted to show. \(\ \blacksquare\) References MATH417 by Charles Rezk Algebra: Abstract and Concrete by Frederick M. Goodman]]></summary></entry><entry><title type="html">Lecture 03: Permutation Groups, Cycle Decomposition</title><link href="http://localhost:4000/jekyll/update/2025/01/26/math417-03-permutation-groups-cycle-decomposition.html" rel="alternate" type="text/html" title="Lecture 03: Permutation Groups, Cycle Decomposition" /><published>2025-01-26T00:01:36-08:00</published><updated>2025-01-26T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/26/math417-03-permutation-groups-cycle-decomposition</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/26/math417-03-permutation-groups-cycle-decomposition.html"><![CDATA[<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Let \(X\) be a set. Define the <b>permutation</b> of \(X\) as a bijection from the set to itself (\(f: X \rightarrow X\)). Let \(Sym(X)\) be the set of all bijections from \(X\) to itself (\(X \rightarrow X\)).
</div>
<!------------------------------------------------------------------------>
<p><br />
\(Sym(X)\) equipped with the composition of functions operation is a group. To see this observe that</p>
<ul>
<li>\(id: X \rightarrow X, id(x) = x\) is the identity element.</li>
<li>Composition of functions is associative.</li>
<li>The composition of two permutations is another permutation.</li>
<li>Bijections have inverses and the inverse of a bijection is another bijection.</li>
</ul>
<p>This group is often denoted by the <b>Permutation Group</b> or more often the <b>Symmetric Group</b>.
<br />
<br />
The standard example for the case of finite sets is the standard set \(X = \{1,2,...,n\}\). The symmetric group has a special name called \(S_n\),</p>
<div>
$$
\begin{align*}
S_n = Sym(\{1,2,...,n\})
\end{align*}
$$
</div>
<p>The size of \(S_n\) is \(|S_n| = n!\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Two Line Notation</b></h4>
<p>Let \(\rho, \psi \in S_4\), then we’ll write</p>
<div>
	$$
	\begin{align*}
	 \rho = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 1 &amp; 4 &amp; 3 &amp; 2\end{pmatrix}
	\end{align*}
	$$
</div>
<p>shows that \(\rho(1) = 1\), \(\rho(2) = 4\), \(\rho(3) = 3\) and \(\rho(4) = 2\). Similarly,</p>
<div>
	$$
	\begin{align*}
	 \psi = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 2 &amp; 1 &amp; 3\end{pmatrix}
	\end{align*}
	$$
</div>
<p>shows that \(\psi(1) = 4\), \(\psi(2) = 2\), \(\psi(3) = 1\) and \(\psi(4) = 3\). Finally,</p>
<div>
	$$
	\begin{align*}
	 \rho\psi = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 2 &amp; 4 &amp; 1 &amp; 3\end{pmatrix} \in S_4
	\end{align*}
	$$
</div>
<p>so \(\rho\psi(1) = 2\), \(\rho\psi(2) = 4\), \(\rho\psi(3) = 1\) and \(\rho\psi(4) = 3\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Cycle Notation</b></h4>
<p>We can decompose the cycles in each permutation above. For example for the first permutation</p>
<div>
	$$
	\begin{align*}
	 \rho = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 1 &amp; 4 &amp; 3 &amp; 2\end{pmatrix}
	\end{align*}
	$$
</div>
<p>We can decompose this permutation into the following</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec03/1.png" width="20%" class="center" /></p>
<p>In this permutation, we have a cycle of length \(2\) For the second permutation</p>
<div>
	$$
	\begin{align*}
	 \psi = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 2 &amp; 1 &amp; 3\end{pmatrix}
	\end{align*}
	$$
</div>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec03/2.png" width="20%" class="center" /></p>
<p>we have a cycle of length \(3\). 
<br />
<br />
To describe a cycle, we can use <b>cycle notation</b> which is defined as follows
<br /></p>
<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Let \(\sigma = (a_1 \quad a_2 \quad ... \quad a_k)\) where \(a_1,...,a_k \in X\) are distinct. \(\sigma\) is defined by
	$$
	\begin{align*}
	 \sigma(a_i) &amp;= a_{i+1}, \quad i = 1,...,k-1 \\
	 \sigma(a_k) &amp;= a_1 \\
	 \sigma(x) &amp;= x, \quad \text{if} x \notin \{a_1,...,a_k\} \\
	\end{align*}
	$$
</div>
<p><br />
So we can write the first permutation with cycle notation as \((2,4)\) only since by definition for the other elements \(\sigma(x)=x\), while the second permutation can be written as \((1,4,3)\). 
<br />
<br />
What about the following example?</p>
<div>
	$$
	\begin{align*}
	 \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\ 3 &amp; 5 &amp; 4 &amp; 1 &amp; 2\end{pmatrix}
	\end{align*}
	$$
</div>
<p>Note here that we have two disjoint cycles. \((1 \quad 4 \quad 3)\) where \(1\) goes to \(3\) and \(3\) goes to \(4\) and \(4\) goes back to \(1\) and \((2 \quad 5)\) where \(2\) goes to \(5\) and \(5\) goes back to \(2\). This permutation can be written as</p>
<div>
	$$
	\begin{align*}
	 (1 \quad 3 \quad 4)(2 \quad 5)
	\end{align*}
	$$
</div>
<!------------------------------------------------------------------------>
<h4><b>Facts</b></h4>
<p>Some facts about the cycle notation</p>
<ul>
<li>\((1) = (2) = ... (n) = id\). All of these represent the identity permutations.</li>
<li>The order of the elements in a cycle matters up to "cyclic permutation". \((1 \quad 2 \quad 3 \quad 4) = (2 \quad 3 \quad 4 \quad 1) \neq (1 \quad 3 \quad 4 \quad 2)\)</li>
<li>For the inverse of a permutation, we just reverse the order of elements so \((a_1 \quad a_2 \quad ... \quad a_k)^{-1} = (a_k \quad a_{k-1} \quad ... \quad a_1)\)</li>
<li>Two cycles \(\sigma = (a_1 \quad a_2 \quad ... \quad a_k)\) and \(\tau = (b_1 \quad b_{2} \quad ... \quad b_l) \in Sym(X)\) are disjoint if \(\{a_1,a_2,...,a_k\} \cap \{b_1,b_2,...,b_l\} = \emptyset\). Moreover, if the two sets are disjoint, then \(\sigma \circ \tau = \tau \circ \sigma\). This means that the permutation above that we described with \((1 \quad 3 \quad 4)(2 \quad 5)\) can also be written as \((2 \quad 5)(1 \quad 3 \quad 4)\)</li>
</ul>
<p><br />
<!------------------------------------------------------------------------></p>
<div class="yellowheaderdiv">
Theorem
</div>
<div class="yellowbodydiv">
Every non-id element in \(Sym(X)\) where \(X\) is finite can be written as a product of pairwise disjoint cycles (of length \(\geq 2\) uniquely up to re-ordering.
</div>
<p><br />
Suppose we have \(\sigma = (1 \quad 3)(2 \quad 7 \quad 8)(4 \quad 5 \quad 6)(9) \in S_9\). Any of the cycles in this notation are pairwise disjoint. We have 3 disjoint cycles where \(9\) is fixed.
<br />
<br />
The proof for this theorem is in the class notes.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Cycle Type</b></h4>
<p>We can classify permutations of a finite set into groups corresponding to the number of cycles of various lengths in their cycle decomposition.
<br />
<br />
For example for \(S_2\), we have two elements and so we have two permutations</p>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>\(1 + 1\)</td>
    <td>\(id = (1)(2)\)</td>
  </tr>
  <tr>
    <td>\(2\)</td>
    <td>\((1 \quad 2)\)</td>
  </tr>
</table>
<p>For \(S_3\),</p>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>\(1 + 1 + 1\)</td>
    <td>\(id = (1)(2)(3)\)</td>
  </tr>
  <tr>
    <td>\(2 + 1\)</td>
    <td>\((1 \quad 2),(1 \quad 3),(2 \quad 3)\)</td>
  </tr>
  <tr>
    <td>\(3\)</td>
    <td>\((1 \quad 2 \quad 3),(1 \quad 3 \quad 2)\)</td>
  </tr>
</table>
<p>For \(S_4\),</p>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>\(1 + 1 + 1 + 1\)</td>
    <td>\(id = (1)(2)(3)(4)\)</td>
  </tr>
  <tr>
    <td>\(2 + 1 + 1\)</td>
    <td>\((1 \quad 2),(1 \quad 3),(1 \quad 4),(2 \quad 3),(2 \quad 4),(3 \quad 4)\)</td>
  </tr>
  <tr>
    <td>\(2 + 2\)</td>
    <td>\((1 \quad 2)(3 \quad 4),(1 \quad 3)(2 \quad 4),(1 \quad 4)(2 \quad 3)\)</td>
  </tr>
  <tr>
    <td>\(3 + 1\)</td>
    <td>\((1 \quad 2 \quad 3),(1 \quad 2 \quad 4)\),\((1 \quad 3 \quad 4),(2 \quad 3 \quad 4),(1 \quad 3 \quad 2)\),\((1 \quad 4 \quad 2),(1 \quad 4 \quad 3),(2 \quad 4 \quad 3)\)</td>
  </tr>
  <tr>
    <td>\(4\)</td>
    <td>\((1 \quad 2 \quad 3 \quad 4),(1 \quad 2 \quad 4 \quad 3)\),\((1 \quad 3 \quad 2 \quad 4),(1 \quad 3 \quad 4 \quad 2)\),\((1 \quad 4 \quad 2 \quad 3),(1 \quad 4 \quad 3 \quad 2)\)</td>
  </tr>
</table>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>The Order of an Element</b></h4>
<p>(Start of lecture 4). The first concept that we will talk about is the order of an element in a group.
<br /></p>
<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Suppose we have a group \((G, \cdot)\) and let \(a \in G\). The order of \(a\) is the smallest positive integer \(n\) such that \(a^n = e\) (or infinite). \(\text{order}(a) \in \mathbf{N} \cup \{\infty\}\).
</div>
<!------------------------------------------------------------------------>
<p><br />
For example let \(\sigma = (1 \quad 2 \quad 3 \quad 4) \in S_5\) The order of \(\sigma\), \(\text{order}(\sigma)\) is \(4\). This is because it will take \(\sigma^4\) will finally get us back to the identity permutation. In fact that the order of a \(k-\)cycle is \(k\).
<br />
<br />
What about \(\tau =  (1 \quad 2)(3 \quad 4 \quad 5)\)? \(\text{order}(\tau) = 6\) because we have to iterate the operation \(6\) times to get to the identity element. Specifically, we have two disjoint cycles and since they are disjoint, then they operate independently. So we need to find \(n\) such that both of the cycles will return to the identity permutation</p>
<div>
$$
\begin{align*}
(1 \quad 2)^n &amp;= e \\
(3 \quad 4 \quad 5)^n &amp;= e
\end{align*}
$$
</div>
<p>This \(n\) must be then the least common multiple of \(2\) and \(3\) which is \(6\).
<br />
<br />
What about \(\nu =  (1 \quad 2)(2 \quad 3 \quad 4)\)? Note here that the two cycles are not disjoint. It’s not clear here what it would be so drawing this permutation might make this very obvious.</p>

<p>[TODO:PIC]</p>

<p>From this we see that \(\text{order}(\nu) = 4\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Parity of a Permutation</b></h4>
<p>The second concept that we want to talk about is the parity of a permutation but first we’ll start with the following proposition.
<br /></p>
<div class="peachheaderdiv">
Proposition
</div>
<div class="peachbodydiv">
Every permutation of a finite set is equal to some product of transpositions (a transposition is  2-cycle) not necessarily disjoint.
</div>
<p><br />
<!------------------------------------------------------------------------>
For example we can write \((1 \quad 2 \quad 3 \quad 4)\) as \((1 \quad 2)(2 \quad 3)(3 \quad 4)\). 
<br />
<br />
Next, we have the following proposition
<br />
<!------------------------------------------------------------------------></p>
<div class="peachheaderdiv">
Proposition
</div>
<div class="peachbodydiv">
If \(\sigma\) is a permutation of a finite set and if \(\sigma = \tau_1\tau_2...\tau_k = \nu_1\nu_2...\nu_l\) where each of \(\tau_i\) and \(\nu_j\) are transpositions, then either \(k,l\) are both even, or are both odd. i.e. \((-1)^k = (-1)^l\)
</div>
<!------------------------------------------------------------------------>
<p><br />
Because of this we can classify permutations as even or odd. We also get the fact that composing two even permutations is another even permutations and composing an even permutation with an odd permutation is an odd permutation.
<br />
<br />
<!------------------------------------------------------------------------>
<b>Proof</b> (there is an alternative proof in the notes)
<br />
Define a function \(sgn: S_n \rightarrow \{\pm 1\}\) such that</p>
<ol>
	<li>\(sgn(id) = +1\)</li>
	<li>\(sgn(\sigma \circ \tau) = sgn(\sigma)sgn(\tau)\)</li>
	<li>If \(\tau\) is a transposition, then \(sgn(\tau) = -1\)</li>
</ol>
<p>So now given a permutation \(\sigma \in S_n\), there is a corresponding permutation matrix \(A_{\sigma} \in GL_{n}(\mathbf{R})\). \(A_{\sigma}\) has the standard basis vectors but permuted according to the permutation \(\sigma\). For example</p>
<div>
$$
\begin{align*}
A_{(1 \quad 2 \quad 3)}
&amp;= 
\begin{pmatrix}
0 &amp; 0 &amp; 1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0
\end{pmatrix}
\end{align*}
$$
</div>
<p>So</p>
<div>
$$
\begin{align*}
A_{\sigma}
&amp;= 
\begin{pmatrix}
e_{\sigma(1)} &amp; e_{\sigma(2)} &amp; ... &amp; e_{\sigma(n)}
\end{pmatrix}
\end{align*}
$$
</div>
<p>where \(e_{\sigma(k)}\) is the standard column vector \(e_k\) permuted according to \(\sigma(k)\). 
<br />
<br />
The permutation matrix \(A_{\sigma}\) is useful in that left multiplication by \(A_{\sigma}\) permutes the subset \(\{e_1,...,e_n\} \in \mathbf{R}^n\) according to \(\sigma\). So</p>
<div>
$$
\begin{align*}
A_{\sigma}e_k = e_{\sigma(k)}
\end{align*}
$$
</div>
<p>This actually leads to a formula</p>
<div>
$$
\begin{align*}
A_{\sigma}A_{\tau} = A_{\sigma \circ \tau}
\end{align*}
$$
</div>
<p>This is because</p>
<div>
$$
\begin{align*}
A_{\sigma}A_{\tau}e_k = A_{\sigma}e_{\tau(k)} = e_{\sigma(\tau(k))} \leftrightarrow A_{\sigma \circ \tau}e_k = e_{(\sigma \circ \tau)(k)}
\end{align*}
$$
</div>
<p>So now define: \(sgn(\sigma) = \det(A_{\sigma})\) where \(sgn: S_n \rightarrow \{\pm 1\}\). This function satisfies the three properties we defined for the \(sgn\) function above.</p>
<ol>
	<li>\(sgn(id) = +1\). This is true because the permutation matrix for the identity permutation is the identity matrix.</li>
	<li>\(sgn(\sigma \circ \tau) = sgn(\sigma)sgn(\tau)\). This follows from the product property of the determinant. \(\det(AB) = \det(A)\det(B)\).</li>
	<li>If \(\tau\) is a transposition, then \(sgn(\tau) = -1\). This also follows from the fact that interchanging any two columns from a matrix results in switching the sign of the determinant.</li>
</ol>
<p><br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>MATH417 by Charles Rezk</li>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition Let \(X\) be a set. Define the permutation of \(X\) as a bijection from the set to itself (\(f: X \rightarrow X\)). Let \(Sym(X)\) be the set of all bijections from \(X\) to itself (\(X \rightarrow X\)). \(Sym(X)\) equipped with the composition of functions operation is a group. To see this observe that \(id: X \rightarrow X, id(x) = x\) is the identity element. Composition of functions is associative. The composition of two permutations is another permutation. Bijections have inverses and the inverse of a bijection is another bijection. This group is often denoted by the Permutation Group or more often the Symmetric Group. The standard example for the case of finite sets is the standard set \(X = \{1,2,...,n\}\). The symmetric group has a special name called \(S_n\), $$ \begin{align*} S_n = Sym(\{1,2,...,n\}) \end{align*} $$ The size of \(S_n\) is \(|S_n| = n!\). Two Line Notation Let \(\rho, \psi \in S_4\), then we’ll write $$ \begin{align*} \rho = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 1 &amp; 4 &amp; 3 &amp; 2\end{pmatrix} \end{align*} $$ shows that \(\rho(1) = 1\), \(\rho(2) = 4\), \(\rho(3) = 3\) and \(\rho(4) = 2\). Similarly, $$ \begin{align*} \psi = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 2 &amp; 1 &amp; 3\end{pmatrix} \end{align*} $$ shows that \(\psi(1) = 4\), \(\psi(2) = 2\), \(\psi(3) = 1\) and \(\psi(4) = 3\). Finally, $$ \begin{align*} \rho\psi = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 2 &amp; 4 &amp; 1 &amp; 3\end{pmatrix} \in S_4 \end{align*} $$ so \(\rho\psi(1) = 2\), \(\rho\psi(2) = 4\), \(\rho\psi(3) = 1\) and \(\rho\psi(4) = 3\). Cycle Notation We can decompose the cycles in each permutation above. For example for the first permutation $$ \begin{align*} \rho = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 1 &amp; 4 &amp; 3 &amp; 2\end{pmatrix} \end{align*} $$ We can decompose this permutation into the following In this permutation, we have a cycle of length \(2\) For the second permutation $$ \begin{align*} \psi = \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 \\ 4 &amp; 2 &amp; 1 &amp; 3\end{pmatrix} \end{align*} $$ we have a cycle of length \(3\). To describe a cycle, we can use cycle notation which is defined as follows Definition Let \(\sigma = (a_1 \quad a_2 \quad ... \quad a_k)\) where \(a_1,...,a_k \in X\) are distinct. \(\sigma\) is defined by $$ \begin{align*} \sigma(a_i) &amp;= a_{i+1}, \quad i = 1,...,k-1 \\ \sigma(a_k) &amp;= a_1 \\ \sigma(x) &amp;= x, \quad \text{if} x \notin \{a_1,...,a_k\} \\ \end{align*} $$ So we can write the first permutation with cycle notation as \((2,4)\) only since by definition for the other elements \(\sigma(x)=x\), while the second permutation can be written as \((1,4,3)\). What about the following example? $$ \begin{align*} \begin{pmatrix}1 &amp; 2 &amp; 3 &amp; 4 &amp; 5\\ 3 &amp; 5 &amp; 4 &amp; 1 &amp; 2\end{pmatrix} \end{align*} $$ Note here that we have two disjoint cycles. \((1 \quad 4 \quad 3)\) where \(1\) goes to \(3\) and \(3\) goes to \(4\) and \(4\) goes back to \(1\) and \((2 \quad 5)\) where \(2\) goes to \(5\) and \(5\) goes back to \(2\). This permutation can be written as $$ \begin{align*} (1 \quad 3 \quad 4)(2 \quad 5) \end{align*} $$ Facts Some facts about the cycle notation \((1) = (2) = ... (n) = id\). All of these represent the identity permutations. The order of the elements in a cycle matters up to "cyclic permutation". \((1 \quad 2 \quad 3 \quad 4) = (2 \quad 3 \quad 4 \quad 1) \neq (1 \quad 3 \quad 4 \quad 2)\) For the inverse of a permutation, we just reverse the order of elements so \((a_1 \quad a_2 \quad ... \quad a_k)^{-1} = (a_k \quad a_{k-1} \quad ... \quad a_1)\) Two cycles \(\sigma = (a_1 \quad a_2 \quad ... \quad a_k)\) and \(\tau = (b_1 \quad b_{2} \quad ... \quad b_l) \in Sym(X)\) are disjoint if \(\{a_1,a_2,...,a_k\} \cap \{b_1,b_2,...,b_l\} = \emptyset\). Moreover, if the two sets are disjoint, then \(\sigma \circ \tau = \tau \circ \sigma\). This means that the permutation above that we described with \((1 \quad 3 \quad 4)(2 \quad 5)\) can also be written as \((2 \quad 5)(1 \quad 3 \quad 4)\) Theorem Every non-id element in \(Sym(X)\) where \(X\) is finite can be written as a product of pairwise disjoint cycles (of length \(\geq 2\) uniquely up to re-ordering. Suppose we have \(\sigma = (1 \quad 3)(2 \quad 7 \quad 8)(4 \quad 5 \quad 6)(9) \in S_9\). Any of the cycles in this notation are pairwise disjoint. We have 3 disjoint cycles where \(9\) is fixed. The proof for this theorem is in the class notes. Cycle Type We can classify permutations of a finite set into groups corresponding to the number of cycles of various lengths in their cycle decomposition. For example for \(S_2\), we have two elements and so we have two permutations \(1 + 1\) \(id = (1)(2)\) \(2\) \((1 \quad 2)\) For \(S_3\), \(1 + 1 + 1\) \(id = (1)(2)(3)\) \(2 + 1\) \((1 \quad 2),(1 \quad 3),(2 \quad 3)\) \(3\) \((1 \quad 2 \quad 3),(1 \quad 3 \quad 2)\) For \(S_4\), \(1 + 1 + 1 + 1\) \(id = (1)(2)(3)(4)\) \(2 + 1 + 1\) \((1 \quad 2),(1 \quad 3),(1 \quad 4),(2 \quad 3),(2 \quad 4),(3 \quad 4)\) \(2 + 2\) \((1 \quad 2)(3 \quad 4),(1 \quad 3)(2 \quad 4),(1 \quad 4)(2 \quad 3)\) \(3 + 1\) \((1 \quad 2 \quad 3),(1 \quad 2 \quad 4)\),\((1 \quad 3 \quad 4),(2 \quad 3 \quad 4),(1 \quad 3 \quad 2)\),\((1 \quad 4 \quad 2),(1 \quad 4 \quad 3),(2 \quad 4 \quad 3)\) \(4\) \((1 \quad 2 \quad 3 \quad 4),(1 \quad 2 \quad 4 \quad 3)\),\((1 \quad 3 \quad 2 \quad 4),(1 \quad 3 \quad 4 \quad 2)\),\((1 \quad 4 \quad 2 \quad 3),(1 \quad 4 \quad 3 \quad 2)\) The Order of an Element (Start of lecture 4). The first concept that we will talk about is the order of an element in a group. Definition Suppose we have a group \((G, \cdot)\) and let \(a \in G\). The order of \(a\) is the smallest positive integer \(n\) such that \(a^n = e\) (or infinite). \(\text{order}(a) \in \mathbf{N} \cup \{\infty\}\). For example let \(\sigma = (1 \quad 2 \quad 3 \quad 4) \in S_5\) The order of \(\sigma\), \(\text{order}(\sigma)\) is \(4\). This is because it will take \(\sigma^4\) will finally get us back to the identity permutation. In fact that the order of a \(k-\)cycle is \(k\). What about \(\tau = (1 \quad 2)(3 \quad 4 \quad 5)\)? \(\text{order}(\tau) = 6\) because we have to iterate the operation \(6\) times to get to the identity element. Specifically, we have two disjoint cycles and since they are disjoint, then they operate independently. So we need to find \(n\) such that both of the cycles will return to the identity permutation $$ \begin{align*} (1 \quad 2)^n &amp;= e \\ (3 \quad 4 \quad 5)^n &amp;= e \end{align*} $$ This \(n\) must be then the least common multiple of \(2\) and \(3\) which is \(6\). What about \(\nu = (1 \quad 2)(2 \quad 3 \quad 4)\)? Note here that the two cycles are not disjoint. It’s not clear here what it would be so drawing this permutation might make this very obvious.]]></summary></entry><entry><title type="html">Lecture 02: Rotations in Space</title><link href="http://localhost:4000/jekyll/update/2025/01/25/math417-02-rotations-in-space.html" rel="alternate" type="text/html" title="Lecture 02: Rotations in Space" /><published>2025-01-25T00:01:36-08:00</published><updated>2025-01-25T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/25/math417-02-rotations-in-space</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/25/math417-02-rotations-in-space.html"><![CDATA[<p>A group is a set with a defined product. This product is associative. The group is closed under this product. We have an identity element and each element has an inverse. Formally,
<br /></p>
<div class="mintheaderdiv">
Definition (1.10.1)
</div>
<div class="mintbodydiv">
A group is a (nonempty) set \(G\) with a binary operation (a product) \(G \times G \rightarrow G\) satisfying the following properties:
<ol type="a">
	<li>The group is closed under the operation. </li>
	<li>The product is associative. For all \(a, b, c \in G\), we have \((ab)c = a(bc)\).</li>
	<li>There is an identity element \(e \in G\) with property that for all \(a \in G\), \(ea = ae = a\).</li>
	<li>For each element \(a \in G\), there is an element \(a^{-1}\ \in G\) satisfying \(aa^{-1} = a^{-1}a = e\) (The inverse).</li>
</ol>
</div>
<!------------------------------------------------------------------------>
<p><br />
What are examples of the groups?</p>
<ol type="a">
	<li>\(\mathbf{R}\) with the addition operation.</li>
	<li>\(\mathbf{R}^{x} = \mathbf{R} - \{0\}\) with the multiplication operation.</li>
	<li>\(\mathbf{Z}\) with the addition operation.</li>
	<li>The set of invertible \(n \times n\) matrices with entries in \(\mathbf{R}\) with matrix multiplication as the product.</li>
	<li>Any vector space is a group if you forget about the scalar multiplication.</li>
	<li>For any set \(T\), define the set of all bijections \(g: T \rightarrow T\). The set of all bijections is the symmetric group of \(T\). The operation here is the composition of these maps.</li>
</ol>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>Suppose we define the group \((\mathbf{R}, \ast)\) where \(\ast\) is defined as</p>
<div>
$$
\begin{align*}
x \ast y = \sqrt[3]{x^3 + y^3}
\end{align*}
$$
</div>
<p>We can further check that this product satisfies the three axioms of a group.
<br />
<br />
<!------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>Let \(F\) be a field (for example \(\mathbf{R}\) or \(\mathbf{C}\)). Let \(Mat_{n \times n}(F)\) be the set of matrices with entries in \(F\). Then define \(GL_n(F)\) (General Linear Group) as a subset of \(A \in M_{n \times n}(F)\) where \(A\) is an invertible matrix.<br />
<br />
<br />
The set \(GL_n(F)\) equipped with matrix multiplication is a group. It satisfies the three axioms</p>
<ol type="a">
	<li>The group is closed under multiplication because multiplying two invertible matrices is another invertible matrix. \((AB)^{-1} = B^{-1}A^{-1}\)</li>
	<li>The identity element is the identity matrix.</li>
	<li>Matrix multiplication is associative.</li>
</ol>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Rotations in Plane</b></h4>
<p>We can define a plane rotation by an angle counter clockwise by the left multiplication by the following rotation matrix</p>
<div>
$$
\begin{align*}
Rot(\theta) &amp;= 
\begin{pmatrix}
\cos\theta &amp; -\sin\theta \\
\sin\theta &amp; \cos\theta
\end{pmatrix}
\end{align*}
$$
</div>
<p>The rotation matrix has some properties</p>
<ol type="a">
	<li>\(\text{Rot}(0) = I\) is the identity matrix.</li>
	<li>\(\text{Rot}(\alpha)Rot(\beta) = \text{Rot}(\alpha + \beta)\).</li>
	<li>\(\text{Rot}(\alpha)^{-1} = \text{Rot}(-\alpha)\).</li>
	<li>\(\text{Rot}(\alpha + 2\pi n) = \text{Rot}(\alpha)\) where \(n \in \mathbf{Z}\).</li>
</ol>
<p>From this we see that the collection of rotation matrices forms a group with matrix multiplication.
<br />
<br />
<!------------------------------------------------------------------------></p>
<h4><b>Rotations in Space</b></h4>
<div>
$$
\begin{align*}
\text{Rot}_{e_3}(\theta) &amp;= 
\begin{pmatrix}
\cos\theta &amp; -\sin\theta &amp; 0 \\
\sin\theta &amp; \cos\theta &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p>This defines a rotation around the \(z-\)axis by angle \(\theta\) counter clockwise viewed from the head of the vector \(e_3\) where \(e_3 = (0,0,1)\). But instead of using \(e_3\), we’ll use a more general vector \(u \in \mathbf{R}^3\) such that \(\lVert {u} \rVert = 1\). So let \(\text{Rot}_u(\theta)\) be a rotation matrix around the axis through \(u\) by angle \(\theta\) counterclockwise when viewed from the head of \(u\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>How Do you Compute The Rotation Matrix?</b></h4>
<p>Recall from Linear Algebra that</p>
<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
An orthogonal matrix is a square matrix \(P \in Mat_{n \times n}(\mathbf{R})\) such that \(P^{T}P = I\) or \(P^{-1} = P^{T}\).
</div>
<p><br />
Equivalently the columns of \(P\) are an orthonormal basis of \(\mathbf{R}^n\) and the rows of \(P\) are also orthonormal basis of \(\mathbf{R}^n\).
<br />
<br />
Given the above definition, there is a useful formula where for \(u \in \mathbf{R}^3\), \(\lVert u \rVert = 1\), \(\theta \in \mathbf{R}\) and \(P\) an orthogonal matrix such the product</p>
<div>
$$
\begin{align*}
P \text{Rot}_u(\theta) P^{-1}
\end{align*}
$$
</div>
<p>is another rotation matrix but instead of having \(u\) as the axis, we have \(Pu\) as the axis so</p>
<div>
$$
\begin{align*}
\text{Rot}_{Pu}(\theta) = P \text{Rot}_u(\theta) P^{-1}
\end{align*}
$$
</div>
<p>Why is this a useful formula? Given \(\lVert u \rVert = 1\) and some angle \(\theta\), construct an orthonormal basis using Gram-Schmidt by setting \(u_3 = u\) and finding two more perpendicular vectors (normalized) \(u_1, u_2 \in \mathbf{R}^3\). Let \(P = [u_1 \quad u_2 \quad u_3]\). This means that \(Pe_3 = u_3 = u\). Therefore</p>
<div>
$$
\begin{align*}
\text{Rot}_{u}(\theta) = P \text{Rot}_{e_3}(\theta) P^{T}
\end{align*}
$$
</div>
<!------------------------------------------------------------------------>
<h4><b>Example</b></h4>
<p>So now suppose we want to rotate around \(\frac{(e_1 + e_2)}{\sqrt{2}}\) (which is a unit vector) by \(\theta = \frac{\pi}{3}\). Then, we’ll need two more orthonormal vectors in addition to \(\frac{(e_1 + e_2)}{\sqrt{2}}\) to construct an orthonormal basis. We can use Gram-Schmidt to come up with the following orthonormal vectors and set them to be the column vectors of \(P\) as follows</p>
<div>
$$
\begin{align*}
P &amp;= 
\begin{pmatrix}
0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
0 &amp; -\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\
1 &amp; 0 &amp; 0
\end{pmatrix}
\end{align*}
$$
</div>
<p>The rotation \(\text{Rot}_{e_3}\) is as follows</p>
<div>
$$
\begin{align*}
\text{Rot}_{e_3}(\frac{\pi}{3}\big) &amp;= 
\begin{pmatrix}
\frac{1}{2} &amp; -\frac{\sqrt{3}}{2} &amp; 0 \\
\frac{\sqrt{3}}{2} &amp; \frac{1}{2} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p>Therefore,</p>
<div>
$$
\begin{align*}
\text{Rot}_{\frac{e_1 + e_2}{\sqrt{2}}}\big(\frac{\pi}{3}\big) &amp;= P \text{Rot}_{e_3}(\frac{\pi}{3}\big) P^{T}
\\
&amp;= 
\begin{pmatrix}
\frac{3}{4} &amp; \frac{1}{4} &amp; \frac{\sqrt{3}}{8} \\
\frac{3}{4} &amp; \frac{3}{4} &amp; -\frac{\sqrt{3}}{8} \\
-\frac{\sqrt{3}}{8} &amp; \frac{\sqrt{3}}{8} &amp; \frac{1}{2}
\end{pmatrix}
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Rotations in Space</b></h4>
<p>From last lecture, we saw the symmetries of the square. These symmetries can be represented with rotation matrices. We have the identity rotation \(I\). We can also define the rotation around the axis coming through the centroid of the face (\(z-\)axis in the lecture) as \(R = \text{Rot}_{e_3}(\frac{\pi}{2})\). Therefore, \(R^2 = \text{Rot}_{e_3}(\pi)\) and \(R^3 = \text{Rot}_{e_3}(\frac{3\pi}{2})\).
<br />
<br />
What about the \(180\) degrees rotation around the \(x-axis\) labeled as \(a\) from last time? We can define it as \(A = \text{Rot}_{e_1}(\pi)\). Similarly, \(B = \text{Rot}_{e_2}(\pi)\), \(C = \text{Rot}_{\frac{e_1 - e_2}{\sqrt{2}}}(\pi)\) and \(D = \text{Rot}_{\frac{e_1 + e_2}{\sqrt{2}}}(\pi)\)
<br />
<br />
Rotations in space have also the following properties / identities</p>
<ol type="a">
	<li>\(\text{Rot}_u(0) = I\) is the identity matrix where \(u\) is any unit vector.</li>
	<li>\(\text{Rot}_u(\theta + 2\pi n) = \text{Rot}_u(\theta)\) where \(n \in \mathbf{Z}\).</li>
	<li>\(\text{Rot}_u(\theta) = \text{Rot}_{-u}(-\theta)\).</li>
	<li>\(\text{Rot}_u(\theta)^{-1} = \text{Rot}_{u}(-\theta) = \text{Rot}_{-u}(\theta)\).</li>
	<li>\(\text{Rot}_u(\alpha)Rot_v(\beta) = a\) is a rotation matrix.</li>
	<li>\(\text{Rot}_u(\alpha)Rot_u(\beta) = Rot_u(\alpha + \beta)\).</li>
</ol>
<p>But why is the last statement true? To figure it out, we need to introduce another definition
<br />
<br />
<!------------------------------------------------------------------------></p>
<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
A special orthogonal matrix is an \(A \in Mat_{n \times n}(\mathbf{R})\) such that
<ol type="a">
	<li>\(A^TA = I\). (The orthogonal property)</li>
	<li>\(\det(A) = \pm 1\). (This is as a result of the fact that \(det(A^{-1}) = \frac{1}{\det(A)}\) and that \(\det(A) = \det(A^T)\)</li> 
</ol>
</div>
<p><br />
And now we have the following proposition
<!------------------------------------------------------------------------></p>
<div class="peachheaderdiv">
Proposition
</div>
<div class="peachbodydiv">
\(A \in Mat_{3 \times 3}(\mathbf{R})\) is a rotation matrix if and only if it is special orthogonal.
</div>
<p><br />
We denote these matrices special matrices with</p>
<div>
$$
\begin{align*}
SO(n) = \{ A \in Mat_{n \times n} \text{ special orthogonal} \} \subseteq O(n) \subseteq GL_n(\mathbf{R}) 
\end{align*}
$$
</div>
<p>Observation: \(A, B \in SO(n)\) implies that \(AB \in SO(n)\). To show that this is true, we need to show that properties of special orthogonal matrices hold. To see that, observe that</p>
<ul>
	<li>\( (AB)^TAB = B^TA^TAB = B^TB = I \)</li>
	<li>\( \det(AB) = \det(A)\det(B) = 1 \)</li>
</ul>
<p><br />
Also observe that the identity matrix is in \(SO(n)\) and that for any \(A \in SO(n)\), \(A^{-1} = A^{T} \in SO(n)\). Therefore \(SO(n)\) is a group with matrix multiplication.
<br />
<br />
So now we know that the collection of special orthogonal matrices is a group. Therefore, if the proposition we introduced earlier holds (where we said that \(A \in Mat_{3 \times 3}(\mathbf{R})\) is a rotation matrix if and only if it is special orthogonal), then we can also conclude that the product of two rotation matrices is also a rotation matrix. So let’s sketch the proof of the proposition
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------>
<b>Proof</b>
<br />
\(\Rightarrow\) (\(\text{Rot}_u(\theta) \in SO(3)\)):
<br />
Let \(\text{Rot}_u(\theta) = P\text{Rot}_{e_3}(\theta)P^{-1}\) for some chosen \(P \in O(3)\). We want to show that \(P\text{Rot}_{e_3}(\theta)P^{-1} \in SO(3)\). To do so we need to show that if \(A \in SO(n)\) and \(P \in O(n)\), then \(PAP^{-1} = PAP^{T} \in SO(3)\). We can easily show this by verifying the two properties of special orthogonal matrices. For example,</p>
<div>
$$
\begin{align*}
(PAP^{T})^{T}PAP^{T} &amp;= PA^TP^TPAP^{T} \\
                     &amp;= PA^TAP^{T} \quad \text{ (because $P \in O(n)$)} \\
                     &amp;= PP^{T} = I.
\end{align*}
$$
</div>
<p>The verification that the determinat is 1 is also the same. So now what’s left is to show that \(\text{Rot}_{e_3}(\theta)\) is in \(SO(3)\). We can verify this because we know the exact matrix of \(\text{Rot}_{e_3}(\theta)\) so we can computationally verify that it is a special orthogonal matrix. Finally, since \(P \in O(n)\) and we just showed that \(\text{Rot}_{e_3}(\theta) \in SO(3)\), then \(P\text{Rot}_{e_3}(\theta)P^{T}\) is in \(SO(3)\) as we wanted to show.
<br />
<br />
\(\Leftarrow\) (\(A \in SO(3) \implies A = \text{Rot}_u(\theta)\)):
<br />
For this we’ll use the fact that if \(A \in SO(3)\), then \(1\) is an eigenvalue of \(A\). So let \(u\) be the eigenvector of \(A\) corresponding to \(\lambda = 1\) so \(Au = u\). Choose \(\lVert u \rVert = 1\). Now let \(u_3 = u\) and form an orthonormal basis \(\{u_1, u_2, u_3\}\). Now Let \(P = [u_1 \quad u_2 \quad u_3]\) and let \(B = P^{-1}AP = P^{T}AP\). We know that \(Pe_3 = u_3\) but \(u_3\) is an eigenvector of \(A\).</p>
<div>
$$
\begin{align*}
Be_3 = P^{-1}APe_3 = P^{-1}Au_3 = P^{-1}u_3 = e_3
\end{align*}
$$
</div>
<p>So \(e_3\) is an eigenvector of \(B\) … then by the fact we used in the left direction, we can conclude that \(B \in SO(3)\) (Why?). So this means that \(B\) has orthonormal columns since it’s in \(SO(3)\) and the third column specifically is \(e_3\). So</p>
<div>
$$
\begin{align*}
B
&amp;= 
\begin{pmatrix}
a &amp; b &amp; 0 \\
c &amp; d &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p>By an algebraic argument we can show that \(a = d = \cos\theta\) and \(c = -b = \sin\theta\). So \(B\) must be \(\text{Rot}_{e_3}\). Therefore, \(A = P\text{Rot}_{e_3}P^{T}\)….
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>MATH417 by Charles Rezk</li>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[A group is a set with a defined product. This product is associative. The group is closed under this product. We have an identity element and each element has an inverse. Formally, Definition (1.10.1) A group is a (nonempty) set \(G\) with a binary operation (a product) \(G \times G \rightarrow G\) satisfying the following properties: The group is closed under the operation. The product is associative. For all \(a, b, c \in G\), we have \((ab)c = a(bc)\). There is an identity element \(e \in G\) with property that for all \(a \in G\), \(ea = ae = a\). For each element \(a \in G\), there is an element \(a^{-1}\ \in G\) satisfying \(aa^{-1} = a^{-1}a = e\) (The inverse). What are examples of the groups? \(\mathbf{R}\) with the addition operation. \(\mathbf{R}^{x} = \mathbf{R} - \{0\}\) with the multiplication operation. \(\mathbf{Z}\) with the addition operation. The set of invertible \(n \times n\) matrices with entries in \(\mathbf{R}\) with matrix multiplication as the product. Any vector space is a group if you forget about the scalar multiplication. For any set \(T\), define the set of all bijections \(g: T \rightarrow T\). The set of all bijections is the symmetric group of \(T\). The operation here is the composition of these maps. Example Suppose we define the group \((\mathbf{R}, \ast)\) where \(\ast\) is defined as $$ \begin{align*} x \ast y = \sqrt[3]{x^3 + y^3} \end{align*} $$ We can further check that this product satisfies the three axioms of a group. Example Let \(F\) be a field (for example \(\mathbf{R}\) or \(\mathbf{C}\)). Let \(Mat_{n \times n}(F)\) be the set of matrices with entries in \(F\). Then define \(GL_n(F)\) (General Linear Group) as a subset of \(A \in M_{n \times n}(F)\) where \(A\) is an invertible matrix. The set \(GL_n(F)\) equipped with matrix multiplication is a group. It satisfies the three axioms The group is closed under multiplication because multiplying two invertible matrices is another invertible matrix. \((AB)^{-1} = B^{-1}A^{-1}\) The identity element is the identity matrix. Matrix multiplication is associative. Rotations in Plane We can define a plane rotation by an angle counter clockwise by the left multiplication by the following rotation matrix $$ \begin{align*} Rot(\theta) &amp;= \begin{pmatrix} \cos\theta &amp; -\sin\theta \\ \sin\theta &amp; \cos\theta \end{pmatrix} \end{align*} $$ The rotation matrix has some properties \(\text{Rot}(0) = I\) is the identity matrix. \(\text{Rot}(\alpha)Rot(\beta) = \text{Rot}(\alpha + \beta)\). \(\text{Rot}(\alpha)^{-1} = \text{Rot}(-\alpha)\). \(\text{Rot}(\alpha + 2\pi n) = \text{Rot}(\alpha)\) where \(n \in \mathbf{Z}\). From this we see that the collection of rotation matrices forms a group with matrix multiplication. Rotations in Space $$ \begin{align*} \text{Rot}_{e_3}(\theta) &amp;= \begin{pmatrix} \cos\theta &amp; -\sin\theta &amp; 0 \\ \sin\theta &amp; \cos\theta &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{pmatrix} \end{align*} $$ This defines a rotation around the \(z-\)axis by angle \(\theta\) counter clockwise viewed from the head of the vector \(e_3\) where \(e_3 = (0,0,1)\). But instead of using \(e_3\), we’ll use a more general vector \(u \in \mathbf{R}^3\) such that \(\lVert {u} \rVert = 1\). So let \(\text{Rot}_u(\theta)\) be a rotation matrix around the axis through \(u\) by angle \(\theta\) counterclockwise when viewed from the head of \(u\). How Do you Compute The Rotation Matrix? Recall from Linear Algebra that Definition An orthogonal matrix is a square matrix \(P \in Mat_{n \times n}(\mathbf{R})\) such that \(P^{T}P = I\) or \(P^{-1} = P^{T}\). Equivalently the columns of \(P\) are an orthonormal basis of \(\mathbf{R}^n\) and the rows of \(P\) are also orthonormal basis of \(\mathbf{R}^n\). Given the above definition, there is a useful formula where for \(u \in \mathbf{R}^3\), \(\lVert u \rVert = 1\), \(\theta \in \mathbf{R}\) and \(P\) an orthogonal matrix such the product $$ \begin{align*} P \text{Rot}_u(\theta) P^{-1} \end{align*} $$ is another rotation matrix but instead of having \(u\) as the axis, we have \(Pu\) as the axis so $$ \begin{align*} \text{Rot}_{Pu}(\theta) = P \text{Rot}_u(\theta) P^{-1} \end{align*} $$ Why is this a useful formula? Given \(\lVert u \rVert = 1\) and some angle \(\theta\), construct an orthonormal basis using Gram-Schmidt by setting \(u_3 = u\) and finding two more perpendicular vectors (normalized) \(u_1, u_2 \in \mathbf{R}^3\). Let \(P = [u_1 \quad u_2 \quad u_3]\). This means that \(Pe_3 = u_3 = u\). Therefore $$ \begin{align*} \text{Rot}_{u}(\theta) = P \text{Rot}_{e_3}(\theta) P^{T} \end{align*} $$ Example So now suppose we want to rotate around \(\frac{(e_1 + e_2)}{\sqrt{2}}\) (which is a unit vector) by \(\theta = \frac{\pi}{3}\). Then, we’ll need two more orthonormal vectors in addition to \(\frac{(e_1 + e_2)}{\sqrt{2}}\) to construct an orthonormal basis. We can use Gram-Schmidt to come up with the following orthonormal vectors and set them to be the column vectors of \(P\) as follows $$ \begin{align*} P &amp;= \begin{pmatrix} 0 &amp; \frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\ 0 &amp; -\frac{1}{\sqrt{2}} &amp; \frac{1}{\sqrt{2}} \\ 1 &amp; 0 &amp; 0 \end{pmatrix} \end{align*} $$ The rotation \(\text{Rot}_{e_3}\) is as follows $$ \begin{align*} \text{Rot}_{e_3}(\frac{\pi}{3}\big) &amp;= \begin{pmatrix} \frac{1}{2} &amp; -\frac{\sqrt{3}}{2} &amp; 0 \\ \frac{\sqrt{3}}{2} &amp; \frac{1}{2} &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{pmatrix} \end{align*} $$ Therefore, $$ \begin{align*} \text{Rot}_{\frac{e_1 + e_2}{\sqrt{2}}}\big(\frac{\pi}{3}\big) &amp;= P \text{Rot}_{e_3}(\frac{\pi}{3}\big) P^{T} \\ &amp;= \begin{pmatrix} \frac{3}{4} &amp; \frac{1}{4} &amp; \frac{\sqrt{3}}{8} \\ \frac{3}{4} &amp; \frac{3}{4} &amp; -\frac{\sqrt{3}}{8} \\ -\frac{\sqrt{3}}{8} &amp; \frac{\sqrt{3}}{8} &amp; \frac{1}{2} \end{pmatrix} \end{align*} $$ Rotations in Space From last lecture, we saw the symmetries of the square. These symmetries can be represented with rotation matrices. We have the identity rotation \(I\). We can also define the rotation around the axis coming through the centroid of the face (\(z-\)axis in the lecture) as \(R = \text{Rot}_{e_3}(\frac{\pi}{2})\). Therefore, \(R^2 = \text{Rot}_{e_3}(\pi)\) and \(R^3 = \text{Rot}_{e_3}(\frac{3\pi}{2})\). What about the \(180\) degrees rotation around the \(x-axis\) labeled as \(a\) from last time? We can define it as \(A = \text{Rot}_{e_1}(\pi)\). Similarly, \(B = \text{Rot}_{e_2}(\pi)\), \(C = \text{Rot}_{\frac{e_1 - e_2}{\sqrt{2}}}(\pi)\) and \(D = \text{Rot}_{\frac{e_1 + e_2}{\sqrt{2}}}(\pi)\) Rotations in space have also the following properties / identities \(\text{Rot}_u(0) = I\) is the identity matrix where \(u\) is any unit vector. \(\text{Rot}_u(\theta + 2\pi n) = \text{Rot}_u(\theta)\) where \(n \in \mathbf{Z}\). \(\text{Rot}_u(\theta) = \text{Rot}_{-u}(-\theta)\). \(\text{Rot}_u(\theta)^{-1} = \text{Rot}_{u}(-\theta) = \text{Rot}_{-u}(\theta)\). \(\text{Rot}_u(\alpha)Rot_v(\beta) = a\) is a rotation matrix. \(\text{Rot}_u(\alpha)Rot_u(\beta) = Rot_u(\alpha + \beta)\). But why is the last statement true? To figure it out, we need to introduce another definition Definition A special orthogonal matrix is an \(A \in Mat_{n \times n}(\mathbf{R})\) such that \(A^TA = I\). (The orthogonal property) \(\det(A) = \pm 1\). (This is as a result of the fact that \(det(A^{-1}) = \frac{1}{\det(A)}\) and that \(\det(A) = \det(A^T)\) And now we have the following proposition Proposition \(A \in Mat_{3 \times 3}(\mathbf{R})\) is a rotation matrix if and only if it is special orthogonal. We denote these matrices special matrices with $$ \begin{align*} SO(n) = \{ A \in Mat_{n \times n} \text{ special orthogonal} \} \subseteq O(n) \subseteq GL_n(\mathbf{R}) \end{align*} $$ Observation: \(A, B \in SO(n)\) implies that \(AB \in SO(n)\). To show that this is true, we need to show that properties of special orthogonal matrices hold. To see that, observe that \( (AB)^TAB = B^TA^TAB = B^TB = I \) \( \det(AB) = \det(A)\det(B) = 1 \) Also observe that the identity matrix is in \(SO(n)\) and that for any \(A \in SO(n)\), \(A^{-1} = A^{T} \in SO(n)\). Therefore \(SO(n)\) is a group with matrix multiplication. So now we know that the collection of special orthogonal matrices is a group. Therefore, if the proposition we introduced earlier holds (where we said that \(A \in Mat_{3 \times 3}(\mathbf{R})\) is a rotation matrix if and only if it is special orthogonal), then we can also conclude that the product of two rotation matrices is also a rotation matrix. So let’s sketch the proof of the proposition Proof \(\Rightarrow\) (\(\text{Rot}_u(\theta) \in SO(3)\)): Let \(\text{Rot}_u(\theta) = P\text{Rot}_{e_3}(\theta)P^{-1}\) for some chosen \(P \in O(3)\). We want to show that \(P\text{Rot}_{e_3}(\theta)P^{-1} \in SO(3)\). To do so we need to show that if \(A \in SO(n)\) and \(P \in O(n)\), then \(PAP^{-1} = PAP^{T} \in SO(3)\). We can easily show this by verifying the two properties of special orthogonal matrices. For example, $$ \begin{align*} (PAP^{T})^{T}PAP^{T} &amp;= PA^TP^TPAP^{T} \\ &amp;= PA^TAP^{T} \quad \text{ (because $P \in O(n)$)} \\ &amp;= PP^{T} = I. \end{align*} $$ The verification that the determinat is 1 is also the same. So now what’s left is to show that \(\text{Rot}_{e_3}(\theta)\) is in \(SO(3)\). We can verify this because we know the exact matrix of \(\text{Rot}_{e_3}(\theta)\) so we can computationally verify that it is a special orthogonal matrix. Finally, since \(P \in O(n)\) and we just showed that \(\text{Rot}_{e_3}(\theta) \in SO(3)\), then \(P\text{Rot}_{e_3}(\theta)P^{T}\) is in \(SO(3)\) as we wanted to show. \(\Leftarrow\) (\(A \in SO(3) \implies A = \text{Rot}_u(\theta)\)): For this we’ll use the fact that if \(A \in SO(3)\), then \(1\) is an eigenvalue of \(A\). So let \(u\) be the eigenvector of \(A\) corresponding to \(\lambda = 1\) so \(Au = u\). Choose \(\lVert u \rVert = 1\). Now let \(u_3 = u\) and form an orthonormal basis \(\{u_1, u_2, u_3\}\). Now Let \(P = [u_1 \quad u_2 \quad u_3]\) and let \(B = P^{-1}AP = P^{T}AP\). We know that \(Pe_3 = u_3\) but \(u_3\) is an eigenvector of \(A\). $$ \begin{align*} Be_3 = P^{-1}APe_3 = P^{-1}Au_3 = P^{-1}u_3 = e_3 \end{align*} $$ So \(e_3\) is an eigenvector of \(B\) … then by the fact we used in the left direction, we can conclude that \(B \in SO(3)\) (Why?). So this means that \(B\) has orthonormal columns since it’s in \(SO(3)\) and the third column specifically is \(e_3\). So $$ \begin{align*} B &amp;= \begin{pmatrix} a &amp; b &amp; 0 \\ c &amp; d &amp; 0 \\ 0 &amp; 0 &amp; 1 \end{pmatrix} \end{align*} $$ By an algebraic argument we can show that \(a = d = \cos\theta\) and \(c = -b = \sin\theta\). So \(B\) must be \(\text{Rot}_{e_3}\). Therefore, \(A = P\text{Rot}_{e_3}P^{T}\)…. References MATH417 by Charles Rezk Algebra: Abstract and Concrete by Frederick M. Goodman]]></summary></entry><entry><title type="html">Lecture 01: Groups and Symmetries</title><link href="http://localhost:4000/jekyll/update/2025/01/24/math417-01-groups-and-symmetries.html" rel="alternate" type="text/html" title="Lecture 01: Groups and Symmetries" /><published>2025-01-24T00:01:36-08:00</published><updated>2025-01-24T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/24/math417-01-groups-and-symmetries</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/24/math417-01-groups-and-symmetries.html"><![CDATA[<h4><b>Introduction</b></h4>
<p>Abstract Algebra lets us examine structures which allow for algebraic manipulations of the types we’ve used in high school. As an example, we have Fields. It’s a set with operations addition, subtraction, multiplication and division that satisfy a few rules. An example of a field is the field of real numbers \(\mathbf{R}\) or the field of complex numbers \(\mathbf{C}\). We also have the field of rational numbers \(\mathbf{Q}\). Or \(\mathbf{Z}_p\) which is a finite field of integers modulo some prime \(p\). It is finite with \(p\) elements.
<br />
<br />
Another example of important structures are Rings. Here we have the operations addition, subtraction and multiplication. The first example of a ring is \(\mathbf{Z}\). Another example of a ring is a polynomial ring in one variable over \(\mathbf{R}\), \(\mathbf{R}[x]\). The set of all square matrices. \(M_{n \times n}(\mathbf{R})\) is also another example. This example is non-commutative.<br />
<br />
<br />
Another structure is a Group. It is a set with one operation usually called “multiplication”. One example is the set of real numbers with just addition. Another example is \((\mathbf{R}^{x})\) (the set of real numbers with zero removed, \(\mathbf{R} - \{0\}\) along with multiplication. \(GL(n,\mathbf{R})\), the set of invertible matrices with multiplication is another example of a Group. This is an example of a non-abelian or non-commutative group.
<br />
<br />
One additional structure that comes up is a Monoid. These are sets with one operation but you don’t have to have inverses like Groups. So \(\mathbf{R}\) with multiplication is not a group because it includes zero and zero doesn’t have an inverse but this set is a Monoid. 
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Groups and Symmetries</b></h4>

<p>From the book, a symmetry is an undetectable motion. An object is symmetric if it has symmetries. Take an equilateral triangle.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-1.png" width="40%" class="center" /></p>

<p>What are the symmetries of this triangle? We want to rotate the triangle in such a way that we won’t tell if it was rotated. For example, if we rotate this triangle by \(120\) degrees counter clockwise, then we’ll get a triangle in the same exact orientation. We label this rotation with \(r_1\). Note here that the labels on the vertices are used to illustrate that we indeed have rotated the triangle. They are a visual aid.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-2.png" width="70%" class="center" /></p>

<p>We can also rotate this triangle \(120\) degrees clockwise to get the following \(r_2\) rotation.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-3.png" width="70%" class="center" /></p>

<p>Are there more rotations? Yes, consider the rotation around the axis that goes through the vertex \(A\) by 180 degrees so essentially it’s a flip around that axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-4.png" width="70%" class="center" /></p>

<p>Similarly, we can do a flip around the axis that goes through the vertex \(B\) and a flip around the axis that goes through the vertex \(C\).</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-5.png" width="40%" class="center" /></p>

<p>So now we have \(5\) symmetries total. Is that all? No, We have one more symmetry representing the identity symmetry \(e\) that does nothing. So the set of symmetries are then</p>
<div>
$$
\begin{align*}
G = \{e, r_1, r_2, a, b, c\}
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Can We Compose Symmetries?</b></h4>

<p>Can we compose symmetries? Yes, in fact we’ll equip the group above with the operation compose. This means that for any \(x, y \in G\), \(xy\) means that we need to apply the rotation \(y\) first and then apply the rotation \(x\). Since we have \(6\) elements in \(G\), then we have \(36\) ways of composing these elements. 
<br />
<br />
For example composing \(r_1\) with \(r_1\) again results in the rotation \(r_2\) so \(r_1r_1 = r_2\).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-6.png" width="70%" class="center" /></p>
<p>And if we compose \(r_1\) with \(r_2\), then we’ll get the identity rotation so \(r_1r_2 = e\).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-7.png" width="70%" class="center" /></p>
<p>In fact since \(r_1r_1 = r_2\) and \(r_1r_2 = e\), we’ll change the notation to a much simpler notation. Let \(r_1 = r\). Then, \(r_2 = r_1r_1 = rr = r^2\). So now we can fill these in a table as follows
<br />
<!------------------------------------------------------------------------></p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(\)</td>
   <td>\(\)</td>	
   <td>\(\)</td>
   <td>\(\)</td>
   <td>\(\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
</table>
</div>
<p><br />
So far so good. What about composing the flips around the axes? For example composing \(a\) with \(b\). What would that do? For starters, note that each flip is a \(180\) degrees flip. So if you compose ANY two flips, we’ll be back to the same face we started with. This means that any two flips will be equivalent to \(e, r\) or \(r^2\). For example, if we apply \(a\) and then apply \(b\), we’ll get</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-8.png" width="90%" class="center" /></p>

<p>Note here that when did the second flip, we still rotated through the \(b\) access which now goes through vertex \(C\) instead. Physically the axis will still be in the same position. So we see above doing two flips \(a\), then around \(b\) is equivalent to applying two rotations so \(ba = r^2\). 
<br />
<br />
What about two flips of the same type? What happens if you apply \(a\) and then again flip it around that same access? We’ll get the identity rotation since we just go back to the same exact orientation. Applying this same logic on the rest of flips, we can fill that forth quadrant of the table which are all about compositions of flips.
<br />
<br />
<!------------------------------------------------------------------------></p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(\)</td>
   <td>\(\)</td>	
   <td>\(r^2\)</td>
   <td>\(e\)</td>
   <td>\(r\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
  </tr>
</table>
</div>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Second and Third Quadrants</b></h4>
<p>What about applying a rotation \(r\) followed by a flip \(a\)? What is \(ar\)? We apply a rotation so we move \(120\) degrees anti-clockwise and then we do an \(a\) flip which is now going to be through the \(C\) vertex. The triangle will now be faced down which is equivalent to applying a single flip. Comparing the vertices in the original triangle and the outcome, we see that \(B\) is fixed while \(A\) and \(C\) have switched. This means that this is a flip around the \(b\) access.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-9.png" width="90%" class="center" /></p>

<!------------------------------------------------------------------------>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(c\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
	<td>\(a\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(c\)</td>
   <td>\(a\)</td>	
   <td>\(r^2\)</td>
   <td>\(e\)</td>
   <td>\(r\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
  </tr>
</table>
</div>
<p>We notice that each row has each rotation appearing exactly once and it’s the same for each column. Notice also that composition is not commutative above. So \(ar \neq ra\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Matrix Representation of Symmetries</b></h4>
<p>We can actually represent these symmetries by matrices. For example, the following matrix will represent a \(120\) degrees rotation around the \(z-\) axis</p>
<div>
$$
\begin{align*}
r(x,y,z) &amp;= 
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; - \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; + \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p>or we can do the \(a\) flip so a \(180\) degree flip around the \(x\)-axis.</p>
<div>
$$
\begin{align*}
a(x,y,z) &amp;= 
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 0
\end{pmatrix}
\end{align*}
$$
</div>
<p>What about something more complex? like \(ra\) which is equal to \(c\) using the multiplication table above. This will be</p>
<div>
$$
\begin{align*}
c(x,y,z) &amp;= ra(x,y,z) 
\\
&amp;= 
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; - \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; + \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 0
\end{pmatrix}
\\
&amp;=
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; - \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Symmetries of the Rectangle</b></h4>
<p>How many symmetries does the rectangle have?</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-rect.png" width="30%" class="center" /></p>

<p>We can have a rotation \(r_1\) around the \(y-\)axis as follows</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-rect-r1.png" width="75%" class="center" /></p>

<p>We can also have a rotation \(r_2\) around the \(x-\)axis</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-rect-r2.png" width="75%" class="center" /></p>

<p>Finally, we have one more rotation \(r_3\) around the \(z-\)axis. (the axis coming off the screen toward us from the centroid of the face.)</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-rect-r3.png" width="75%" class="center" /></p>

<p>So we have four rotations which make the following group</p>
<div>
$$
\begin{align*}
G = \{e, r_1, r_2, r_3\}
\end{align*}
$$
</div>
<p>One thing to notice here that for any rotation in \(G\), if you apply it twice, you’ll get the identity rotation. So each rotation has an order \(2\). The multiplication table for the symmetries of the rectangle is as follows</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r_1\)</td>
	<td>\(r_2\)</td>
	<td>\(r_3\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r_1\)</td>
	<td>\(r_2\)</td>
	<td>\(r_3\)</td>
  </tr>
  <tr>
    <td>\(r_1\)</td>
    <td>\(r_1\)</td>
    <td>\(r_2\)</td>
	<td>\(r_3\)</td>
	<td>\(e\)</td>
  </tr>
  <tr>
    <td>\(r_2\)</td>
    <td>\(r_2\)</td>
    <td>\(r_3\)</td>
	<td>\(e\)</td>
	<td>\(r_1\)</td>
  </tr>
  <tr>
    <td>\(r_3\)</td>
    <td>\(r_3\)</td>
    <td>\(e\)</td>
	<td>\(r_1\)</td>
	<td>\(r_2\)</td>
  </tr>
</table>
</div>
<p><br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Symmetries of the Square</b></h4>
<p>What about the symmetries of the square? There are eight of them. First we consider the axis coming through the centroid of the face toward us. There are three rotations around this axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-square-r.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-square-r2.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-square-r3.png" width="55%" class="center" /></p>

<p>Next, we can consider the \(x-\)axis or the axis coming through the center of the edges. We can do a \(180\) degrees rotation around this access (a flip). Call this one \(a\).</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-square-a.png" width="55%" class="center" /></p>

<p>Similarly, we can do one around the \(y-\)axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-square-b.png" width="55%" class="center" /></p>

<p>And then two more through the diagonals of the square.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-square-c.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/lec01/01-square-d.png" width="55%" class="center" /></p>

<div>
$$
\begin{align*}
G = \{e, r, r^2, r^3, a, b, c, d\}
\end{align*}
$$
</div>
<p><br />
What about the cube? How many symmetries does it have? it has 24 symmetries!
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>MATH417 by Charles Rezk</li>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Introduction Abstract Algebra lets us examine structures which allow for algebraic manipulations of the types we’ve used in high school. As an example, we have Fields. It’s a set with operations addition, subtraction, multiplication and division that satisfy a few rules. An example of a field is the field of real numbers \(\mathbf{R}\) or the field of complex numbers \(\mathbf{C}\). We also have the field of rational numbers \(\mathbf{Q}\). Or \(\mathbf{Z}_p\) which is a finite field of integers modulo some prime \(p\). It is finite with \(p\) elements. Another example of important structures are Rings. Here we have the operations addition, subtraction and multiplication. The first example of a ring is \(\mathbf{Z}\). Another example of a ring is a polynomial ring in one variable over \(\mathbf{R}\), \(\mathbf{R}[x]\). The set of all square matrices. \(M_{n \times n}(\mathbf{R})\) is also another example. This example is non-commutative. Another structure is a Group. It is a set with one operation usually called “multiplication”. One example is the set of real numbers with just addition. Another example is \((\mathbf{R}^{x})\) (the set of real numbers with zero removed, \(\mathbf{R} - \{0\}\) along with multiplication. \(GL(n,\mathbf{R})\), the set of invertible matrices with multiplication is another example of a Group. This is an example of a non-abelian or non-commutative group. One additional structure that comes up is a Monoid. These are sets with one operation but you don’t have to have inverses like Groups. So \(\mathbf{R}\) with multiplication is not a group because it includes zero and zero doesn’t have an inverse but this set is a Monoid. Groups and Symmetries]]></summary></entry><entry><title type="html">Project Euler: 69 Totient Maximum</title><link href="http://localhost:4000/jekyll/update/2025/01/23/project-euler-69-totient-maximum.html" rel="alternate" type="text/html" title="Project Euler: 69 Totient Maximum" /><published>2025-01-23T00:01:36-08:00</published><updated>2025-01-23T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/23/project-euler-69-totient-maximum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/23/project-euler-69-totient-maximum.html"><![CDATA[<p>I wrote about Euler’s Totient function in <a href="https://strncat.github.io/jekyll/update/2025/01/22/euler-totient.html">here</a>, but to recap, given an integer \(n\), the Totient function \(\phi(n)\) is the number of positive integers not exceeding \(n\) and are relatively prime to \(n\). The goal of this problem is to find  \(n\) such that \(\frac{n}{\phi(n)}\) is maximized.
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>To start, we should definitely make use of the existing formula to compute the Totient function. Given an integer \(n\) and the distinct prime divisors of \(n\),  \(\{p_1,p_2...,p_k\}\), we can compute the Totient function as follows</p>
<div>
	$$
	\begin{align*}
	 \phi(n) = n \prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big).
	\end{align*}
	$$
</div>
<p>Since we’re interested in computing specifically \(\frac{n}{\phi(n)}\) so we get a simplified expression as follows</p>
<div>
	$$
	\begin{align*}
	 \frac{n}{\phi(n)} &amp;= \frac{n}{n\prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big)} \\
	                   &amp;= \frac{1}{\big( 1 - \frac{1}{p_1} \big) \big( 1 - \frac{1}{p_2} \big) ... \big( 1 - \frac{1}{p_k} \big)} \\
					   &amp;= \frac{1}{\big( \frac{p_1 - 1}{p_1} \big) \big( \frac{p_2 - 1}{p_2} \big) ... \big( \frac{p_k - 1}{p_k} \big)}  \\
					   &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1)  }
	\end{align*}
	$$
</div>
<p>Before we can implement the function, we need to generate these distinct prime factors. We implemented this before in <a href="https://strncat.github.io/jekyll/update/2024/12/24/project-euler-03-largest-prime-factor.html">Problem 3</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">prime_factorization</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">factors</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// prime factor 2</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">factors</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// all the other prime factors</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">factors</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// n is prime itself</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">factors</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
Once we have these distinct factors, we can just run this for all integers \(n \leq 1000000\) as follows:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">double</span> <span class="n">max</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">factors</span><span class="p">;</span>
        <span class="n">prime_factorization</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">factors</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">tot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">//printf("%d: ", i);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">factors</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">factors</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//printf("%d, ", *e);</span>
            <span class="n">tot</span> <span class="o">*=</span> <span class="o">*</span><span class="n">e</span> <span class="o">/</span> <span class="p">(</span><span class="o">*</span><span class="n">e</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tot</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">tot</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//printf("tot = %f \n", tot);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"max n = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span></code></pre></figure>

<p>I added one small optimization which didn’t do much and feels unnecessary to skip prime numbers since based on the formula, the solution will never be a prime number.
<br />
<br />
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0069-totient-maximum">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>More Advanced Solution?</b></h4>
<p>while the brute force solution is great (good to practice writing all of these methods), you can see above that the formula</p>
<div>
	$$
	\begin{align*}
	 \frac{n}{\phi(n)} &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1)  }
	\end{align*}
	$$
</div>
<p>is maximized when we have the most distinct prime numbers. So instead we can generate all prime numbers with sieve and then multiply them until we hit the limit \(1,000,000\).
<br />
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=69">Project Euler - 69</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I wrote about Euler’s Totient function in here, but to recap, given an integer \(n\), the Totient function \(\phi(n)\) is the number of positive integers not exceeding \(n\) and are relatively prime to \(n\). The goal of this problem is to find \(n\) such that \(\frac{n}{\phi(n)}\) is maximized. Solution To start, we should definitely make use of the existing formula to compute the Totient function. Given an integer \(n\) and the distinct prime divisors of \(n\), \(\{p_1,p_2...,p_k\}\), we can compute the Totient function as follows $$ \begin{align*} \phi(n) = n \prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big). \end{align*} $$ Since we’re interested in computing specifically \(\frac{n}{\phi(n)}\) so we get a simplified expression as follows $$ \begin{align*} \frac{n}{\phi(n)} &amp;= \frac{n}{n\prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big)} \\ &amp;= \frac{1}{\big( 1 - \frac{1}{p_1} \big) \big( 1 - \frac{1}{p_2} \big) ... \big( 1 - \frac{1}{p_k} \big)} \\ &amp;= \frac{1}{\big( \frac{p_1 - 1}{p_1} \big) \big( \frac{p_2 - 1}{p_2} \big) ... \big( \frac{p_k - 1}{p_k} \big)} \\ &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1) } \end{align*} $$ Before we can implement the function, we need to generate these distinct prime factors. We implemented this before in Problem 3. void prime_factorization(int n, std::set&lt;int&gt;&amp; factors) { // prime factor 2 while (n % 2 == 0) { n /= 2; factors.insert(2); } // all the other prime factors int limit = sqrt(n); for (int i = 3; i &lt;= limit; i += 2) { while (n % i == 0) { factors.insert(i); n /= i; } } // n is prime itself if (n &gt; 2) { factors.insert(n); } } Once we have these distinct factors, we can just run this for all integers \(n \leq 1000000\) as follows: double max = 0.0; int n = 0; for (int i = 1000000; i &gt; 0; i--) { if (!prime[i]) { std::set&lt;int&gt; factors; prime_factorization(i, factors); double tot = 1; //printf("%d: ", i); for (auto e = factors.begin(); e != factors.end(); e++) { //printf("%d, ", *e); tot *= *e / (*e - 1.0); } if (tot &gt; max) { max = tot; n = i; } //printf("tot = %f \n", tot); } } printf("max n = %d\n", n); I added one small optimization which didn’t do much and feels unnecessary to skip prime numbers since based on the formula, the solution will never be a prime number. The entire code is here. More Advanced Solution? while the brute force solution is great (good to practice writing all of these methods), you can see above that the formula $$ \begin{align*} \frac{n}{\phi(n)} &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1) } \end{align*} $$ is maximized when we have the most distinct prime numbers. So instead we can generate all prime numbers with sieve and then multiply them until we hit the limit \(1,000,000\). References Project Euler - 69]]></summary></entry><entry><title type="html">Euler’s Totient Function</title><link href="http://localhost:4000/jekyll/update/2025/01/22/euler-totient.html" rel="alternate" type="text/html" title="Euler’s Totient Function" /><published>2025-01-22T00:01:36-08:00</published><updated>2025-01-22T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/22/euler-totient</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/22/euler-totient.html"><![CDATA[<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Given an integer \(n\). Euler's totient function is a function that counts the positive integers up to \(n\) that are relatively prime to \(n\). It is denoted with \(\phi(n)\).
</div>
<p><br />
Alternatively, it is the the number of integers \(k\) in the range \(1 \leq k \leq n\) for which \(gcd(n,k)=1\). 
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>Take \(n = 9\). The numbers \(1,2,4,5,7\) and \(8\) are relatively prime to \(9\) while \(3,6\) and \(9\) are not. Therefore \(\phi(9) = 6\). 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Computing Euler Totient's Function</b></h4>
<p>One formula that computes Euler’s Totient’s function is the following</p>
<div>
$$
\begin{align*}
\phi(n) = n \prod_{p|n} \big( 1 - \frac{1}{p} \big).
\end{align*}
$$
</div>
<p>where \(p\) is a distinct prime factor of \(n\). For example, for \(9\),</p>
<div>
$$
\begin{align*}
\phi(9) &amp;= 9 \big( 1 - \frac{1}{3} \big) \\
        &amp;= 9 \big( \frac{2}{3} \big) = 6.
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Multiplicative Function</b></h4>
<p>Euler’s Totient’s function is a multiplicative function. This means that if \(m\) and \(n\) are relatively prime, then \(\phi(mn) = \phi(m)(n)\) which makes sense since they won’t share any prime divisors. 
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Wikipedia</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition Given an integer \(n\). Euler's totient function is a function that counts the positive integers up to \(n\) that are relatively prime to \(n\). It is denoted with \(\phi(n)\). Alternatively, it is the the number of integers \(k\) in the range \(1 \leq k \leq n\) for which \(gcd(n,k)=1\). Example Take \(n = 9\). The numbers \(1,2,4,5,7\) and \(8\) are relatively prime to \(9\) while \(3,6\) and \(9\) are not. Therefore \(\phi(9) = 6\). Computing Euler Totient's Function One formula that computes Euler’s Totient’s function is the following $$ \begin{align*} \phi(n) = n \prod_{p|n} \big( 1 - \frac{1}{p} \big). \end{align*} $$ where \(p\) is a distinct prime factor of \(n\). For example, for \(9\), $$ \begin{align*} \phi(9) &amp;= 9 \big( 1 - \frac{1}{3} \big) \\ &amp;= 9 \big( \frac{2}{3} \big) = 6. \end{align*} $$ Multiplicative Function Euler’s Totient’s function is a multiplicative function. This means that if \(m\) and \(n\) are relatively prime, then \(\phi(mn) = \phi(m)(n)\) which makes sense since they won’t share any prime divisors. References Wikipedia]]></summary></entry><entry><title type="html">Project Euler: 33 Digit Cancelling Fractions</title><link href="http://localhost:4000/jekyll/update/2025/01/21/project-euler-33-digit-canceling-fractions.html" rel="alternate" type="text/html" title="Project Euler: 33 Digit Cancelling Fractions" /><published>2025-01-21T00:01:36-08:00</published><updated>2025-01-21T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/21/project-euler-33-digit-canceling-fractions</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/21/project-euler-33-digit-canceling-fractions.html"><![CDATA[<p>The goal of this problem is to find the exact 4 fractions such that</p>
<ul>
	<li>The fraction is less than one in value.</li>
	<li>It contains two digits in the numerator and two digits in the denominator.</li>
	<li>The numerator and denominator have a digit in common.</li>
	<li>If you remove the common digit from both the numerator and the denominator, you'll get a fraction equal to what you get when you simplify the fraction in a proper way. For example, \(49 / 98\) has \(9\) as a common digit. If we remove it, then we'll get \(4/8\) which is the actual value that you would get if you properly divide both the numerator and the denominator by \(49\).</li>
	<li>We should not count trivial examples. For example \(30/50 = 3/5\) is a trivial example.</li>
</ul>
<p>With just the first three conditions, the search space contains at most 1377 fractions. You can use the loop below to see them!
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">den</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">den</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">den</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">den</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">d1</span> <span class="o">||</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">||</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">d1</span> <span class="o">||</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">d2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d / %d with digits %d%d / %d%d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"count = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>Since we have at most \(1377\) cases, then we can easily check all of them. We will ignore trivial cases. For the non-trivial cases like \(49/98\), we will extract the \(4\) digits and save them in different variables. The numerator digits are \(n_1 = 9\) and \(n_2 = 4\). The denominator digits are \(d_1 = 8\) and \(d_2 = 8\). To check if \(\frac{49}{98}\) is equal to \(\frac{4}{8}\), we can check if</p>
<div>
	$$
	\begin{align*}
	 49 \times 8 &amp;= 98 * 4 \\
	 numerator \times d_1 &amp;= denominator \times n_2 
	\end{align*}
	$$
</div>
<p>After we collect all the fractions, we can divide by the greatest common divisor. This is captured in the following code.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">numerator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">den</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">den</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">den</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">den</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="c1">//</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n2</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">||</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">d1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// even if it works, this is a trivial example</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">||</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">d1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// example is 49/98. this will simplify to 4/8</span>
            <span class="c1">// now we want to check if 49/98 == 4/8 which is the same as checking if 49*8 == 98*4</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">den</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">num</span> <span class="o">*</span> <span class="n">d1</span> <span class="o">||</span> <span class="n">den</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">num</span> <span class="o">*</span> <span class="n">d2</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// printf("%d / %d\n", num, den);</span>
                <span class="n">numerator</span> <span class="o">*=</span> <span class="n">num</span><span class="p">;</span>
                <span class="n">denominator</span> <span class="o">*=</span> <span class="n">den</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">gcd</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span><span class="n">denominator</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"denominator = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">denominator</span><span class="o">/</span><span class="n">gcd</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0033-digit-canceling-fractions.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=33">Project Euler - 33</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The goal of this problem is to find the exact 4 fractions such that The fraction is less than one in value. It contains two digits in the numerator and two digits in the denominator. The numerator and denominator have a digit in common. If you remove the common digit from both the numerator and the denominator, you'll get a fraction equal to what you get when you simplify the fraction in a proper way. For example, \(49 / 98\) has \(9\) as a common digit. If we remove it, then we'll get \(4/8\) which is the actual value that you would get if you properly divide both the numerator and the denominator by \(49\). We should not count trivial examples. For example \(30/50 = 3/5\) is a trivial example. With just the first three conditions, the search space contains at most 1377 fractions. You can use the loop below to see them! int count = 0; for (int num = 10; num &lt;= 99; num++) { for (int den = num+1; den &lt;= 99; den++) { int n1 = num % 10; int n2 = num / 10; int d1 = den % 10; int d2 = den / 10; if (n1 == d1 || n1 == d2 || n2 == d1 || n2 == d2) { count++; printf("%d / %d with digits %d%d / %d%d \n", num, den, n2, n1, d2, d1); } } } printf("count = %d\n", count); Solution Since we have at most \(1377\) cases, then we can easily check all of them. We will ignore trivial cases. For the non-trivial cases like \(49/98\), we will extract the \(4\) digits and save them in different variables. The numerator digits are \(n_1 = 9\) and \(n_2 = 4\). The denominator digits are \(d_1 = 8\) and \(d_2 = 8\). To check if \(\frac{49}{98}\) is equal to \(\frac{4}{8}\), we can check if $$ \begin{align*} 49 \times 8 &amp;= 98 * 4 \\ numerator \times d_1 &amp;= denominator \times n_2 \end{align*} $$ After we collect all the fractions, we can divide by the greatest common divisor. This is captured in the following code. int numerator = 1; int denominator = 1; for (int num = 10; num &lt;= 99; num++) { for (int den = num+1; den &lt;= 99; den++) { int n1 = num % 10; int n2 = num / 10; int d1 = den % 10; int d2 = den / 10; // if (n2 == d2 || n1 == d1) { continue; // even if it works, this is a trivial example } if (n1 == d2 || n2 == d1) { // example is 49/98. this will simplify to 4/8 // now we want to check if 49/98 == 4/8 which is the same as checking if 49*8 == 98*4 if (den * n2 == num * d1 || den * n1 == num * d2) { // printf("%d / %d\n", num, den); numerator *= num; denominator *= den; } } } } int gcd = std::gcd(numerator,denominator); printf("denominator = %d\n", denominator/gcd); The entire code is here. References Project Euler - 33]]></summary></entry><entry><title type="html">Project Euler: 02 Even Fibonacci Numbers</title><link href="http://localhost:4000/jekyll/update/2025/01/20/project-euler-02-even-fibonacci-numbers.html" rel="alternate" type="text/html" title="Project Euler: 02 Even Fibonacci Numbers" /><published>2025-01-20T00:01:36-08:00</published><updated>2025-01-20T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/20/project-euler-02-even-fibonacci%20numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/20/project-euler-02-even-fibonacci-numbers.html"><![CDATA[<p>The first few terms of the fibonacci sequence are</p>
<div>
	$$
	\begin{align*}
	1,2,3,5,8,13,21,34,55,89,...
	\end{align*}
	$$
</div>
<p>The goal of this problem is finding the sum of the even-valued terms where the maximum term that we need to consider is at most 4 million.
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>One thing to note immediately is that we’re going to exceed 4 million just with the 35th term! So the simplest solution that just implements the fibonacci recurrence (below) will work.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define N 35 // the 35th term exceeds 4 million
</span><span class="c1">// all fibonacci's terms</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">all</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">void</span> <span class="nf">fibonacci_all</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">all</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">all</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">all</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">35</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">fibonacci_all</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// add only if it's even</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sum = %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span> <span class="c1">// works!</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0002-even-fibonacci-numbers.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=2">Project Euler - 02</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The first few terms of the fibonacci sequence are $$ \begin{align*} 1,2,3,5,8,13,21,34,55,89,... \end{align*} $$ The goal of this problem is finding the sum of the even-valued terms where the maximum term that we need to consider is at most 4 million. Solution One thing to note immediately is that we’re going to exceed 4 million just with the 35th term! So the simplest solution that just implements the fibonacci recurrence (below) will work. #define N 35 // the 35th term exceeds 4 million // all fibonacci's terms unsigned long long all[N] = {0}; void fibonacci_all() { all[0] = 0; all[1] = 1; all[2] = 1; for (int i = 3; i &lt; 35; i++) { all[i] = all[i-1] + all[i-2]; } } int main(int argc, const char * argv[]) { fibonacci_all(); unsigned long long sum = 0; for (int i = 0; i &lt; N; i++) { if (all[i] % 2 == 0) { // add only if it's even sum += all[i]; } } printf("sum = %llu\n", sum); // works! return 0; } The entire code is here. References Project Euler - 02]]></summary></entry><entry><title type="html">Project Euler: 50 Consecutive Prime Sum</title><link href="http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum.html" rel="alternate" type="text/html" title="Project Euler: 50 Consecutive Prime Sum" /><published>2025-01-19T00:01:36-08:00</published><updated>2025-01-19T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum.html"><![CDATA[<p>The prime \(41\), can be written as the sum of six consecutive primes \(2 + 3 + 5 + 7 + 11 + 13\). The goal of this problem is to find the prime below one-million that can be written as the sum of the most consecutive primes. 
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>It took me a few attempts to get this one right. The first few recurrences that I was trying to build didn’t go anywhere and one of them was this two dimensional table that included every sum of the primes between any pair of prime numbers \(i\) and \(j\). But that was too much. After a few more attempts on paper, I noticed one critical pattern that led to a reasonable solution. To see this, write down the first few consecutive sums below</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>Prime</td>
    <td>\(2\)</td>
    <td>\(3\)</td>
    <td>\(5\)</td>
	<td>\(7\)</td>
	<td>\(11\)</td>
	<td>\(13\)</td>
	<td>\(17\)</td>
	<td>\(...\)</td>
  </tr>
  <tr>
    <td>Sum</td>
    <td>\(2\)</td>
    <td>\(5\)</td>
    <td>\(10\)</td>
	<td>\(17\)</td>
	<td>\(28\)</td>
	<td>\(41\)</td>
	<td>\(58\)</td>
	<td>\(...\)</td>
  </tr>
</table>
</div>
<p>Now notice that if we wanted to find the sum of primes between \(3\) and \(11\) not including \(3\), then we can use the table above to see that it is</p>
<div>
	$$
	\begin{align*}
	 sum(11) - sum(3) &amp;= 28 - 5 = 23
	\end{align*}
	$$
</div>
<p>which is exactly the sum of primes \(5 + 7 + 11\). So for any two primes \(i\) and \(j\), the sum of the primes between them (while including \(j\) and not \(i\)) is</p>
<div>
	$$
	\begin{align*}
	 sum(j) - sum(i)
	\end{align*}
	$$
</div>
<p>This idea is crucial. Because all we have to do now is try all prime pairs below 1 million and we’ll get an \(O(n^2)\) algorithm instead of an exponential one. All we need to do is to pre-compute that table with all the sums and then write a double loop to find the prime that can be written as the sum of the most consecutive primes.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">cons_sum</span> <span class="o">=</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">-</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">second</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">cons_sum</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cons_sum</span><span class="p">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
But checking every pair below one million is a lot. Does prime_numbers above need to have all the prime numbers below 1 million? No! Another critical hint to this problem that I completely missed is that the prime we’re trying to find has to be below a million. In fact, the sum of the first \(546\) primes will already exceed a million! Therefore, we can limit the search to a much smaller range of prime numbers.
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prime_numbers</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">consecutive_sums</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">prime_sums</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// fake prime</span>
    <span class="n">consecutive_sums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span>  <span class="mi">546</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c1">// we don't need more than that!</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
Finally, the method to precompute the prime_numbers array is the usual sieve method that we’ve used over and over again before. Adding it below for completion.
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">prime</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0050-consecutive-prime-sum.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=50">Project Euler - 50</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The prime \(41\), can be written as the sum of six consecutive primes \(2 + 3 + 5 + 7 + 11 + 13\). The goal of this problem is to find the prime below one-million that can be written as the sum of the most consecutive primes. Solution It took me a few attempts to get this one right. The first few recurrences that I was trying to build didn’t go anywhere and one of them was this two dimensional table that included every sum of the primes between any pair of prime numbers \(i\) and \(j\). But that was too much. After a few more attempts on paper, I noticed one critical pattern that led to a reasonable solution. To see this, write down the first few consecutive sums below Prime \(2\) \(3\) \(5\) \(7\) \(11\) \(13\) \(17\) \(...\) Sum \(2\) \(5\) \(10\) \(17\) \(28\) \(41\) \(58\) \(...\) Now notice that if we wanted to find the sum of primes between \(3\) and \(11\) not including \(3\), then we can use the table above to see that it is $$ \begin{align*} sum(11) - sum(3) &amp;= 28 - 5 = 23 \end{align*} $$ which is exactly the sum of primes \(5 + 7 + 11\). So for any two primes \(i\) and \(j\), the sum of the primes between them (while including \(j\) and not \(i\)) is $$ \begin{align*} sum(j) - sum(i) \end{align*} $$ This idea is crucial. Because all we have to do now is try all prime pairs below 1 million and we’ll get an \(O(n^2)\) algorithm instead of an exponential one. All we need to do is to pre-compute that table with all the sums and then write a double loop to find the prime that can be written as the sum of the most consecutive primes. int p = 0; int max = 0; for (int i = prime_numbers.size() - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; i; j++) { int first = prime_numbers[i]; int second = prime_numbers[j]; int cons_sum = consecutive_sums[first] - consecutive_sums[second]; if (prime[cons_sum] &amp;&amp; max &lt; abs(i - j)) { p = cons_sum; max = abs(i - j); } } } printf("%d\n", p); But checking every pair below one million is a lot. Does prime_numbers above need to have all the prime numbers below 1 million? No! Another critical hint to this problem that I completely missed is that the prime we’re trying to find has to be below a million. In fact, the sum of the first \(546\) primes will already exceed a million! Therefore, we can limit the search to a much smaller range of prime numbers. std::vector&lt;int&gt; prime_numbers; std::unordered_map&lt;int,int&gt; consecutive_sums; void prime_sums() { int sum = 0; prime_numbers.push_back(0); // fake prime consecutive_sums[0] = 0; for (int i = 0; i &lt; N; i++) { if (prime[i]) { sum += i; prime_numbers.push_back(i); consecutive_sums[i] = sum; if (prime_numbers.size() &gt; 546) { break; // we don't need more than that! } } } } Finally, the method to precompute the prime_numbers array is the usual sieve method that we’ve used over and over again before. Adding it below for completion. int prime[N]; void sieve() { // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { prime[i] = 1; } prime[0] = prime[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (prime[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { prime[i] = 0; } } } } The entire code is here. References Project Euler - 50]]></summary></entry></feed>