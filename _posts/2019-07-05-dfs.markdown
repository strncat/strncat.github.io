---
layout: post
title:  "Depth First Search"
date:   2019-07-05 12:01:36 -0700
categories: jekyll update
mathjax: true
---
<b>0 References</b><br>
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>1 Introduction</b>
<br>
![my photo]({{ site.url }}/assets/dfs/0.png)

Depth first search like breadth first search, is an algorithm used to explore a graph. Let $$G = (V, E)$$ be a graph consisting of $$V$$ vertices and $$E$$ edges and let $$s$$ be the source vertex where we will start the traversal from. Depth first search explores the graph from the root as deep as possible until there are no more vertices to visit and then we resume the search again from a different branch.
<br><br>
It is very useful in depth first search to keep track of the time we first discover the vertex and also to keep track of the time we finished we are processing a vertex (after we look at all its neighbors). This information will help later in topologically sort a graph!
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>2 Data Structures</b>
<br>
To perform a depth first search, we will maintain the following data structures:
<br>
(2) A set or an array that keeps track of the visited nodes. Remember that $$G$$ might contain cycles and so we want to make sure that we explore each node once
<br><br>
(1) A stack. We want to explore the nodes closest to $$s$$ first. Since we're insterested in going as deep as possible, a stack will be the ideal data structures. Note that we can just eliminate the use of an explicit stack and can instead use recursion (implicit stack) as we'll doing in the implementation below.
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>3 Example</b>
<br>
Let's explore the graph above. We will start from $$s$$ and add as soon as we see $$a$$ we'll recursively call $$a$$ again. The start time for $$s$$ is 0 and the start time for $$a$$ is 1.

![my photo]({{ site.url }}/assets/dfs/1.png)

Next we will recursively visit $$c$$, $$e$$ and $$d$$. They will have start times 2, 3 and 4 respectively.

![my photo]({{ site.url }}/assets/dfs/2.png)


At this point, there will be no more vertices to traverse and so node 
$$d$$ is now finished with time 5, followed by $$e$$, $$c$$ and then $$a$$.

![my photo]({{ site.url }}/assets/dfs/3.png)

Finally, we will traverse node $$b$$ with start time 9 and finish time 10. Node $$s$$ will now be done with finish time $$11$$.

![my photo]({{ site.url }}/assets/dfs/4.png)
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>4 Implementation</b>
<br>
{% highlight c++ %}
int dfs(int v, int current_time,
        std::vector<std::vector<int>>& graph,
        std::vector<std::pair<int,int>> &times,
        std::vector<int> &visited) {

    times[v].first = current_time++; // seeing v for the first time
    visited[0] = true;
    for (int i = 0; i < graph[v].size(); i++) {
        int u = graph[v][i];
        if (visited[u] == false) {
            current_time = dfs(u, current_time, graph, times, visited);
            current_time++;
        }
    }
    times[v].second = current_time; // v is done bye forever
    return current_time;
}
{% endhighlight %}
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>6 Running Time</b>
<br>
Similar to the analysis of breadth first search. We visit each vertex once only. That's $$O(V)$$ time. Therefore, we also visit the adjacency list of each vertex at most once and that's $$O(E)$$. Therefore, the total time is $$O(V+E)$$.
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>7 Full Implementation:</b> 
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/depth-first-search
<br>
<br>


