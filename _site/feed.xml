<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-09T08:40:04-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>Hello.</subtitle><entry><title type="html">Patricia Tries</title><link href="http://localhost:4000/jekyll/update/2019/07/08/patricia-trie.html" rel="alternate" type="text/html" title="Patricia Tries" /><published>2019-07-08T12:01:36-07:00</published><updated>2019-07-08T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/08/patricia-trie</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/08/patricia-trie.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs166/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Now that we have seen the &lt;a href=&quot;/jekyll/update/2019/07/06/tries.html&quot;&gt;trie&lt;/a&gt; data structure, we cans see how space inefficient it is. For example in the trie below, we can see how we’re wasting so many pointers to just store a single character in each branch.
&lt;img src=&quot;http://localhost:4000/assets/trie/3.png&quot; width=&quot;100%&quot; /&gt;
So now what if we do the following: any node (with the exception of the root) that has only one child can be merged with its parent. Let’s look at the result.
&lt;img src=&quot;http://localhost:4000/assets/trie/4.png&quot; width=&quot;100%&quot; /&gt;
Looks awesome right? This trie is called a Patricia trie! we basically merge internal nodes that have one child only into their parents to optimize the space needed to store all keys.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Properties of Patricia Tries&lt;/b&gt;
&lt;br /&gt;
Can we upper bound the number of nodes in a Patricia trie? Yes!&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim: the number of nodes in a Patricia trie with &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; words is &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt; nodes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof:&lt;br /&gt;
We know that we have at most &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; nodes that mark the end of a valid word in a patricia trie. Let’s remove all internal nodes so now we have &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; clusters and let’s add the internal nodes one at a time. Each internal node added will combine two clusters together. This will mean there are &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt; internal nodes total. (If not then an internal node will end up having only one child which is a contradiction). Therefore, the total number of nodes is &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Search&lt;/b&gt;
&lt;br /&gt;
S
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
How long does search takes? oh only the length of the key or pattern!! so &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Insert&lt;/b&gt;
&lt;br /&gt;
S
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So insert takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time as well!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
W
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt; 
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References http://web.stanford.edu/class/cs166/ 1 Introduction Now that we have seen the trie data structure, we cans see how space inefficient it is. For example in the trie below, we can see how we’re wasting so many pointers to just store a single character in each branch. So now what if we do the following: any node (with the exception of the root) that has only one child can be merged with its parent. Let’s look at the result. Looks awesome right? This trie is called a Patricia trie! we basically merge internal nodes that have one child only into their parents to optimize the space needed to store all keys. 2 Properties of Patricia Tries Can we upper bound the number of nodes in a Patricia trie? Yes!</summary></entry><entry><title type="html">Suffix Trees</title><link href="http://localhost:4000/jekyll/update/2019/07/08/suffix-trees.html" rel="alternate" type="text/html" title="Suffix Trees" /><published>2019-07-08T12:01:36-07:00</published><updated>2019-07-08T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/08/suffix-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/08/suffix-trees.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Algorithms by Robert Sedgwick and Kevin Wayne
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs166/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Given &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and a string pattern &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. We want to find all the strings that match  &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; time. However, suppose that we now we have &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; patterns, then this approach will take &lt;script type=&quot;math/tex&quot;&gt;O(mr)&lt;/script&gt; time is really slow. In the RMQ notation &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
&lt; %]]&gt;&lt;/script&gt;preprocessing time,  query_time&lt;script type=&quot;math/tex&quot;&gt;&gt;&lt;/script&gt;, this will be &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
&lt;O(1), O(mr)&gt; %]]&gt;&lt;/script&gt;. So how can we make it faster?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 The Trie Data Structure&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/trie/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider.
&lt;br /&gt;
Let’s start with studying some properties of tries:
&lt;br /&gt;&lt;br /&gt;
&amp;lt;&amp;gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &lt;br /&gt;
&amp;lt;&amp;gt; Each node will have &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; pointers or children where &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is the alphabet size. &lt;br /&gt;
&amp;lt;&amp;gt; Edges represent letters. For example, the root node has one edge (&lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;) to the node below.&lt;br /&gt;
&amp;lt;&amp;gt; Each node also has only one parent.&lt;br /&gt;
&lt;br /&gt;
Let’s look at what a trie really looks like:
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/trie/2.png&quot; width=&quot;100%&quot; /&gt;
You can see above, the root has only &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; edge/link. From &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, we can traverse to either &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. From &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; we can add &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; only and from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; we can add &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and so on.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Search&lt;/b&gt;
&lt;br /&gt;
How do we search for a word? We just traverse down the root and keep matching until we reach the last character of the string we’re searching. If the node we’re on has a marker to indicate it ends a word, then we return true. If it’s not or if we reach a null node, then we return false.
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// null pointer&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not found&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// move to the child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
How long does search takes? oh only the length of the key or pattern!! so &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Insert&lt;/b&gt;
&lt;br /&gt;
To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter.
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// word exists&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// increment word count&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;// this letter doesn't exist, create it&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// this letter has a link already, follow it along&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// mark the last node, this is the end of our word&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// this is a marker of an end to a valid word&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So insert takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time as well!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
We mentioned above that insert and search both take &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the length of the pattern. How long does it take to build a trie to represent all words of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;? We need to make &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; insertions each of which will take &lt;script type=&quot;math/tex&quot;&gt;O(&lt;/script&gt;size of each word&lt;script type=&quot;math/tex&quot;&gt;)&lt;/script&gt;. Since the total length of all words is &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;, then the total time is &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; which happens only once intially. Therefore, in the RMQ notation we will have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
&lt;O(m), O(n)&gt; %]]&gt;&lt;/script&gt; which is a lot better than the naive solution. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt; 
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References Algorithms by Robert Sedgwick and Kevin Wayne http://web.stanford.edu/class/cs166/ 1 Introduction Given strings of total length and a string pattern of length . We want to find all the strings that match . The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take time. However, suppose that we now we have patterns, then this approach will take time is really slow. In the RMQ notation preprocessing time, query_time, this will be . So how can we make it faster? 2 The Trie Data Structure The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider. Let’s start with studying some properties of tries: &amp;lt;&amp;gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &amp;lt;&amp;gt; Each node will have pointers or children where is the alphabet size. &amp;lt;&amp;gt; Edges represent letters. For example, the root node has one edge () to the node below. &amp;lt;&amp;gt; Each node also has only one parent. Let’s look at what a trie really looks like: You can see above, the root has only edge/link. From , we can traverse to either or . From we can add or only and from we can add or and so on. 3 Search How do we search for a word? We just traverse down the root and keep matching until we reach the last character of the string we’re searching. If the node we’re on has a marker to indicate it ends a word, then we return true. If it’s not or if we reach a null node, then we return false. int search(std::string word) { long m = word.length(); node *current = root; for (int i = 0; i &amp;lt; m; i++) { int index = word[i] - 'a'; if (!current-&amp;gt;children[index]) { // null pointer return 0; // not found } // move to the child current = current-&amp;gt;children[index]; } return (current != NULL &amp;amp;&amp;amp; current-&amp;gt;value); } How long does search takes? oh only the length of the key or pattern!! so ! 4 Insert To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter. void insert(std::string word) { if (search(word)) { // word exists return; } int length = (int) word.length(); node *current = root; this-&amp;gt;count++; // increment word count for (int i = 0; i &amp;lt; length; i++) { int index = word[i] - 'a'; if (!current-&amp;gt;children[index]) { // this letter doesn't exist, create it current-&amp;gt;children[index] = new node(); } // this letter has a link already, follow it along current = current-&amp;gt;children[index]; } // mark the last node, this is the end of our word // this is a marker of an end to a valid word current-&amp;gt;value = this-&amp;gt;count; } So insert takes time as well! 6 Running Time We mentioned above that insert and search both take time where is the length of the pattern. How long does it take to build a trie to represent all words of total length ? We need to make insertions each of which will take size of each word. Since the total length of all words is , then the total time is which happens only once intially. Therefore, in the RMQ notation we will have which is a lot better than the naive solution. 7 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp</summary></entry><entry><title type="html">Tries</title><link href="http://localhost:4000/jekyll/update/2019/07/06/tries.html" rel="alternate" type="text/html" title="Tries" /><published>2019-07-06T12:01:36-07:00</published><updated>2019-07-06T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/06/tries</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/06/tries.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Algorithms by Robert Sedgwick and Kevin Wayne
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs166/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Consider the following problem: Given &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and a string pattern &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. We want to find all the strings that match  &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; time. However, suppose that we now we have &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; patterns, then this approach will take &lt;script type=&quot;math/tex&quot;&gt;O(mr)&lt;/script&gt; time which is really slow. In the RMQ notation &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
&lt; %]]&gt;&lt;/script&gt;preprocessing time,  query_time&lt;script type=&quot;math/tex&quot;&gt;&gt;&lt;/script&gt;, this will be &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
&lt;O(1), O(mr)&gt; %]]&gt;&lt;/script&gt;. So how can we make it faster?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 The Trie Data Structure&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/trie/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider.
&lt;br /&gt;
Let’s start with studying some properties of tries:
&lt;br /&gt;&lt;br /&gt;
&amp;lt;&amp;gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &lt;br /&gt;
&amp;lt;&amp;gt; Each node will have &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; pointers or children where &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is the alphabet size. &lt;br /&gt;
&amp;lt;&amp;gt; Edges represent letters. For example, the root node has one edge (&lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;) to the node below.&lt;br /&gt;
&amp;lt;&amp;gt; Each node also has only one parent.&lt;br /&gt;
&lt;br /&gt;
Let’s look at what a trie really looks like:
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/trie/2.png&quot; width=&quot;100%&quot; /&gt;
You can see above, the root has only &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; edge/link. From &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, we can traverse to either &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. From &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; we can add &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; only and from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; we can add &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and so on.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Searching for a Prefix&lt;/b&gt;
&lt;br /&gt;
How do we search for a word? We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word.
&lt;br /&gt;
Let’s look at search first:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// null pointer&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not found&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// move to the child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// prefix match: print all possible matches&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;words_with_prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no matches&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// total matches&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// collect matches recursively from all branches&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// save them in q&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue.
&lt;br /&gt;
How long does search takes? oh only the length of the key or pattern!! so &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Insert&lt;/b&gt;
&lt;br /&gt;
To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter.
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// word exists&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// increment word count&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;// this letter doesn't exist, create it&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// this letter has a link already, follow it along&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// mark the last node, this is the end of our word&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// this is a marker of an end to a valid word&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So insert takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time as well!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Running Time&lt;/b&gt;
&lt;br /&gt;
We mentioned above that insert and search both take &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the length of the pattern. How long does it take to build a trie to represent all words of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;? We need to make &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; insertions each of which will take &lt;script type=&quot;math/tex&quot;&gt;O(&lt;/script&gt;size of each word&lt;script type=&quot;math/tex&quot;&gt;)&lt;/script&gt;. Since the total length of all words is &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;, then the total time is &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; which happens only once initially. Therefore, in the RMQ notation we will have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
&lt;O(m), O(n)&gt; %]]&gt;&lt;/script&gt; which is a lot better than the naive solution. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Full Implementation:&lt;/b&gt; 
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References Algorithms by Robert Sedgwick and Kevin Wayne http://web.stanford.edu/class/cs166/ 1 Introduction Consider the following problem: Given strings of total length and a string pattern of length . We want to find all the strings that match . The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take time. However, suppose that we now we have patterns, then this approach will take time which is really slow. In the RMQ notation preprocessing time, query_time, this will be . So how can we make it faster? 2 The Trie Data Structure The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider. Let’s start with studying some properties of tries: &amp;lt;&amp;gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &amp;lt;&amp;gt; Each node will have pointers or children where is the alphabet size. &amp;lt;&amp;gt; Edges represent letters. For example, the root node has one edge () to the node below. &amp;lt;&amp;gt; Each node also has only one parent. Let’s look at what a trie really looks like: You can see above, the root has only edge/link. From , we can traverse to either or . From we can add or only and from we can add or and so on. 3 Searching for a Prefix How do we search for a word? We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word. Let’s look at search first: node* search(std::string word) { long m = word.length(); node *current = root; for (int i = 0; i &amp;lt; m; i++) { int index = word[i] - 'a'; if (!current-&amp;gt;children[index]) { // null pointer return NULL; // not found } // move to the child current = current-&amp;gt;children[index]; } return current; } Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix: // prefix match: print all possible matches int words_with_prefix(std::string prefix) { node *current = search(prefix); if (current == NULL) { return 0; } // no matches std::queue&amp;lt;std::string&amp;gt; q; collect(current, prefix, q); while (!q.empty()) { printf(&quot;%s\n&quot;, q.front().c_str()); q.pop(); } return current-&amp;gt;value; // total matches } Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect: // collect matches recursively from all branches // save them in q void collect(node *current, std::string prefix, std::queue&amp;lt;std::string&amp;gt; &amp;amp;q) { if (current == NULL) { return; } if (current-&amp;gt;marker) { q.push(prefix); } for (int i = 0; i &amp;lt; SIZE; i++) { if (current-&amp;gt;children[i] != NULL) { char c = i + 'a'; collect(current-&amp;gt;children[i], prefix + c, q); } } } Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue. How long does search takes? oh only the length of the key or pattern!! so ! 4 Insert To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter. void insert(std::string word) { if (search(word)) { // word exists return; } int length = (int) word.length(); node *current = root; current-&amp;gt;value++; // increment word count for (int i = 0; i &amp;lt; length; i++) { int index = word[i] - 'a'; if (!current-&amp;gt;children[index]) { // this letter doesn't exist, create it current-&amp;gt;children[index] = new node(); } // this letter has a link already, follow it along current = current-&amp;gt;children[index]; current-&amp;gt;value++; } // mark the last node, this is the end of our word // this is a marker of an end to a valid word current-&amp;gt;marker = true; } So insert takes time as well! 5 Running Time We mentioned above that insert and search both take time where is the length of the pattern. How long does it take to build a trie to represent all words of total length ? We need to make insertions each of which will take size of each word. Since the total length of all words is , then the total time is which happens only once initially. Therefore, in the RMQ notation we will have which is a lot better than the naive solution. 6 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp</summary></entry><entry><title type="html">Depth First Search</title><link href="http://localhost:4000/jekyll/update/2019/07/05/dfs.html" rel="alternate" type="text/html" title="Depth First Search" /><published>2019-07-05T12:01:36-07:00</published><updated>2019-07-05T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/05/dfs</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/05/dfs.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/dfs/0.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Depth first search like breadth first search is an algorithm used to explore a graph. Let &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt; be a graph consisting of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges and let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be the source vertex where we will start the traversal from. Depth first search explores the graph from the root as deep as possible until there are no more vertices to visit and then resumes the search again from a different branch.
&lt;br /&gt;&lt;br /&gt;
In a depth first search, we typically keep track of the time we first discovered a vertex and also the time we finished processing a vertex (after we look at all its neighbors). This information will help later in topologically sorting a graph. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Data Structures&lt;/b&gt;
&lt;br /&gt;
To perform a depth first search, we will maintain the following data structures:
&lt;br /&gt;
(2) A set or an array that keeps track of the visited nodes. Remember that &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; might contain cycles and so we want to make sure that we explore each node once.
&lt;br /&gt;&lt;br /&gt;
(1) A stack. We want to explore the nodes closest to &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; first. Since we’re insterested in going as deep as possible, a stack will be the ideal data structures. Note that we can just eliminate the use of an explicit stack by using recursion (implicit stack) as we’ll be doing in the implementation below.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;
&lt;br /&gt;
Let’s explore the graph above. We will start from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and as soon as we see &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; we’ll recursively call dfs again. The start time for &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is 0 and the start time for &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is 1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dfs/1.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next we will recursively visit &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;. They will have start times 2, 3 and 4 respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dfs/2.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, there will be no more vertices to traverse and so node 
&lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; is now finished with time 5, followed by &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dfs/3.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, we will traverse node &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; with start time 9 and finish time 10. Node &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; will now be done with finish time &lt;script type=&quot;math/tex&quot;&gt;11&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dfs/4.png&quot; alt=&quot;my photo&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Implementation&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// seeing v for the first time&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// v is done bye forever&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
Similar to the analysis of breadth first search. We visit each vertex once only. That’s &lt;script type=&quot;math/tex&quot;&gt;O(V)&lt;/script&gt; time. Therefore, we also visit the adjacency list of each vertex at most once and that’s &lt;script type=&quot;math/tex&quot;&gt;O(E)&lt;/script&gt; time. Therefore, the total time is &lt;script type=&quot;math/tex&quot;&gt;O(V+E)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt;
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/depth-first-search
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction</summary></entry><entry><title type="html">Permuations and Combinations Code Examples</title><link href="http://localhost:4000/jekyll/update/2019/07/03/permutations-combinations.html" rel="alternate" type="text/html" title="Permuations and Combinations Code Examples" /><published>2019-07-03T07:01:36-07:00</published><updated>2019-07-03T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/03/permutations-combinations</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/03/permutations-combinations.html">&lt;p&gt;&lt;b&gt;0 Permutations&lt;/b&gt;&lt;br /&gt;
Say we have an array = [1,2,3] and we would like to permute its elements to generate all possible permutations. In this case we want to print [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1].
&lt;br /&gt;&lt;br /&gt;
The first thing we want to do is select a single number from the three numbers available to us. We can model this with an index that we pass to the permutation function indicating which position we’re working on. In a for loop, we now loop over the numbers/selections/choices available to us (In this case, all three) and place each number in that specific cell. This is what it is going to look like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/competitive-programming/perm1.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next thing thing we want to do is from each iteration after selecting a number/choice, we want to go ahead and select the next number for the next position. In our example above, Suppose we selected 1 to be placed in position 0 (left most branch). Now we can call the function again for position 1 but before doing so, we need to mark our current selection (1) as not availble for the next call since we don’t want to select 1 again for any position that comes after this one.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/competitive-programming/perm2.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see above for the next call with position 1 and choices (2,3), we loop again over the choices and place each choice in position 1. From here, we again call the function again to select the next number for the next position 2. If we focus again on the left most branch, we see that the only choice left for position 2 is 3 only.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/competitive-programming/perm3.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The code below implements this idea:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// suppose a = [1,2,3] and sel = [0,0,0,0] (a simple map)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;generate_numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// we could print a permutation or do anything with it&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not selected yet&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;generate_numbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// make it available for the next iteration&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Of course, there is a library in the standard library which you can use to generate permutions and avoid doing things manually.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// just fill an array with numbers&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// generate permutations, yay!&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// do something&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next_permutation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt; &lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Combinations&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 Permutations Say we have an array = [1,2,3] and we would like to permute its elements to generate all possible permutations. In this case we want to print [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. The first thing we want to do is select a single number from the three numbers available to us. We can model this with an index that we pass to the permutation function indicating which position we’re working on. In a for loop, we now loop over the numbers/selections/choices available to us (In this case, all three) and place each number in that specific cell. This is what it is going to look like:</summary></entry><entry><title type="html">Knapsack</title><link href="http://localhost:4000/jekyll/update/2019/07/02/knapsack.html" rel="alternate" type="text/html" title="Knapsack" /><published>2019-07-02T07:01:36-07:00</published><updated>2019-07-02T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/02/knapsack</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/02/knapsack.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
The Knapsack problem is a classic dynamic programming problem. In this problem, we are given a knapsack of size &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; for some integer &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; and a list of items. Each item &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; has an integer weight &lt;script type=&quot;math/tex&quot;&gt;w_i&lt;/script&gt; and an integer value, &lt;script type=&quot;math/tex&quot;&gt;v_i&lt;/script&gt;. The goal is to maximize the value of the knapsack under the constraint &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt;. There are many variations of the Knapsack problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack in the knapsack. So we either select an item &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; or we don’t. There is also the unbounded knaspack where you have multiple/unbounded copies of each item.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Unbounded Knapsack&lt;/b&gt;&lt;br /&gt;
Let’s focus now on the unbounded knapsack problem and let’s start with an example. Suppose we have an unbounded number of tacos, each of weight 2 and value 4. We also have burritos each of weight 6 and value 17. Suppose now that we have a knapsack of size, &lt;script type=&quot;math/tex&quot;&gt;W=14&lt;/script&gt;. The optimal solution is to pack 2 burritos and 1 taco which will give an optimal value of &lt;script type=&quot;math/tex&quot;&gt;2*17+1*4=38&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.1 How to solve the Knapsack problem?&lt;/b&gt;&lt;br /&gt;
The first thought that comes to mind is to try a greedy approach. Perhaps there is some way to pick the items at each step until the knapsack is filled? One might try a simple greedy algorithm of say always picking the item with the best value/weight ratio. In the example, we’ll pick 2 burritos of value &lt;script type=&quot;math/tex&quot;&gt;2*17=34&lt;/script&gt; which is not an optimal value!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.2 Complete Search&lt;/b&gt;
&lt;br /&gt;
We can also try a complete search of every possible combinations of items. I’m not sure about the thought process here but I was thinking the following should give us an upper bound. For each item &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; with weight &lt;script type=&quot;math/tex&quot;&gt;w_i&lt;/script&gt; and value &lt;script type=&quot;math/tex&quot;&gt;v_i&lt;/script&gt;, we insert &lt;script type=&quot;math/tex&quot;&gt;\lceil W/x_i \rceil&lt;/script&gt; copies of &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; to a new list of items. If we original had &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; items, we could potentially insert &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; items. Give this this list. For each item in the list, we can either select the item to be in the knapsack or not. Therefore, the running time will be &lt;script type=&quot;math/tex&quot;&gt;O(2^{n^2})&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.3 Dynamic Programming&lt;/b&gt;
&lt;br /&gt;
As we saw above, greedy doesn’t work and exhaustive search takes exponential time. It turns out we can do much better with dynamic programming! To use dynamic programming we need to find an optimal substructure. An optimal substructure means that the solution to the problem will contain within it solutions to smaller subproblems. It turns out we have a beautiful optimal substructure for the Knapsack problem.
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;K[x]&lt;/script&gt; be the optimal value for capacity &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We will have the following recursive substructure:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
K[x] = \max_i\{K[x - w_i] + v_i\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, suppose we have unlimited copies of the following &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; items, &lt;script type=&quot;math/tex&quot;&gt;\{\{w_0,v_0\},\{w_1,v_0\},...,\{w_n,v_n\}\}&lt;/script&gt;. Assume now that the optimal solution contains some item &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt;. Then we will see that &lt;script type=&quot;math/tex&quot;&gt;K[x-w_i] = k[x] - v_i&lt;/script&gt;, meaning that the optimal solution for &lt;script type=&quot;math/tex&quot;&gt;K[x]&lt;/script&gt; contains within it optimal solutions to smaller subproblems.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.4 Implementation&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;unbounded_knapsack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// base case, k[0] = 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each weight w&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each item i&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// maybe there is a more effient way?&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// print items&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;(%d %d) &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Optimal value = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.5 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
We claim that our recursive substructure we’ve shown earlier is optimal. 
&lt;br /&gt;
&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
Suppose that we have a knapsack of size &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; and suppose that we have unbounded copies of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; items available to us. Now suppose that we know the optimal value to the knapsack is &lt;script type=&quot;math/tex&quot;&gt;K[W]&lt;/script&gt; and that the optimal solution contains one copy of item &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt; for some natural number &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. We claim that &lt;script type=&quot;math/tex&quot;&gt;K[W] - v_k&lt;/script&gt; is an optimal value for a knapsack of size &lt;script type=&quot;math/tex&quot;&gt;W - x_k&lt;/script&gt;. That is, &lt;script type=&quot;math/tex&quot;&gt;K[W - x_k] = K[W] - v_k&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
We will prove our claim by contradiction. Suppose that &lt;script type=&quot;math/tex&quot;&gt;K[W] - v_k&lt;/script&gt; is not an optimal value and that the optimal value is &lt;script type=&quot;math/tex&quot;&gt;T^{\prime}&lt;/script&gt;. Since we know that the optimal solution to the knapsack of size &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; contains a copy of item &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt;, we can therefore add &lt;script type=&quot;math/tex&quot;&gt;x_k&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;K[W - x_k]&lt;/script&gt; to obtain an optimal value &lt;script type=&quot;math/tex&quot;&gt;T^{\prime} + v_k&lt;/script&gt;. But &lt;script type=&quot;math/tex&quot;&gt;T^{\prime} + v_k &gt;  K[W] - v_k + v_k = K[W]&lt;/script&gt;. This is a contradiction since we assumed that &lt;script type=&quot;math/tex&quot;&gt;K[W]&lt;/script&gt; is an optimal value. Therefore, &lt;script type=&quot;math/tex&quot;&gt;K[W] - v_k&lt;/script&gt; must be an optimal value for a knapsack of size &lt;script type=&quot;math/tex&quot;&gt;W - x_k&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.6 Running Time:&lt;/b&gt; &lt;br /&gt;
Assume we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; items and the knapsack is of size &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt;. The runtime is &lt;script type=&quot;math/tex&quot;&gt;O(nW)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 0/1 Knapsack&lt;/b&gt;&lt;br /&gt;
Let’s focus now on the 0/1 knapsack problem and let’s start with an example. Suppose we have a taco of weight 3 and value 10. We also a burrito of weight 6 and value 14 and a enchilada of weight 5 and value 11. Suppose now that we have a knapsack of size, &lt;script type=&quot;math/tex&quot;&gt;W=9&lt;/script&gt;. The optimal solution is to pack a taco and an enchilada for a total value of 27.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3.1 Solutions? Complete Search&lt;/b&gt;&lt;br /&gt;
A greedy approach won’t work similar to the unbounded knapsack. We can instead do an exhaustive search. We can check every possible combination of the items we have. We will have 2 choices for each item. We either select the item or we don’t. Therefore, we have &lt;script type=&quot;math/tex&quot;&gt;2^n&lt;/script&gt; possible subsets to check and the running time is &lt;script type=&quot;math/tex&quot;&gt;O(2^n)&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3.2 Dynamic Programming&lt;/b&gt;
&lt;br /&gt;
Unfortunately we can’t use the same recursive substructure in the unbounded knapsack above. In this problem, we need to also keep track of which items are available at each step since some might have been taken. So if the smaller subproblem is using an item &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, the larger problem must know not to re-take it which is a violation to the constraint of having one copy only per item.
&lt;br /&gt;
&lt;br /&gt;
Therefore, our subproblems must track both the size of the knapsack and the items allowed so far and therefore, we need a two dimensional table! we’ll let &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; to indicate the knapsack size and &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; to indicate that we’re using the first &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; items.
&lt;br /&gt;
&lt;br /&gt;
Suppose we know the optimal solution to &lt;script type=&quot;math/tex&quot;&gt;K[x,y]&lt;/script&gt; for a knapsack of size &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; using items &lt;script type=&quot;math/tex&quot;&gt;0,..y&lt;/script&gt;.
&lt;br /&gt;
There are two cases:
&lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;K[x,y]&lt;/script&gt; does not use item &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;. In this case, &lt;script type=&quot;math/tex&quot;&gt;K[x,y] = K[x,y-1]&lt;/script&gt;.
&lt;br /&gt;
Case 2: We do use item &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;. In this case, we claim that &lt;script type=&quot;math/tex&quot;&gt;K[x,y] = K[x-w_y,y-1] + y_k&lt;/script&gt;.
&lt;br /&gt;
We can therefore, summarize it in:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
K[x,y] = \max\{K[x, y-1], K[x - w_y, y-1] + v_y\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;With the base case of &lt;script type=&quot;math/tex&quot;&gt;K[x,0]=0&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;K[0,y]=0&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3.3 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
The proof is very similar to the structure of our earlier proof to the unbounded knapsack problem. If we can have a better solution to the subproblem then we can have even a better solution to the optimal solution to the larger problem which is a contradiction. I might write it later?.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3.3 Implementation&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;knapsack_01&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// base case k[0][j] = 0, K[i][0] = 0&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each weight w&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each item i:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// case 1: item i is not in the optimal solution&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// case 2: item i is in the optimal solution&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// print items&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur_w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cur_v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;res&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur_v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cur_w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cur_v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;cur_w&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Optimal value = %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()]);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;K&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;W&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Full Implementation:&lt;/b&gt; &lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/knapsack.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction The Knapsack problem is a classic dynamic programming problem. In this problem, we are given a knapsack of size for some integer and a list of items. Each item has an integer weight and an integer value, . The goal is to maximize the value of the knapsack under the constraint . There are many variations of the Knapsack problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack in the knapsack. So we either select an item or we don’t. There is also the unbounded knaspack where you have multiple/unbounded copies of each item. 2 Unbounded Knapsack Let’s focus now on the unbounded knapsack problem and let’s start with an example. Suppose we have an unbounded number of tacos, each of weight 2 and value 4. We also have burritos each of weight 6 and value 17. Suppose now that we have a knapsack of size, . The optimal solution is to pack 2 burritos and 1 taco which will give an optimal value of . 2.1 How to solve the Knapsack problem? The first thought that comes to mind is to try a greedy approach. Perhaps there is some way to pick the items at each step until the knapsack is filled? One might try a simple greedy algorithm of say always picking the item with the best value/weight ratio. In the example, we’ll pick 2 burritos of value which is not an optimal value! 2.2 Complete Search We can also try a complete search of every possible combinations of items. I’m not sure about the thought process here but I was thinking the following should give us an upper bound. For each item with weight and value , we insert copies of to a new list of items. If we original had items, we could potentially insert items. Give this this list. For each item in the list, we can either select the item to be in the knapsack or not. Therefore, the running time will be . 2.3 Dynamic Programming As we saw above, greedy doesn’t work and exhaustive search takes exponential time. It turns out we can do much better with dynamic programming! To use dynamic programming we need to find an optimal substructure. An optimal substructure means that the solution to the problem will contain within it solutions to smaller subproblems. It turns out we have a beautiful optimal substructure for the Knapsack problem. Let be the optimal value for capacity . We will have the following recursive substructure: $$ \begin{align*} K[x] = \max_i\{K[x - w_i] + v_i\} \end{align*} $$ In other words, suppose we have unlimited copies of the following items, . Assume now that the optimal solution contains some item . Then we will see that , meaning that the optimal solution for contains within it optimal solutions to smaller subproblems. 2.4 Implementation typedef struct item { int w; int v; item(int weight, int value) { w = weight; v = value; } } item; int unbounded_knapsack(std::vector&amp;lt;item&amp;gt; &amp;amp;bag, int W) { std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; items; std::vector&amp;lt;int&amp;gt; K; for (int i = 0; i &amp;lt;= W; i++) { K.push_back(0); items.push_back(std::vector&amp;lt;int&amp;gt;()); } // base case, k[0] = 0 for (int w = 1; w &amp;lt;= W; w++) { // for each weight w for (int i = 0; i &amp;lt; bag.size(); i++) { // for each item i if (bag[i].w &amp;lt;= w &amp;amp;&amp;amp; bag[i].v + K[w - bag[i].w] &amp;gt; K[w]) { // maybe there is a more effient way? items[w].clear(); items[w].push_back(i); items[w].insert(items[w].end(), items[w-bag[i].w].begin(), items[w-bag[i].w].end()); K[w] = bag[i].v + K[w - bag[i].w]; } } } // print items for (int i = 0; i &amp;lt; items[W].size(); i++) { printf(&quot;(%d %d) &quot;, bag[items[W][i]].w, bag[items[W][i]].v); } printf(&quot;\n&quot;); printf(&quot;Optimal value = %d\n&quot;, K[W]); return K[W]; } 2.5 Proof of Correctness We claim that our recursive substructure we’ve shown earlier is optimal. Proof: Suppose that we have a knapsack of size and suppose that we have unbounded copies of items available to us. Now suppose that we know the optimal value to the knapsack is and that the optimal solution contains one copy of item for some natural number . We claim that is an optimal value for a knapsack of size . That is, . We will prove our claim by contradiction. Suppose that is not an optimal value and that the optimal value is . Since we know that the optimal solution to the knapsack of size contains a copy of item , we can therefore add to to obtain an optimal value . But . This is a contradiction since we assumed that is an optimal value. Therefore, must be an optimal value for a knapsack of size . 2.6 Running Time: Assume we have items and the knapsack is of size . The runtime is . 3 0/1 Knapsack Let’s focus now on the 0/1 knapsack problem and let’s start with an example. Suppose we have a taco of weight 3 and value 10. We also a burrito of weight 6 and value 14 and a enchilada of weight 5 and value 11. Suppose now that we have a knapsack of size, . The optimal solution is to pack a taco and an enchilada for a total value of 27. 3.1 Solutions? Complete Search A greedy approach won’t work similar to the unbounded knapsack. We can instead do an exhaustive search. We can check every possible combination of the items we have. We will have 2 choices for each item. We either select the item or we don’t. Therefore, we have possible subsets to check and the running time is . 3.2 Dynamic Programming Unfortunately we can’t use the same recursive substructure in the unbounded knapsack above. In this problem, we need to also keep track of which items are available at each step since some might have been taken. So if the smaller subproblem is using an item , the larger problem must know not to re-take it which is a violation to the constraint of having one copy only per item. Therefore, our subproblems must track both the size of the knapsack and the items allowed so far and therefore, we need a two dimensional table! we’ll let to indicate the knapsack size and to indicate that we’re using the first items. Suppose we know the optimal solution to for a knapsack of size using items . There are two cases: Case 1: does not use item . In this case, . Case 2: We do use item . In this case, we claim that . We can therefore, summarize it in: $$ \begin{align*} K[x,y] = \max\{K[x, y-1], K[x - w_y, y-1] + v_y\} \end{align*} $$ With the base case of and . 3.3 Proof of Correctness The proof is very similar to the structure of our earlier proof to the unbounded knapsack problem. If we can have a better solution to the subproblem then we can have even a better solution to the optimal solution to the larger problem which is a contradiction. I might write it later?. 3.3 Implementation int knapsack_01(std::vector&amp;lt;item&amp;gt; &amp;amp;bag, int W) { int K[100][100] = {0}; // base case k[0][j] = 0, K[i][0] = 0 for (int w = 1; w &amp;lt;= W; w++) { // for each weight w for (int i = 1; i &amp;lt;= bag.size(); i++) { // for each item i: // case 1: item i is not in the optimal solution K[w][i] = K[w][i-1]; // case 2: item i is in the optimal solution if (bag[i-1].w &amp;lt;= w &amp;amp;&amp;amp; bag[i-1].v + K[w - bag[i-1].w][i-1] &amp;gt; K[w][i]) { K[w][i] = bag[i-1].v + K[w - bag[i-1].w][i-1]; } } } // print items int res = K[W][bag.size()]; printf(&quot;%d\n&quot;, res); int cur_w = W; int cur_v = K[W][bag.size()]; for (int i = (int)bag.size(); i &amp;gt; 0 &amp;amp;&amp;amp; res &amp;gt; 0; i--) { if (cur_v != K[cur_w][i-1]) { printf(&quot;%d %d\n&quot;, bag[i-1].w, bag[i-1].v); cur_v -= bag[i-1].v; cur_w -= bag[i-1].w; } } printf(&quot;\n&quot;); printf(&quot;Optimal value = %d\n&quot;, K[W][bag.size()]); return K[W][bag.size()]; } 6 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/knapsack.cpp</summary></entry><entry><title type="html">Greedy: Maximum Activity Selection</title><link href="http://localhost:4000/jekyll/update/2019/07/01/activity-selection.html" rel="alternate" type="text/html" title="Greedy: Maximum Activity Selection" /><published>2019-07-01T07:01:36-07:00</published><updated>2019-07-01T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/01/activity-selection</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/01/activity-selection.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
Problems with greedy solutions might have really simple and straight forward solutions however they are really hard to reason about and therefore, greedy algorithms are generally taught toward the end of an algorithms class. One the of classic problems with greedy solutions is the activity selection problem. In this problem we are given a list of activities, each with a start time &lt;script type=&quot;math/tex&quot;&gt;t_i&lt;/script&gt; and a finish time &lt;script type=&quot;math/tex&quot;&gt;f_i&lt;/script&gt; and we would like to pick activities such that the total number of activities is maximized with the constraint that no two activities can overlap.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Greedy Solution&lt;/b&gt;&lt;br /&gt;
As we said earlier, typically greedy solutions are super straight forward and easy. For the activity selection problem, one approach that works is to simply select the activiy with the earliest finish time at each step until we run out of activities.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;&lt;br /&gt;
Suppose we have the following activities:
&lt;img src=&quot;http://localhost:4000/assets/activities.png&quot; alt=&quot;my photo&quot; /&gt;
Based on our solution, we will pick &lt;script type=&quot;math/tex&quot;&gt;A1&lt;/script&gt; first. We will skip &lt;script type=&quot;math/tex&quot;&gt;A2&lt;/script&gt; since it violates the condition of not having overlapped activities. We will then go on to pick &lt;script type=&quot;math/tex&quot;&gt;A3&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;A5&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;A6&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Algorithm&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// re-do it again&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;select_maximum_activities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;custom_sort_by_finish_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;act&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;act&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finish_time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;act&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
This is the most interesting part of any greedy algorithm! why does it work? To prove the correctness of greedy algorithms, we want to prove that as we select activities, we are &lt;b&gt; not ruling out &lt;/b&gt; the optimal solution. So each decision we make doesn’t affect the our ability of reaching out an optimal solution, which means that at the end we must have an optimal solution.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Now, this should sound very familiar, we have a base case where we start with an empty set of activities and then we want to prove that each selection we make doesn’t rule out an optimal solution. What proof method should we use? of course, Induction.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Proof By Induction:&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;Inductive Hypothesis: &lt;/b&gt; After adding the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th activity, there is an optimal solution that extends our current solution.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case:&lt;/b&gt; When we add the zero’th activity, there exists an optimal solution that extends the current solution which contains no activities yet.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Inductive Step:&lt;/b&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; be a natural number and suppose we’re about to add the &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;‘th activity and that our inductive hypothesis holds for &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt;, meaning that we didn’t rule out an optimal solution yet and that there is some optimal solution &lt;script type=&quot;math/tex&quot;&gt;T^*&lt;/script&gt; that extends the &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt; choices we’ve made so far. We’re about to select our &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;‘th activity. 
&lt;br /&gt;&lt;br /&gt;
Our greedy algorithm picks the next activity with the earliest finish time such that it doesn’t overlap with any of the &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt; activities we’ve selected so far. Let our selection be &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; for some natural number &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt;. There are two cases &lt;br /&gt;&lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; is in the optimal solution so &lt;script type=&quot;math/tex&quot;&gt;a_j \in T^*&lt;/script&gt;. yay, we didn’t rule out the optimal solution and we’re done! &lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; is not in the optimal solution so &lt;script type=&quot;math/tex&quot;&gt;a_j \not\in T^*&lt;/script&gt;. In this case, some other activity was selected instead of &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt;. Let that activity be &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt;. Let’s consider swapping &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt; to create a new set of activities, &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
We claim that &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; is allowed and optimal. First, we know that &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; has a smaller finish than &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt; because our greedy algorithm selects the activity with the earliest finish time. Therefore, &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; doesn’t conflict with anything chosen after &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt;. From this we see that &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; also has the same number of activities as &lt;script type=&quot;math/tex&quot;&gt;T^*&lt;/script&gt; and therefore, we can conclude that &lt;script type=&quot;math/tex&quot;&gt;T^*&lt;/script&gt; is optimal.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Conclusion:&lt;/b&gt;
After adding the last activity, we will have an optimal solution that extends our current choices. Our current choices or solution is the only solution that extends the current solution and therefore, our current solution is optimal. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time:&lt;/b&gt; &lt;br /&gt;
If we need to sorted then it will be &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;. If it’s sorted then we’re only doing a linear scan of activities and therefore, the running time is &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Detailed Implementation:&lt;/b&gt; &lt;br /&gt;
-
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction Problems with greedy solutions might have really simple and straight forward solutions however they are really hard to reason about and therefore, greedy algorithms are generally taught toward the end of an algorithms class. One the of classic problems with greedy solutions is the activity selection problem. In this problem we are given a list of activities, each with a start time and a finish time and we would like to pick activities such that the total number of activities is maximized with the constraint that no two activities can overlap. 2 Greedy Solution As we said earlier, typically greedy solutions are super straight forward and easy. For the activity selection problem, one approach that works is to simply select the activiy with the earliest finish time at each step until we run out of activities. 3 Example Suppose we have the following activities: Based on our solution, we will pick first. We will skip since it violates the condition of not having overlapped activities. We will then go on to pick , and . 4 Algorithm // re-do it again std::vector&amp;lt;activity&amp;gt; select_maximum_activities(std::vector&amp;lt;activity&amp;gt; a) { std::sort(a.begin(), a.end(), custom_sort_by_finish_time); std::vector&amp;lt;activity&amp;gt; picked; for act in a { if act.start_time &amp;gt;= last picked activity.finish_time { picked.push_back(act); } } return picked } 5 Proof of Correctness This is the most interesting part of any greedy algorithm! why does it work? To prove the correctness of greedy algorithms, we want to prove that as we select activities, we are not ruling out the optimal solution. So each decision we make doesn’t affect the our ability of reaching out an optimal solution, which means that at the end we must have an optimal solution.</summary></entry><entry><title type="html">Longest Increasing Subsequence</title><link href="http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html" rel="alternate" type="text/html" title="Longest Increasing Subsequence" /><published>2019-06-25T12:01:36-07:00</published><updated>2019-06-25T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;A = [a_0, a_1, a_2,...,a_n]&lt;/script&gt; be an array containing &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; real numbers. A longest increasing subsequence of A is a sequence &lt;script type=&quot;math/tex&quot;&gt;0 \leq i_0 \leq i_1 \leq ... \leq i_k \leq n&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;A[i_i] \leq A[i_2] \leq ... \leq A[i_k]&lt;/script&gt; so that &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is of maximum value.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;2 Example&lt;/b&gt;
&lt;br /&gt;
Suppose &lt;script type=&quot;math/tex&quot;&gt;A = [3, 8, 1, 2, 7, 9, 6, 4, 5]&lt;/script&gt; then a longest increasing subsequence could be &lt;script type=&quot;math/tex&quot;&gt;[1, 2, 4, 5]&lt;/script&gt;. Note that it is not unique.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;3 The Brute Force Solution&lt;/b&gt;
&lt;br /&gt;
We can check every possible subsequence. For each element of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;, we either select that element or not. Therefore, the total number of possible subsequences is &lt;script type=&quot;math/tex&quot;&gt;2^n&lt;/script&gt;. As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is &lt;script type=&quot;math/tex&quot;&gt;O(2^n)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;4 Dynamic Programming and the Optimal Substructure&lt;/b&gt;
&lt;br /&gt;
To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS).&lt;br /&gt;
&lt;br /&gt;
It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let &lt;script type=&quot;math/tex&quot;&gt;D[i]&lt;/script&gt; be the length of the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;, then we will find that&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
D[i] = 1 + \max({D[k] : k &amp;lt; i \text{ and } A[k] &amp;lt; A[i]})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; can be found by looking at all &lt;script type=&quot;math/tex&quot;&gt;D[k]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i %]]&gt;&lt;/script&gt; (meaning that &lt;script type=&quot;math/tex&quot;&gt;A[k]&lt;/script&gt; comes before &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;) and &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; A[k]&lt;/script&gt; (meaning that &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; can extend the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[k]&lt;/script&gt;). We then take the maximum value of &lt;script type=&quot;math/tex&quot;&gt;D[k]&lt;/script&gt;, 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof:&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; be a natural number and let &lt;script type=&quot;math/tex&quot;&gt;D[i]&lt;/script&gt; be the length of the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Consider the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i + 1]&lt;/script&gt;. We have two cases:
&lt;br /&gt;
&lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is the smallest element in &lt;script type=&quot;math/tex&quot;&gt;A[0...i+1]&lt;/script&gt;. Therefore, the length of the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is 1.
&lt;br /&gt;
&lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is not the smallest element in &lt;script type=&quot;math/tex&quot;&gt;A[0...i+1]&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; be a natural number where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i+1 %]]&gt;&lt;/script&gt;. This means that we can use &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; to extend the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[k]&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[k] &lt; A[i + 1] %]]&gt;&lt;/script&gt;. Since we are searching for the longest increasing subsequence then we take the maximum value for all possible &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i + 1 %]]&gt;&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;D[i+1]&lt;/script&gt; is the maximum value plus 1 as defined above.
&lt;br /&gt;
&lt;br /&gt;
We claim that &lt;script type=&quot;math/tex&quot;&gt;D[i+1]&lt;/script&gt; is the length of longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt;. Suppose it wasn’t and that the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;m &gt; D[i+1]&lt;/script&gt;. By our definition, we know that &lt;script type=&quot;math/tex&quot;&gt;D[i+1] = D[k] + 1&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;D[k]&lt;/script&gt; is the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i+1 %]]&gt;&lt;/script&gt;. This means that &lt;script type=&quot;math/tex&quot;&gt;m &gt; D[k]+1&lt;/script&gt; but this is not possible since we’re only adding &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; to the subsequence. Therefore, &lt;script type=&quot;math/tex&quot;&gt;D[i+1]&lt;/script&gt; is optimal.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;3 The &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; Implementation&lt;/b&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;longest_increasing_subsequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// maximum subsequence ending at a[i] is initially 1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// parent array&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// for element a[i], check all the previous subsequences where i &amp;lt; j&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// and see if a[i] can extend any of them&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// I can extend the subsequence&lt;/span&gt;
	            &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// used for reconstructing the subsequence&lt;/span&gt;
	        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// maximum subsequence so far&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Running Time:&lt;/b&gt; 
&lt;br /&gt;
We’re doing two simple loops to fill arrays &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. Therefore, our runtime is just &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Example:&lt;/b&gt; 
&lt;br /&gt;
Initially we start with arrays &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;:
Consider again &lt;script type=&quot;math/tex&quot;&gt;A = [3, 8, 1, 2, 7, 9, 6, 4, 5]&lt;/script&gt;. We initialize &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;D = [1, 1, 1, 1, 1, 1, 1, 1, 1]&lt;/script&gt; representing the initial length of the subsequence ending at each possible &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Iteration &lt;script type=&quot;math/tex&quot;&gt;i = 1&lt;/script&gt;. We look at &lt;script type=&quot;math/tex&quot;&gt;A[1] = 8&lt;/script&gt;. We have &lt;script type=&quot;math/tex&quot;&gt;D[1]=1&lt;/script&gt; and so the subsequence is just &lt;script type=&quot;math/tex&quot;&gt;\{8\}&lt;/script&gt;. Can 8 extend any previous subsequences? We look at &lt;script type=&quot;math/tex&quot;&gt;j = 0&lt;/script&gt; and in that case, we see that &lt;script type=&quot;math/tex&quot;&gt;A[1] &gt; A[0]&lt;/script&gt;, meaning that that the subsequence can now include 3 and become &lt;script type=&quot;math/tex&quot;&gt;\{3, 8\}&lt;/script&gt;. And so now we have:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Iteration &lt;script type=&quot;math/tex&quot;&gt;i = 2&lt;/script&gt;. We look at &lt;script type=&quot;math/tex&quot;&gt;A[2] = 1&lt;/script&gt;. We have &lt;script type=&quot;math/tex&quot;&gt;D[2]=1&lt;/script&gt; and so the subsequence is just &lt;script type=&quot;math/tex&quot;&gt;\{1\}&lt;/script&gt;. Can 4 extend any previous subsequences? We need to look at &lt;script type=&quot;math/tex&quot;&gt;j = 0&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;j = 1&lt;/script&gt;. It turns out that 1 will not be able to extend either subsequence.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
We continue doing so until we reach the end and we have:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$
&lt;/div&gt;
&lt;p&gt;This means that the longest subsequence ends at element 9 or 5. We can then &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; to construct the subsequence. One possible construction will generate: &lt;script type=&quot;math/tex&quot;&gt;[1, 2, 7, 9]&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 The O(nlg(n)) Solution with Binary Search:&lt;/b&gt; 
&lt;br /&gt;
The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes!
&lt;br /&gt;&lt;br /&gt;
Previously, we said that &lt;script type=&quot;math/tex&quot;&gt;D[i]&lt;/script&gt; is the length of the longest subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Now we will consider a completely different substructure. Let &lt;script type=&quot;math/tex&quot;&gt;M[i]&lt;/script&gt; to be the smallest element that ends a subsequence of length &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. For simplicity we will initially let &lt;script type=&quot;math/tex&quot;&gt;M[0]&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;-\infty&lt;/script&gt; and everything else to be &lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;. 
&lt;br /&gt;&lt;br /&gt;
Let’s take the same example where &lt;script type=&quot;math/tex&quot;&gt;A = [3, 8, 1, 2, 7, 9, 6, 4, 5]&lt;/script&gt;. In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;[-\infty, 1, 2, 4, 5, \infty, \infty, \infty, \infty]&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; must be sorted because this will help us later on. To prove that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted, we will prove that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is a strictly increasing array and that for any &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
M[k] &lt; M[k+1] %]]&gt;&lt;/script&gt;. (We will ignore the placeholder &lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;’s otherwise the proof would not work)
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim: M is a strictly increasing array&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;b&gt;Proof:&lt;/b&gt;&lt;br /&gt;
Suppose it is not and that there exists some &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; where either &lt;script type=&quot;math/tex&quot;&gt;M[j] = M[j+1]&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;M[j] &gt; M[j+1]&lt;/script&gt;. We will prove neither case is possible.
&lt;br /&gt;&lt;br /&gt;
First, suppose that &lt;script type=&quot;math/tex&quot;&gt;M[j] = M[j+1]&lt;/script&gt; then this means that we have two strictly increasing subsequences that end in &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt;. Let the first subsequence be &lt;script type=&quot;math/tex&quot;&gt;\{a_1, a_2,...a_n,M[j]\}&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; and let the second subsequence be &lt;script type=&quot;math/tex&quot;&gt;\{b_1,b_2,..,b_m,M[j]\}&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;j+1&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;m = n + 1&lt;/script&gt;. Since this is a strictly increasing subsequence, we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b_m &lt; M[j] %]]&gt;&lt;/script&gt;. This is a contradiction because by assumption we know that &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; is the smallest element that ends a subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; but we just showed that there exists a subsequence, namely, &lt;script type=&quot;math/tex&quot;&gt;\{b_1,b_2,..,b_m\}&lt;/script&gt;, of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that ends with a smaller element, &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b_m &lt; M[j] %]]&gt;&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Next, suppose that &lt;script type=&quot;math/tex&quot;&gt;M[j] &gt; M[j+1]&lt;/script&gt;. This is a contradiction for the same reasons above. Let &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; be the subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that ends with &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; and if we let &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; the subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j+1&lt;/script&gt; that ends with M[j+1]. Since subsequences are strictly increasing then we can extract all the elements from &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; except for &lt;script type=&quot;math/tex&quot;&gt;M[j+1]&lt;/script&gt;. This new sequence ends with an element strictly less than &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; and therefore, we arrive at the same contradiction and conclude that it is not possible.
&lt;br /&gt;&lt;br /&gt;
Therefore, we can conclude that we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
M[k] &lt; M[k+1] %]]&gt;&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; as we wanted to show.
&lt;!-- --&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;Algorithm:&lt;/b&gt;&lt;br /&gt;
Let’s traverse &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; from left to right. For the base case, we consider &lt;script type=&quot;math/tex&quot;&gt;i = 0&lt;/script&gt; and at this point we know that &lt;script type=&quot;math/tex&quot;&gt;A[0] &gt; -\infty&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;M[1] = A[0]&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Now let’s consider iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Also, let &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; be the length of the longest subsequence reached so far, meaning that &lt;script type=&quot;math/tex&quot;&gt;M[k] \neq \infty&lt;/script&gt; and for any &lt;script type=&quot;math/tex&quot;&gt;j &gt; k&lt;/script&gt; we have &lt;script type=&quot;math/tex&quot;&gt;M[j] = \infty&lt;/script&gt;. Let’s consider two cases:
&lt;br /&gt;&lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[k]&lt;/script&gt;. In this case, we see that it is possible to extend the subsequence ending with element &lt;script type=&quot;math/tex&quot;&gt;M[k]&lt;/script&gt; because &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; is greater, yay! Now we can set &lt;script type=&quot;math/tex&quot;&gt;M[k+1] = A[i]&lt;/script&gt; and we are done. (But why? don’t we need to check previous subsequences in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;? No. Proof: We established previously that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted and so if &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[k]&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[j]&lt;/script&gt; for &lt;script type=&quot;math/tex&quot;&gt;j \leq k&lt;/script&gt;. This means that &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; is not a possible candidate for replacing any of the previous elements because &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; holds ONLY the minimum possible elements that end each subsequence.)
&lt;br /&gt;&lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[i] &lt; M[k] %]]&gt;&lt;/script&gt;. This one is tricky. In this case &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; can’t extend the current subsequence of length &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; but it can potentially be a better candidate for ending some subsequence of length &lt;script type=&quot;math/tex&quot;&gt;1,...,k&lt;/script&gt;. Recall that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted and is a strictly increasing array. Let &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; be natural number where &lt;script type=&quot;math/tex&quot;&gt;j \leq k&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; is the smallest element such that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[i] &lt; M[j] %]]&gt;&lt;/script&gt;. (Note that it might be that &lt;script type=&quot;math/tex&quot;&gt;j = k&lt;/script&gt;). By our construction, this means that &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[j-1]&lt;/script&gt;. (Note that it might be that j-1 = 0). This means that we can take the subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j-1&lt;/script&gt; ending with &lt;script type=&quot;math/tex&quot;&gt;M[j-1]&lt;/script&gt; and extend it with &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;, making a new subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that has a smaller ending value than the one ending with &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt;! (we’re basically replacing the subsequence ending with M[j] with the new subsequence consisting of what we have already in &lt;script type=&quot;math/tex&quot;&gt;M[j-1]&lt;/script&gt; plus &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;). How do we find such an index &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
M[j-1] &lt; A[i] &lt; M[j] %]]&gt;&lt;/script&gt;? This is where binary search comes in! since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted, we can find this position in just &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Could we replace the end of any other subsequence? No. Even though &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[i] &lt; M[j] %]]&gt;&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;j..k&lt;/script&gt;, only &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; can be replaced because &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[j-1]&lt;/script&gt;. Any subsequence of length greater than &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; already has more elements than just &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; so &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; could not end these subsequences. (more formal?)
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;3 The &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; Implementation&lt;/b&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;longest_increasing_subsequence_fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// O(nlogn)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// keeps track of the length of the longest &lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// increasing subsequence found so far&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// in each iteration either a[i] &amp;gt; a[k] meaning we can &lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// extend the subsequence&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// or a[i] &amp;lt; a[k] meaning we can update one of the previous &lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// subsequences to a better subsequence ending &lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// just a binary search&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Full Implementation: &lt;/b&gt;&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/longest-increasing-subsequence.cpp&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;References: &lt;/b&gt;&lt;br /&gt;
These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html and CLRS.&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction Let be an array containing real numbers. A longest increasing subsequence of A is a sequence such that so that is of maximum value. 2 Example Suppose then a longest increasing subsequence could be . Note that it is not unique. 3 The Brute Force Solution We can check every possible subsequence. For each element of , we either select that element or not. Therefore, the total number of possible subsequences is . As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is . 4 Dynamic Programming and the Optimal Substructure To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS). It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let be the length of the longest increasing subsequence ending at , then we will find that $$ \begin{align*} D[i] = 1 + \max({D[k] : k &amp;lt; i \text{ and } A[k] &amp;lt; A[i]}) \end{align*} $$ In other words, the longest increasing subsequence ending at can be found by looking at all where (meaning that comes before ) and (meaning that can extend the subsequence ending at ). We then take the maximum value of , Proof: Let be a natural number and let be the length of the longest increasing subsequence ending at . Consider the subsequence ending at . We have two cases: Case 1: is the smallest element in . Therefore, the length of the subsequence ending at is 1. Case 2: is not the smallest element in . Let be a natural number where . This means that we can use to extend the subsequence ending at if . Since we are searching for the longest increasing subsequence then we take the maximum value for all possible and so is the maximum value plus 1 as defined above. We claim that is the length of longest increasing subsequence ending at . Suppose it wasn’t and that the longest increasing subsequence ending at is and so . By our definition, we know that where is the longest increasing subsequence ending at . This means that but this is not possible since we’re only adding to the subsequence. Therefore, is optimal. 3 The Implementation int longest_increasing_subsequence(int *a, int n) { int D[n], p[n], max = 0; // maximum subsequence ending at a[i] is initially 1 for (int i = 0; i &amp;lt; n; i++) { D[i] = 1; p[i] = -1; // parent array } // for element a[i], check all the previous subsequences where i &amp;lt; j // and see if a[i] can extend any of them for (int i = 1; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; i; j++) { if (A[i] &amp;gt; A[j] &amp;amp;&amp;amp; D[i] &amp;lt; D[j] + 1) { // I can extend the subsequence D[i] = D[j] + 1; p[i] = j; // used for reconstructing the subsequence } } if (D[i] &amp;gt; max) { // maximum subsequence so far max = D[i]; } } return max; } 5 Running Time: We’re doing two simple loops to fill arrays and . Therefore, our runtime is just 6 Example: Initially we start with arrays and : Consider again . We initialize to be representing the initial length of the subsequence ending at each possible . Iteration . We look at . We have and so the subsequence is just . Can 8 extend any previous subsequences? We look at and in that case, we see that , meaning that that the subsequence can now include 3 and become . And so now we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ Iteration . We look at . We have and so the subsequence is just . Can 4 extend any previous subsequences? We need to look at and . It turns out that 1 will not be able to extend either subsequence. $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ We continue doing so until we reach the end and we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$ This means that the longest subsequence ends at element 9 or 5. We can then to construct the subsequence. One possible construction will generate: 5 The O(nlg(n)) Solution with Binary Search: The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes! Previously, we said that is the length of the longest subsequence ending at . Now we will consider a completely different substructure. Let to be the smallest element that ends a subsequence of length . For simplicity we will initially let to be and everything else to be . Let’s take the same example where . In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have is . Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of , that must be sorted because this will help us later on. To prove that is sorted, we will prove that is a strictly increasing array and that for any , we have . (We will ignore the placeholder ’s otherwise the proof would not work)</summary></entry><entry><title type="html">Breadth First Search</title><link href="http://localhost:4000/jekyll/update/2019/06/20/bfs.html" rel="alternate" type="text/html" title="Breadth First Search" /><published>2019-06-20T12:01:36-07:00</published><updated>2019-06-20T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/06/20/bfs</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/06/20/bfs.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/bfs/bfs1.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Traversing a graph is just essential. Breadth first search is one way to traverse a given graph. Let &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt; be a graph consisting of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges and let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be the source vertex where we will start the traversal from. The key thing about breadth first search is that it explores the vertices closest (in terms of number of edges) to the source first. We start by looking at &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;’s neighbors. These vertices are the closest vertices to &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and have distance 1 from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. We then explore each adjacent vertex. Any vertex adjacent to these vertices will have distance 2.
&lt;br /&gt;&lt;br /&gt;
You can see how breadth first search explores the graph in layers, one layer at a time and finds all the vertices reachable from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. Because we explore the closest vertices first, BFS also finds the the shortest paths from the &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to every other vertex in the graph in terms of the number of edges between &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and each vertex. We’ll prove this later.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Data Structures&lt;/b&gt;
&lt;br /&gt;
To perform a breadth first search, we will maintain the following data structures:
&lt;br /&gt;
(1) A queue. We want to explore the nodes closest to &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; first. We know that a queue maintains the property that a node inserted first will be popped/explored first. We will also use the queue to insert the vertex’s distance from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. We can do this because we first insert &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; with distance 0 in the queue. As we explore adjacent vertices in the queue, we will just increment whatever distance was stored with the parent node that was just popped from the queue.
&lt;br /&gt;&lt;br /&gt;
(2) A set or an array that keeps track of the visited nodes. Remember that &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; might contain cycles and so we want to make sure that we explore each node once only.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;
&lt;br /&gt;
Let’s explore the graph above. We will start from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and add both &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; to our queue with distance 1 and mark them visited. &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; are now in the closest layer to &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/bfs/bfs2.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next we will we will pop &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; from the queue. We will traverse &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;’s neighbors &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; will be ignored since it was visited before. When we add &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; to the queue, we will also push the current distance plus 1 which is 2 on the queue to indicate that &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is two steps away from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. Next we will we will pop &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; from the queue and repeat the same process and push &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; on the queue with distance 2. &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; are colored in green below to indicate a new layer.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/bfs/bfs3.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We will repeat the same process until the queue is empty and we have reached every node reachable from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/bfs/bfs4.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notice now how the nodes are organized in layers in terms of the distance from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; (number of edges).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/bfs/bfs5.png&quot; alt=&quot;my photo&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Implementation&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// another queue to push the distances down (bfs works in layers)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;qd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// visited array so we don't revisit nodes&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// parent array to print the path&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;qd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;qd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// print path (reversed)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Proof&lt;/b&gt;
&lt;br /&gt;
Why does BFS find the shortest paths from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to every other vertex in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;? Intuitively, we know that we explore the vertices in layers starting at &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. So if we have a vertex &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in layer &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; then we know the distance to &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is just &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; and that &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; can’t have a shorter path to &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; simply because we would have found &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in an earlier layer, right? Let’s make this formal.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Inductive Hypothesis:&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G = (V,E)&lt;/script&gt; be a graph and &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be the source vertex. Let &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; be natural numbers. For all &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
i &lt; j %]]&gt;&lt;/script&gt;, the vertices in layer &lt;script type=&quot;math/tex&quot;&gt;L_i&lt;/script&gt; have distance &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Base Case:&lt;/b&gt;&lt;br /&gt;
For &lt;script type=&quot;math/tex&quot;&gt;j=0&lt;/script&gt;, we know that &lt;script type=&quot;math/tex&quot;&gt;L_0=\{s\}&lt;/script&gt; and we know that &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; has distance 0 from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; so we’re done.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Inductive Step:&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; be natural numbers and suppose that for all &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
i &lt; k %]]&gt;&lt;/script&gt;, the vertices in layer &lt;script type=&quot;math/tex&quot;&gt;L_i&lt;/script&gt; have distance &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. We want to prove that all vertices in layer &lt;script type=&quot;math/tex&quot;&gt;L_{k}&lt;/script&gt; have distance &lt;script type=&quot;math/tex&quot;&gt;i+1=k&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; be a vertex in &lt;script type=&quot;math/tex&quot;&gt;L_k&lt;/script&gt;. We must have &lt;script type=&quot;math/tex&quot;&gt;dist(s,w) \leq k&lt;/script&gt;. This is because by the inductive hypothesis, we know that &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt;’s parent is in &lt;script type=&quot;math/tex&quot;&gt;L_{k-1}&lt;/script&gt; and therefore has distance &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. Therefore, we know there is a path from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Next we need to prove that &lt;script type=&quot;math/tex&quot;&gt;dist(s,w) \geq k&lt;/script&gt;. Suppose not and that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
dist(s,w) &lt; k %]]&gt;&lt;/script&gt;. This means that &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; must have show up in an earlier layer but we know that it’s impossible and &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; was only discovered after its parent was discovered in layer &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt;. 
&lt;br /&gt;&lt;br /&gt;
Since &lt;script type=&quot;math/tex&quot;&gt;dist(s,w) \leq k&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;dist(s,w) \geq k&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;dist(s,w)=k&lt;/script&gt; as we wanted to show.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Conclusion:&lt;/b&gt;&lt;br /&gt;
For all vertices &lt;script type=&quot;math/tex&quot;&gt;w \in V&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;w \in L_j&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;dist(s,w) = j&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Proof (Take 2) (The CLRS Way)&lt;/b&gt;
&lt;br /&gt;
 I really really really want to go through the CLRS way of doing this proof formally. This is a TODO! (starts in page 598)
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
We visit each vertex at most once only because of the visited array we’re maintaining. That’s &lt;script type=&quot;math/tex&quot;&gt;O(V)&lt;/script&gt; time. As a result, we also visit the adjacency list of each vertex at most once and that’s &lt;script type=&quot;math/tex&quot;&gt;O(E)&lt;/script&gt;. Therefore, the total time is &lt;script type=&quot;math/tex&quot;&gt;O(V+E)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt; 
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/breadth-first-search
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction</summary></entry><entry><title type="html">Input Handling Examples</title><link href="http://localhost:4000/jekyll/update/2019/06/18/input-handling.html" rel="alternate" type="text/html" title="Input Handling Examples" /><published>2019-06-18T12:01:36-07:00</published><updated>2019-06-18T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/06/18/input-handling</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/06/18/input-handling.html">&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Introduction&lt;/b&gt;&lt;br /&gt;
These are some samples for reading inputs while doing UVa problems. I find myself often looking at past solutions and wasting time finding the right template. This is a reference for myself to lookup what I want really fast.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;0 Read a 2D grid with no spaces between cells (std::getline)&lt;/b&gt;&lt;br /&gt;
Simple 2D grid, though we don’t know when the tests terminate. Also no space between cells&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
&lt;td&gt;
3 &lt;br /&gt;
111 &lt;br /&gt;
222 &lt;br /&gt;
333 &lt;br /&gt;
2 &lt;br /&gt;
444 &lt;br /&gt;
333 &lt;br /&gt;
&lt;/td&gt;
&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;read_input&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a line here is 123&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// no input, return false (we didn't read anything)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'1'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// starting cells, can have multiple&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Unbounded tests and variable length strings (use sstream)&lt;/b&gt;&lt;br /&gt;
We have a bunch of tests but we don’t know the number of tests. This is an example:&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
	&lt;td&gt;
5 &lt;br /&gt;
E 0.01 *A &lt;br /&gt;
... &lt;br /&gt;
10 &lt;br /&gt;
S 2.23 Q* &lt;br /&gt;
A 9.76 CKM &lt;br /&gt;
...
&lt;/td&gt;
&lt;/table&gt;

&lt;p&gt;Each test case starts with the number of lines in the test case. Each line contains three values and so we use std::istringstream to extract the values. The following works although not pretty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&amp;lt;sstream&amp;gt;
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// for each test case, we read the number of lines in the test case&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;planet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// this is my hack to know we're done and there are no more lines&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;c1&quot;&gt;// take this line now and process it the way you want&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// in this specific case, we know we have three values&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istringstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;planet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Reading a 3D grid with no space between cells plus a terminating character (can use fgets)&lt;/b&gt;&lt;br /&gt;
This is from problem “532 - Dungeon Master”. Here we know when to terminate. We also know the number of rows, colums and the height (number of levels). There is also an extra new line between each board.&lt;/p&gt;

&lt;table&gt;
&lt;td&gt;
2 4 5 &lt;br /&gt;
SXXXX &lt;br /&gt;
X@@@X &lt;br /&gt;
X@@XX &lt;br /&gt;
@@@X@&lt;br /&gt;
&lt;br /&gt;
@@@@@ &lt;br /&gt;
@@@@@ &lt;br /&gt;
@@X@@ &lt;br /&gt;
@@XXX &lt;br /&gt;
&lt;br /&gt;
1 3 3 &lt;br /&gt;
S@@&lt;br /&gt;
@E@ &lt;br /&gt;
@@@ &lt;br /&gt;
&lt;br /&gt;
0 0 0
&lt;/td&gt;
&lt;/table&gt;

&lt;p&gt;And this is the code I’ve used.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d %d %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// each level&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// each board&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a line here is @@XX@&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// put each char in its cell&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'S'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// record the start position&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start_k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start_i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start_j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// get the nasty extra line between levels&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Strings with variable number of ints&lt;/b&gt;&lt;br /&gt;
Consider a number of lines where each line consists of a variable number of ints. We can use std::istringstream and use a while loop to read as many ints as possible from that line. Code below shows this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&amp;lt;sstream&amp;gt;
&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istringstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// do something with num&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Other examples:&lt;/b&gt; 
https://github.com/strncat/competitive-programming&lt;/p&gt;</content><author><name></name></author><summary type="html">Introduction These are some samples for reading inputs while doing UVa problems. I find myself often looking at past solutions and wasting time finding the right template. This is a reference for myself to lookup what I want really fast. 0 Read a 2D grid with no spaces between cells (std::getline) Simple 2D grid, though we don’t know when the tests terminate. Also no space between cells 3 111 222 333 2 444 333 char m[MAX][MAX]; std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; start; bool read_input() { int n; scanf(&quot;%d\n&quot;, &amp;amp;n); std::string line; for (int i = 0; i &amp;lt; n; i++) { std::getline(std::cin, line); // a line here is 123 // no input, return false (we didn't read anything) if (line.size() == 0) { return false; } for (int j = 0; j &amp;lt; n; j++) { m[i][j] = line[j]; if (m[i][j] == '1') { // starting cells, can have multiple start.push_back({i,j}); } } } return true; } 1 Unbounded tests and variable length strings (use sstream) We have a bunch of tests but we don’t know the number of tests. This is an example: 5 E 0.01 *A ... 10 S 2.23 Q* A 9.76 CKM ...</summary></entry></feed>