I"Ó/<p>We are given an input file consisting of ASCII characters.</p>
<div>
	$$
	\begin{align*}
	36,22,80,0,0,4,23,25,19,17,88...
	\end{align*}
	$$
</div>
<p>The text file originally had plain text that was converted (each byte) to ASCII and then each byte was XORâ€™ed with a given secret value to produce the above values. To restore the plain text, we need to take each byte again and XOR it with the same key to restore back the original value. This works because</p>
<div>
	$$
	\begin{align*}
	65 \ \oplus \ 42 &amp;= 107 \ \oplus \ 42 = 65
	\end{align*}
	$$
</div>
<p>For this problem, we are told that the password or key consists of three lower case characters and if the password is shorter than the message, then the key is cyclically repeated throughout the message. So if the key was \(abc\), then for the above text, weâ€™ll do \(36 \oplus a\), \(22 \oplus b\), \(80 \oplus c\), \(0 \oplus a\), and so on.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h3>Solution</h3>
<p>I only did the brute force solution which worked and it was pretty fast. It was a pain to figure out which characters were allowed. I did this in \(c++\) and the code to read the input and put it in a vector is the following</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">freopen</span><span class="p">(</span><span class="s">"0059_cipher.txt"</span> <span class="p">,</span> <span class="s">"r"</span> <span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">encrypted</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// read the entire string</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="nf">ss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">token</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">','</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stoi</span><span class="p">(</span><span class="n">token</span><span class="p">);</span>
    <span class="n">encrypted</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
And then weâ€™ll iterate through every possible key from \(aaa\) to \(zzz\) and decrypt the message with the key. To verify that we have a valid message, weâ€™ll only allow certain characters. Figuring out the characters was completely done manually by just guessing and trying different ones.
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">key_length</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">i</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">j</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">k</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="sc">'z'</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">key</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">};</span>
            <span class="c1">// (1) try this key here</span>
            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">decrypted</span><span class="p">;</span>
            <span class="kt">bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// by default, this will be a valid result</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">encrypted</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// If the password is shorter than the message, the key is repeated cyclically throughout the message.</span>
                <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">w</span> <span class="o">%</span> <span class="n">key_length</span><span class="p">]</span> <span class="o">^</span> <span class="n">encrypted</span><span class="p">[</span><span class="n">w</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isalnum</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'`'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'('</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">')'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">' '</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'?'</span> <span class="o">||</span>
                    <span class="n">c</span> <span class="o">==</span> <span class="sc">'!'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">','</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">';'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">':'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span> <span class="o">||</span>
                    <span class="n">c</span> <span class="o">==</span> <span class="sc">'\''</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'"'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'\\'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'/'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'['</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">']'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'+'</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">decrypted</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">valid</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="c1">// (2) after we finish trying the key, we'll check if we have a valid result</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">"WORKS</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">decrypted</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">printf</span><span class="p">(</span><span class="s">"%c"</span><span class="p">,</span> <span class="n">decrypted</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="n">sum</span> <span class="o">+=</span> <span class="n">decrypted</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="p">}</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0059-xor-decryption.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h3>References</h3>
<p><a href="https://projecteuler.net/problem=55">Project Euler - 55</a>
<br />
<br /></p>

:ET