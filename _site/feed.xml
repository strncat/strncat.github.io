<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-27T08:54:47-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>hello</subtitle><entry><title type="html">Discrete Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html" rel="alternate" type="text/html" title="Discrete Random Variables" /><published>2019-08-25T07:01:36-07:00</published><updated>2019-08-25T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html">&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;0 References&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Indicator/Bernoulli Random Variable&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; for success and &lt;script type=&quot;math/tex&quot;&gt;1-p&lt;/script&gt; for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
X = \Big\{ \begin{array}{@{}lr@{}}
        1 \quad \text{If even A occurs } \\
        0 \quad \text{otherwise} \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1\}&lt;/script&gt;. Let’s look at the PMF of &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;. Remember that the PMF of a random variable is just the probability that this random variable takes on a value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;R_x&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}}
        p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\
        p(0) = 1 - P(A) \quad \text{if } x = 0 \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;What the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;? Recall that the expected value of a discrete random variable is defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = p(1)*1 + p(0)*0 = p(1) = P(A)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Binomial Random Variable&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If we on the other hand have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; independent trials of Bernoulli random variables with a probability of success &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can use a binomial random variable to represent the number of successes in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. For example, if we are flipping a coin with probability of getting heads (success) equals to &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can define a binomial random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to represent the number of heads in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. 
&lt;br /&gt;
&lt;br /&gt;
Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt; and the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The expected value, variance and second moment of a binomial random variable:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= np \\
Var(X) &amp;amp;= np(1-p) \\
E[X^2] &amp;amp;= n^2p^2 - np^2 + np
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Poisson Random Variable&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Consider a duration of time where events occur at an average rate of &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt; (number of occurrences per unit time). Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of occurrences in a unit of time. We have &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt; and the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The expected value, variance and second moment of a binomial random variable:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = np \\
Var(X) = np(1-p) \\
E[X^2] = n^2p^2 - np^2 + np
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt; Example 1: &lt;/b&gt;&lt;br /&gt;
Given a web server, suppose that the server load averages 2 hits per second. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of hits received in a second. What is &lt;script type=&quot;math/tex&quot;&gt;P(X=5)?&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Binomial and Poisson Random Variables&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; be very large and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; very small. Let &lt;script type=&quot;math/tex&quot;&gt;\lambda = np&lt;/script&gt; which is the average number of successes you see in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. Then we will have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\
&amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} (1-\frac{\lambda}{n})^{n-k} \\
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">0 References My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ Indicator/Bernoulli Random Variable If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability for success and for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following: $$ \begin{align*} X = \Big\{ \begin{array}{@{}lr@{}} 1 \quad \text{If even A occurs } \\ 0 \quad \text{otherwise} \\ \end{array} \end{align*} $$ Therefore, . Let’s look at the PMF of . Remember that the PMF of a random variable is just the probability that this random variable takes on a value in . Therefore, $$ \begin{align*} p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}} p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\ p(0) = 1 - P(A) \quad \text{if } x = 0 \\ \end{array} \end{align*} $$ What the expected value of ? Recall that the expected value of a discrete random variable is defined as $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ Therefore, $$ \begin{align*} E[X] = p(1)*1 + p(0)*0 = p(1) = P(A) \end{align*} $$ Binomial Random Variable If we on the other hand have independent trials of Bernoulli random variables with a probability of success , then we can use a binomial random variable to represent the number of successes in trials. For example, if we are flipping a coin with probability of getting heads (success) equals to , then we can define a binomial random variable to represent the number of heads in trials. Therefore, and the PMF of is: $$ \begin{align*} p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k} \end{align*} $$ The expected value, variance and second moment of a binomial random variable: $$ \begin{align*} E[X] &amp;amp;= np \\ Var(X) &amp;amp;= np(1-p) \\ E[X^2] &amp;amp;= n^2p^2 - np^2 + np \end{align*} $$ Poisson Random Variable Consider a duration of time where events occur at an average rate of (number of occurrences per unit time). Let be the number of occurrences in a unit of time. We have and the PMF of is: $$ \begin{align*} p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda} \end{align*} $$ The expected value, variance and second moment of a binomial random variable: $$ \begin{align*} E[X] = np \\ Var(X) = np(1-p) \\ E[X^2] = n^2p^2 - np^2 + np \end{align*} $$ Example 1: Given a web server, suppose that the server load averages 2 hits per second. Let be the number of hits received in a second. What is $$ \begin{align*} P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361 \end{align*} $$ Binomial and Poisson Random Variables Let be very large and very small. Let which is the average number of successes you see in trials. Then we will have $$ \begin{align*} P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\ &amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} (1-\frac{\lambda}{n})^{n-k} \\ \end{align*} $$</summary></entry><entry><title type="html">Prime Numbers</title><link href="http://localhost:4000/jekyll/update/2019/08/23/prime-numbers.html" rel="alternate" type="text/html" title="Prime Numbers" /><published>2019-08-23T07:01:36-07:00</published><updated>2019-08-23T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/23/prime-numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/23/prime-numbers.html">&lt;p&gt;&lt;b&gt;References&lt;/b&gt;&lt;br /&gt;
These study notes are from the following sources: &lt;br /&gt;
(1) http://mathworld.wolfram.com/ &lt;br /&gt;
(2)
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Divisibility&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a,b \in Z&lt;/script&gt;. We say that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; divides &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;a \ | \ b&lt;/script&gt; if for some &lt;script type=&quot;math/tex&quot;&gt;c \in Z&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;b = ac&lt;/script&gt;. In this case, &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is a divisor of &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. If there is no such &lt;script type=&quot;math/tex&quot;&gt;c \in Z&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;b = ac&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; does not divide &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;a \nmid b&lt;/script&gt;.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Prime&lt;/b&gt;&lt;br /&gt;
An Integer &lt;script type=&quot;math/tex&quot;&gt;n &gt; 1&lt;/script&gt; is prime if the only positive divisors of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; are &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is not prime then &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is composite.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Fundamental Theorem of Arithmetic:&lt;/b&gt;&lt;br /&gt; 
Every integer greater than 1 can be represented in exactly one way apart from rearrangement as a product of one or more primes.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Greatest Common Divisor&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a, b \in Z&lt;/script&gt;. Let&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
gcd(a,b) = \max \{ d \in Z : d \ |\  a \ \text{ and } \ d \ | \ b \}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; is the greatest common divisor of both &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Properties of the Greatest Common Divisor&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a, b \in Z&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
gcd(a,b) = gcd(a,b-a) = gcd(a,b+a)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Proof: Let &lt;script type=&quot;math/tex&quot;&gt;gcd(a,b) = d \in Z&lt;/script&gt;. By the defintion of &lt;script type=&quot;math/tex&quot;&gt;gcd&lt;/script&gt; we know that &lt;script type=&quot;math/tex&quot;&gt;d \ | \ a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;d \ | \ b&lt;/script&gt;. Therefore, for some &lt;script type=&quot;math/tex&quot;&gt;x, y \in Z&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a = xd&lt;/script&gt; and, &lt;script type=&quot;math/tex&quot;&gt;b = yd&lt;/script&gt;. From this we have, &lt;script type=&quot;math/tex&quot;&gt;a - b = d(x - y)&lt;/script&gt;. Therefore, we know that &lt;script type=&quot;math/tex&quot;&gt;d = gcd(a,b) \ | \ a - b&lt;/script&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">References These study notes are from the following sources: (1) http://mathworld.wolfram.com/ (2) Divisibility Let . We say that divides or if for some , . In this case, is a divisor of . If there is no such such that then does not divide or . Prime An Integer is prime if the only positive divisors of are and . If is not prime then is composite. Fundamental Theorem of Arithmetic: Every integer greater than 1 can be represented in exactly one way apart from rearrangement as a product of one or more primes. Greatest Common Divisor Let . Let $$ \begin{align*} gcd(a,b) = \max \{ d \in Z : d \ |\ a \ \text{ and } \ d \ | \ b \} \end{align*} $$ is the greatest common divisor of both and . Properties of the Greatest Common Divisor Let , we have $$ \begin{align*} gcd(a,b) = gcd(a,b-a) = gcd(a,b+a) \end{align*} $$ Proof: Let . By the defintion of we know that and . Therefore, for some , we have and, . From this we have, . Therefore, we know that .</summary></entry><entry><title type="html">Congruences</title><link href="http://localhost:4000/jekyll/update/2019/08/22/congruences.html" rel="alternate" type="text/html" title="Congruences" /><published>2019-08-22T07:01:36-07:00</published><updated>2019-08-22T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/22/congruences</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/22/congruences.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes from ?
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;What is a Random Variable?&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p center=&quot;&quot; style=&quot;background-color:#FFFDD0; border:1px; border-style:solid; border-color:#FXFXFX; padding: 1em;&quot;&gt;
The numbers $$a$$ and $$b$$ are congruent module $$m$$ if and only if $$m  \ | \ (a-b)$$ and also if and only if $$m \ | \ (b-a)$$.
$$
\begin{align*}
p_X(k) = P(X = k)
\end{align*}
$$

&lt;br /&gt;
&lt;br /&gt;






















&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes from ? What is a Random Variable? The numbers $$a$$ and $$b$$ are congruent module $$m$$ if and only if $$m \ | \ (a-b)$$ and also if and only if $$m \ | \ (b-a)$$. $$ \begin{align*} p_X(k) = P(X = k) \end{align*} $$</summary></entry><entry><title type="html">Binary Search Correctness Proof</title><link href="http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof.html" rel="alternate" type="text/html" title="Binary Search Correctness Proof" /><published>2019-08-19T07:01:36-07:00</published><updated>2019-08-19T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof.html">&lt;p&gt;&lt;b&gt;References&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
These are my study notes from CLRS and ?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Binary Search&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Given a sorted array &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; integers and a key, we want to return the index of the key in the array or -1 if the key doesn’t exist in the array. Binary search takes advantage of the property that the array is sorted and then iteratively finds which half of the list the key will be located in. After &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; iterations, we will either correctly return that index or return -1 if the key doesn’t exist.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not found&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Preconditions, Postconditions and Loop Invariants&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
This is my attempt to prove that binary search algorithm implemented above is correct.
&lt;br /&gt;&lt;br /&gt;
As a reminder from CLRS, we use loop invariants to help understand why an algorithm is correct. In order to prove an algorithm is correct, we must show that:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The invariant is true before the first iteration of the loop. (Initialization)&lt;/li&gt;
  &lt;li&gt;If the invariant is true before iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;, then it is true before iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. (Maintenance)&lt;/li&gt;
  &lt;li&gt;When the loop terminates, the invariant gives us a property to help show that the algorithm is correct. (Termination)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
The first two properties are similar to mathematical induction since we need to prove a base case and then prove the inductive step.
&lt;br /&gt;
&lt;br /&gt;
In addition to loop invariants, we also need to describe the preconditions of binary search. Preconditions are just assertions that must be true at the beginning of our function. In our case, &lt;b&gt;our precondition is that the array is sorted in an ascending order&lt;/b&gt;. If the array is not sorted, then we don’t guarantee anything about the outcome.
&lt;br /&gt;
&lt;br /&gt;
In addition to preconditions, we also need to describe our postconditions. Given that we met the preconditions, our loop invariant is correct and our algorithm terminates, our &lt;b&gt;post condition is that we return -1 if the key is not in the array or return the index of the key in the array&lt;/b&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Binary Search’s Loop Invariant&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let’s define the following loop invariant: At the start of each iteration of the while loop above the following is true: &lt;br /&gt;
(1) &lt;script type=&quot;math/tex&quot;&gt;1 \leq first \leq last \leq n&lt;/script&gt;&lt;br /&gt;
(2) If the key is in the array and so there is some &lt;script type=&quot;math/tex&quot;&gt;index&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;1 \leq index \leq n&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;first \leq index \leq last&lt;/script&gt;. This just means that we are correctly picking the right range to search at every iteration.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Initialization:&lt;/b&gt;
&lt;br /&gt;
Before the first iteration we know that &lt;script type=&quot;math/tex&quot;&gt;first = 1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;last = n-1&lt;/script&gt; and so (1) is trivially true. Also, if the key is in &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; then it must be that &lt;script type=&quot;math/tex&quot;&gt;1 \leq index \leq n-1&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt;. Therefore, we are searching the correct range.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Maintenance:&lt;/b&gt;
&lt;br /&gt;
Suppose the invariant holds before iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and that if our key is in &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; then for some index where &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt; we have &lt;script type=&quot;math/tex&quot;&gt;first \leq index \leq last&lt;/script&gt;. Let’s look at iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. We first calculate the mid point in the range &lt;script type=&quot;math/tex&quot;&gt;[first, last]&lt;/script&gt;. Based on this, we have three cases: 
&lt;br /&gt;
&lt;br /&gt;
(1) &lt;script type=&quot;math/tex&quot;&gt;a[m] == key&lt;/script&gt;. We therefore, return &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and we are done. 
&lt;br /&gt;
&lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm in this case searches the new range &lt;script type=&quot;math/tex&quot;&gt;[first, m-1]&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;first \leq index&lt;/script&gt; and we so we only need to prove that &lt;script type=&quot;math/tex&quot;&gt;index \leq m-1&lt;/script&gt;. Note that we know that &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt; and since the array is sorted then it must be that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
index &lt; m %]]&gt;&lt;/script&gt; is true otherwise &lt;script type=&quot;math/tex&quot;&gt;a[index]&lt;/script&gt; comes after &lt;script type=&quot;math/tex&quot;&gt;a[m]&lt;/script&gt; which indicates that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is not sorted.
&lt;br /&gt;
&lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm will then search the new range &lt;script type=&quot;math/tex&quot;&gt;[m+1, last]&lt;/script&gt;. We can use a similar argument to (2) to prove that &lt;script type=&quot;math/tex&quot;&gt;index \in [m+1, last]&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
From (1), (2), (3) we conclude that the invariant holds before iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Termination:&lt;/b&gt;
&lt;br /&gt;
Will we terminate? we need to prove that if the search range is &lt;script type=&quot;math/tex&quot;&gt;[first_i, last_i]&lt;/script&gt; in iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and the search range in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;[first_{i+1}, last_{i+1}]&lt;/script&gt; then it must be that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
last_{i+1} - first_{i+1} &lt; last_{i} - first_{i} %]]&gt;&lt;/script&gt;. To do so we can use a similar approach to the one we used to prove our maintenance step. We know there are three cases, in each case we can prove that the new range is shrinking. (TODO).
&lt;br /&gt;
&lt;br /&gt;
Since our algorithm terminates then by the loop invariant&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">References These are my study notes from CLRS and ? Binary Search Given a sorted array of integers and a key, we want to return the index of the key in the array or -1 if the key doesn’t exist in the array. Binary search takes advantage of the property that the array is sorted and then iteratively finds which half of the list the key will be located in. After iterations, we will either correctly return that index or return -1 if the key doesn’t exist. int binary_search(int *a, int key, int n) { int m, first = 0, last = n - 1; while (first &amp;lt;= last) { m = (first + (last - first / 2); if (key &amp;gt; a[m]) { first = m + 1; } else if (key &amp;lt; a[m]) { last = m - 1; } else if (key == a[m]) { return m; } } return -1; // not found } Preconditions, Postconditions and Loop Invariants This is my attempt to prove that binary search algorithm implemented above is correct. As a reminder from CLRS, we use loop invariants to help understand why an algorithm is correct. In order to prove an algorithm is correct, we must show that: The invariant is true before the first iteration of the loop. (Initialization) If the invariant is true before iteration , then it is true before iteration . (Maintenance) When the loop terminates, the invariant gives us a property to help show that the algorithm is correct. (Termination)</summary></entry><entry><title type="html">Closest Pair of Points</title><link href="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html" rel="alternate" type="text/html" title="Closest Pair of Points" /><published>2019-07-29T07:01:36-07:00</published><updated>2019-07-29T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/29/closest-pair</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Problem&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we are given a list of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; two dimensional points &lt;script type=&quot;math/tex&quot;&gt;\{\{x_1,y_1\},\{x_2,y_2\},...\{x_n,y_n\}\}&lt;/script&gt; and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; since we have &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; possible pairs. What else can we do?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Divide and Conquer&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we arrive at the final result. As a starting point we will sort the points by their x-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We will also sort the points by their y-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;. We will be using &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; later in the algorithm.
&lt;img src=&quot;http://localhost:4000/assets/closest/1.png&quot; width=&quot;100%&quot; /&gt;
Given &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We can start by applying the following divide and conquer idea. Repeatedly divide &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/closest/2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How do we combine the results to find the single true closest pair? we need to consider that the closest pair might have a point in the left half and a point in the right half. We call this pair a &lt;b&gt;split pair&lt;/b&gt;. So in the combine step we need to do two things, we find the split pair with the minimum distance. We then return the minimum pair of the three pairs we have, the left pair, the right pair and the split pair. The following pseudo-code implements this idea.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Px sorted by x-coordinate, Py by y-coordinate&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;less&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;three&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
       &lt;span class=&quot;c1&quot;&gt;// just use the naive algorithm &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we will divide Px into two arrays left and right&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// median = Px[n/2-1]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_px_around_the_median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// We want to sort each of left_x and right_x by the y-coordinate.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// discussed next&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort_left_and_right_by_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we find the closest pair in each half&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// delta_left and delta_right are the minimum distances in the left and right halfs&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we'll discuss this soon!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
We sorted the array upfront twice in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; time. We divide the input repeatedly in half until we reached the base case. We then combined the results by finding the split pair and returning the pair with the minimum distance. So we have a recurrence that looks like this:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 T(n) = aT(n/b) + n^c \\
 T(n) = 2T(n/2) + n^c
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; constant depends on the work we’re doing in each level. We first create the four arrays &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. This takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. We then find the split pair. If we find the split pair in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;c = 2&lt;/script&gt; and by the master theorem, the total runtime is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. This defeats the purpose since the naive solution runs in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. We also know that we initially sorted the array in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; so the final runtime is at least &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;. So roughly we know that we need to find the split pair really fast in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; to have &lt;script type=&quot;math/tex&quot;&gt;c = 1&lt;/script&gt; and therefore, keeping our runtime at &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 How to repeatedly sort &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; by the x-coordinate and the y-coordinate &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time? &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
So we’re claiming that we’re sorting once only and then somehow we’re are repeatedly passing the two halfs of the &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; sorted by the x-coordinate and by the y-coordinate. How?! For sorting by the x-coordinate, we simply split &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; in half by calculating the median in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; time and then iterating over &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; to split the array into &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. That takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the current size of &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Now that we have both &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. We want to create two arrays &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; but sorted by the y-coordinate. We also want &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; sorted by the y-coordinate. How do we do this in just &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time? This is when we will use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;! We will iterate over &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; and if we see an element with an x-coordinate below or equal to the median then this element belongs to &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; otherwise it belongs to &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. Remember that &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; is just &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; but sorted by the y-coordinate. We are also assuming for the sake of simplicity that the points are distinct. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Finding the split pair in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/closest/3.png&quot; width=&quot;100%&quot; /&gt;
Let’s assume that the minimum pair is not a left pair or a right pair and it is a split pair. In the algorithm we described above, let the left minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; (shown above) and let the right minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; be the minimum of &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Also let the right most point in the left array be &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. Now construct &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; to be an array with all the points that have x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x} + \delta&lt;/script&gt; sorted by their y-coordinate (we can use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; with a linear scan to insert any point that has an x-coordinate that fits our criteria). This linear scan costs &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time which is fine by us!
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;p=(x_1,y_1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q=(x_2,y_2)&lt;/script&gt; be the split pair points we’re trying to find where &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is in the left half and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; is in the right half. We claim the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;At most 6 points are between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in M.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
So, assuming the above is correct (we’ll prove it formally), we now have a constant number of pairs to look at. Basically, for each point, we will look at 7 points and therefore, we only have &lt;script type=&quot;math/tex&quot;&gt;7n&lt;/script&gt; pairs and so we can find the split pair in only &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
But why why why the above is the correct? let’s look at the first claim.
&lt;br /&gt;&lt;br /&gt;
Proof:&lt;br /&gt;
We want to show that if the closest pair of points is a split pair then our algorithm will find it. Since our algorithm only searches &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, then we want to show that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;. So assuming that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are the closest pair, we then know that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
d(p,q) &lt; \delta %]]&gt;&lt;/script&gt;. From here we can expand the euclidean distance definition:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 \delta &amp;amp;&amp;gt; d(p,q) \\
  &amp;amp;= \sqrt{(y_2-y_1)^2 + (x_2-x_1)^2} \\
  &amp;amp;\geq \sqrt{\max\{(y_2-y_1)^2, (x_2-x_1)^2}\} \\
  &amp;amp;= \max\{(y_2-y_1), (x_2-x_1)\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This says that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; in both their &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; coordinates!! So &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
|x_2-x_1| &lt; \delta %]]&gt;&lt;/script&gt;. We also know that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are a split pair and so by definition we have &lt;script type=&quot;math/tex&quot;&gt;x_1 \leq \bar{x}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 &gt; \bar{x}&lt;/script&gt;. Therefore, we must have &lt;script type=&quot;math/tex&quot;&gt;x_1 \geq \bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 \leq \bar{x} + \delta&lt;/script&gt;. Finally, since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is defined to include all points such that the x-coordinate satisfies &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta \leq x \leq \bar{x} + \delta&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; and thererfore, we will find them. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Let’s move to the second claim. why must we have 6 points only between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
Proof:
&lt;br /&gt;
Without the loss of generality, assume that &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; has the lower y-coordinate. We do know that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;’s x and y coordinates differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;’s x and y coordinates respectively. What do we know about the points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted by the y-coordinate, we do know that any point that comes between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;, this makes the y-coordinate of any of these points be in between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1 \leq y_2 + \delta&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We know that any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have an x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x}-\delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x}+\delta&lt;/script&gt; by our construction of &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using the above restrictions, any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must be in one of the following boxes. (again, if you look at the x-axis, &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; only allow points within &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. If you look vertically, the fact that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted makes the points between &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and that gap is also less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;!!).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/closest/4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next question is how many points do we have in each box?
&lt;br /&gt;&lt;br /&gt;
We claim that each box has only 1 point. Proof: Suppose it doesn’t and some box in the diagram above has 2 points. Let these points be &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. This means than &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; are both a left pair or a right pair. Moreover, the distance between &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is at most &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sqrt{(\delta/2)^2 + (\delta/2)^2} = \delta/\sqrt{2} &lt; \delta %]]&gt;&lt;/script&gt;. This is a contradiction, since by assumption we said both &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt; are greater than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;. Therefore, we must have 1 point in each box and so there are only 6 points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; Wonderful!!&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!! 1 Problem Suppose we are given a list of two dimensional points and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of since we have possible pairs. What else can we do? 2 Divide and Conquer The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we arrive at the final result. As a starting point we will sort the points by their x-coordinate and let that array be . We will also sort the points by their y-coordinate and let that array be . We will be using later in the algorithm. Given . We can start by applying the following divide and conquer idea. Repeatedly divide into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.</summary></entry><entry><title type="html">Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html" rel="alternate" type="text/html" title="Random Variables" /><published>2019-07-26T07:01:36-07:00</published><updated>2019-07-26T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/26/random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html">&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;0 References&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188// &lt;br /&gt;
Specifically: http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/lectures/06_random_variables.pdf
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;What is a Random Variable?&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;A random variable is a real-valued function defined on a sample space. Why define a random variable? sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some groups of the outcomes or more formally some &lt;b&gt;function of the outcome&lt;/b&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 1:&lt;/b&gt;
&lt;br /&gt; 
Suppose we’re interested in &lt;i&gt;counting&lt;/i&gt; the number of heads in &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt; trials of flipping a coin. We can define a random variable &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to represent the number of heads in 5 trials. Using &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;, we can now refer to the probability of seeing two heads in 5 trials as &lt;script type=&quot;math/tex&quot;&gt;P(Y=2)&lt;/script&gt;. This is much simpler that listing the exact outcomes we’re interested in which are getting heads in trial 1 and 2 or getting heads in 1 or 3 or getting heads in trials 1 and 4 only and so on. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 2:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice and we’re interested in the sum of the two dice. We define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 as &lt;script type=&quot;math/tex&quot;&gt;P(X=7)&lt;/script&gt;. This is much simpler that saying that we want the probability of seeing any of these outcomes: &lt;script type=&quot;math/tex&quot;&gt;(3,4),(4,3),(2,5),(5,2),(1,6),(6,1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Discrete Random Variables&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If our random variable takes on countable values &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, x_3,...,x_n&lt;/script&gt;, we call it a discrete random variable. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Probability Mass Function&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Suppose we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; that takes on a discrete values in &lt;script type=&quot;math/tex&quot;&gt;R_X = \{k_1, k_2,...,k_n\}&lt;/script&gt;. Define the probability mass function &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; to be the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; takes on a particular value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. In other words, the PMF is defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p_X(k) = P(X = k)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Furthermore, the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; satisfies:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=1}^{\infty} p_X(k_i) = 1
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This also means that for any value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; that is not in &lt;script type=&quot;math/tex&quot;&gt;R_X&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;p_X(k) = 0&lt;/script&gt;, in other words,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 P(X=k) = \Big\{ \begin{array}{@{}lr@{}}
        p_X(k) \quad \text{ for } k \in R_X \\
        0 \quad \quad \quad \text{ otherwise} \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We can also refer to &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; as just &lt;script type=&quot;math/tex&quot;&gt;p(k)&lt;/script&gt; if the random variable is clear from the context. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 2:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll the two dice again from example 2. Define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be to the sum of the two dice. We know &lt;script type=&quot;math/tex&quot;&gt;R_X = \{2,3,4,5,6,7,8,9,10,11,12\}&lt;/script&gt;. Below is a graph of the &lt;script type=&quot;math/tex&quot;&gt;PMF&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; for all values in &lt;script type=&quot;math/tex&quot;&gt;R_X&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/random/pmf.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Cumulative Distribution Function&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Now instead of defining the probability that a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; takes on a particular value, we define a new function, the cumulative distribution function (CDF) that gives the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is less than or equal to a particular value.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = F(k) = P(X \leq k), \quad \text{ where } -\infty &amp;lt; k &amp;lt; \infty
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;For a discrete random variable, this will be just the sum of all variables&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = F(k) = \sum_{\text{ all } i \leq k} p(i)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Expectation&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;The expectation or expected value of a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is defined as:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the expected value is a weighted average of the value of the random variable (values weighted by their probabilities).
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 4:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice again from example 2 and 3. Define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be to the sum of the two dice. We can use our PMF from the previous section to compute the expected value as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= 2*P(X=2) + 3*P(X=3) + 4*P(X=4) + 5 * P(X=5) * 6*P(X=6) + 7*P(X=7) \\
\\ &amp;amp;+ 8*P(X=8) + 9*P(X=9) + 10*P(X=10) + 11*P(X=11) * 12*P(X=12) \\
E[X] &amp;amp;= 2*\frac{1}{36} + 3*\frac{2}{36} + 4*\frac{3}{36} + 5*\frac{4}{36} + 6*\frac{5}{36} + 7*\frac{6}{36} + 8*\frac{5}{36} + 9*\frac{4}{36} + 10*\frac{3}{36} \\
&amp;amp;+ 11*\frac{2}{36} + 12*\frac{1}{36} = 7
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Expectation of a function of a random variable&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Suppose we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; and we have a function &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; is real-valued function. Suppose we want to calculate the expected value of &lt;script type=&quot;math/tex&quot;&gt;g(X)&lt;/script&gt;. Define&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[g(X)] = E[Y] &amp;amp;= \sum_j y_jp(y_j) \\
&amp;amp;= \sum_i g(x_i) p(x_i) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;PROOF?
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 5:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll a die and define &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be the value on the die. Define a new random variable &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;X^2&lt;/script&gt;. What is &lt;script type=&quot;math/tex&quot;&gt;E[Y]&lt;/script&gt;?&lt;br /&gt;
&lt;br /&gt;
Using the above, &lt;script type=&quot;math/tex&quot;&gt;E[Y] = E[X^2] = \sum_i (k_i^2)p(k_i) = 1/6*(1+4+9+16+25+36) \approx 15.167&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Properties of Expectation&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Two important properties of expectation are the following: &lt;br /&gt;
(1) Linearity of expectation:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[aX + b] &amp;amp;= aE[X] + b 
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;(2) Expectation of the sum of two random variables is the sum of expectation of the two random variables:&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[X + Y] &amp;amp;= E[X] + E[Y]
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Example 6:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll a die and let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable representing the outcome of the roll. Suppose also that you will a number of dollars equals to &lt;script type=&quot;math/tex&quot;&gt;3X+5&lt;/script&gt;. What is the expected value of your winnings? We can let &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; be a random variable representing our winnings. Now we have&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Y] = E[6X^2+5] &amp;amp;= \sum_i (3x_i + 5)p(x_i) \\
&amp;amp;= \frac{1}{6} \sum_{i=1}^6 3x_i+5 \\
&amp;amp;= \frac{1}{6} (8+11+14+17+20+23) = 15.5
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;However using the linearity of expectation, we know that &lt;script type=&quot;math/tex&quot;&gt;E[X]=3.5&lt;/script&gt;. Therefore we could do the following:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Y] = E[3X+5] &amp;amp;= 3E[X]+5  \\
&amp;amp;= 3(3.5) + 5 = 15.5
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Example 7:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice again and we’re interested in the expectation of the sum of two dice. We calculated this value previously in example 4 using the PMF. Let’s use the second property of expectation. Let &lt;script type=&quot;math/tex&quot;&gt;X_1&lt;/script&gt; be a random variable representing the value of the first die and &lt;script type=&quot;math/tex&quot;&gt;X_2&lt;/script&gt; be a random variable representing the sum value of the second die. Let the sum of the two dice be &lt;script type=&quot;math/tex&quot;&gt;X_1 + X_2&lt;/script&gt;.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X_1 + X_2] = E[X_1] + E[X_2] = 7
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Example 8: St. Petersburg Paradox&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;A fair coin comes up heads with &lt;script type=&quot;math/tex&quot;&gt;p = 0.5&lt;/script&gt;. We flip the coin until we see the first tails. We will then win &lt;script type=&quot;math/tex&quot;&gt;2^n&lt;/script&gt; dollars where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the number of heads seen before the first tail. How much would you pay to play?
&lt;br /&gt;
&lt;br /&gt;
Let’s define the following random variables: &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; be the number of “heads” before the the first “tails”.&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; be a random variable representing our winnings. &lt;script type=&quot;math/tex&quot;&gt;W = 2^Y&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
What is the probability of seeing &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; heads before seeing the first tail on the &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;th trial? &lt;script type=&quot;math/tex&quot;&gt;P(Y = i) = (1/2) * (1/2) * ... = (1/2)^{i+1}&lt;/script&gt;. This is because  we stop at the &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; flip which is a tail. Each outcome has a probability equals to &lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
What is the expected value of our winnings?&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[W] = E[2^Y] &amp;amp;= \sum_i 2^i P(Y=i) =  \sum_i 2^i p(i) \\
&amp;amp;= (\frac{1}{2})^1 2^0 + (\frac{1}{2})^2 2^1 +  (\frac{1}{2})^3 2^2 + ... \\
&amp;amp;= \sum_i^{\infty} (\frac{1}{2})^{i+1} 2^i = \infty
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Example 9: Roulette&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Consider an even money bet (betting “Red” in Roulette). &lt;script type=&quot;math/tex&quot;&gt;p=18/38&lt;/script&gt; you win &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; dollars, otherwise &lt;script type=&quot;math/tex&quot;&gt;1-p&lt;/script&gt; you lose &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; dollars. Consider the following strategy:
(1) Let &lt;script type=&quot;math/tex&quot;&gt;Y=1&lt;/script&gt;. &lt;br /&gt;
(2) Bet &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;.&lt;br /&gt;
(3) If win then stop.&lt;br /&gt;
(4) else let &lt;script type=&quot;math/tex&quot;&gt;Y=2Y&lt;/script&gt; go to step 2.&lt;br /&gt;
&lt;br /&gt;
What is the expected value of our winning? &lt;br /&gt;
Define &lt;script type=&quot;math/tex&quot;&gt;Z&lt;/script&gt; to be the winnings until we stop.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Z] &amp;amp;= p*1 + (1-p)p*(2-1) + (1-p)^2p*(4-2-1) + ... \\
&amp;amp;= \sum_{i=0}^{\infty} p(1-p)^i(2^i - \sum_{j=0}^{i-1}2^j) \\
&amp;amp;= p\sum_{i=0}^{\infty} (1-p)^i = p\frac{1}{1-(1-p)} = 1
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">0 References My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188// Specifically: http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/lectures/06_random_variables.pdf What is a Random Variable? A random variable is a real-valued function defined on a sample space. Why define a random variable? sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some groups of the outcomes or more formally some function of the outcome. Example 1: Suppose we’re interested in counting the number of heads in trials of flipping a coin. We can define a random variable to represent the number of heads in 5 trials. Using , we can now refer to the probability of seeing two heads in 5 trials as . This is much simpler that listing the exact outcomes we’re interested in which are getting heads in trial 1 and 2 or getting heads in 1 or 3 or getting heads in trials 1 and 4 only and so on. Example 2: Suppose we roll two dice and we’re interested in the sum of the two dice. We define a random variable to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 as . This is much simpler that saying that we want the probability of seeing any of these outcomes: . Discrete Random Variables If our random variable takes on countable values , we call it a discrete random variable. Probability Mass Function Suppose we have a random variable that takes on a discrete values in . Define the probability mass function to be the probability that takes on a particular value . In other words, the PMF is defined as $$ \begin{align*} p_X(k) = P(X = k) \end{align*} $$ Furthermore, the PMF of satisfies: $$ \begin{align*} \sum_{i=1}^{\infty} p_X(k_i) = 1 \end{align*} $$ This also means that for any value that is not in , we have , in other words, $$ \begin{align*} P(X=k) = \Big\{ \begin{array}{@{}lr@{}} p_X(k) \quad \text{ for } k \in R_X \\ 0 \quad \quad \quad \text{ otherwise} \\ \end{array} \end{align*} $$ We can also refer to as just if the random variable is clear from the context. Example 2: Suppose we roll the two dice again from example 2. Define a random variable to be to the sum of the two dice. We know . Below is a graph of the of , for all values in . Cumulative Distribution Function Now instead of defining the probability that a random variable takes on a particular value, we define a new function, the cumulative distribution function (CDF) that gives the probability that is less than or equal to a particular value. $$ \begin{align*} F_X(k) = F(k) = P(X \leq k), \quad \text{ where } -\infty &amp;lt; k &amp;lt; \infty \end{align*} $$ For a discrete random variable, this will be just the sum of all variables $$ \begin{align*} F_X(k) = F(k) = \sum_{\text{ all } i \leq k} p(i) \end{align*} $$ Expectation The expectation or expected value of a random variable is defined as: $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ In other words, the expected value is a weighted average of the value of the random variable (values weighted by their probabilities). Example 4: Suppose we roll two dice again from example 2 and 3. Define a random variable to be to the sum of the two dice. We can use our PMF from the previous section to compute the expected value as $$ \begin{align*} E[X] &amp;amp;= 2*P(X=2) + 3*P(X=3) + 4*P(X=4) + 5 * P(X=5) * 6*P(X=6) + 7*P(X=7) \\ \\ &amp;amp;+ 8*P(X=8) + 9*P(X=9) + 10*P(X=10) + 11*P(X=11) * 12*P(X=12) \\ E[X] &amp;amp;= 2*\frac{1}{36} + 3*\frac{2}{36} + 4*\frac{3}{36} + 5*\frac{4}{36} + 6*\frac{5}{36} + 7*\frac{6}{36} + 8*\frac{5}{36} + 9*\frac{4}{36} + 10*\frac{3}{36} \\ &amp;amp;+ 11*\frac{2}{36} + 12*\frac{1}{36} = 7 \end{align*} $$ Expectation of a function of a random variable Suppose we have a random variable and we have a function where is real-valued function. Suppose we want to calculate the expected value of . Define $$ \begin{align*} E[g(X)] = E[Y] &amp;amp;= \sum_j y_jp(y_j) \\ &amp;amp;= \sum_i g(x_i) p(x_i) \\ \end{align*} $$ PROOF? Example 5: Suppose we roll a die and define to be the value on the die. Define a new random variable to be . What is ? Using the above, Properties of Expectation Two important properties of expectation are the following: (1) Linearity of expectation: $$ \begin{align*} E[aX + b] &amp;amp;= aE[X] + b \end{align*} $$</summary></entry><entry><title type="html">Ford-Fulkerson’s Maximum Flow</title><link href="http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson.html" rel="alternate" type="text/html" title="Ford-Fulkerson's Maximum Flow" /><published>2019-07-22T07:01:36-07:00</published><updated>2019-07-22T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes on chapter 26 in CLRS.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we want to ship oranges from NYC to SF because we have a current shortage of oranges in SF. We want to ship as many oranges as possible. Everything needs to be shipped by ground. We have different routes of different capacities. The total number of oranges that enter a city &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;, must be equal to the number of the oranges leaving city &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. In other words, cities can’t withhold oranges. We want to find the maximum number of oranges we can ship to SF. How can we solve can this problem? Let’s start by modeling this problem.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Anatomy of a Flow Network&lt;/b&gt;
&lt;img src=&quot;http://localhost:4000/assets/flow/1.png&quot; width=&quot;100%&quot; /&gt;
A flow network &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; is a directed graph where &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We have two distinguished vertices, the source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and the sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;Each edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; has a non-negative capacity &lt;script type=&quot;math/tex&quot;&gt;c(u,v) \geq 0&lt;/script&gt;. (edge capacities are in black above) &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If we have edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;For any vertex &lt;script type=&quot;math/tex&quot;&gt;v \in V&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;(v,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt;, then we can assume that &lt;script type=&quot;math/tex&quot;&gt;c(u,v)=0&lt;/script&gt;.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected and so &lt;script type=&quot;math/tex&quot;&gt;|E| \geq |V| - 1&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 What is Flow?&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/flow/2.png&quot; width=&quot;100%&quot; /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;f(u,v)&lt;/script&gt; be the flow from vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; to vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; (marked in purple above). &lt;br /&gt;
A &lt;b&gt;flow&lt;/b&gt; is a real valued function &lt;script type=&quot;math/tex&quot;&gt;f : V \times V \rightarrow \mathbb{R}&lt;/script&gt; that satisfies:&lt;br /&gt;
(1) &lt;b&gt;Capacity constraint:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u, v \in V&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
0 \leq f(u,v) \leq c(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the flow on every edge must not exceed its capacity. Also in other words, if the route from city &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to city &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; has a capacity of 5 oranges then we can’t ship more than 5 oranges on this route. 
&lt;br /&gt;&lt;br /&gt;
(2) &lt;b&gt;Flow Conservation:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u \in V - \{s,t\}&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the total flow coming into &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is equal to the total flow leaving &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;. Also in other words, citities can’t withhold oranges. If the number of oranges coming in city &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is 15 then the number of oranges leaving &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; must equal to 15 (5 to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, 8 to &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and 2 to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;).
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 The Maximum Flow Problem&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;!--
Let $$|f|$$ be the flow value defined as
&lt;div center&gt;
$$
\begin{align*}
|f| = \sum_{v \in V}f(s,v) = \sum_{v \in V} f(v,s)
\end{align*}
$$
&lt;/div&gt;
In other words, the flow value is the total flow coming out of the source minus the total flow coming into the source. 
--&gt;

&lt;p&gt;In the maximum-flow problem we are given a flow network &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with a source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and a sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; and we are asked to find the maximum flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. In the above graph the current flow is 15 oranges from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;, can we do better?
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Greedy Approach&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
One greedy approach we might try is to push as much flow as possible starting from the source node. This approach will not work. Suppose we have the below graph &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now suppose we apply the greedy strategy. We generate the flow below.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This flow is not optimal. In order to find the optimal flow we need to have a way to reduce the amount we’re pushing on &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; and then push more instead on &lt;script type=&quot;math/tex&quot;&gt;(s,b)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How do implement this or keep track of the original edges and edges where want to reverse the flow? That’s where Ford-Fulkerson comes (at least that’s where I knew about it first). We instead create a &lt;i&gt;residual graph&lt;/i&gt; which we’ll define formally next. Residual graphs provide a way for us to augment paths in the original graph with more flow or reverse the flow we pushed to create more flow in other paths.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Residual Graphs&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a flow network with source &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and sink &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; be a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. For any vertices &lt;script type=&quot;math/tex&quot;&gt;u,v \in V&lt;/script&gt;. The &lt;b&gt;residual capacity&lt;/b&gt; &lt;script type=&quot;math/tex&quot;&gt;c_f(u,v)&lt;/script&gt; by
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 c_f(u,v) = \Bigg \{ \begin{array}{@{}lr@{}}
                     c(u,v) - f(u,v)   \text{ if} (u,v) \in E,\\
                     f(v,u) \text{ if} (v,u) \in E, \\
					 0  \text{ otherwise.}
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The &lt;b&gt;residual network&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; induced by &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;G_f=(V,E_f)&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;E_f = \{(u,v) \in V \times V : c_f(u,v) &gt; 0\}&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Creating a Residual Graph&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Based on the formal definition above, we want to consider all possible pairs of vertices (&lt;script type=&quot;math/tex&quot;&gt;V*(V-1)&lt;/script&gt; different pairs) and evaluate the formal definition. For example, in the following graph &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, let’s consider what happens to vertices &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/flow/fix2.png&quot; width=&quot;100%&quot; /&gt;
We first consider the pair &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;(a,t) \in E&lt;/script&gt;. Therefore, we create a new edge in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; with capacity &lt;script type=&quot;math/tex&quot;&gt;c_f(a,t) = c(a,t) - f(a,t) = 7 - 2 = 5&lt;/script&gt;. This just means that we can still possibly push 5 oranges on this path.
&lt;img src=&quot;http://localhost:4000/assets/flow/at1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We next consider the pair &lt;script type=&quot;math/tex&quot;&gt;(t,a)&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;(t,a) \not\in E&lt;/script&gt;. Therefore, we create a new edge in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; with capacity &lt;script type=&quot;math/tex&quot;&gt;c_f(t,a) = f(a,t) = 2&lt;/script&gt;. This means that if we decide to push two oranges on this path then this really means that we decreased the flow in the original graph by 2 oranges.
&lt;img src=&quot;http://localhost:4000/assets/flow/at2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We repeat the process for all pairs to generate the following graph. (Remember that we omit edges with capacities 0 (they are implied)).
&lt;img src=&quot;http://localhost:4000/assets/flow/gf.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Augmenting Paths&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
So now that we have a graph &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with some flow &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and it’s residual graph &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;, we can talk about flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. The gist or  intuition is that whatever flow we can send from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; will result in additional flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. How and why this works?
&lt;br /&gt;&lt;br /&gt;
First, define &lt;script type=&quot;math/tex&quot;&gt;f \uparrow f'&lt;/script&gt; as the augmentation of flow &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;f'&lt;/script&gt; to be a function from &lt;script type=&quot;math/tex&quot;&gt;V \times V&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; where&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 (f \uparrow f')(u,v) = \Bigg \{ \begin{array}{@{}lr@{}}
                     f(u,v) + f'(u,v) - f'(v,u)   \text{ if} (u,v) \in E,\\
					 0  \text{ otherwise.}
        \end{array}
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;Based on this, we claim the following:&lt;br /&gt;&lt;br /&gt;
Lemma: &lt;script type=&quot;math/tex&quot;&gt;|f \uparrow f'| = |f| + |f'|&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Proof in CLRS but basically we need to verify that &lt;script type=&quot;math/tex&quot;&gt;f \uparrow f'&lt;/script&gt; obeys the capacity constraint and flow conversation in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and then prove that both are equal.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 The Ford-Fulkerson’s Method&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
Ford-Fulkerson starts with &lt;script type=&quot;math/tex&quot;&gt;f(u,v)=0&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; and incrementally increases the flow value. It does so by finding an augmenting path in the residual network &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;?&lt;/p&gt;

&lt;p&gt;This what Ford-Fulerkson is essentially doing. We will augment flow
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ford&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fulkerson&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Initialize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;residual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gf&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;have&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;augmenting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;augment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes on chapter 26 in CLRS. 1 Introduction Suppose we want to ship oranges from NYC to SF because we have a current shortage of oranges in SF. We want to ship as many oranges as possible. Everything needs to be shipped by ground. We have different routes of different capacities. The total number of oranges that enter a city , must be equal to the number of the oranges leaving city . In other words, cities can’t withhold oranges. We want to find the maximum number of oranges we can ship to SF. How can we solve can this problem? Let’s start by modeling this problem. 2 Anatomy of a Flow Network A flow network is a directed graph where We have two distinguished vertices, the source vertex and the sink vertex . Each edge has a non-negative capacity . (edge capacities are in black above) If we have edge then we must have . For any vertex , . If , then we can assume that . is connected and so . 3 What is Flow? Let be the flow from vertex to vertex (marked in purple above). A flow is a real valued function that satisfies: (1) Capacity constraint: For all , we require $$ \begin{align*} 0 \leq f(u,v) \leq c(u,v) \end{align*} $$ In other words, the flow on every edge must not exceed its capacity. Also in other words, if the route from city to city has a capacity of 5 oranges then we can’t ship more than 5 oranges on this route. (2) Flow Conservation: For all , we require $$ \begin{align*} \sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v) \end{align*} $$ In other words, the total flow coming into is equal to the total flow leaving . Also in other words, citities can’t withhold oranges. If the number of oranges coming in city is 15 then the number of oranges leaving must equal to 15 (5 to , 8 to and 2 to ). 4 The Maximum Flow Problem</summary></entry><entry><title type="html">Worst Case vs Expected Case vs Average Case</title><link href="http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case.html" rel="alternate" type="text/html" title="Worst Case vs Expected Case vs Average Case" /><published>2019-07-19T07:01:36-07:00</published><updated>2019-07-19T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
(1) Class study notes from http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
(2) CLRS (Chapter 5)
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
These are my notes on Chapter 5. I got really confused the first time I read chapter 5 and definitely had to re-read several parts multiple times.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Average Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs. In, CLRS 5.2, we perform an expected-runtime over the average input is performed 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Worst Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we take the worst possible input and then analyze the running time of our algorithm against this input However the adversary here also chooses the randomness of the algorithm so even though QuickSort . For example, to build a binary search tree, the worst possible input is a sorted array. Insert an element in a binary search tree takes &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; and when the array is sorted. The height of the tree is &lt;script type=&quot;math/tex&quot;&gt;(n)&lt;/script&gt;. Therefore, building a binary search tree will require &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Average Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs and therefore it is called an average case analysis.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Worst Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we take the worst possible input and then analyze the running time of our algorithm against this input. For example, to build a binary search tree, the worst possible input is a sorted array. We know the running time in
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Expected Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
 we must use knowledge of, or make assumptions about, the distribution of the inputs. Then we analyze our algorithm, computing an average-case running time, where we take the average over the distribution of the possible inputs. Thus we are, in effect, averaging the running time over all possible inputs. When reporting such a running time, we will refer to it as the average-case running time.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;</content><author><name></name></author><summary type="html">0 References (1) Class study notes from http://web.stanford.edu/class/cs161/schedule.html (2) CLRS (Chapter 5) Introduction These are my notes on Chapter 5. I got really confused the first time I read chapter 5 and definitely had to re-read several parts multiple times. Average Case Running Time In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs. In, CLRS 5.2, we perform an expected-runtime over the average input is performed Worst Case Running Time In this case, we take the worst possible input and then analyze the running time of our algorithm against this input However the adversary here also chooses the randomness of the algorithm so even though QuickSort . For example, to build a binary search tree, the worst possible input is a sorted array. Insert an element in a binary search tree takes and when the array is sorted. The height of the tree is . Therefore, building a binary search tree will require . Average Case Running Time In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs and therefore it is called an average case analysis. Worst Case Running Time In this case, we take the worst possible input and then analyze the running time of our algorithm against this input. For example, to build a binary search tree, the worst possible input is a sorted array. We know the running time in Expected Case Running Time we must use knowledge of, or make assumptions about, the distribution of the inputs. Then we analyze our algorithm, computing an average-case running time, where we take the average over the distribution of the possible inputs. Thus we are, in effect, averaging the running time over all possible inputs. When reporting such a running time, we will refer to it as the average-case running time.</summary></entry><entry><title type="html">Merge Sort Analysis</title><link href="http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html" rel="alternate" type="text/html" title="Merge Sort Analysis" /><published>2019-07-18T07:01:36-07:00</published><updated>2019-07-18T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call &lt;i&gt;MergeSort&lt;/i&gt; again on each half. Once we’re done, we can combine the halfs in &lt;i&gt;Merge&lt;/i&gt;. The follow pesudo-code shows this (Based on CLRS)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;(1) The Recursion Tree Method&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling &lt;i&gt;MergeSort&lt;/i&gt; on each half until we reach the base case. And then we will go all way up calling &lt;i&gt;Merge&lt;/i&gt; in every level until the final &lt;i&gt;Merge&lt;/i&gt; call to combine the two halfs of the array and finally exiting MergeSort.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Level 0:&lt;/i&gt;
&lt;br /&gt;
At the top level, we have the whole input, array &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; of size &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. We will recursively call MergeSort on each half of the &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level 1:&lt;/i&gt;
&lt;br /&gt;
In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/2.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level 2:&lt;/i&gt;
&lt;br /&gt;
In level 2, we will have 4 calls. Each call is on an array of size &lt;script type=&quot;math/tex&quot;&gt;n/4&lt;/script&gt;. We also notice here that the total number of elements is also &lt;script type=&quot;math/tex&quot;&gt;n/4+n/4+n/4+n/4=n&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/3.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;:&lt;/i&gt;
&lt;br /&gt;
At the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th level, we will have &lt;script type=&quot;math/tex&quot;&gt;2^t&lt;/script&gt; calls to MergeSort. Each of the arrays passed to MergeSort is of size &lt;script type=&quot;math/tex&quot;&gt;n/2^t&lt;/script&gt;. Again, the total number of elements is also &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/4.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level ?:&lt;/i&gt;
&lt;br /&gt;
When do we stop dividing/recursively calling MergeSort? Our base case happens when &lt;script type=&quot;math/tex&quot;&gt;first == last&lt;/script&gt;. This means that we stop the recursion when each call has an array of size 1. How many times do we divide &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. &lt;script type=&quot;math/tex&quot;&gt;log_d(n)&lt;/script&gt; is the number of times that we divide &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!)
&lt;br /&gt;&lt;br /&gt;
Therefore, the answer is: at the &lt;script type=&quot;math/tex&quot;&gt;log_2(n)&lt;/script&gt; level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together!
&lt;img src=&quot;http://localhost:4000/assets/merge/5.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
Now let’s climb up the recursion tree. We will assume that Merge performs &lt;script type=&quot;math/tex&quot;&gt;cn&lt;/script&gt; operations where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the size of the array and &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is a positive constant.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Level &lt;script type=&quot;math/tex&quot;&gt;log(n):&lt;/script&gt;&lt;/i&gt;
&lt;img src=&quot;http://localhost:4000/assets/merge/5.png&quot; width=&quot;100%&quot; /&gt;
We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
first &lt; last %]]&gt;&lt;/script&gt; to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; for all calls. 
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Level &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;:&lt;/i&gt;
&lt;img src=&quot;http://localhost:4000/assets/merge/4.png&quot; width=&quot;100%&quot; /&gt;
At the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th level, we have &lt;script type=&quot;math/tex&quot;&gt;2^t&lt;/script&gt; arrays. Each of these arrays is of size &lt;script type=&quot;math/tex&quot;&gt;n/2^t&lt;/script&gt;. We will perform &lt;script type=&quot;math/tex&quot;&gt;n/2^t * c&lt;/script&gt; operations per call. Summing everything, we have &lt;script type=&quot;math/tex&quot;&gt;2^t * n/2^t * c = cn&lt;/script&gt; operations. 
&lt;br /&gt;
&lt;br /&gt;
So at each level we’re doing at most &lt;script type=&quot;math/tex&quot;&gt;cn&lt;/script&gt; operations.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Putting it all together&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let’s now summarize everything in a nice table:
&lt;img src=&quot;http://localhost:4000/assets/merge/final.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;? Well, we have &lt;script type=&quot;math/tex&quot;&gt;log(n)+1&lt;/script&gt; levels and in each level we’re doing &lt;script type=&quot;math/tex&quot;&gt;cn&lt;/script&gt; operations, therefore MergeSort performs &lt;script type=&quot;math/tex&quot;&gt;cn(\log(n)+1)&lt;/script&gt; operations.
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;f(n) = cn(\log(n)+1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;g(n) = n\log(n)&lt;/script&gt;. To see that &lt;script type=&quot;math/tex&quot;&gt;f(n) = O(g(n))&lt;/script&gt;, recall that we need to find &lt;script type=&quot;math/tex&quot;&gt;c', n_0 &gt; 0&lt;/script&gt; such that for all &lt;script type=&quot;math/tex&quot;&gt;n \geq n_0&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;0 \leq f(n) \leq c'g(n)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Choose &lt;script type=&quot;math/tex&quot;&gt;c'=2c&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;n_0=2&lt;/script&gt; and so for all &lt;script type=&quot;math/tex&quot;&gt;n \geq n_0&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c' = 2c&lt;/script&gt; we need to prove:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
0 \leq cn(\log(n)+1) &amp;amp;\leq c'n\log(n) = (2cn)\log(n) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Solving for &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; (&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is positive)&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\log(n)+1 &amp;amp;\leq 2\log(n) \\
\log(n) &amp;amp;\geq 1 \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is certainly true for all &lt;script type=&quot;math/tex&quot;&gt;n \geq 2&lt;/script&gt; and so we are done.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;(2) The Substitution Method&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
TODO&lt;/p&gt;

&lt;!--
Now let's take a step back and forget about the recursion tree. Also assume that we don't know the master theorem. We know that MergeSort divides the input into halfs and performs $$cn$$ operations in Merge. Therefore, we have the following recurrence:
&lt;div center&gt;
$$
\begin{align*}
T(n) = 2T(\frac{n}{2}) + cn
\end{align*}
$$
&lt;/div&gt;
How do we go about solving this? The substituition method says generate a guess and prove it formally by induction! How do we guess the solution? One way is expand the recurrence multiple times to help us find a pattern.
&lt;br&gt;&lt;br&gt;
Let's guess that $$T(n) = O(n\log(n))$$. In order to prove it formally though, we need to find $$c' &gt; 0$$ and $$n_0 &gt; 0$$ such that for all $$n \geq n_0$$, we have $$T(n) \leq c'n\log(n)$$. In order to find $$c'$$, we can &lt;b&gt;substitute&lt;/b&gt; our guess and solve for $$c'$$
&lt;div center&gt;
$$
\begin{align*}
T(n) &amp;= 2T(\frac{n}{2}) + cn \\
&amp;\leq 2c'\frac{n}{2}\log(\frac{n}{2}) + cn \\
&amp;= c'n\log(\frac{n}{2}) + cn \\
&amp;= c'n\log(n)-c'n\log(2) + cn \\
&amp;= c'n\log(n)-c'n + cn \\
&amp;\leq c'n\log(n) + cn \\
\end{align*}
$$
&lt;/div&gt;
--&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS Introduction In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call MergeSort again on each half. Once we’re done, we can combine the halfs in Merge. The follow pesudo-code shows this (Based on CLRS) MergeSort(A, first, last) { if (first &amp;lt; last) { mid = floor((first+last)/2) MergeSort(A,first,mid) MergeSort(A,mid+1,last) Merge(A,first,mid,last) } } (1) The Recursion Tree Method How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling MergeSort on each half until we reach the base case. And then we will go all way up calling Merge in every level until the final Merge call to combine the two halfs of the array and finally exiting MergeSort. Level 0: At the top level, we have the whole input, array of size . We will recursively call MergeSort on each half of the . Level 1: In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still . Level 2: In level 2, we will have 4 calls. Each call is on an array of size . We also notice here that the total number of elements is also . Level : At the ‘th level, we will have calls to MergeSort. Each of the arrays passed to MergeSort is of size . Again, the total number of elements is also . Level ?: When do we stop dividing/recursively calling MergeSort? Our base case happens when . This means that we stop the recursion when each call has an array of size 1. How many times do we divide by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. is the number of times that we divide by to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!) Therefore, the answer is: at the level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together! Now let’s climb up the recursion tree. We will assume that Merge performs operations where is the size of the array and is a positive constant. Level We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is for all calls. Level : At the ‘th level, we have arrays. Each of these arrays is of size . We will perform operations per call. Summing everything, we have operations. So at each level we’re doing at most operations. Putting it all together Let’s now summarize everything in a nice table: So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size ? Well, we have levels and in each level we’re doing operations, therefore MergeSort performs operations. Let and . To see that , recall that we need to find such that for all , we have</summary></entry><entry><title type="html">Binary Heaps</title><link href="http://localhost:4000/jekyll/update/2019/07/12/binary-heaps.html" rel="alternate" type="text/html" title="Binary Heaps" /><published>2019-07-12T07:01:36-07:00</published><updated>2019-07-12T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/12/binary-heaps</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/12/binary-heaps.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes / summary on chapter 6 in CLRS.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/heaps/1.png&quot; width=&quot;100%&quot; /&gt;
The heap data structure is an array &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; that can be viewed as an almost complete binary tree. Each node in the tree is represented by an element in the array. &lt;script type=&quot;math/tex&quot;&gt;A[1]&lt;/script&gt; is the root of the tree. In the above tree, &lt;script type=&quot;math/tex&quot;&gt;A[1]=17&lt;/script&gt; is the root of the tree.
&lt;br /&gt;&lt;br /&gt;
Because the heap is based on a complete binary tree, the height of a heap of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; elements is &lt;script type=&quot;math/tex&quot;&gt;\Theta(\log(n))&lt;/script&gt;. As a reminder, the height of a node is the longest path down from the node to a leaf and the height of the tree is the height of the root of the tree. This observation is crucial in proving that many operations on heaps run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Finding the Parent, Left and Right Children &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Given an element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Its parent is located at &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor i/2 \rfloor]&lt;/script&gt;. For example the parent of 2 (index 7) is &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor 7/2 \rfloor]=A[3]=11&lt;/script&gt;. The left child is &lt;script type=&quot;math/tex&quot;&gt;A[2*i]&lt;/script&gt; and the right child is &lt;script type=&quot;math/tex&quot;&gt;A[2*i+1]&lt;/script&gt;. For example the right child of 13 (index 2) is &lt;script type=&quot;math/tex&quot;&gt;A[2*2 + 1] = A[5] = 3&lt;/script&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we know that i/2 is rounded down so we don't need to floor&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2*i;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2*i+1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;The Heap Property &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;There are two kinds of binary heaps, min heaps and max heaps. Depending on the heap type the array must satisfy a &lt;b&gt;heap property&lt;/b&gt;. The heap property depends on the type of the heap. For any given element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; we must have:&lt;/p&gt;

&lt;p&gt;If this is a max-heap then,&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A[parent(i)] \geq A[i]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If this is a min-heap then,&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A[parent(i)] \leq A[i]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The heap property is crucial. Because of it, we know that the root of the heap must be the smallest or the largest element in the heap and therefore, extracting the minimum or the maximum depending on the heap type can be done in constant time!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Maintaining the Max-Heap Property&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we have an element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; that is smaller than its children. This is a violation of the max-heap property, how do we fix this? First we will assume that both children of &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; maintain the heap property. We know in constant time that the children are &lt;script type=&quot;math/tex&quot;&gt;A[2*i]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;A[2*i+1]&lt;/script&gt;. We can then swap &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; with the larger of the two children. Finally, we recursively call the function on the larger child we just swapped at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Let’s look at a simple implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) check if the left child is greater&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) check if the right child is greater&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if one of the children is greater, swap it&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// with i and then call heapify again on the child&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we swapped with&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How long does max_heapify take? Well, in the worst case, we will go down all the way to a leaf and so the runtime is &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;O(log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Building a Max-Heap&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Based on how we store the heap elements in the array, the leaves of the tree are located stating at &lt;script type=&quot;math/tex&quot;&gt;A[n/2+1], A[n/2+2],...,n&lt;/script&gt;. (proof?). Therefore, if we go over the remaining nodes in the tree and ran max-heapify, it will be enough to gaurantee that every element of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; maintains the heap property. Therefore, we can use the following to build a max-heap:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;build_max_heap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Building a Max-Heap (Example)&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let’s look at an example of building a max-heap using the above idea. We’re given the following array and we want to build a max-heap out of it.
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/heaps/e1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
To build a max-heap we’ll only consider the non-leaf nodes, highlighted below.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e2.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
We’ll start with node 5 and call max_heapify on it. In max_heapify, we’ll swap both nodes 5 and 11. We will then recusively call max_heapify node 5.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e3.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Notice that node 5 is now a leaf node so we can’t push it further down the tree and so we’ll move to the next node, node 3. 
&lt;img src=&quot;http://localhost:4000/assets/heaps/e4.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Node 3 above will be swapped with the larger of its children, node 13.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e5.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Notice how nodes 3 and 13 are now swapped. Next we will recursively call max_heapify on node 3 but node 3 is a just a leaf node and we will stop. The final node in the build_max_heap for loop is node 1.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e6.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
We will swap node 1 with the larger of its children, node 13.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e7.png&quot; width=&quot;100%&quot; /&gt;
We will then recusively call max_heapify on node 1.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e8.png&quot; width=&quot;100%&quot; /&gt;
And finally we will swap 1 with the larger of its children, node 7.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e9.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Finally, you can see now that the tree/array is a max-heap:
&lt;img src=&quot;http://localhost:4000/assets/heaps/e10.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Building a Max-Heap (Proof of Correctness)&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Why should we believe that build_max_heap works? This is going to be exactly what’s in CLRS (my notes for myself to quickly remember). We’ll show that it works by proving that the following loop invariant is maintained prior to the first iteration, before each iteration and when the loop terminates.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;At the start of each iteration of the for loop in build_max_heap, each node &lt;script type=&quot;math/tex&quot;&gt;i+1, i+2, ..., n&lt;/script&gt; is the root of a max_heap.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;b&gt;Initialization&lt;/b&gt;:
Before the first iteration that starts at &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor n/2 \rfloor]&lt;/script&gt;, the nodes &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor n/2 \rfloor + 1], A[\lfloor n/2 \rfloor + 2],...A[n]&lt;/script&gt; are leaf nodes and therefore each node is a root of a max-heap.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Maintenance&lt;/b&gt;: (so the gist here is that max_heapify will maintain that node &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; follows the heap property because indices &lt;script type=&quot;math/tex&quot;&gt;2*i, 2*i+1&lt;/script&gt; are higher than &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and therefore already maintain the heap property).
&lt;br /&gt;
At each iteration, we call max-heapify on the node &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. The children of node &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; are &lt;script type=&quot;math/tex&quot;&gt;A[2*i]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;A[2*i+1]&lt;/script&gt;. Since they both have a higher index than &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; then this means that both of these nodes are already roots of max-heaps by the loop invariant. Recall that max_heapify requires that the children maintain the heap property. Also we know that max_heapify maintains the heap property for any nodes to follow &lt;script type=&quot;math/tex&quot;&gt;i+1, i+2, ..., n&lt;/script&gt;. Therefore, when we decrement &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;, the loop invariant will be established before the next iteration.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Termination&lt;/b&gt;:
At termination when &lt;script type=&quot;math/tex&quot;&gt;i=0&lt;/script&gt;, we know by the loop invariant that the nodes &lt;script type=&quot;math/tex&quot;&gt;1, 2,...,n&lt;/script&gt; are all roots of max-heaps, specifically node &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; which is the root of the final max heap we have. So we are done.
&lt;br /&gt;
&lt;br /&gt;
I would obviously recommend looking at CLRS’s way unless I’m in a rush and this is easily accessible on my phone. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Building a Max-Heap (Running Time)&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
The most exciting question is how long does it take to build a max heap? We know that max_heapify takes &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time for each node. We also know that we at most have &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; iterations. This means that building a max heap will run in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;. But we derive a much tighter bound than this by observing that:
&lt;br /&gt;&lt;br /&gt;
(1) Binary heaps with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; nodes have height &lt;script type=&quot;math/tex&quot;&gt;\lfloor \log(n) \rfloor&lt;/script&gt;. &lt;br /&gt;
(2) At any height &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;, we have at most &lt;script type=&quot;math/tex&quot;&gt;\lceil \frac{n}{2^{i+1}} \rceil&lt;/script&gt; nodes. &lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Aside: What does (2) mean? Suppose we have a binary heap with &lt;script type=&quot;math/tex&quot;&gt;n=7&lt;/script&gt; just like the tree below:
&lt;img src=&quot;http://localhost:4000/assets/heaps/2.png&quot; width=&quot;100%&quot; /&gt;
The number of nodes at height 0 (leaves) is &lt;script type=&quot;math/tex&quot;&gt;\lceil \frac{n}{2^{i+1}} \rceil = \lceil \frac{7}{2^{0+1}} \rceil = \lceil 3.5 \rceil = 4&lt;/script&gt; &lt;br /&gt;
The number of nodes at height 1 is &lt;script type=&quot;math/tex&quot;&gt;\lceil \frac{7}{2^{2}} \rceil= 2&lt;/script&gt; &lt;br /&gt;
The number of nodes at height 2 (root) is &lt;script type=&quot;math/tex&quot;&gt;\lceil \frac{7}{2^{3}} \rceil= 1&lt;/script&gt; &lt;br /&gt;
&lt;b&gt;Formal Proof:&lt;/b&gt;&lt;br /&gt;
TODO
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
We can now sum the work we’re doing at each level which is just the height of the level multipled by the number of nodes in that level. We do that for each level in the tree, from the 0th level to the &lt;script type=&quot;math/tex&quot;&gt;\lfloor \log(n) \rfloor&lt;/script&gt;’s level:&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=0}^{\lfloor \log(n) \rfloor} \lceil \frac{n}{2^{i+1}} \rceil O(i) = O(n\sum_{i=0}^{\lfloor \log(n) \rfloor} \frac{i}{2^{i}} )
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We can use the following summation:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{k=0}^{\infty} kx^k = \frac{x}{(1-x)^2}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;By substituting &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt; to get:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{k=0}^{\infty} \frac{k}{2^k} = \frac{1/2}{(1-1/2)^2} = \frac{1}{2(1/4)} = 2
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And therefore, we can bound the earlier summation to just:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
O(n\sum_{i=0}^{\lfloor \log(n) \rfloor} \frac{i}{2^{i}} ) = O(n)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;and we’re done!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Heapsort&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
TODO&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes / summary on chapter 6 in CLRS. Introduction The heap data structure is an array that can be viewed as an almost complete binary tree. Each node in the tree is represented by an element in the array. is the root of the tree. In the above tree, is the root of the tree. Because the heap is based on a complete binary tree, the height of a heap of elements is . As a reminder, the height of a node is the longest path down from the node to a leaf and the height of the tree is the height of the root of the tree. This observation is crucial in proving that many operations on heaps run in time. Finding the Parent, Left and Right Children Given an element . Its parent is located at . For example the parent of 2 (index 7) is . The left child is and the right child is . For example the right child of 13 (index 2) is .</summary></entry></feed>