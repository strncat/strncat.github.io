---
layout: post
title:  "Cycles in Graphs"
date:   2019-07-09 12:01:36 -0700
categories: jekyll update
mathjax: true
---
<!--
<b>0 References</b><br>
?
<br>
<br>
<hr>
<br>
-->

<b>1 Introduction</b>
<br>
![my photo]({{ site.url }}/assets/cycle/1.png)

We are given a graph $$G = (V,E)$$ and we want to know if there exists a cycle in $$G$$. 

<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>2 Undirected Graphs</b>
<br>
<br>
This is extremely simple. We already keep track of nodes visited so far. If it happens during our search that we come across a visited node then we're done! there must exists a cycle otherwise, we won't ever re-visit any vertex in $$G$$. 
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>3 Directed Graph</b>
<br>
If we think about this case carefully, we'll see that it's simple. Let's think of this in terms of the tree generated by DFS. 


<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>4 Implementation</b>
<br>
{% highlight c++ %}
void dfs(graph& g, int v, int *color, std::stack<int> &ordered) {
    color[v] = gray;
    for (auto i = 0; i < g[v].size(); i++) {
        int u = g[v][i];
        if (color[u] == black) {
            dfs(g, u, color, ordered);
        } else if (color[u] == gray) {
            // CYCLE
        }
    }
    color[v] = white;
    ordered.push(v); // node is done, we can push it on the ordered stack
}
{% endhighlight %}
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>7 Full Implementation</b>
<br>
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/cycles
<br>
<br>


