---
layout: post
title:  "Breadth First Search"
date:   2019-06-20 12:01:36 -0700
categories: jekyll update
mathjax: true
---
<b>0 References</b><br>
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>1 Introduction</b>
<br>
![my photo]({{ site.url }}/assets/bfs/bfs1.png)

Breadth first search is a useful and widely used algorithm in graph traversal problems. Let $$G = (V, E)$$ be a graph consisting of $$V$$ vertices and $$E$$ edges and let $$s$$ be the source vertex where we will start the traversal from. The key thing about breadth first search is that it explores the vertices closest (in terms of the number of edges) to the source vertex first. We start by looking at $$s$$'s neighbors. These vertices are the closest vertices to $$s$$ and have distance 1 from $$s$$. We then explore each adjacent vertex to all the neighbors. Any vertex adjacent to these vertices will have distance 2 and so on.
<br><br>
In other words, breadth first search explores the graph in layers. The immediate neighbors are in layer 1 and have distance 1 to the source vertex. The vertices in layer 2 have distance 2 to the source vertex and so on. Given a layer, all the vertices in that layer have the same distance to the source vertex. It turns out that breadth first search also finds the the shortest paths from the $$s$$ to every other vertex in the graph in terms of the number of edges between $$s$$ and each vertex. We'll prove this more formally later!
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>2 Data Structures</b>
<br>
To perform a breadth first search, we will maintain the following data structures:
<br>
(1) A queue. We want to explore the nodes closest to $$s$$ first. We know that a queue maintains the property that a node inserted first will be popped/explored first. We will also use the queue to keep track of the distance of each vertex to $$s$$. Initially we will enqueue $$s$$ with distance 0. When we enqueue new nodes, we will also enqueue their distance to $$s$$ which is just their parent's distance plus 1.
<br><br>
(2) A set or an array that keeps track of the visited nodes. Remember that $$G$$ might contain cycles and so we want to make sure that we explore each node once only.
<br><br>
(3) A set or an array that keeps track of the parent nodes. This is optional and only needed if we want to recover the path from $$s$$ to every other node in $$G$$.
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>3 Example</b>
<br>
Let's explore the graph above. We will start by popping $$s$$ from the queue with its distance 0. We will then enqueue the neighbors of $$s$$ along with distance 1 and also mark them visited. We could also use the parent array to indicate that $$s$$ is the parent of $$a$$ and $$b$$. At this point, we have $$a$$ and $$b$$ in layer 1 with distance 1. We also marked their parent $$s$$ correctly. This information will not change in any future iteration. 

![my photo]({{ site.url }}/assets/bfs/bfs2.png)

Next we will we will pop $$a$$ from the queue. We will traverse $$a$$'s neighbors $$s$$ and $$c$$ but $$s$$ will be ignored since it was visited before. When we add $$c$$ to the queue, we will also push distance 2 which indicates that $$c$$ is in layer 2 or is two steps away from $$s$$. We also mark $$c$$'s parent as $$a$$. Next we will we will pop $$b$$ from the queue and repeat the same process and push $$d$$ on the queue with distance 2. $$c$$ and $$d$$ are colored in green below to indicate that they are in a new layer (distance = 2).

![my photo]({{ site.url }}/assets/bfs/bfs3.png)


We will repeat the same process until the queue is empty and we have reached every node reachable from $$s$$.

![my photo]({{ site.url }}/assets/bfs/bfs4.png)

Notice now how the nodes are organized in layers in terms of the distance from $$s$$ (number of edges).

![my photo]({{ site.url }}/assets/bfs/bfs5.png)
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>4 Implementation</b>
<br>
{% highlight c++ %}
int bfs(int start, int end, std::vector<std::vector<int>>& graph) {
    std::queue<int> q;
    q.push(start);
    // another queue to push the distances down (bfs works in layers)
    std::queue<int> qd;
    qd.push(0);
    // visited array so we don't revisit nodes
    std::vector<int> visited(graph.size(), false);
    visited[start] = true;
    // parent array to print the path
    std::vector<int> parent(graph.size(), -1);
    int d = 0;
    while (!q.empty()) {
        int v = q.front();
        d = qd.front();
        qd.pop();
        q.pop();
        if (v == end) {
            break;
        }
        for (int i = 0; i < graph[v].size(); i++) {
            int u = graph[v][i];
            if (visited[u] == false) {
                q.push(u);
                parent[u] = v;
                visited[u] = true;
                qd.push(d+1);
            }
        }
    }
    // print path (reversed)
    while (end != -1) {
        printf("%d ", end);
        end = parent[end];
    }
    printf("\n");
    return d;
}
{% endhighlight %}
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>5 Proof</b>
<br>
Why does BFS find the shortest paths from $$s$$ to every other vertex in $$G$$? Intuitively, we know that we explore the vertices in layers starting at $$s$$. So if we have a vertex $$x$$ in layer $$j$$ then we know the distance to $$s$$ is just $$j$$ and that $$x$$ can't have a shorter path to $$s$$ simply because we would have found $$x$$ in an earlier layer, right? Let's make this formal.
<br>
<br>
<b>Inductive Hypothesis:</b><br>
Let $$G = (V,E)$$ be a graph and $$s$$ be the source vertex. Let $$i$$ and $$j$$ be natural numbers. For all $$i < j$$, the vertices in layer $$L_i$$ have distance $$i$$ from $$s$$. 
<br>
<br>
<b>Base Case:</b><br>
For $$j=0$$, we know that $$L_0=\{s\}$$ and we know that $$s$$ has distance 0 from $$s$$ so we're done.
<br>
<br>
<b>Inductive Step:</b><br>
Let $$i$$ and $$k$$ be natural numbers and suppose that for all $$i < k$$, the vertices in layer $$L_i$$ have distance $$i$$ from $$s$$. We want to prove that all vertices in layer $$L_{k}$$ have distance $$i+1=k$$ from $$s$$.
<br><br>
Let $$w$$ be a vertex in $$L_k$$. We must have $$dist(s,w) \leq k$$. This is because by the inductive hypothesis, we know that $$w$$'s parent is in $$L_{k-1}$$ and therefore has distance $$k-1$$ from $$s$$. Therefore, we know there is a path from $$s$$ to $$w$$ of length $$k$$.
<br><br>
Next we need to prove that $$dist(s,w) \geq k$$. Suppose not and that $$dist(s,w) < k$$. This means that $$w$$ must have show up in an earlier layer but we know that it's impossible and $$w$$ was only discovered after its parent was discovered in layer $$k-1$$. 
<br><br>
Since $$dist(s,w) \leq k$$ and $$dist(s,w) \geq k$$ then we must have $$dist(s,w)=k$$ as we wanted to show.
<br>
<br>
<b>Conclusion:</b><br>
For all vertices $$w \in V$$, if $$w \in L_j$$, then $$dist(s,w) = j$$.
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>6 Proof (Take 2) (The CLRS Way)</b>
<br>
 I really really really want to go through the CLRS way of doing this proof formally. This is a TODO! (starts in page 598)
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>6 Running Time</b>
<br>
We visit each vertex at most once only because of the visited array we're maintaining. That's $$O(V)$$ time. As a result, we also visit the adjacency list of each vertex at most once and that's $$O(E)$$. Therefore, the total time is $$O(V+E)$$.
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>7 Full Implementation:</b> 
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/breadth-first-search
<br>
<br>


