<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>10069 - Distinct Subsequences | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="10069 - Distinct Subsequences" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Solution To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”. $$ c[p] = \sum_i\left\{\begin{array}{@{}lr@{}} \sum_{j &lt; i}c[p_0...p_{i-1}] &amp; \text{if }x_i = p_i\\ 0 &amp; \text{otherwise} \end{array}\right\} $$ Why does this work? Let be a string and let be the string we want to count the occurences of in . Let be the length of . Assume that we know the optimal count of in and suppose toward a contradiction that the count of is not optimal. Since there are more ocurrences of , then naturally this means that there are more ocurrences of . This is a contradiction because we assumed that the number of occurrences of is optimal. Therefore our solution must be optimal. Implementation Details Base Case: Let be a string and let be the string that we are looking for. We initialize an array to store 1 if we see in otherwise, we store 0." />
<meta property="og:description" content="Solution To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”. $$ c[p] = \sum_i\left\{\begin{array}{@{}lr@{}} \sum_{j &lt; i}c[p_0...p_{i-1}] &amp; \text{if }x_i = p_i\\ 0 &amp; \text{otherwise} \end{array}\right\} $$ Why does this work? Let be a string and let be the string we want to count the occurences of in . Let be the length of . Assume that we know the optimal count of in and suppose toward a contradiction that the count of is not optimal. Since there are more ocurrences of , then naturally this means that there are more ocurrences of . This is a contradiction because we assumed that the number of occurrences of is optimal. Therefore our solution must be optimal. Implementation Details Base Case: Let be a string and let be the string that we are looking for. We initialize an array to store 1 if we see in otherwise, we store 0." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-27T12:01:36-07:00" />
<script type="application/ld+json">
{"description":"Solution To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”. $$ c[p] = \\sum_i\\left\\{\\begin{array}{@{}lr@{}} \\sum_{j &lt; i}c[p_0...p_{i-1}] &amp; \\text{if }x_i = p_i\\\\ 0 &amp; \\text{otherwise} \\end{array}\\right\\} $$ Why does this work? Let be a string and let be the string we want to count the occurences of in . Let be the length of . Assume that we know the optimal count of in and suppose toward a contradiction that the count of is not optimal. Since there are more ocurrences of , then naturally this means that there are more ocurrences of . This is a contradiction because we assumed that the number of occurrences of is optimal. Therefore our solution must be optimal. Implementation Details Base Case: Let be a string and let be the string that we are looking for. We initialize an array to store 1 if we see in otherwise, we store 0.","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html","headline":"10069 - Distinct Subsequences","dateModified":"2019-03-27T12:01:36-07:00","datePublished":"2019-03-27T12:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">10069 - Distinct Subsequences</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-27T12:01:36-07:00" itemprop="datePublished">Mar 27, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><b>Solution</b>
<br />
To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”.
<br />
<!-- try \Big\{  only --></p>
<div center="">
$$
 c[p] = \sum_i\left\{\begin{array}{@{}lr@{}}
        \sum_{j &lt; i}c[p_0...p_{i-1}] &amp; \text{if }x_i = p_i\\
        0                       &amp; \text{otherwise} 
        \end{array}\right\}
$$
</div>
<p><br />
<br />
<b>Why does this work?</b>
<br />
Let <script type="math/tex">s</script> be a string and let <script type="math/tex">p</script> be the string we want to count the occurences of in <script type="math/tex">s</script>. Let <script type="math/tex">n</script> be the length of <script type="math/tex">p</script>. Assume that we know the optimal count of <script type="math/tex">p_0...p_{n-1}</script> in <script type="math/tex">s</script> and suppose toward a contradiction that the count of <script type="math/tex">p_0...p_{n}</script> is not optimal. Since there are more ocurrences of <script type="math/tex">p_0...p_{n-1}</script>, then naturally this means that there are more ocurrences of <script type="math/tex">p_0...p_{n}</script>. This is a contradiction because we assumed that the number of occurrences of <script type="math/tex">p_0...p_{n-1}</script> is optimal. Therefore our solution must be optimal.
<br />
<br />
<b>Implementation Details</b>
<br />
Base Case: Let <script type="math/tex">s</script> be a string and let <script type="math/tex">p</script> be the string that we are looking for. We initialize an array <script type="math/tex">c</script> to store 1 if we see <script type="math/tex">p[0]</script> in <script type="math/tex">s</script> otherwise, we store 0.</p>

<table>
  <thead>
    <tr>
      <th>b</th>
      <th>a</th>
      <th>b</th>
      <th>g</th>
      <th>b</th>
      <th>a</th>
      <th>g</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </tbody>
</table>

<p>From this point, we iterate through <script type="math/tex">p</script> starting at index <script type="math/tex">i=1</script> and apply the above recurrence. At each step we need row “i-1” to produce row “i”. Instead of maintaining two arrays or a two dimensional array, we simply maintain a sum variable to keep track of the sum of the previous row and also reset the cells as we go. 
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// starting matching p[i] at i</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">bignum</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">temp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
		<span class="n">c</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<b>Example</b>
<br /></p>

<table>
  <thead>
    <tr>
      <th> </th>
      <th>b</th>
      <th>a</th>
      <th>b</th>
      <th>g</th>
      <th>b</th>
      <th>a</th>
      <th>g</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>i=0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <td>i=1</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>3</td>
      <td>0</td>
    </tr>
    <tr>
      <td>i=2</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>4</td>
    </tr>
  </tbody>
</table>


  </div><a class="u-url" href="/jekyll/update/2019/03/27/10069-distinct-subsequences.html" hidden></a>
</article>
		 
      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
