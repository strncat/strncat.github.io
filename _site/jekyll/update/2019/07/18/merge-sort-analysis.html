<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Merge Sort Analysis | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Merge Sort Analysis" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS Introduction In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call MergeSort again on each half. Once we’re done, we can combine the halfs in Merge. The follow pesudo-code shows this (Based on CLRS) MergeSort(A, first, last) { if (first &lt; last) { mid = floor((first+last)/2) MergeSort(A,first,mid) MergeSort(A,mid+1,last) Merge(A,first,mid,last) } } (1) The Recursion Tree Method How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling MergeSort on each half until we reach the base case. And then we will go all way up calling Merge in every level until the final Merge call to combine the two halfs of the array and finally exiting MergeSort. Level 0: At the top level, we have the whole input, array of size . We will recursively call MergeSort on each half of the . Level 1: In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still . Level 2: In level 2, we will have 4 calls. Each call is on an array of size . We also notice here that the total number of elements is also . Level : At the ‘th level, we will have calls to MergeSort. Each of the arrays passed to MergeSort is of size . Again, the total number of elements is also . Level ?: When do we stop dividing/recursively calling MergeSort? Our base case happens when . This means that we stop the recursion when each call has an array of size 1. How many times do we divide by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. is the number of times that we divide by to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!) Therefore, the answer is: at the level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together! Now let’s climb up the recursion tree. We will assume that Merge performs operations where is the size of the array and is a positive constant. Level We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is for all calls. Level : At the ‘th level, we have arrays. Each of these arrays is of size . We will perform operations per call. Summing everything, we have operations. So at each level we’re doing at most operations. Putting it all together Let’s now summarize everything in a nice table: So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size ? Well, we have levels and in each level we’re doing operations, therefore MergeSort performs operations. Let and . To see that , recall that we need to find such that for all , we have" />
<meta property="og:description" content="0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS Introduction In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call MergeSort again on each half. Once we’re done, we can combine the halfs in Merge. The follow pesudo-code shows this (Based on CLRS) MergeSort(A, first, last) { if (first &lt; last) { mid = floor((first+last)/2) MergeSort(A,first,mid) MergeSort(A,mid+1,last) Merge(A,first,mid,last) } } (1) The Recursion Tree Method How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling MergeSort on each half until we reach the base case. And then we will go all way up calling Merge in every level until the final Merge call to combine the two halfs of the array and finally exiting MergeSort. Level 0: At the top level, we have the whole input, array of size . We will recursively call MergeSort on each half of the . Level 1: In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still . Level 2: In level 2, we will have 4 calls. Each call is on an array of size . We also notice here that the total number of elements is also . Level : At the ‘th level, we will have calls to MergeSort. Each of the arrays passed to MergeSort is of size . Again, the total number of elements is also . Level ?: When do we stop dividing/recursively calling MergeSort? Our base case happens when . This means that we stop the recursion when each call has an array of size 1. How many times do we divide by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. is the number of times that we divide by to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!) Therefore, the answer is: at the level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together! Now let’s climb up the recursion tree. We will assume that Merge performs operations where is the size of the array and is a positive constant. Level We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is for all calls. Level : At the ‘th level, we have arrays. Each of these arrays is of size . We will perform operations per call. Summing everything, we have operations. So at each level we’re doing at most operations. Putting it all together Let’s now summarize everything in a nice table: So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size ? Well, we have levels and in each level we’re doing operations, therefore MergeSort performs operations. Let and . To see that , recall that we need to find such that for all , we have" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-18T07:01:36-07:00" />
<script type="application/ld+json">
{"url":"http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html","headline":"Merge Sort Analysis","dateModified":"2019-07-18T07:01:36-07:00","datePublished":"2019-07-18T07:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html"},"description":"0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS Introduction In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call MergeSort again on each half. Once we’re done, we can combine the halfs in Merge. The follow pesudo-code shows this (Based on CLRS) MergeSort(A, first, last) { if (first &lt; last) { mid = floor((first+last)/2) MergeSort(A,first,mid) MergeSort(A,mid+1,last) Merge(A,first,mid,last) } } (1) The Recursion Tree Method How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling MergeSort on each half until we reach the base case. And then we will go all way up calling Merge in every level until the final Merge call to combine the two halfs of the array and finally exiting MergeSort. Level 0: At the top level, we have the whole input, array of size . We will recursively call MergeSort on each half of the . Level 1: In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still . Level 2: In level 2, we will have 4 calls. Each call is on an array of size . We also notice here that the total number of elements is also . Level : At the ‘th level, we will have calls to MergeSort. Each of the arrays passed to MergeSort is of size . Again, the total number of elements is also . Level ?: When do we stop dividing/recursively calling MergeSort? Our base case happens when . This means that we stop the recursion when each call has an array of size 1. How many times do we divide by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. is the number of times that we divide by to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!) Therefore, the answer is: at the level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together! Now let’s climb up the recursion tree. We will assume that Merge performs operations where is the size of the array and is a positive constant. Level We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is for all calls. Level : At the ‘th level, we have arrays. Each of these arrays is of size . We will perform operations per call. Summing everything, we have operations. So at each level we’re doing at most operations. Putting it all together Let’s now summarize everything in a nice table: So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size ? Well, we have levels and in each level we’re doing operations, therefore MergeSort performs operations. Let and . To see that , recall that we need to find such that for all , we have","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
  
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Merge Sort Analysis</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-07-18T07:01:36-07:00" itemprop="datePublished">Jul 18, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><b>0 References</b>
<br />
<br />
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>Introduction</b>
<br />
<br />
In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call <i>MergeSort</i> again on each half. Once we’re done, we can combine the halfs in <i>Merge</i>. The follow pesudo-code shows this (Based on CLRS)</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">floor</span><span class="p">((</span><span class="n">first</span><span class="o">+</span><span class="n">last</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">mid</span><span class="p">)</span>
        <span class="n">MergeSort</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">last</span><span class="p">)</span>
        <span class="n">Merge</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">first</span><span class="p">,</span><span class="n">mid</span><span class="p">,</span><span class="n">last</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>(1) The Recursion Tree Method</b>
<br />
<br />
How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling <i>MergeSort</i> on each half until we reach the base case. And then we will go all way up calling <i>Merge</i> in every level until the final <i>Merge</i> call to combine the two halfs of the array and finally exiting MergeSort.
<br />
<br />
<i>Level 0:</i>
<br />
At the top level, we have the whole input, array <script type="math/tex">A</script> of size <script type="math/tex">n</script>. We will recursively call MergeSort on each half of the <script type="math/tex">A</script>.
<img src="http://localhost:4000/assets/merge/1.png" width="100%" />
<i>Level 1:</i>
<br />
In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still <script type="math/tex">n</script>.
<img src="http://localhost:4000/assets/merge/2.png" width="100%" />
<i>Level 2:</i>
<br />
In level 2, we will have 4 calls. Each call is on an array of size <script type="math/tex">n/4</script>. We also notice here that the total number of elements is also <script type="math/tex">n/4+n/4+n/4+n/4=n</script>.
<img src="http://localhost:4000/assets/merge/3.png" width="100%" />
<i>Level <script type="math/tex">t</script>:</i>
<br />
At the <script type="math/tex">t</script>‘th level, we will have <script type="math/tex">2^t</script> calls to MergeSort. Each of the arrays passed to MergeSort is of size <script type="math/tex">n/2^t</script>. Again, the total number of elements is also <script type="math/tex">n</script>.
<img src="http://localhost:4000/assets/merge/4.png" width="100%" />
<i>Level ?:</i>
<br />
When do we stop dividing/recursively calling MergeSort? Our base case happens when <script type="math/tex">first == last</script>. This means that we stop the recursion when each call has an array of size 1. How many times do we divide <script type="math/tex">n</script> by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. <script type="math/tex">log_d(n)</script> is the number of times that we divide <script type="math/tex">n</script> by <script type="math/tex">d</script> to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!)
<br /><br />
Therefore, the answer is: at the <script type="math/tex">log_2(n)</script> level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together!
<img src="http://localhost:4000/assets/merge/5.png" width="100%" />
<br />
<br /></p>
<hr />

<p><br />
<br />
Now let’s climb up the recursion tree. We will assume that Merge performs <script type="math/tex">cn</script> operations where <script type="math/tex">n</script> is the size of the array and <script type="math/tex">c</script> is a positive constant.
<br />
<br />
<i>Level <script type="math/tex">log(n):</script></i>
<img src="http://localhost:4000/assets/merge/5.png" width="100%" />
We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if <script type="math/tex">% <![CDATA[
first < last %]]></script> to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is <script type="math/tex">n</script> for all calls. 
<br />
<br />
<br />
<i>Level <script type="math/tex">t</script>:</i>
<img src="http://localhost:4000/assets/merge/4.png" width="100%" />
At the <script type="math/tex">t</script>‘th level, we have <script type="math/tex">2^t</script> arrays. Each of these arrays is of size <script type="math/tex">n/2^t</script>. We will perform <script type="math/tex">n/2^t * c</script> operations per call. Summing everything, we have <script type="math/tex">2^t * n/2^t * c = cn</script> operations. 
<br />
<br />
So at each level we’re doing at most <script type="math/tex">cn</script> operations.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>Putting it all together</b>
<br />
<br />
Let’s now summarize everything in a nice table:
<img src="http://localhost:4000/assets/merge/final.png" width="100%" />
<br />
<br />
So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size <script type="math/tex">n</script>? Well, we have <script type="math/tex">log(n)+1</script> levels and in each level we’re doing <script type="math/tex">cn</script> operations, therefore MergeSort performs <script type="math/tex">cn(\log(n)+1)</script> operations.
<br /><br />
Let <script type="math/tex">f(n) = cn(\log(n)+1)</script> and <script type="math/tex">g(n) = n\log(n)</script>. To see that <script type="math/tex">f(n) = O(g(n))</script>, recall that we need to find <script type="math/tex">c', n_0 > 0</script> such that for all <script type="math/tex">n \geq n_0</script>, we have <script type="math/tex">0 \leq f(n) \leq c'g(n)</script></p>

<p>Choose <script type="math/tex">c'=2c</script> and <script type="math/tex">n_0=2</script> and so for all <script type="math/tex">n \geq n_0</script> and <script type="math/tex">c' = 2c</script> we need to prove:</p>
<div center="">
$$
\begin{align*}
0 \leq cn(\log(n)+1) &amp;\leq c'n\log(n) = (2cn)\log(n) \\
\end{align*}
$$
</div>
<p>Solving for <script type="math/tex">n</script> (<script type="math/tex">n</script> is positive)</p>
<div center="">
$$
\begin{align*}
\log(n)+1 &amp;\leq 2\log(n) \\
\log(n) &amp;\geq 1 \\
\end{align*}
$$
</div>
<p>This is certainly true for all <script type="math/tex">n \geq 2</script> and so we are done.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>(2) The Substitution Method</b>
<br />
<br />
TODO</p>

<!--
Now let's take a step back and forget about the recursion tree. Also assume that we don't know the master theorem. We know that MergeSort divides the input into halfs and performs $$cn$$ operations in Merge. Therefore, we have the following recurrence:
<div center>
$$
\begin{align*}
T(n) = 2T(\frac{n}{2}) + cn
\end{align*}
$$
</div>
How do we go about solving this? The substituition method says generate a guess and prove it formally by induction! How do we guess the solution? One way is expand the recurrence multiple times to help us find a pattern.
<br><br>
Let's guess that $$T(n) = O(n\log(n))$$. In order to prove it formally though, we need to find $$c' > 0$$ and $$n_0 > 0$$ such that for all $$n \geq n_0$$, we have $$T(n) \leq c'n\log(n)$$. In order to find $$c'$$, we can <b>substitute</b> our guess and solve for $$c'$$
<div center>
$$
\begin{align*}
T(n) &= 2T(\frac{n}{2}) + cn \\
&\leq 2c'\frac{n}{2}\log(\frac{n}{2}) + cn \\
&= c'n\log(\frac{n}{2}) + cn \\
&= c'n\log(n)-c'n\log(2) + cn \\
&= c'n\log(n)-c'n + cn \\
&\leq c'n\log(n) + cn \\
\end{align*}
$$
</div>
-->

<p><br />
<br />
<br /></p>


  </div><div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = /jekyll/update/2019/07/18/merge-sort-analysis.html;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier =  /jekyll/update/2019/07/18/merge-sort-analysis; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://strncat-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="u-url" href="/jekyll/update/2019/07/18/merge-sort-analysis.html" hidden></a>
</article>
		 
      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>hello</p>
      </div>
    </div>

  </div>

</footer>
-->

	
  </body>

</html>
