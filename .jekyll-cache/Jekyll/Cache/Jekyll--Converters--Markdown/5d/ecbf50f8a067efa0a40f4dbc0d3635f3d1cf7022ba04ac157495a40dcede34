I"Ö-<!------------------------------------------------------------------------------------>
<h4><b>Convexity</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/conv-0.png" width="100%" class="center" /></p>
<p>A set of points $S$ is convex if for any two points $a \in S$ and $b \in S$, then the line segment connecting these two points is also in $S$ ($\overline{ab} \subseteq S$). A convex polygon is a polygon that is the boundary of a convex set. The left figure is a convex polygon while the right figure is not per our definition.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Convex Hull</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/conv-1.png" width="70%" class="center" /></p>
<p>The convex hull of a set $S={p_1,p_2,‚Ä¶,p_n}$ is the set that contains all the combinations of the points in the $S$,</p>
<div>
$$
\begin{align*}
conv(S) = \{ \sum_{i=1}^{n} \lambda_i p_i | \sum_{i=1}^{n} \lambda_i = 1 \text{ and } \lambda_i \geq 0 \text{ for all $i$} \}
\end{align*}
$$
</div>
<p>We can also define the convex hull of $S$ to be the smallest convex set that contains all the points in $S$ which also implies the definition that the convex hull of $S$ is the intersection of all convex sets containing $S$.</p>
<div>
$$
\begin{align*}
conv(S) = \text{ Intersection of all convex sets containing $S$ }
\end{align*}
$$
</div>
<p>In the figure above for example, the yellow, green and pink sets are all convex sets that contain $S$ but the smallest one is the pink one which is also the intersection of all three. Why does this definition matter? there are infinitely many convex sets that will contain all the points in $S$. It turns out that this definition also works for a special kind of convex sets, called half-planes.</p>
<div>
$$
\begin{align*}
conv(S) = \text{ Intersection of all "half planes" containing $S$ }
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Finding the Convex Hull</b></h4>
<p>Finding the convex hull is a classic computatioal geometry problem and many algorithms have been developed to solve it. Next, we discuss one of the simplest algorithms that is used to find the convex hull of a set of points.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Jarvis's March (Gift Wrapping Algorithm)</b></h4>
<p>Jarvis‚Äôs March is similar to Selection Sort. In each iteration of Selection Sort, we pick the smallest element in the array and then move it to the front. Once we‚Äôre done, we‚Äôll have a sorted array. In Jarvis‚Äôs algorithm, the smallest element in each iteration is the right most vertex relative to the last vertex that was added to the convex hull. We start from some initial vertex in the convex hull and each iteration, we add a new vertex. Once we‚Äôre done, we‚Äôll have the convex hull of our polygon.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>1. Preconditions</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-1.png" width="60%" class="center" /></p>
<p>Initially, we will pick a vertex that we know will be in the hull. We can pick the left most vertex or the bottom most vertex or any vertex where all the points will be on one side (half plane). Let‚Äôs pick the left most vertex and let it be $p_0$. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>2. Picking the Right Most Vertex</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2.png" width="70%" class="center" /></p>
<p>So now that we have a point in the convex hull, we need to proceed by picking the right most vertex relative to $p_0$. How do we determine the right most vertex? Imagine shooting a ray from $p_0$ to each of the remaining vertices. Before iterating over these vertices, we‚Äôll start by labeling the first vertex from this set as ‚Äúright_most‚Äù because it‚Äôs the right most one relative to $p_0$ for now. We will continue iterating through remaining vertices while updating ‚Äúright_most‚Äù whenever we come across a vertex more to the right relative to $p_0$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2a.png" width="85%" class="center" /></p>
<p>In each iteration, we will have the vertex $p_0$ on the hull, the current ‚Äúright most‚Äù vertex so far and the vertex we‚Äôre testing right now $i$. The immediate approach we might think of is just to simply compare the angels right? comparing floating points is a pain. There is actually a much better way that we‚Äôve previously discovered and used when triagulating a polygon. (See Orientation of Three Points). Precisely, we‚Äôve derived an expression to find out whether a point $r$ is on the left or right of the line that goes through two given points $p$ and $q$. We can wrap this expression in the function below.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// determines if r is on the left of the line pq</span>
<span class="kt">int</span> <span class="nf">direction</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">r_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">q_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// anti-clockwise</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// clockwise</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// collinear</span>
<span class="p">}</span></code></pre></figure>

<p>We can then call this function to test if vertex $i$ above is located on the right or left of the line that goes through the segment $\overline{p_0, ‚Äúright most‚Äù}$ below.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2b.png" width="85%" class="center" /></p>
<p>We can see above that $i$ is indeed more to the right of the line and hence more to the right relative to $p_0$. So this means that ‚Äúright most‚Äù vertex will be set to $i$. The figure below illustrates what happens in the next iteration of the for loop.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2c.png" width="75%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Picking the Next Vertex</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-3.png" width="65%" class="center" /></p>
<p>Once we we‚Äôre done with step 2, we know we have arrived at the most to the right vertex relative to $p_0$. We‚Äôll go and add this vertex to the convex hull and label it as $p_1$. We then repeat step 2 to find the most to the right vertex relative to $p_1$ this time around. The pesudo code below shows an outline of what we‚Äôre doing. The outer loop sets the initial ‚Äúright most‚Äù vertex and also adds it to the hull after we‚Äôre done with the inner loop. The inner loop will test all the vertices and update ‚Äúright most‚Äù whenever we find a better vertex.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">while</span> <span class="p">(....)</span> <span class="p">{</span>
    <span class="c1">// 1) let most_right be the first vertex in the remaining vertices</span>
    <span class="c1">// not on the convex hull and call this set S</span>
    <span class="n">most_right</span> <span class="o">=</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1">// 2) iterate through each vertex i and update most_right if</span>
	<span class="c1">// necessary </span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mf">1.</span><span class="p">..</span><span class="n">size</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">orientation</span><span class="p">(</span><span class="n">hull_point</span><span class="p">,</span> <span class="n">most_right</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	        <span class="n">most_right_</span> <span class="o">=</span> <span class="n">i</span>
	    <span class="p">}</span>
	<span class="p">}</span>
    <span class="c1">// step 3: add most_right_ to the convex hull</span>
    <span class="n">convex_hull</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">most_right</span><span class="p">)</span>
	<span class="c1">// most_right is the new hull point for the next iteration</span>
    <span class="n">hull_point</span> <span class="o">=</span> <span class="n">most_right</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>3. Termination</b></h4>
<p>When do we terminate? We terminate when our next right most vertex happens to be our starting point $p_0$. Once we get to this point, then we terminate and return the convex hull points.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-4.png" width="65%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Running Time</b></h4>
<p>How fast is Jarvis‚Äôs March? The inner loop goes over $O(n)$ vertices. The outerloop really depends on the size of the convex hull. If we have $h$ points in the hull, then the running time is $O(h)$. Therefore, the overall running time is $O(hn)$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://jeffe.cs.illinois.edu/teaching/compgeom/schedule.html">CS 498: Computational Geometry</a>
<br />
<br /></p>

:ET