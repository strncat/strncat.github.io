<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-17T10:34:58-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Any Pair of Segments Intersection</title><link href="http://localhost:4000/jekyll/update/2020/05/15/any-pair-of-segments-intersection.html" rel="alternate" type="text/html" title="Any Pair of Segments Intersection" /><published>2020-05-15T09:01:36-07:00</published><updated>2020-05-15T09:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/15/any-pair-of-segments-intersection</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/15/any-pair-of-segments-intersection.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/any-segment-intersection/intro.png&quot; width=&quot;100%&quot; /&gt;
We’ve looked at how to check if &lt;a href=&quot;https://strncat.github.io/jekyll/update/2020/04/08/line-segment-intersection.html&quot;&gt;two segments intersect&lt;/a&gt; in just $O(1)$ time. Now, suppose we have a set of line segments and we want to know if any two segments in this set intersect. How can we do that?
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Sweep Line&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/any-segment-intersection/sweep-line.png&quot; width=&quot;100%&quot; /&gt;
Sweep Line  is a common technique used often in computational geometry where we imagine a vertical line going through the set of objects we’re interested in. The sweep line sweeps through one dimension that we chooses. This dimension is treated as a dimension of time. For example, in the figure above, the x-axis is our time line. The vertical line sweeps through the line segments to check whether any two segments intersect. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Basics&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;First, we’ll assume that no three points intersect at a single point and that we don’t have vertical line segments. Second, instead of talking about line segments, we’ll just talk about the individual points that make up these segments. We’ll label the start point of a segment with “s” and the end point of a segment with “e”. If we have $n$ segments, we will have $2n$ points. Finally, we’ll sort these points by their x-coordinate. In case of ties, we’ll place the “start” points before the “end” points. If we still have ties, we’ll put the points with the lower y-coordinate first. Our dimension of time here is the x-coordinate and we will sweep from left to right.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Big Idea&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/any-segment-intersection/big-idea.png&quot; width=&quot;100%&quot; /&gt;
Naively, we would spend $O(n^2)$ time to check if any pair intersects by literally checking all possible intersections. CLRS presents a very smart algorithm that is based on one big idea. 
&lt;br /&gt;
&lt;br /&gt;
Sort the segment points and sweep through the points from left to right, stopping to evaluate the sweep line at every segment point. Suppose we know that a pair of segments intersect. The big idea is that we are guaranteed to have the two line segments be &lt;b&gt;consecutive at some sweep line&lt;/b&gt;. In the figure above, the line segments intersect at $p$ and they are consecutive at the sweep line $x$. This is a huge idea! why? Because now we can just sweep through the points from left to right. When we evaluate a point, we only need to check the segment right below it or the segment right above it for a possible intersection! This means that the running time is dominated by the sort which runs in $O(n\log(n))$. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Proof&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;If we have two segments $a$ and $b$ intersecting at some point $p$. Why must the segments be consecutive at some sweep line? 
&lt;br /&gt;
&lt;br /&gt;
Suppose we are at some sweep line $x$, let $T$ be the set of segments intersecting $x$. Let $\succeq_x$ be a relation on $T$. We say $a \succeq_x b$ if both $a$ and $b$ intersect $x$ and the intersection of $a$ with $x$ is higher than the intersection of $b$ with $x$. The below figure shows segments $a$, $b$ and $c$ intersecting sweep line $x$.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/any-segment-intersection/big-idea-proof-1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$\succeq_x$ is &lt;b&gt;total preorder&lt;/b&gt;. This is because for any two segments $a, b \in T$, either $a \succeq_x b$ or $b \succeq_x a$ or both and $\succeq_x$ is a total order. Furthermore, if we have a third segment $c \in T$ such that $a \succeq_x b$ and $c \succeq_x b$ then we must have $a \succeq_x b$ and so $\succeq_x$ is transitive. 
&lt;br /&gt;
&lt;br /&gt;
When we pass the intersection point $p$, the segments $a$ and $b$ reverse their order in the total preorder. Before the intersection, we had $a \succeq b$ and after the intersection, we have $b \succeq a$. Furthermore, since no three lines intersect at the same point then we must have some sweep $x$ where $a$ and $b$ are consecutive. We basically want to prove there is some empty triangle bounded by $a, b$ and $x$ which will imply that $a$ and $b$ are consecutive in the total preorder $\succeq_x$. 
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Proof:&lt;/i&gt; Suppose the triangle isn’t empty and pick the right most intersection point with the triangle to the left of $p$, call it $q$. We know $p != q$ because of the assumption that we don’t have three segments intersecting at the same point. We know the $x$-coordinate of $q$ is less than $p$ by assumption. Therefore, there will exist a region defined the sweep line at $q$, call it $x$, where the triangle bounded by $x, a$ and $b$ is empty. Therefore, $a$ and $b$ will be consecutive in the total preorder $\succeq_x$. $\blacksquare$
&lt;br /&gt;
&lt;br /&gt;
There is another more intuitive way to think about this. We have two cases. We either have no segment points besides $a$ and $b$ before we hit $p$ which will imply that $a$ and $b$ are consecutive in the total preorder of the sweep line that hits the latest segment start of $a$ and $b$. (left case in the figure). Or we do have some segment $c$ but because of the precondition that no three segments intersect at $p$ then we must hit the end point of $c$ before $p$ and so $a$ and $b$ will be consecutive after that point (middle case). Someone might ask, what if we don’t hit the end of $c$ first and $c$ continues? This is the third case in the figure which is just misleading because in this case, we will discover $p^{\prime}$ first instead and return true!
&lt;img src=&quot;http://localhost:4000/assets/geometry/any-segment-intersection/big-idea-proof-2.png&quot; width=&quot;100%&quot; /&gt; 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Algorithm&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The algorithm will maintain two sets of data.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The first set, $S$, is the sorted list of start and end points, also called the &lt;b&gt;event points&lt;/b&gt;.&lt;/li&gt;
  &lt;li&gt;The second set is $T$, the &lt;b&gt;sweep-line status&lt;/b&gt;. $T$ will hold the ordered segments currently intersecting the current sweep line.
&lt;img src=&quot;http://localhost:4000/assets/geometry/any-segment-intersection/T.png&quot; width=&quot;100%&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The algorithm then iterates through the event-points or $S$. There two cases only:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The point is a start point of some segment $t$. We will add the segment to the &lt;b&gt;sweep-line-status&lt;/b&gt; and then check if $t$ intersects the segment below it or the segment above it. If the answer is yes, then we’re done. If not, we continue processing the next point.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The point is an end point of some segment “r”. We will check if the segments below $r$ and above $r$ intersect and, then we will remove $r$ from the sweep-line-status.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;Pseudocode&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// S is a set of n segments&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;any_segments_intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Assume or rearrange S to have 2n points (the start and end points of each segment)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Sort the points in S by their x-coordinate, breaking ties by putting&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// start points before end points and then lower y-coordinate first&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// sweep-line-status&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;some&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;above&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intersects&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;OR&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;below&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intersects&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// p is an end point&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;above&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;below&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AND&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;both&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;these&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;segments&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intersect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Proof&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;But why does any of the above work? Is this magic? kind of. To prove the correctness of the algorithm we need to prove&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;any_segments_intersect(S) returns true if and only if there is an intersection among the segments in $S$.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt;
&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(\Rightarrow)&lt;/script&gt;: If &lt;i&gt;any_segments_intersect&lt;/i&gt; returns true, then it is clear from the algorithm above that it can only return true if an intersection passes so we’re good.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(\Leftarrow)&lt;/script&gt;: If there is an intersection, we’ll prove that &lt;i&gt;any_segments_intersect&lt;/i&gt; finds it. Suppose we have an intersection and let $p$ be the left most intersection with the lowest y-coordinate. Let $a$ and $b$ be the intersecting segments. We know from the previous proof that no three segments can intersect at $p$ and so $a$ and $b$ will be consecutive at some sweep line $z$. We also know that there is some segment start or end point $q$ that intersects $z$. We have three cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Case 1: We already have either $a$ or $b$ in $T$ and then we hit the start of $a$ or $b$ and so the first if-statement catches this.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Case 2: We hit the end point of some segment $c$ and so the second if-statement catches this case. We compare $a$ and $b$ and delete $c$.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Case 3: We didn’t process the sweep line $x$ at $q$ because we’ve already hit $p^{\prime}$ before! (this must be the case because $c$ must either end before $p$ hits $a$ or $b$ before $p$ since we can’t have 3 points intersecting at $p$)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/any-segment-intersection/big-idea-proof-2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Therefore, if there is an intersection point, then &lt;i&gt;any_segments_intersect&lt;/i&gt; must return true. $\blacksquare$.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS Chapter 33
&lt;br /&gt;
&lt;a href=&quot;https://cs.stackexchange.com/questions/124027/in-determining-whether-any-segments-intersect-why-there-must-be-some-sweep-wher&quot;&gt;Proof&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">We’ve looked at how to check if two segments intersect in just $O(1)$ time. Now, suppose we have a set of line segments and we want to know if any two segments in this set intersect. How can we do that? Sweep Line Sweep Line is a common technique used often in computational geometry where we imagine a vertical line going through the set of objects we’re interested in. The sweep line sweeps through one dimension that we chooses. This dimension is treated as a dimension of time. For example, in the figure above, the x-axis is our time line. The vertical line sweeps through the line segments to check whether any two segments intersect. Basics First, we’ll assume that no three points intersect at a single point and that we don’t have vertical line segments. Second, instead of talking about line segments, we’ll just talk about the individual points that make up these segments. We’ll label the start point of a segment with “s” and the end point of a segment with “e”. If we have $n$ segments, we will have $2n$ points. Finally, we’ll sort these points by their x-coordinate. In case of ties, we’ll place the “start” points before the “end” points. If we still have ties, we’ll put the points with the lower y-coordinate first. Our dimension of time here is the x-coordinate and we will sweep from left to right. Big Idea Naively, we would spend $O(n^2)$ time to check if any pair intersects by literally checking all possible intersections. CLRS presents a very smart algorithm that is based on one big idea. Sort the segment points and sweep through the points from left to right, stopping to evaluate the sweep line at every segment point. Suppose we know that a pair of segments intersect. The big idea is that we are guaranteed to have the two line segments be consecutive at some sweep line. In the figure above, the line segments intersect at $p$ and they are consecutive at the sweep line $x$. This is a huge idea! why? Because now we can just sweep through the points from left to right. When we evaluate a point, we only need to check the segment right below it or the segment right above it for a possible intersection! This means that the running time is dominated by the sort which runs in $O(n\log(n))$. Proof If we have two segments $a$ and $b$ intersecting at some point $p$. Why must the segments be consecutive at some sweep line? Suppose we are at some sweep line $x$, let $T$ be the set of segments intersecting $x$. Let $\succeq_x$ be a relation on $T$. We say $a \succeq_x b$ if both $a$ and $b$ intersect $x$ and the intersection of $a$ with $x$ is higher than the intersection of $b$ with $x$. The below figure shows segments $a$, $b$ and $c$ intersecting sweep line $x$.</summary></entry><entry><title type="html">Coin Change</title><link href="http://localhost:4000/jekyll/update/2020/05/10/coin-change.html" rel="alternate" type="text/html" title="Coin Change" /><published>2020-05-10T07:01:36-07:00</published><updated>2020-05-10T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/10/coin-change</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/10/coin-change.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dynamic-programming/coin-change/coin-change.png&quot; width=&quot;100%&quot; /&gt;
Suppose we’re given a bill of value $n=5$. We’re also given unlimited amount of coins. The possible coin values are 1, 2 and 5. What is the total number of ways of changing the bill into coins? We can exchange it for 5 coins of value 1. We can also exchange it for 3 coins of value 1 and 1 coin of value 2. Here are total possible ways:
&lt;img src=&quot;http://localhost:4000/assets/dynamic-programming/coin-change/change.png&quot; width=&quot;100%&quot; /&gt;
How can we design an algorithm to solve this problem?
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Method 1&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;One way to count the number of ways to make change is to iterate through the coins and use each coin as a  starting point:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Start with a coin of value 5, then make change for $n-5$.&lt;/li&gt;
  &lt;li&gt;Start with a coin of value 2, then make change for $n-2$.&lt;/li&gt;
  &lt;li&gt;Start with a coin of value 1, then make change for $n-1$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When do we stop?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When the amount is negative, meaning this is not a valid combination.&lt;/li&gt;
  &lt;li&gt;When the amount is zero which means that we have arrived at a valid solution.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is illustrated below with amount = 4 and coins 1, 2 and 5:
&lt;img src=&quot;http://localhost:4000/assets/dynamic-programming/coin-change/method1-before.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The solutions are highlighted in yellow. One thing we immediately notice is that we have duplicates! we’re finding (1,1,2), (1,2,1) and (2,1,1) as valid solutions. How can we fix this? The simplest way to fix this issue is to restrict the coins in the next iteration to coins  that are less than our current coin. For example if our current coin is 2, then we only try out coins 1 and 2 at the next level. So our steps will now be:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Start with a coin of value 5, then make change for $n-5$ with coins (1,2,5).&lt;/li&gt;
  &lt;li&gt;Start with a coin of value 2, then make change for $n-2$ with coins (1,2).&lt;/li&gt;
  &lt;li&gt;Start with a coin of value 1, then make change for $n-1$ with coins (1).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is illustrated below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dynamic-programming/coin-change/method1-after.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Implementation wise, we can pass an index to keep track of which coins we are allowed to use at the next level of recursion.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_change_recursive_alt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// used coins = exact amount&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not the right combination of coins&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// recurse again but with the largest coin = coins[i]&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// this way we don't count duplicates&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_change_recursive_alt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;total&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Method 2&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Another way to think about this problem is to divide the solutions into two sets. Fix a coin of choice, $c$, and then divide the set of solutions into solutions that use the coin $c$ and solutions that don’t use $c$. For amount 4 and coin “2”, we have 1 way that doesn’t use coin “2” and 2 different ways that does use it.
&lt;img src=&quot;http://localhost:4000/assets/dynamic-programming/coin-change/method2-coin.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let $K[c,n]$ be the total number of ways to make change for amount $n$ and coins $c$. Fix a coin $c_i$ from the set $c$. We will have,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
K[c,n] = K[c-{c_i},n] + K[c, x-c_i].
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The following implementation is based on the above recurrence. Just like previously, in order not to run into duplicate solutions, we make sure to have the sequence of coins in some pre set order and then use an index to keep track of which coins we’re allowed to use in the next iteration.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_change_recursive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// used coins = exact amount&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not the right combination of coins&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// ran out of coins&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// either use the coin c[n-1] or don't&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_change_recursive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// don't use this coin&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;make_change_recursive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// use the coin&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;However, for $n$ coins, this solution still takes $O(2^n)$ time and is not efficient.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Method 3: Dynamic Programming&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/dynamic-programming/coin-change/substructure.png&quot; width=&quot;100%&quot; /&gt;
Suppose we know the solution to a problem we’re solving. An optimal substructure means that the solution will contain solutions to smaller subproblems. Does this apply to the coin change problem? Yes! we just came up with a beautiful recurrence in the recursive solution above. Let $K[c,n]$ be the total number of ways to make change for amount $n$ and coins $c$. Fix a coin $c_i$ from the set $c$. We will have,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
K[c,n] = K[c-{c_i},n] + K[c, n-c_i].
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;Both subproblems are independent of each other and both are smaller in size than the original problem.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The first subproblem, $K[c-{c_i},n]$, has one fewer coin.&lt;/li&gt;
  &lt;li&gt;The second subproblem, $K[c,n-{c_i}]$, has a smaller amount.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is exactly what we need to implement a dynamic programming algorithm. The only thing left is to define the base case. For this particular problem:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$K[c,0] = 1$. The number of ways to make change for any zero amount is 1.&lt;/li&gt;
  &lt;li&gt;$K[0,n] = 1$ where $n &amp;gt; 0$. The number of ways to make change for any amount greater than zero using zero coins is 0.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It is also important just like in the recursive structure, to take care of the duplicates issue. We need to keep track of which coins we’re allowed to use.&lt;/p&gt;
&lt;table&gt;
	&lt;tr&gt;
		&lt;td&gt;amount/coins&lt;/td&gt;
		&lt;td&gt;0&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;2&lt;/td&gt;
		&lt;td&gt;3&lt;/td&gt;
		&lt;td&gt;4&lt;/td&gt;
		&lt;td&gt;5&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;0&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;0&lt;/td&gt;
		&lt;td&gt;0&lt;/td&gt;
		&lt;td&gt;0&lt;/td&gt;
		&lt;td&gt;0&lt;/td&gt;	
		&lt;td&gt;0&lt;/td&gt;			
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;{1}&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;{1,2}&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;2&lt;/td&gt;
		&lt;td&gt;2&lt;/td&gt;
		&lt;td&gt;3&lt;/td&gt;
		&lt;td&gt;3&lt;/td&gt;
	&lt;/tr&gt;
	&lt;tr&gt;
		&lt;td&gt;{1,2,5}&lt;/td&gt;
		&lt;td&gt;1&lt;/td&gt;
		&lt;td&gt;2&lt;/td&gt;
		&lt;td&gt;2&lt;/td&gt;
		&lt;td&gt;2&lt;/td&gt;
		&lt;td&gt;3&lt;/td&gt;
		&lt;td&gt;4&lt;/td&gt;
	&lt;/tr&gt;
&lt;/table&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_change_2d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// base case for amount = 0, there is 1 way to make change&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise the total number of ways to make change is zero for any amount &amp;gt; 0 with zero coins&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_AMOUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each coin&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_AMOUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each amount&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// dp[n][amount] = dp[n-1][amount] + dp[n][amount-c[n]]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;For amount $n$ and $m$ coins, The runtime is &lt;script type=&quot;math/tex&quot;&gt;O(nm)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Method 4: Optimized Dynamic Programming&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The previous method is great and optimal. We could however reduce the storage requirement from 2D to only 1D. If you pay attention to the recursive structure, you’ll see that each row only depends on the previous row. So what we could do is just over write the current row onto the previous row until we reach the final answer in the last row.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// bottom up with less memory&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;make_change_1d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// base case&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each coin&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX_AMOUNT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for each amount, m needs to be &amp;gt;= c[i], start from c[i]&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;amount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Proof of Correctness&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO?&lt;/p&gt;

&lt;!-- 

&lt;i&gt;Proof:&lt;/i&gt; &lt;br&gt;
Suppose that we have a bill of size $$n$$ and suppose that we have unbounded copies of $$c$$ coins available to us. Now suppose that we know that the number of ways to make change is $K[c,n]$. Fix a coin $c_i$. If We claim that $K[c-{c_i},n]$ is the number of ways to make change and that one of the solutions contains one coin of value $c_i$ for some natural number $i$. We claim that $K[W] - v_k$ is an optimal value for a knapsack of size $$W - x_k$$. That is, $$K[W - x_k] = K[W] - v_k$$.
&lt;br&gt;&lt;br&gt;
We will prove our claim by contradiction. Suppose that $$K[W] - v_k$$ is not an optimal value and that the optimal value is $$T^{\prime}$$. Since we know that the optimal solution to the knapsack of size $$W$$ contains a copy of item $$x_k$$, we can therefore add $$x_k$$ to $$K[W - x_k]$$ to obtain an optimal value $$T^{\prime} + v_k$$. But $$T^{\prime} + v_k &gt;  K[W] - v_k + v_k = K[W]$$. This is a contradiction since we assumed that $$K[W]$$ is an optimal value. Therefore, $$K[W] - v_k$$ must be an optimal value for a knapsack of size $$W - x_k$$. $$\blacksquare$$

--&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Practice Problems&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;page=show_problem&amp;amp;problem=2078&quot;&gt;11137 - Ingenuous Cubrency&lt;/a&gt; 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;(Method 2) &lt;a href=&quot;https://www.geeksforgeeks.org/coin-change-dp-7/&quot;&gt;GeeksforGeeks&lt;/a&gt; 
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Suppose we’re given a bill of value $n=5$. We’re also given unlimited amount of coins. The possible coin values are 1, 2 and 5. What is the total number of ways of changing the bill into coins? We can exchange it for 5 coins of value 1. We can also exchange it for 3 coins of value 1 and 1 coin of value 2. Here are total possible ways: How can we design an algorithm to solve this problem? Method 1 One way to count the number of ways to make change is to iterate through the coins and use each coin as a starting point: Start with a coin of value 5, then make change for $n-5$. Start with a coin of value 2, then make change for $n-2$. Start with a coin of value 1, then make change for $n-1$.</summary></entry><entry><title type="html">Combinations</title><link href="http://localhost:4000/jekyll/update/2020/05/08/combinations.html" rel="alternate" type="text/html" title="Combinations" /><published>2020-05-08T08:01:36-07:00</published><updated>2020-05-08T08:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/08/combinations</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/08/combinations.html">&lt;p&gt;Many competitive programming problems require generating combinations. For example, in &lt;a href=&quot;https://onlinejudge.org/index.php?option=onlinejudge&amp;amp;page=show_problem&amp;amp;problem=382&quot;&gt;411 - Lotto&lt;/a&gt;, we are given &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; integers (all distinct) and we want to print all possible ways of choosing 6 numbers from the set. There are different approaches to generate these combinations. The following approach is an extremely simple approach. 
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Approach 1&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;In this approach, we generate all possible subsets, stopping when we reach the combination size we’re after. Suppose we’re generating $k=3$ numbers from the following set:
&lt;img src=&quot;http://localhost:4000/assets/competitive-programming/combinations/set.png&quot; width=&quot;100%&quot; /&gt;
We start generating the combinations by looking at each element starting at element “1”. We also keep track of what elements make our combination in a new array called &lt;i&gt;selected&lt;/i&gt;. We have two choices for “1”. We either select it or we skip it. We record our selection and move down to the next level.
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/competitive-programming/combinations/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
So now we’re maintaining two &lt;i&gt;selected&lt;/i&gt; arrays, one for each choice. Next we look at “2”. We again have two choices. We either select “2” or we skip it.
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/competitive-programming/combinations/2.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
We next look at “3”. For each &lt;i&gt;selected&lt;/i&gt; array above, we have two more choices of whether we want to add “3” or just skip it.
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/competitive-programming/combinations/3.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
We repeat this process until one of two things happen:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We reach &lt;script type=&quot;math/tex&quot;&gt;k=3&lt;/script&gt; elements in &lt;i&gt;selected&lt;/i&gt; and so we can print our choice and return.&lt;/li&gt;
  &lt;li&gt;We run out of possible elements to choose and we exit.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The following code represents the process we just followed.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;combinations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
                  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
                  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
                  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;selections&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;print_combination&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no more elements&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// two choices&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) select a[i]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;combinations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// (2) don't select a[i]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;combinations&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;selections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Worst case analysis&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;At the top level of the recursion tree (level = 0), we make one call. At level 1 we make &lt;script type=&quot;math/tex&quot;&gt;2^1&lt;/script&gt; calls. At level 2, we make $2^2$ calls. The last level (level = $n-1$) would have $2^n$ subproblems. For each call, we make $O(1)$ work of selecting or not selecting the element. So the total time would be $1+2+2^2+2^3+…+2^n = 2^{n+1} - 1 = O(2^{n})$.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Approach 2&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Practice Problems&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://onlinejudge.org/index.php?option=onlinejudge&amp;amp;page=show_problem&amp;amp;problem=382&quot;&gt;411 - Lotto&lt;/a&gt;
(&lt;a href=&quot;https://github.com/strncat/competitive-programming/blob/master/uva/backtracking/441-lotto.cpp&quot;&gt;Solution Using Approach 1&lt;/a&gt;)
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Many competitive programming problems require generating combinations. For example, in 411 - Lotto, we are given integers (all distinct) and we want to print all possible ways of choosing 6 numbers from the set. There are different approaches to generate these combinations. The following approach is an extremely simple approach. Approach 1 In this approach, we generate all possible subsets, stopping when we reach the combination size we’re after. Suppose we’re generating $k=3$ numbers from the following set: We start generating the combinations by looking at each element starting at element “1”. We also keep track of what elements make our combination in a new array called selected. We have two choices for “1”. We either select it or we skip it. We record our selection and move down to the next level. So now we’re maintaining two selected arrays, one for each choice. Next we look at “2”. We again have two choices. We either select “2” or we skip it. We next look at “3”. For each selected array above, we have two more choices of whether we want to add “3” or just skip it. We repeat this process until one of two things happen: We reach elements in selected and so we can print our choice and return. We run out of possible elements to choose and we exit.</summary></entry><entry><title type="html">10003 - Cutting Sticks</title><link href="http://localhost:4000/jekyll/update/2020/05/05/10003-cutting-sticks.html" rel="alternate" type="text/html" title="10003 - Cutting Sticks" /><published>2020-05-05T12:01:36-07:00</published><updated>2020-05-05T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/05/10003-cutting-sticks</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/05/10003-cutting-sticks.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry><entry><title type="html">B-Trees</title><link href="http://localhost:4000/jekyll/update/2020/05/04/b-trees.html" rel="alternate" type="text/html" title="B-Trees" /><published>2020-05-04T01:01:36-07:00</published><updated>2020-05-04T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/04/b-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/04/b-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/b-trees/b-tree.png&quot; width=&quot;100%&quot; /&gt;
B-trees are balanced search trees. While red-black trees are also balanced search trees, their branching factor is only 2. B-trees differ in that their branching factor can be really large. The number of keys in a B-tree node determines the number of its children. A node with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; keys have &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; children. This way, each child handles a specific range of keys in its parent. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Motivation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;But why do we need a large branching factor? The motivation behind this idea has to do with minimizing disk I/O operations. Data on disk can be read in &lt;i&gt;pages&lt;/i&gt; and so if each node’s size is a whole page in which we pack a lot of keys in, we can then minimize the number of read operations. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Specifications&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; be an internal node and let &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; be the number of keys stored at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; must have &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; children. Furthermore, the keys are stored in non-decreasing order. Leaf nodes on the other hand have no children. No restrictions on the number of children of the root.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The minimum degree of a b-tree is an integer, &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;t \geq 2&lt;/script&gt;. Every node besides the root must have between &lt;script type=&quot;math/tex&quot;&gt;t-1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;2t-1&lt;/script&gt; keys. This also implies that it must have at least &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; children and at most &lt;script type=&quot;math/tex&quot;&gt;2t&lt;/script&gt; children. If the tree is not empty, the root must be at least have 1 key.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The keys in each node are stored in non-decreasing order. The keys also define the range of keys stored in the children subtrees below. In the above figure, We see the range [0,23] defines the range for the child keys below [11,19]. Similarly [23,53] defines the range for the next child’s keys [29,43].
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;Why are B-trees balanced?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;To see why B-trees are balanced, we will prove that the maximum height of a b-tree of degree &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; keys is &lt;script type=&quot;math/tex&quot;&gt;O(\log_t(n))&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Proof: At level 0, the root must at least have 1 key. At level 1 we must have two children, each of which must have at least &lt;script type=&quot;math/tex&quot;&gt;t-1&lt;/script&gt; keys, so the total number of keys is &lt;script type=&quot;math/tex&quot;&gt;2(t-1)&lt;/script&gt;. Each of these children will have at least &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; children and so at level 2, we should have &lt;script type=&quot;math/tex&quot;&gt;2t(t-1)&lt;/script&gt; keys. Therefore, the total number of keys is at least&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n &amp;amp;\geq 1 + 2(t-1) + 2t(t-1) + 2t^2(t-1) + ... + 2t^{h-1}(t-1) \\
&amp;amp;= 1 + 2(t-1)(1 + t + t^2 + ... t^{h-1}) \\
&amp;amp;= 1 + 2(t-1)\frac{t^h - 1}{t - 1} \text{ (using } \sum_{k=0}^{n}x^k = \frac{x^{n+1} - 1}{x - 1} ) \\
&amp;amp;= 1 + 2(t^h - 1) \\
&amp;amp;= 2t^h - 1 \\
\log_t(\frac{n + 1}{2}) &amp;amp;\geq \log_t(h) \\
h &amp;amp;\leq \log_t(\frac{n + 1}{2}). \blacksquare
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Search&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similar searching in a binary tree, we descend down the tree and select the right branch based on the key value. If the current node has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; keys then we will have &lt;script type=&quot;math/tex&quot;&gt;n+1&lt;/script&gt; branches that might be a possible match.
&lt;img src=&quot;http://localhost:4000/assets/trees/b-trees/search.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
In the figure above, suppose we’re searching for &lt;script type=&quot;math/tex&quot;&gt;k = 84&lt;/script&gt;. Each node stores an array of its keys. We first find the smallest index such that &lt;script type=&quot;math/tex&quot;&gt;k \leq keys[i]&lt;/script&gt;. For $k=84$, the smallest index is $i = 3$. 101 is the smallest key that is larger than 84. We then have several cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;$k = keys[i]$. This is great, we just return that node with the index.&lt;/li&gt;
  &lt;li&gt;$x$ is a leaf node so we return NULL.&lt;/li&gt;
  &lt;li&gt;$k \neq keys[i]$. $k$ falls somewhere between the key at index &lt;script type=&quot;math/tex&quot;&gt;i-1&lt;/script&gt; and the key at index &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; (could be $x.n$, but it’s okay because we have $x.n+1$ children). This range corresponds to the child at index &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// search a b-tree of degree t &lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// search for the smallest index such that k &amp;lt;= keys[i]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// this means k will be in the range (keys[i-1], keys[i])&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// three possible cases&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;keys&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// key found&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x is a leaf node&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no more possible matches&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// i is x.n. No key is larger than k, we search the very last child&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;How long does Search take?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Note that in the above method, we were using a linear search to find the right key. For a tree of degree &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;, each node can have at most &lt;script type=&quot;math/tex&quot;&gt;2t-1&lt;/script&gt; keys. So this search takes &lt;script type=&quot;math/tex&quot;&gt;O(t)&lt;/script&gt; time. Since the tree height is &lt;script type=&quot;math/tex&quot;&gt;O(log_t(n))&lt;/script&gt; then the total cost is &lt;script type=&quot;math/tex&quot;&gt;O(t\log_t(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Suppose we instead use binary search to find the key. This means that each search will now take &lt;script type=&quot;math/tex&quot;&gt;\log(t)&lt;/script&gt; and so the total cost is now &lt;script type=&quot;math/tex&quot;&gt;O(\log(t)\log_t(n))&lt;/script&gt;. Re-writing &lt;script type=&quot;math/tex&quot;&gt;\log_t(n)&lt;/script&gt; as &lt;script type=&quot;math/tex&quot;&gt;\frac{\log(n)}{\log(t)}&lt;/script&gt;, the total is now  &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Delete&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;CLRS&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://web.stanford.edu/class/cs166/lectures/05/Small05.pdf&quot;&gt;Stanford CS166&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">B-trees are balanced search trees. While red-black trees are also balanced search trees, their branching factor is only 2. B-trees differ in that their branching factor can be really large. The number of keys in a B-tree node determines the number of its children. A node with keys have children. This way, each child handles a specific range of keys in its parent. Motivation But why do we need a large branching factor? The motivation behind this idea has to do with minimizing disk I/O operations. Data on disk can be read in pages and so if each node’s size is a whole page in which we pack a lot of keys in, we can then minimize the number of read operations. Specifications Let be an internal node and let be the number of keys stored at . must have children. Furthermore, the keys are stored in non-decreasing order. Leaf nodes on the other hand have no children. No restrictions on the number of children of the root.</summary></entry><entry><title type="html">Eulerian Paths and Tours</title><link href="http://localhost:4000/jekyll/update/2020/05/02/euler.html" rel="alternate" type="text/html" title="Eulerian Paths and Tours" /><published>2020-05-02T12:01:36-07:00</published><updated>2020-05-02T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/02/euler</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/02/euler.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/euler.png&quot; width=&quot;100%&quot; /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a connected undirected a graph. An &lt;b&gt;Eulerian path&lt;/b&gt; is a path in a graph that traverses each edge exactly once and an &lt;b&gt;Eulerian tour, circuit or cycle&lt;/b&gt; is an Eulerian path that starts and ends at the same vertex. Note that in both definitions, we can traverse any vertex more than once. It is named after Euler because in 1736 Euler proved that crossing all the seven bridges in Königsberg without crossing any bridge more than once is impossible (left figure). For more details, refer to &lt;a href=&quot;https://en.wikipedia.org/wiki/Seven_Bridges_of_Königsberg&quot;&gt;this Wikipedia article&lt;/a&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;When do we have an Eulerian tour?&lt;/b&gt;&lt;/h4&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a connected undirected graph. &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an Eulerian tour if and only if every vertex in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an even degree.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In the left figure above, it’s impossible to have an Eulerian tour since not every node has an even degree. However, the right figure has an Eulerian cycle and every node is of even degree.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Proof:&lt;/i&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be an undirected graph. We’ll prove both directions below,&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(\Rightarrow)&lt;/script&gt;: Since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an Eulerian cycle, we must traverse at least two edges every time we pass through a vertex except for the start and end vertex. This means that degree of these vertices must be even. Since the start and the end vertex are the same, then this vertex must also have an even degree.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(\Leftarrow)&lt;/script&gt;: Start traversing at an arbitrary vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. Since all vertices are of even degree and &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected, then we are guaranteed to return to &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and we cannot get stuck at any other vertex. Let &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; be any other vertex than &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. Suppose we get stuck at &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;. We claim that it is impossible, since &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and the node we get stuck at will both be of odd degree and this is a contradiction to our assumption of all nodes having even degrees. After we return, we would have constructed a cycle in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, call it &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. if every edge in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; was in &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;, then we are done. Otherwise, we must have some vertices in &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; that still have edges which were not traversed because &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected. Choose a vertex and start traversing the remaining edges. We are again guaranteed to return to the same vertex because of the even degree property. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/proof.png&quot; width=&quot;100%&quot; /&gt;
We can combine both cycles to form a bigger cycle. We can then repeat the same steps until no edges are left in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. We are able to find all cycles and merge them since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected. Therefore, the cycle must be an Eulerian cycle as we wanted to show.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Assuming every node is of even degree, it is clear that the way to discover an Eulerian cycle is by discovering the cycles one at a time and then merging all cycles together (from the proof above). This sounds hard. Fortunately, there is a really smart idea of using two stacks, one to traverse the current cycle and one that collects all the nodes in the final big cycle. This makes the algorithm run in only &lt;script type=&quot;math/tex&quot;&gt;O(E+V)&lt;/script&gt; time, which is fantastic! 
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// pick some node&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// now traverse it's edges&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// (a) consider an edge between the current node and any of its neighbors&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Edge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; 

        &lt;span class=&quot;c1&quot;&gt;// (b) if it's used then we'll check another. If it's not then mark it used&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// mark it used&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// (c) push current_node back on the stack so we can go back to it (backtrack to it)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// push current_node&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;// (d) move to the other end of edge to process it&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;other_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// this node is now part of the big final cycle&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cycle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The best way to proceed with this algorithm is with an example.
&lt;br /&gt;
&lt;br /&gt;
We initially push any node of choice on “stack”, we pick &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. We then pop a node from the stack and set the current node to &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. We then proceed to traverse the cycle starting at &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. We do so by selecting one of its unvisited edges. We pick the edge &lt;script type=&quot;math/tex&quot;&gt;a-b&lt;/script&gt; and mark it as used. We then push &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; on “stack”. We switch the current node to the other end of the edge which is &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. We traverse an unvisited edge incident to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. This time it’s &lt;script type=&quot;math/tex&quot;&gt;b-f&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We repeat the above steps and set the current node to &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and pick &lt;script type=&quot;math/tex&quot;&gt;f-d&lt;/script&gt;. We then move to &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; and pick &lt;script type=&quot;math/tex&quot;&gt;d-a&lt;/script&gt;, show in the figures below,
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;When setting the current node to &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;, this time we don’t have edges to traverse. At this point it means that we reached a cycle. This cycle is “a-b-d-f”. So now we want to push this cycle onto “cycle”. We push &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and then pop &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; and push it as well. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We next pop &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; in order to push it as well. However, this is where the magic happens. &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; has unvisited edges. This means that there must be a new cycle that starts at &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;. Instead of pushing &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; to complete the original cycle “a-d-b-f”, we explore this new cycle first, push it and then go back to complete pushing the original cycle! We set the current node to &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and start traversing this new cycle by traversing &lt;script type=&quot;math/tex&quot;&gt;f-e&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We repeat the same steps by pushing &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; back on “stack” and setting the current node to &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;. We then explore &lt;script type=&quot;math/tex&quot;&gt;e-c&lt;/script&gt; and push &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; on “stack”. We then explore &lt;script type=&quot;math/tex&quot;&gt;b-c&lt;/script&gt; and push $$c$ on “stack”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/5.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We set the current node to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; below and explore &lt;script type=&quot;math/tex&quot;&gt;b-f&lt;/script&gt;. Finally we set the current node to &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and this is where no longer have unvisited edges, meaning that we reach the end of the cycle we’re traversing. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/6.png&quot; width=&quot;100%&quot; /&gt;
We start popping the nodes from “stack” and pushing them onto “cycle”. We stop this process if we arrive at any node with unvisited edges. However, this time we don’t see any more unvisited edges and we end up pushing the whole cycle plus the original cycle on “cycle”. And we’re done!
&lt;img src=&quot;http://localhost:4000/assets/graphs/euler/7.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;What about directed graphs?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similar to the undirected case. Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a strongly connected graph. An &lt;b&gt;Eulerian path&lt;/b&gt; is a path in a graph that traverses each edge exactly once and an &lt;b&gt;Eulerian tour&lt;/b&gt; is an Eulerian path that starts and ends at the same vertex. Moreover,&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has an Eulerian tour if and only if for every vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, in-degree(&lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;) = out-degree(&lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;).&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt;
TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Practice Problems&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=24&amp;amp;page=show_problem&amp;amp;problem=508&quot;&gt;10054 - The Necklace&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=24&amp;amp;page=show_problem&amp;amp;problem=53&quot;&gt;117 - The Postal Worker Rings Once&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.math.caltech.edu/~2014-15/1term/ma006a/class8.pdf&quot;&gt;Proof&lt;/a&gt;
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://algs4.cs.princeton.edu/41graph/EulerianCycle.java&quot;&gt;Implementation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Let be a connected undirected a graph. An Eulerian path is a path in a graph that traverses each edge exactly once and an Eulerian tour, circuit or cycle is an Eulerian path that starts and ends at the same vertex. Note that in both definitions, we can traverse any vertex more than once. It is named after Euler because in 1736 Euler proved that crossing all the seven bridges in Königsberg without crossing any bridge more than once is impossible (left figure). For more details, refer to this Wikipedia article. When do we have an Eulerian tour?</summary></entry><entry><title type="html">Red Black Trees</title><link href="http://localhost:4000/jekyll/update/2020/05/01/red-black-trees.html" rel="alternate" type="text/html" title="Red Black Trees" /><published>2020-05-01T12:01:36-07:00</published><updated>2020-05-01T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/01/red-black-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/01/red-black-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/red-black-trees/red-black-tree.png&quot; width=&quot;100%&quot; /&gt;
We previously discussed binary search trees and how the binary search tree property allows us to do tree operations such as insert and delete in just &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; time. However, if the tree height is of order &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;, then we end up with a worse data structure than just a linked list or a sorted array. What we need is a guarantee that the height is &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. How can we achieve this?
&lt;br /&gt;&lt;br /&gt;
A red-black tree is a binary search tree that is balanced. By only adding one extra bit to store the color of the node (red or black) and some restrictions on how to insert and delete nodes, we can have a balanced binary search tree that guarantees the height to be &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Red-black tree specifications&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;A red-black tree must satisfy the following properties:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Every node is either red or black.&lt;/li&gt;
  &lt;li&gt;The root is black.&lt;/li&gt;
  &lt;li&gt;Every leaf node is black.&lt;/li&gt;
  &lt;li&gt;If a node is red, then its children are black.&lt;/li&gt;
  &lt;li&gt;The number of black nodes must be the same across all simple paths from any node to a leaf node.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;Why are red-black trees balanced?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Why do the above properties guarantee anything about the tree being balanced? Intuitively, just restricting the number of black nodes to be the same across all simple paths means that we will have a balanced tree. The red nodes are there to give us some buffer. We could have extra “red” nodes but not a lot in order to keep the height at &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. 
&lt;br /&gt;&lt;br /&gt;
To show a formal proof, we first need to define the black height of a node. Let &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt; be the &lt;b&gt;black height&lt;/b&gt; of a node. &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt; is number of black nodes from a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; to a leaf but &lt;i&gt;not including &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; itself&lt;/i&gt;. In the above tree, we see that the black height of the root is 2 as every simple path includes exactly 2 black nodes. To show that the height is at most &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;, we want to prove somehow that we have “enough” internal nodes at every node such that the height can’t exceed &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. Formally, we’ll prove&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Given a red-black tree $t$ and a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;, The subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;  contains at least &lt;script type=&quot;math/tex&quot;&gt;2^{bh(x)}-1&lt;/script&gt; internal nodes (including x itself)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Looking at the figure below, we see in the first figure we have &lt;script type=&quot;math/tex&quot;&gt;bh(root)=3&lt;/script&gt; and we have at least &lt;script type=&quot;math/tex&quot;&gt;2^{3}-1=7&lt;/script&gt; nodes. In the second figure, we have &lt;script type=&quot;math/tex&quot;&gt;bh(root)=2&lt;/script&gt; and at least &lt;script type=&quot;math/tex&quot;&gt;2^2-1=3&lt;/script&gt; internal nodes. Similarly, in the third figure, we have &lt;script type=&quot;math/tex&quot;&gt;2^2-1&lt;/script&gt; internal nodes.
&lt;img src=&quot;http://localhost:4000/assets/trees/red-black-trees/internal-nodes.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Proof: By Induction on the height of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. For the base case, consider when the height is 0, then we know that &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is NIL. Therefore, &lt;script type=&quot;math/tex&quot;&gt;2^{bh(x)} - 1 = 1 - 1 = 0&lt;/script&gt;. For the inductive step, suppose &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has some positive height &amp;gt; 0 and has two internal children (why 2?). Each child must have either &lt;script type=&quot;math/tex&quot;&gt;bh(x)-1&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt; black height depending on its color. If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; was red, then both children must be black and the black height of both children is  &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; was black, then both its children must have black height &lt;script type=&quot;math/tex&quot;&gt;bh(x)-1&lt;/script&gt;. Since the height of both children is less than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, then we can apply the inductive hypothesis and conclude that each child must have at least &lt;script type=&quot;math/tex&quot;&gt;2^{bh(x)-1}-1&lt;/script&gt; internal nodes. Therefore, &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has at least &lt;script type=&quot;math/tex&quot;&gt;1 + 2^{bh(x)-1} - 1 + 2^{bh(x)-1} - 1 = 2^{bh(x)} -1&lt;/script&gt; internal nodes which completes the proof. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; 
&lt;br /&gt;
&lt;br /&gt;
To prove that the height of the tree is at most &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;, . The next thing we want to use is the fact that every red node in a red-black tree must have black children. Therefore, half the nodes on any path must be black. Therefore, if the height of the tree is &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;bh(root) \geq h/2&lt;/script&gt;. Using what we proved earlier, we see that&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n &amp;amp;\geq 2^{bh(root))} - 1 \text{ (using the earlier lemma we proved) }\\
n &amp;amp;\geq 2^{h/2} - 1  \text { (using the fact that red nodes must have black children) }\\ 
\log(n-1) &amp;amp;\geq h/2 \\
h/2 &amp;amp;\leq \log(n-1) \\
h &amp;amp;\leq 2\log(n-1). \blacksquare
\end{align*}
$$
&lt;/div&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Rotations&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Operations on red-black trees such as insert and delete modify the tree such that we might violate the red-black tree properties. To restore these properties we perform an essential operation called a rotation. Rotations maintain the binary search property. More on rotations are 
&lt;a href=&quot;https://strncat.github.io/jekyll/update/2019/05/02/binary-tree-rotation.html&quot;&gt;here&lt;/a&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Just like &lt;a href=&quot;https://strncat.github.io/jekyll/update/2020/04/28/binary-search-trees.html&quot;&gt;inserting a node into a binary search tree&lt;/a&gt;, we just find an appropriate place to insert it such that we don’t violate the binary search property. Since all leaf nodes must be black, we create a special dummy node and color it black. We call it SNIL, just to differentiate it from NIL (dumb?).&lt;br /&gt;
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// create a new node&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SNIL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// potenial parent&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SNIL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SNIL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// tree was empty&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SNIL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// new for red-black-trees&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SNIL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// new for red-black-trees&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RED&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// new for red-black-trees&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;insertFixUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;z&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// new for red-black-trees&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Also note that we color the node red by default. Red nodes allow for some room in the definition of a “balanced tree”. We still be okay. If the parent of the node is black, then all is fine. However if we choose to color it black then we immediately violate the property that the number of black nodes must be the same across all simple paths. 
&lt;br /&gt;
&lt;br /&gt;
In general, there are two main violations that could happen. This could be our very first node which the root and the root must be black. The parent of the node might be red and red nodes are not allowed to have red children.&lt;/p&gt;

&lt;p&gt;TODO: EACH CASE :)
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Delete&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;TODO
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/red-black-tree.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">We previously discussed binary search trees and how the binary search tree property allows us to do tree operations such as insert and delete in just time. However, if the tree height is of order , then we end up with a worse data structure than just a linked list or a sorted array. What we need is a guarantee that the height is . How can we achieve this? A red-black tree is a binary search tree that is balanced. By only adding one extra bit to store the color of the node (red or black) and some restrictions on how to insert and delete nodes, we can have a balanced binary search tree that guarantees the height to be . Red-black tree specifications A red-black tree must satisfy the following properties: Every node is either red or black. The root is black. Every leaf node is black. If a node is red, then its children are black. The number of black nodes must be the same across all simple paths from any node to a leaf node. Why are red-black trees balanced? Why do the above properties guarantee anything about the tree being balanced? Intuitively, just restricting the number of black nodes to be the same across all simple paths means that we will have a balanced tree. The red nodes are there to give us some buffer. We could have extra “red” nodes but not a lot in order to keep the height at . To show a formal proof, we first need to define the black height of a node. Let be the black height of a node. is number of black nodes from a node to a leaf but not including itself. In the above tree, we see that the black height of the root is 2 as every simple path includes exactly 2 black nodes. To show that the height is at most , we want to prove somehow that we have “enough” internal nodes at every node such that the height can’t exceed . Formally, we’ll prove</summary></entry><entry><title type="html">Binary Search Trees</title><link href="http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees.html" rel="alternate" type="text/html" title="Binary Search Trees" /><published>2020-04-28T12:01:36-07:00</published><updated>2020-04-28T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/binary-search-tree.png&quot; width=&quot;100%&quot; /&gt;
A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The &lt;b&gt;binary-search-tree property&lt;/b&gt; states that given a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in the tree, every node in the left subtree has a key less than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s key and every node in the right subtree has a key greater than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s key.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Motivation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;But why invent another data structure? Let’s take a look at sorted arrays. We can search a sorted array for keys in just &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time with binary search. However, inserting and deleting elements takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. Similarly, while inserting elements in a linked list takes only &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; time, searching a linked list takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time in the worst case. Can we do better with binary search trees? yes!
&lt;br /&gt;&lt;br /&gt;
The binary search tree property is really great at allowing us to insert/search and delete in just &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; where is &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists!
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;In Order Walk&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. 
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!----------------------&gt;
&lt;p&gt;Proving that it takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof)
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Search&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similar to the in-order walk, we can simply perform a search by using the following
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Minimum, Maximum, Predecessor and Successor&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, we have two cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has a right subtree, then the most left element (tree minimum) of the right subtree is the successor.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; doesn’t have a right subtree, then the next element would be the first ancestor such that &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a left child of it. 
&lt;!----------------------&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;successor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise, find the closest parent where t is a left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Inserting a node into a binary search tree is pretty simple. We need to follow the following steps:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Create a new node and assign both the left and right pointers to NULL.&lt;/li&gt;
  &lt;li&gt;Similar to search, descend in the tree with pointer &lt;script type=&quot;math/tex&quot;&gt;current&lt;/script&gt; based on the key value, while keeping a trailing pointer &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; to its parent. Once we hit NULL, we know that the &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; will be the parent of our node.
The figure below illustrates the process:
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/insert.png&quot; width=&quot;100%&quot; /&gt;
&lt;!----------------------&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// create a new node x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x is now the root!&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Delete&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Before discussing delete, we’ll present a helper function that we will use in deleting a node in a binary search three. &lt;i&gt;transplant&lt;/i&gt; replaces a subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; with another subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, illustrated below, 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/transplant.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// replace subtree u with subtree v&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is the root &lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fix v's parent pointer&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, suppose we’re about to delete node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and that are given a pointer to it
We have four different cases that we need to handle:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has no children. We then can simply delete that node and return. This case could be handled implicitly in the next case. 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has only one child. We then just transplant its child at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s parent and remove &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// one child case&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// delete node x if x has only one child&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its right child&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its left child&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// we're good to remove x's memory using &quot;free&quot; or &quot;delete&quot; or whatever we need&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has two children. The idea here is that the successor of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; will take &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s place to maintain the binary search tree property and then we can just delete &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We do know that the successor is the most left child (minimum node) in &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right subtree. Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be the successor of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. It is also important to note that &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; can’t have left children since it is the most left node by definition. We now break deleting &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; into two sub-cases:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(1) &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is the right child of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.  In this case, we transplant &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s parent. We also move &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s left subtree to be &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;’s left subtree. We then we remove &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// two children first sub-case (s is a right child of x)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is x's immediate right child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree = x's left subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is in the left subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right child. In this case, it’s a little more complicated. We first want to replace &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; (21 in the example) with its right subtree (25 in the example) (remember &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; can’t have a left subtree). We then assign &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right subtree to be &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;’s right subtree. So now the subtree 29 is the right child of 21. Finally just like in the earlier case, simply replace &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; with its right subtree. In this example, it means to replace 19 with 21!
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// two children second sub-case (s is not right child of x)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is not x's immediate right child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace s with its right subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's right subtree = x's right subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// repeat steps from above to replace x with its right child (s)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree is now x's left subtree&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
Finally putting everything together in one place:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// one child case&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its right child&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its left child&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// two children second sub-case (s is not right child of x)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is not x's immediate right child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace s with its right subtree&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's right subtree = x's right subtree&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree is now x's left subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/binary-search-tree.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The binary-search-tree property states that given a node in the tree, every node in the left subtree has a key less than ’s key and every node in the right subtree has a key greater than ’s key. Motivation But why invent another data structure? Let’s take a look at sorted arrays. We can search a sorted array for keys in just time with binary search. However, inserting and deleting elements takes time. Similarly, while inserting elements in a linked list takes only time, searching a linked list takes time in the worst case. Can we do better with binary search trees? yes! The binary search tree property is really great at allowing us to insert/search and delete in just time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be where is is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists! In Order Walk Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. void in_order_walk(tree *t) { if (t == NULL) { return; } in_order_walk(t-&amp;gt;left); print key in_order_walk(t-&amp;gt;right); } Proving that it takes time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof) Search Similar to the in-order walk, we can simply perform a search by using the following tree* search(tree *t, key) { while (t != NULL &amp;amp;&amp;amp; k != t-&amp;gt;key) { if (key &amp;lt; t-&amp;gt;key) { t = t-&amp;gt;left; } else { t = t-&amp;gt;right; } } return t; } Minimum, Maximum, Predecessor and Successor Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node , we have two cases: If has a right subtree, then the most left element (tree minimum) of the right subtree is the successor. If doesn’t have a right subtree, then the next element would be the first ancestor such that is a left child of it. tree* successor(tree *t) { if (t-&amp;gt;right != NULL) { return tree_minimum(t-&amp;gt;right); }; // otherwise, find the closest parent where t is a left child tree *p = t-&amp;gt;parent; while (p != NULL &amp;amp;&amp;amp; p-&amp;gt;right == t) { t = p; p = t-&amp;gt;parent; } return p; } Insert Inserting a node into a binary search tree is pretty simple. We need to follow the following steps: Create a new node and assign both the left and right pointers to NULL. Similar to search, descend in the tree with pointer based on the key value, while keeping a trailing pointer to its parent. Once we hit NULL, we know that the will be the parent of our node. The figure below illustrates the process: void insert(tree **t, key) { // create a new node x p = NULL; current = *t; while (current != NULL) { p = current; if (x-&amp;gt;key &amp;lt; current-&amp;gt;key) { current = current-&amp;gt;left; } else { current = current-&amp;gt;right; } } x.parent = p; if (p == NULL) { // x is now the root! *t = x; } else if (p-&amp;gt;key &amp;gt; x-&amp;gt;key) { p-&amp;gt;left = x; } else { p-&amp;gt;right = x; } } Delete Before discussing delete, we’ll present a helper function that we will use in deleting a node in a binary search three. transplant replaces a subtree rooted at with another subtree rooted at , illustrated below, // replace subtree u with subtree v void transplant(tree **t, tree *u, tree *v) { if (u.parent == NULL) { // u is the root *t = v; } else if (u == u.parent.left) { // u is a left child u.parent.left = v; } else if (u == u.parent.right) { u.parent.right = v; } if (v != NULL) { // fix v's parent pointer v.parent = u.parent } }</summary></entry><entry><title type="html">Floyd-Warshall’s Shortest Paths</title><link href="http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall.html" rel="alternate" type="text/html" title="Floyd-Warshall's Shortest Paths" /><published>2020-04-24T07:01:36-07:00</published><updated>2020-04-24T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall.html">&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a directed weighted graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. Floyd-Warshall’s algorithm is a dynamic programming algorithm that solves the all-pairs shortest paths problem in $O(V^3)$ time given that we don’t have negative-weight cycles in the $G$.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Optimal Substructure&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;V = \{1,2,3,...,n\}&lt;/script&gt; and consider a subset &lt;script type=&quot;math/tex&quot;&gt;S = \{1,2,3,...,k\}&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;S \subseteq V&lt;/script&gt; for some &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; be two vertices in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;. Now, consider all the paths from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; whose intermediate vertices are in &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Intermediate vertices on a path are all the vertices on the path except for the start and end vertex. Let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be a shortest path among the paths from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that are drawn from &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/graphs/floyd-warshall/path.png&quot; width=&quot;100%&quot; /&gt;
This is where it gets interesting. There are two cases here. Either &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; or it’s not.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is not on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; then we claim that all the intermediate vertices of &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; are drawn from the set &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can decompose &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; into two shortest paths. A shortest path &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; with intermediate vertices &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt; and a shortest path &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; with intermediate vertices &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt;.
Therefore, we can derive the following:&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 d_{ij}^{k} =\Big\{ \begin{array}{@{}lr@{}}
        w_{ij} \text{ $\quad \quad \quad \quad \quad \quad \quad$ if $k = 0$}\\
        \min (d_{ij}^{k-1}, d_{ik}^{k-1}+d_{jk}^{k-1}) \text{ if $k \geq 0$}\\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Simple Implementation&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;floyd_warshall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// O(n^3)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the shortest path between i and j contains some internal nodes (none repeated, simple path)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// let k be an internal node, either node k is on the optimal path or it's not&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is on the path =&amp;gt; the shortest distance is d[i][k] + d[k][j]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is not on the optimal path =&amp;gt; the shortest distance is dij&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is zero, then the shortest distance is just wij (if it exist) otherwise infinity&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) initialize the distance matrix&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// distance from node to itself is zero&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_ij&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_ij&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// current edge weight&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this edge doesn't exist, set it to infinity&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) apply floyd-warshall&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// k is the internal node on the path&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// for each internal node k, see if it improves the distance[i][j]&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                 &lt;span class=&quot;c1&quot;&gt;// current distance vs distance though k (from i to k then k to j)&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Also,
&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/floyd-warshall.cpp&quot;&gt;Full Code&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Practice Problems&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=24&amp;amp;page=show_problem&amp;amp;problem=508&quot;&gt;567 - Risk&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://onlinejudge.org/index.php?option=com_onlinejudge&amp;amp;Itemid=8&amp;amp;category=24&amp;amp;page=show_problem&amp;amp;problem=762&quot;&gt;821 - Page Hopping&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">Let be a directed weighted graph with vertices and edges. Floyd-Warshall’s algorithm is a dynamic programming algorithm that solves the all-pairs shortest paths problem in $O(V^3)$ time given that we don’t have negative-weight cycles in the $G$. Optimal Substructure Let and consider a subset such that for some . Let and be two vertices in . Now, consider all the paths from to whose intermediate vertices are in . Intermediate vertices on a path are all the vertices on the path except for the start and end vertex. Let be a shortest path among the paths from to that are drawn from . This is where it gets interesting. There are two cases here. Either is on or it’s not. If is not on then we claim that all the intermediate vertices of are drawn from the set . If is on , then we can decompose into two shortest paths. A shortest path from to with intermediate vertices and a shortest path from to with intermediate vertices . Therefore, we can derive the following: $$ \begin{align*} d_{ij}^{k} =\Big\{ \begin{array}{@{}lr@{}} w_{ij} \text{ $\quad \quad \quad \quad \quad \quad \quad$ if $k = 0$}\\ \min (d_{ij}^{k-1}, d_{ik}^{k-1}+d_{jk}^{k-1}) \text{ if $k \geq 0$}\\ \end{array} \end{align*} $$ Simple Implementation void floyd_warshall(int n) { // O(n^3) // the shortest path between i and j contains some internal nodes (none repeated, simple path) // let k be an internal node, either node k is on the optimal path or it's not // if k is on the path =&amp;gt; the shortest distance is d[i][k] + d[k][j] // if k is not on the optimal path =&amp;gt; the shortest distance is dij // if k is zero, then the shortest distance is just wij (if it exist) otherwise infinity // (1) initialize the distance matrix int distance[N][N]; for (int i = 1; i &amp;lt;= vertices; i++) { for (int j = 1; j &amp;lt;= vertices; j++) { if (i == j) { distance[i][j] = 0; // distance from node to itself is zero } else if (w_ij exists) { distance[i][j] = w_ij; // current edge weight } else { distance[i][j] = INT_MAX; // this edge doesn't exist, set it to infinity } } } // (2) apply floyd-warshall for (int k = 1; k &amp;lt;= n; k++) { // k is the internal node on the path // for each internal node k, see if it improves the distance[i][j] for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (distance[i][k] == INT_MAX || distance[k][j] == INT_MAX) { continue; } // current distance vs distance though k (from i to k then k to j) distance[i][j] = std::min(distance[i][j], distance[i][k] + distance[k][j]); } } } } Also, Full Code Practice Problems 567 - Risk 821 - Page Hopping References CLRS</summary></entry><entry><title type="html">Line Segment Intersection</title><link href="http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection.html" rel="alternate" type="text/html" title="Line Segment Intersection" /><published>2020-04-08T12:01:36-07:00</published><updated>2020-04-08T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/segments.png&quot; width=&quot;100%&quot; /&gt;
Suppose we have two line segments in two dimensions. Each line segment is determined by two given points. How can we determine if the two line segments intersect? Before answering this question, let’s review some concepts.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;What is a line segment?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Given two points &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. A line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; is the set of convex combinations of &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. That is for any point &lt;script type=&quot;math/tex&quot;&gt;p_3&lt;/script&gt; on the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
x_{p_3} = \alpha x_{p_1} + (1-\alpha)x_{p_2} \\
y_{p_3} = \alpha y_{p_1} + (1-\alpha)y_{p_2}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;0 \leq \alpha \leq 1&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are the end points of the line segment.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Straddling&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The algorithm CLRS presents is based on the idea of checking whether each line segment &lt;b&gt;straddles&lt;/b&gt; the line containing the other line segment.
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle.png&quot; width=&quot;100%&quot; /&gt;
In the above figure, consider the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; and the line containing the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We say that &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; straddles the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are on opposite sides of the line. Should this check be enough to guarantee the intersection of both segments? No. Consider the following figure,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-not-crossing-segment.png&quot; width=&quot;100%&quot; /&gt;
In this case, segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; straddles the line but it does intersect the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_4p_3}&lt;/script&gt;. We could fix this by also checking whether &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; straddles the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt;. Should this be enough now to handle everything? Unfortunately, we are still missing a case. Consider the following,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-end-point.png&quot; width=&quot;100%&quot; /&gt;
In this case, one of the end points is on the line and so we’re not exactly on opposite sides of the line. Therefore, we need to check whether &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; falls on the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_4p_3}&lt;/script&gt;. 
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Pseudocode&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// line 1 = p1,p2 and line 2 = p3,p4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;segment_intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// first check whether each segment straddles the line&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// containing the other segment&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_segment_straddling_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;is_segment_straddling_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise check the boundary conditions&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// on_line_segment(px, py, pz) determines if px is &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// on the line segment pypz&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next questions would be how to check whether a line segment is straddling a line and how to check whether a point falls on a line segment. Both of these questions can be answered utilizing cross product.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Cross Product&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/cross-product.png&quot; width=&quot;100%&quot; /&gt;
Given two vectors &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt;. If the cross product &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1} \times \vec{p_2}&lt;/script&gt; is positive, then we say that &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; is clockwise from/relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt; and we turn right at &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. Similarly, if the cross product is negative then we say that &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; is anti-clockwise from/relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt; and we turn left at &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Proof&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;(This is also exercise &lt;script type=&quot;math/tex&quot;&gt;33.1-1&lt;/script&gt;)
&lt;br /&gt;
If the cross product is positive then we know that &lt;script type=&quot;math/tex&quot;&gt;x_1y_2 - x_2y_1 &gt; 0&lt;/script&gt;.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
x_1y_2 - x_2y_1 &amp;gt; 0 \\
x_1y_2 &amp;gt; x_2y_1  \\
\frac{y_2}{x_2} &amp;gt; \frac{y_1}{x_1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Consider now the angle that both vectors make with the positive &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; axis. In the below figure,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/cross-product-proof.png&quot; width=&quot;100%&quot; /&gt;
we see that this angle is given by &lt;script type=&quot;math/tex&quot;&gt;\tan^{-1}{y/x}&lt;/script&gt;. We also know that &lt;script type=&quot;math/tex&quot;&gt;\arctan&lt;/script&gt; is monotone and so since &lt;script type=&quot;math/tex&quot;&gt;\frac{y_2}{x_2} &gt; \frac{y_1}{x_1}&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;\theta_2 &gt; \theta_1&lt;/script&gt;. Therefore, &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; must be clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. Similarly, when the cross product is negative, we will see that &lt;script type=&quot;math/tex&quot;&gt;\frac{y_1}{x_1} &gt; \frac{y_2}{x_2}&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; must be anti-clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt;. (Ref (2)).&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Checking whether a segment is straddling a line&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-vectors.png&quot; width=&quot;100%&quot; /&gt;
Using the above idea, it becomes straight forward to determine whether a segment is straddling a line. Suppose we’re determining if segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; is straddling the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We first find the result of the cross product &lt;script type=&quot;math/tex&quot;&gt;(p_1-p_3) \times (p_4-p_3)&lt;/script&gt;. This will tell us whether &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1-p_3}&lt;/script&gt; is clockwise or anti-clockwise relative to  &lt;script type=&quot;math/tex&quot;&gt;\vec{p_4-p_3}&lt;/script&gt; (left figure). Next, we find &lt;script type=&quot;math/tex&quot;&gt;(p_2-p_3) \times (p_4-p_3)&lt;/script&gt; to determine if &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2-p_3}&lt;/script&gt; is clockwise or anti-clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_4-p_3}&lt;/script&gt; (right figure). Finally, we check if the products have different signs to rule out that &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are on different sides of the line.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Checking whether a point falls on a line segment&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we’re determining if point &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls on the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We first need to determine if all three points &lt;script type=&quot;math/tex&quot;&gt;p_1, p_3&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_4&lt;/script&gt; are colinear. To do so, we can check the cross product we’ve computed previously, namely, &lt;script type=&quot;math/tex&quot;&gt;(p_1-p_3) \times (p_4-p_3)&lt;/script&gt;. If this product is 0, then we know that the three points are colinear. 
&lt;br /&gt;&lt;br /&gt;
Next, we need to determine if the point &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls between the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; or on one of its end points. To do so, we need to check that the x-coordinate of &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls in the range of &lt;script type=&quot;math/tex&quot;&gt;min(x_3,x_4), max(x_3,x_4)&lt;/script&gt; and the y-coordinate falls in the range &lt;script type=&quot;math/tex&quot;&gt;min(y_3,y_4),max(y_3,y_4)&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/geometry/intersection-two-line-segments-clrs.cpp&quot;&gt;Full Implementation&lt;/a&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Practice Problems&lt;/b&gt;&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://onlinejudge.org/external/113/11343.pdf&quot;&gt;11343 Isolated Segments&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS Chapter 33
&lt;br /&gt;
&lt;a href=&quot;https://sites.math.rutgers.edu/~ajl213/CLRS/Ch33.pdf&quot;&gt;Cross Product Proof&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Suppose we have two line segments in two dimensions. Each line segment is determined by two given points. How can we determine if the two line segments intersect? Before answering this question, let’s review some concepts. What is a line segment? Given two points and . A line segment is the set of convex combinations of and . That is for any point on the line segment , we have $$ \begin{align*} x_{p_3} = \alpha x_{p_1} + (1-\alpha)x_{p_2} \\ y_{p_3} = \alpha y_{p_1} + (1-\alpha)y_{p_2} \end{align*} $$ where . and are the end points of the line segment. Straddling The algorithm CLRS presents is based on the idea of checking whether each line segment straddles the line containing the other line segment. In the above figure, consider the line segment and the line containing the segment . We say that straddles the line containing if and are on opposite sides of the line. Should this check be enough to guarantee the intersection of both segments? No. Consider the following figure, In this case, segment straddles the line but it does intersect the segment . We could fix this by also checking whether straddles the line containing . Should this be enough now to handle everything? Unfortunately, we are still missing a case. Consider the following, In this case, one of the end points is on the line and so we’re not exactly on opposite sides of the line. Therefore, we need to check whether or falls on the line segment . Pseudocode // line 1 = p1,p2 and line 2 = p3,p4 segment_intersection(p1,p2,p3,p4) { // first check whether each segment straddles the line // containing the other segment if (is_segment_straddling_line(p1,p2,p3,p4) &amp;amp;&amp;amp; is_segment_straddling_line(p3,p4,p1,p2)) { return true; } // otherwise check the boundary conditions // on_line_segment(px, py, pz) determines if px is // on the line segment pypz if (on_line_segment(p1, p3, p4) || on_line_segment(p2, p3, p4) || on_line_segment(p3, p1, p2) || on_line_segment(p4, p1, p2)) { return true; } return false; } The next questions would be how to check whether a line segment is straddling a line and how to check whether a point falls on a line segment. Both of these questions can be answered utilizing cross product. Cross Product Given two vectors and . If the cross product is positive, then we say that is clockwise from/relative to and we turn right at . Similarly, if the cross product is negative then we say that is anti-clockwise from/relative to and we turn left at . Proof (This is also exercise ) If the cross product is positive then we know that . $$ \begin{align*} x_1y_2 - x_2y_1 &amp;gt; 0 \\ x_1y_2 &amp;gt; x_2y_1 \\ \frac{y_2}{x_2} &amp;gt; \frac{y_1}{x_1} \end{align*} $$ Consider now the angle that both vectors make with the positive axis. In the below figure, we see that this angle is given by . We also know that is monotone and so since then we must have . Therefore, must be clockwise relative to . Similarly, when the cross product is negative, we will see that and so must be anti-clockwise relative to . (Ref (2)).</summary></entry></feed>