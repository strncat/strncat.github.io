<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-10T14:29:49-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">nemo’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Reptend Prime</title><link href="http://localhost:4000/jekyll/update/2025/01/05/reptend-prime.html" rel="alternate" type="text/html" title="Reptend Prime" /><published>2025-01-05T00:01:36-08:00</published><updated>2025-01-05T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/05/reptend-prime</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/05/reptend-prime.html"><![CDATA[<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
A Full Reptend Prime is a prime $$p$$ for which $$1/p$$ has $$p-1$$ digits in its decimal expansion. Moreover, a prime \(p\) is full reptend if and only if 10 is a primitive root modulo \(p\). This means that
$$
\begin{align*}
10^k \equiv 1 (mod p)
\end{align*}
$$
for \(k = p - 1\) and not \(k\) less than that. In other words, the multiplicative order of \(10\) modulo \(p\) is \(p-1\).
</div>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>Recall that the <a href="">multiplicative order</a> of \(a\) when \(a\) is coprime to \(n\), is the smallest \(k\) such that \(a^k \equiv 1 \mod n\). Here set \(n = p\) and \(a = 10\), the multiplicative order of \(10\) modulo \(p\) is then the smallest \(k\) for which \(10^k \equiv 1 (\mod p)\).
<br />
<br />
As an example, set \(p = 7\), observe that</p>
<div>
$$
\begin{align*}
10^1 &amp;\equiv 3 (mod 7) \\
10^2 &amp;\equiv 2 (mod 7) \\
10^3 &amp;\equiv 6 (mod 7) \\
10^4 &amp;\equiv 4 (mod 7) \\
10^5 &amp;\equiv 5 (mod 7) \\
10^6 &amp;\equiv 1 (mod 7) \\
\end{align*}
$$
</div>
<p>So the multiplicative order of 10 modulo 7 is 6 which is \(7-1\). So 7 is a full reptend prime.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Multiplicative_order">Wikipedia</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition A Full Reptend Prime is a prime $$p$$ for which $$1/p$$ has $$p-1$$ digits in its decimal expansion. Moreover, a prime \(p\) is full reptend if and only if 10 is a primitive root modulo \(p\). This means that $$ \begin{align*} 10^k \equiv 1 (mod p) \end{align*} $$ for \(k = p - 1\) and not \(k\) less than that. In other words, the multiplicative order of \(10\) modulo \(p\) is \(p-1\). Example Recall that the multiplicative order of \(a\) when \(a\) is coprime to \(n\), is the smallest \(k\) such that \(a^k \equiv 1 \mod n\). Here set \(n = p\) and \(a = 10\), the multiplicative order of \(10\) modulo \(p\) is then the smallest \(k\) for which \(10^k \equiv 1 (\mod p)\). As an example, set \(p = 7\), observe that $$ \begin{align*} 10^1 &amp;\equiv 3 (mod 7) \\ 10^2 &amp;\equiv 2 (mod 7) \\ 10^3 &amp;\equiv 6 (mod 7) \\ 10^4 &amp;\equiv 4 (mod 7) \\ 10^5 &amp;\equiv 5 (mod 7) \\ 10^6 &amp;\equiv 1 (mod 7) \\ \end{align*} $$ So the multiplicative order of 10 modulo 7 is 6 which is \(7-1\). So 7 is a full reptend prime. References Wikipedia]]></summary></entry><entry><title type="html">Multiplicative Order</title><link href="http://localhost:4000/jekyll/update/2025/01/04/multiplicative-order.html" rel="alternate" type="text/html" title="Multiplicative Order" /><published>2025-01-04T00:01:36-08:00</published><updated>2025-01-04T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/04/multiplicative-order</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/04/multiplicative-order.html"><![CDATA[<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Given a positive integer \(n\) and an integer \(a\) coprime to \(n\), the multiplicative order of \(a\) modulo \(n\) is the smallest positive integer \(k\) such that 
$$
\begin{align*}
a^k \equiv 1 (mod n)
\end{align*}
$$
</div>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>

<p>Suppose n = 7 and a = 3, then</p>
<div>
$$
\begin{align*}
3^1 &amp;= 3 \equiv 3 (mod n) \\
3^2 &amp;= 6 \equiv 6 (mod n) \\
3^3 &amp;= 9 \equiv 2 (mod n) \\
3^4 &amp;= 81 \equiv 4 (mod n) \\
3^5 &amp;= 243 \equiv 5 (mod n) \\
3^6 &amp;= 729 \equiv 1 (mod n) \\
\end{align*}
$$
</div>
<p>So the multiplicative order of 3 modulo 7 is 6. Similarly for a = 4 and n = 7</p>
<div>
$$
\begin{align*}
4^1 &amp;= 4 \equiv 4 (mod n) \\
4^2 &amp;= 16 \equiv 2 (mod n) \\
4^3 &amp;= 64 \equiv 1 (mod n) \\
\end{align*}
$$
</div>
<p>So the multiplicative order of 4 modulo 7 is 3.</p>

<!------------------------------------------------------------------------------------>
<h4><b>References</b></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Multiplicative_order">Wikipedia</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition Given a positive integer \(n\) and an integer \(a\) coprime to \(n\), the multiplicative order of \(a\) modulo \(n\) is the smallest positive integer \(k\) such that $$ \begin{align*} a^k \equiv 1 (mod n) \end{align*} $$ Example]]></summary></entry><entry><title type="html">Project Euler: 26 Reciprocal Cycles</title><link href="http://localhost:4000/jekyll/update/2025/01/02/project-euler-26-reciprocal-cycles.html" rel="alternate" type="text/html" title="Project Euler: 26 Reciprocal Cycles" /><published>2025-01-02T00:01:36-08:00</published><updated>2025-01-02T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/02/project-euler-26-reciprocal-cycles</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/02/project-euler-26-reciprocal-cycles.html"><![CDATA[<p>In order to find the longest cycle, we first need to find a way to compute the length of a cycle. To do so, we need to find a way to count the digits in the decimal expansion of a given number. Take \(\frac{1}{7} = 0.(142857)\) for instance. We want a way to iterate through the digits 1,4,2,8,5,7,…. How do we do it? To simplify, let’s assume that we want to iterate over exactly 6 digits of the decimal expansion of \(\frac{1}{7}\). What can we do? The easiest way to do this is to multiply 1 by \(10^6\) and divide to get</p>
<div>
	$$
	\begin{align*}
1,000,000 / 7 = 142,857.143
	\end{align*}
	$$
</div>
<p>But if the cycle is of length 300? So we can’t just multiply the numerator by a huge number all at once. Luckily, we can simulate this long division one step at a time, multiplying the remainder each time by 10 and dividing by 7. So the single division above will be broken into the following steps:</p>

<p>Step 1:
Multiply 1 by 10 and divide to get 10 / 7 = 1 with remainder 3.
<br />
Step 2:
Multiply 3 by 10 and divide to get 30 / 7 = 4 with remainder 2.
<br />
Step 3:
Multiply 2 by 10 and divide to get 20 / 7 = 2 with remainder 6.
<br />
Step 4:
Multiply 6 by 10 and divide to get 60 / 7 = 8 with remainder 4.
<br />
Step 5:
Multiply 4 by 10 and divide to get 40 / 7 = 5 with remainder 5.
<br />
Step 6:
Multiply 5 by 10 and divide to get 50 / 7 = 7 with remainder 1.
<br />
<br />
At this point, we have a reminder that we’ve seen before. We know what we’ll see exactly in step 7 and we know this will repeat for the next 5 steps. So we can stop here and declare that the cycle length is exactly 6.
<br />
<br />
We can simulate this simple long division for all the integers below 1000 to see what integer \(d\) has the longest cycle. We can easily do this with some hash table (unordered_map in c++ for example) to keep track of the remainders we’ve seen so far. Since we’re only checking for up to 1000, we can also put a limit on how many steps in long division we’re willing to do. Playing around with this, it doesn’t seem like any integers below 1000 will have a cycle longer than 1000 digits. So the following is enough to solve this problem
<br />
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">long_division</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">numerator</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cycle_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// let the maximum cycle length be 1000</span>
        <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">%</span> <span class="n">number</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">seen</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cycle ends</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">seen</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">remainder</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">cycle_len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cycle_len</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Other Ideas</b></h4>
<p>So far we have a solution that is fast and acceptable but is there more to this? Take a look at the longest cycle for all numbers up to 1000 and observe that when d = 7, 1/d has d-1=6 digits, when d = 17, 1/d has d-1=16 digits. Furthermore, when d = 19, 1/d has 19-1=18 digits. Same for 1/23 which has 23-1=22 digits. All of these are prime numbers. But when we take d = 11, 1/11 has only two digits in its cycle. So what’s special about 7, 17, 19, 23 …? It turns out these special primes have a special name. These special primes are <a href="">Full Reptend Primes</a>.
<br />
<br />
Since for any full reptend prime \(p\), the the cycle length is \(p - 1\), then a potenial idea is just finding the maximum full reptend prime less than 1000. In fact, the maximum full reptend prime less than 1000 is 983. But does this mean that any other number between 983 and 999 won’t have more digits in its decimal expansion? I don’t know the answer to this question.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ol>
<li><a href="https://projecteuler.net/problem=26">Project Euler - 26</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reciprocals_of_primes">Wikipedia: Reciprocals of Primes</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reciprocals_of_primes">Wikipedia: Reciprocals of Primes</a></li>
</ol>
<p><br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In order to find the longest cycle, we first need to find a way to compute the length of a cycle. To do so, we need to find a way to count the digits in the decimal expansion of a given number. Take \(\frac{1}{7} = 0.(142857)\) for instance. We want a way to iterate through the digits 1,4,2,8,5,7,…. How do we do it? To simplify, let’s assume that we want to iterate over exactly 6 digits of the decimal expansion of \(\frac{1}{7}\). What can we do? The easiest way to do this is to multiply 1 by \(10^6\) and divide to get $$ \begin{align*} 1,000,000 / 7 = 142,857.143 \end{align*} $$ But if the cycle is of length 300? So we can’t just multiply the numerator by a huge number all at once. Luckily, we can simulate this long division one step at a time, multiplying the remainder each time by 10 and dividing by 7. So the single division above will be broken into the following steps:]]></summary></entry><entry><title type="html">[2.5] Cosets and Lagrange’s Theorem</title><link href="http://localhost:4000/jekyll/update/2025/01/01/2.5-cosets-lagrange.html" rel="alternate" type="text/html" title="[2.5] Cosets and Lagrange’s Theorem" /><published>2025-01-01T00:01:36-08:00</published><updated>2025-01-01T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/01/2.5-cosets-lagrange</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/01/2.5-cosets-lagrange.html"><![CDATA[<div class="mintheaderdiv">
Definition 2.4.14
</div>
<div class="mintbodydiv">
Let \(H\) be subgroup of a group \(G\). A subset of the form
\(gH\), where \(g \in G\), is called a left coset of \(H\) in \(G\). A subset of the form
\(Hg\), where \(g \in G\), is called a right coset of \(H\) in \(G\).
</div>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Example 1</b></h4>
<p>Consider H = \(\{e , (1,2)\} \subseteq S_3\). We know \(S_3\) has six elements. Let \(\pi \in S_3\) and compute \(\pi H = \{ \pi \sigma \ : \ \sigma \in H \}\). So</p>
<div>
$$
\begin{align*}
S_3 = \{ e, \begin{pmatrix}1 &amp; 2 \end{pmatrix}, \begin{pmatrix}1 &amp; 3 \end{pmatrix}, \begin{pmatrix}2 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 2 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 3 &amp; 2 \end{pmatrix} 
\}
\end{align*}
$$
</div>
<p>For example \(\begin{pmatrix}1 &amp; 3 \end{pmatrix} H\) is</p>
<div>
$$
\begin{align*}
\begin{pmatrix}1 &amp; 3 \end{pmatrix} H &amp;= \{ \begin{pmatrix}1 &amp; 3 \end{pmatrix}e, \begin{pmatrix}1 &amp; 3 \end{pmatrix}  \begin{pmatrix}1 &amp; 2 \end{pmatrix} \} \\
&amp;= \{ \begin{pmatrix}1 &amp; 3 \end{pmatrix}, \begin{pmatrix} 1 &amp; 2 &amp; 3 \end{pmatrix} \}
\end{align*}
$$
</div>
<p>This is because if we let \(f = (1 \quad 3)\) and \(g = (1 \quad 2)\), then \(f \circ g\) results in \(f(g(1)) = f(2) = 2\). So 1 gets mapped to 2. Similarly \(f(g(2)) = f(1) = 3\). So 2 gets mapped to 3 and \(f(g(3)) = f(3) = 1\) so 3 gets mapped to 1. Writing this in cycle notation means \(1 \rightarrow 2, 2 \rightarrow 3, 3 \rightarrow 1\) or \((1 \quad 2 \quad 3)\).</p>
<div>
$$
\begin{align*}
eH &amp;= (1 \quad 2) H = H \\
\begin{pmatrix}1 &amp; 3 \end{pmatrix} H &amp;= (1 \quad 2 \quad 3)H = \{ \begin{pmatrix}1 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 2 &amp; 3 \end{pmatrix} \} \\
\begin{pmatrix}2 &amp; 3 \end{pmatrix} H &amp;= (1 \quad 3 \quad 2)H = \{ \begin{pmatrix}2 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 3 &amp; 2 \end{pmatrix} \} \\
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Example 2</b></h4>
<p>Suppose \(G = (\mathbf{Z}_4, +)\) and $$H = {0, 2}. Then we have the following cosests</p>
<div>
$$
\begin{align*}
H+0 &amp;= \{0,2\} \\
H+1 &amp;= \{1,3\} \\
H+2 &amp;= \{2,0\} \\
H+3 &amp;= \{3,1\}
\end{align*}
$$
</div>
<p>We can see here that we have two distinct right cosets. Moreover, the cosets are disjoint and partition the group. Next, we’ll formalize these properties about cosets!
<br />
<br />
<!------------------------------------------------------------------------></p>
<div class="peachheaderdiv">
Proposition 2.5.3
</div>
<div class="peachbodydiv">
Let \(H\) be a subgroup of a group \(G\), and let \(a\) and \(b\) be
elements of \(G\). The following conditions are equivalent:
<ol type="a">
	<li>\(a \in bH\).</li>
	<li>\(b \in aH\).</li>
	<li>\(aH = bH\).</li>
	<li>\(b^{-1}a \in H\).</li>
	<li>\(a^{-1}b \in H\).</li>
</ol>
</div>
<!------------------------------------------------------------------------>
<p><br />
<b>Proof</b>
<br />
Suppose \((a)\) holds. Let \(a \in bH\). Then there exists some \(h \in H\) such that \(a = bh\). Since \(H\) is a subgroup, then we know \(h^{-1} \in H\). So we can write \(b = ah^{-1}\). But \(ah^{-1}\) is in \(aH\) by the definition of a left coset which is what we wanted to show. With similar reason \((b)\) also implies \((a)\). 
<br />
<br />
For \((c)\), we want to show that \(aH \subseteq bH\) and \(bH \subseteq aH\). To show that \(bH \subseteq aH\), we want to show that for any arbitrary element \(x\) in \(bH\), that \(x\) is also in \(aH\). So consider any \(x \in bH\). By the definition of a coset, we can write \(x = bh\) for some \(h \in H\). Now suppose that \((b)\) holds and so we have \(b \in aH\). This means that we can write \(b = ah_1\) for some \(h_1 \in H\). But this means that we can write \(x = bh = ah_1h\). The product \(h_1h\) is in \(H\) because \(H\) is a subgroup. Furthermore, \(ah_1h\) must be in \(aH\) by the definition of a coset. Therefore, \(x = bh \in aH\) and so \(bH \subseteq aH\) as we wanted to show. Since \((b)\) also implies \((a)\) we can use a similar reasoning to show that \(aH \subseteq bH\).
<br />
<br />
For \((d)\) ….
<br />
<br />
<!------------------------------------------------------------------------></p>
<div class="peachheaderdiv">
Proposition 2.5.4
</div>
<div class="peachbodydiv">
Let \(H\) be a subgroup of a group \(G\).
<ol type="a">
	<li>Let \(a\) and \(b\) be elements of \(G\). Either \(aH = bH\) or \(aH \cap bH = \emptyset\)</li>
	<li>Each left coset \(aH\) is nonempty and the union of left cosets is \(G\).</li>
</ol>
</div>
<!------------------------------------------------------------------------>
<p><br />
<b>Proof</b>
<br />
For \((a)\), Suppose \(aH \cap bH \neq \emptyset\) and let \(c \in aH \cap bH\). Since \(c \in aH\), then \(aH = cH\) by Proposition 2.5.3. Similarly since \(c \in bH\), then \(bH = cH\). Therefore, \(aH = bH\).
<br />
<br />
For \((b)\), \(aH\) is nonempty since \(H\) is a subgroup and can’t be empty. Furthermore, for each element \(g \in G\), \(g \in gH\). By \((a)\) then the union of all the left cosets must be \(G\).
<br />
<br />
<!------------------------------------------------------------------------></p>
<div class="peachheaderdiv">
Proposition 2.5.5
</div>
<div class="peachbodydiv">
Let \(H\) be a subgroup of a group \(G\) and let \(a\) and \(b\) be
elements of \(G\). Then \(x \longmapsto ba^{-1}\) is a bijection between \(aH\) and \(bH\).
</div>
<!------------------------------------------------------------------------>
<p><br />
<b>Proof</b>
Let \(f : aH \rightarrow bH\) where \(f(x) = ba^{-1}x\). We want to show that \(f\) is a bijection by showing that it’s one-to-one and onto. Suppose \(a_1, a_2 \in aH\) then we can write \(a_1 = ah_1\) and \(a_2 = ah_2\) for some \(h_1, h_2 \in H\). Moreover, suppose that \(f(a_1) = f(a_2)\). Observe that</p>
<div>
$$
\begin{align*}
ba^{-1}a_1 &amp;= ba^{-1}a_2 \\
b^{-1}ba^{-1}a_1 &amp;= b^{-1}ba^{-1}a_2 \quad \text{($G$ is a group so the inverse exists)} \\
aa^{-1}a_1 &amp;= aa^{-1}a_2 \\
a_1 &amp;= a_2 \\
\end{align*}
$$
</div>
<p>From this we see that \(f\) is one-to-one or injective. To see that it’s surjective, we need to show that for any element \(y \in bH\), that there exists an element \(x \in aH\) such that \(f(x) = y\). Since \(y \in bH\), then we can write \(y = bh\) for some \(h \in H\). Now, let \(x = ah \in aH\) and observe that</p>
<div>
$$
\begin{align*}
f(x) &amp;= ba^{-1}x \\
     &amp;= ba^{-1}(ah) \\
	 &amp;= b(a^{-1}ah) \\
	 &amp;= bh = y.
\end{align*}
$$
</div>
<p>\(ah\) is in \(aH\) by definition. Therefore \(f\) is surjective. From this we see that \(f\) is a bijection from \(aH\) to \(bH\). \(\ \blacksquare\)
<br />
<br />
<!------------------------------------------------------------------------></p>
<div class="yellowheaderdiv">
Theorem 2.5.6 (Lagrange's Theorem)
</div>
<div class="yellowbodydiv">
Let \(G\) be a finite group and \(H\) a subgroup. Then the cardinality of \(H\) divides the cardinality of \(G\), and the quotient \(\frac{|G|}{|H|}\) is the number of left cosets of \(H\) in \(G\).
</div>
<!------------------------------------------------------------------------>
<p><br />
<b>Proof</b></p>

<p><br />
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
<li><a href="https://www.youtube.com/watch?v=kthl-MhIf4s&amp;list=PLztBpqftvzxVvdVmBMSM4PVeOsE5w1NnN&amp;index=22">Wrath of Math Youtube Channel</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition 2.4.14 Let \(H\) be subgroup of a group \(G\). A subset of the form \(gH\), where \(g \in G\), is called a left coset of \(H\) in \(G\). A subset of the form \(Hg\), where \(g \in G\), is called a right coset of \(H\) in \(G\). Example 1 Consider H = \(\{e , (1,2)\} \subseteq S_3\). We know \(S_3\) has six elements. Let \(\pi \in S_3\) and compute \(\pi H = \{ \pi \sigma \ : \ \sigma \in H \}\). So $$ \begin{align*} S_3 = \{ e, \begin{pmatrix}1 &amp; 2 \end{pmatrix}, \begin{pmatrix}1 &amp; 3 \end{pmatrix}, \begin{pmatrix}2 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 2 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 3 &amp; 2 \end{pmatrix} \} \end{align*} $$ For example \(\begin{pmatrix}1 &amp; 3 \end{pmatrix} H\) is $$ \begin{align*} \begin{pmatrix}1 &amp; 3 \end{pmatrix} H &amp;= \{ \begin{pmatrix}1 &amp; 3 \end{pmatrix}e, \begin{pmatrix}1 &amp; 3 \end{pmatrix} \begin{pmatrix}1 &amp; 2 \end{pmatrix} \} \\ &amp;= \{ \begin{pmatrix}1 &amp; 3 \end{pmatrix}, \begin{pmatrix} 1 &amp; 2 &amp; 3 \end{pmatrix} \} \end{align*} $$ This is because if we let \(f = (1 \quad 3)\) and \(g = (1 \quad 2)\), then \(f \circ g\) results in \(f(g(1)) = f(2) = 2\). So 1 gets mapped to 2. Similarly \(f(g(2)) = f(1) = 3\). So 2 gets mapped to 3 and \(f(g(3)) = f(3) = 1\) so 3 gets mapped to 1. Writing this in cycle notation means \(1 \rightarrow 2, 2 \rightarrow 3, 3 \rightarrow 1\) or \((1 \quad 2 \quad 3)\). $$ \begin{align*} eH &amp;= (1 \quad 2) H = H \\ \begin{pmatrix}1 &amp; 3 \end{pmatrix} H &amp;= (1 \quad 2 \quad 3)H = \{ \begin{pmatrix}1 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 2 &amp; 3 \end{pmatrix} \} \\ \begin{pmatrix}2 &amp; 3 \end{pmatrix} H &amp;= (1 \quad 3 \quad 2)H = \{ \begin{pmatrix}2 &amp; 3 \end{pmatrix}, \begin{pmatrix}1 &amp; 3 &amp; 2 \end{pmatrix} \} \\ \end{align*} $$ Example 2 Suppose \(G = (\mathbf{Z}_4, +)\) and $$H = {0, 2}. Then we have the following cosests $$ \begin{align*} H+0 &amp;= \{0,2\} \\ H+1 &amp;= \{1,3\} \\ H+2 &amp;= \{2,0\} \\ H+3 &amp;= \{3,1\} \end{align*} $$ We can see here that we have two distinct right cosets. Moreover, the cosets are disjoint and partition the group. Next, we’ll formalize these properties about cosets! Proposition 2.5.3 Let \(H\) be a subgroup of a group \(G\), and let \(a\) and \(b\) be elements of \(G\). The following conditions are equivalent: \(a \in bH\). \(b \in aH\). \(aH = bH\). \(b^{-1}a \in H\). \(a^{-1}b \in H\). Proof Suppose \((a)\) holds. Let \(a \in bH\). Then there exists some \(h \in H\) such that \(a = bh\). Since \(H\) is a subgroup, then we know \(h^{-1} \in H\). So we can write \(b = ah^{-1}\). But \(ah^{-1}\) is in \(aH\) by the definition of a left coset which is what we wanted to show. With similar reason \((b)\) also implies \((a)\). For \((c)\), we want to show that \(aH \subseteq bH\) and \(bH \subseteq aH\). To show that \(bH \subseteq aH\), we want to show that for any arbitrary element \(x\) in \(bH\), that \(x\) is also in \(aH\). So consider any \(x \in bH\). By the definition of a coset, we can write \(x = bh\) for some \(h \in H\). Now suppose that \((b)\) holds and so we have \(b \in aH\). This means that we can write \(b = ah_1\) for some \(h_1 \in H\). But this means that we can write \(x = bh = ah_1h\). The product \(h_1h\) is in \(H\) because \(H\) is a subgroup. Furthermore, \(ah_1h\) must be in \(aH\) by the definition of a coset. Therefore, \(x = bh \in aH\) and so \(bH \subseteq aH\) as we wanted to show. Since \((b)\) also implies \((a)\) we can use a similar reasoning to show that \(aH \subseteq bH\). For \((d)\) …. Proposition 2.5.4 Let \(H\) be a subgroup of a group \(G\). Let \(a\) and \(b\) be elements of \(G\). Either \(aH = bH\) or \(aH \cap bH = \emptyset\) Each left coset \(aH\) is nonempty and the union of left cosets is \(G\). Proof For \((a)\), Suppose \(aH \cap bH \neq \emptyset\) and let \(c \in aH \cap bH\). Since \(c \in aH\), then \(aH = cH\) by Proposition 2.5.3. Similarly since \(c \in bH\), then \(bH = cH\). Therefore, \(aH = bH\). For \((b)\), \(aH\) is nonempty since \(H\) is a subgroup and can’t be empty. Furthermore, for each element \(g \in G\), \(g \in gH\). By \((a)\) then the union of all the left cosets must be \(G\). Proposition 2.5.5 Let \(H\) be a subgroup of a group \(G\) and let \(a\) and \(b\) be elements of \(G\). Then \(x \longmapsto ba^{-1}\) is a bijection between \(aH\) and \(bH\). Proof Let \(f : aH \rightarrow bH\) where \(f(x) = ba^{-1}x\). We want to show that \(f\) is a bijection by showing that it’s one-to-one and onto. Suppose \(a_1, a_2 \in aH\) then we can write \(a_1 = ah_1\) and \(a_2 = ah_2\) for some \(h_1, h_2 \in H\). Moreover, suppose that \(f(a_1) = f(a_2)\). Observe that $$ \begin{align*} ba^{-1}a_1 &amp;= ba^{-1}a_2 \\ b^{-1}ba^{-1}a_1 &amp;= b^{-1}ba^{-1}a_2 \quad \text{($G$ is a group so the inverse exists)} \\ aa^{-1}a_1 &amp;= aa^{-1}a_2 \\ a_1 &amp;= a_2 \\ \end{align*} $$ From this we see that \(f\) is one-to-one or injective. To see that it’s surjective, we need to show that for any element \(y \in bH\), that there exists an element \(x \in aH\) such that \(f(x) = y\). Since \(y \in bH\), then we can write \(y = bh\) for some \(h \in H\). Now, let \(x = ah \in aH\) and observe that $$ \begin{align*} f(x) &amp;= ba^{-1}x \\ &amp;= ba^{-1}(ah) \\ &amp;= b(a^{-1}ah) \\ &amp;= bh = y. \end{align*} $$ \(ah\) is in \(aH\) by definition. Therefore \(f\) is surjective. From this we see that \(f\) is a bijection from \(aH\) to \(bH\). \(\ \blacksquare\) Theorem 2.5.6 (Lagrange's Theorem) Let \(G\) be a finite group and \(H\) a subgroup. Then the cardinality of \(H\) divides the cardinality of \(G\), and the quotient \(\frac{|G|}{|H|}\) is the number of left cosets of \(H\) in \(G\). Proof]]></summary></entry><entry><title type="html">Project Euler: 25 1000-digit Fibonacci Number</title><link href="http://localhost:4000/jekyll/update/2024/12/14/project-euler-25-1000-digit-fibonacci-number.html" rel="alternate" type="text/html" title="Project Euler: 25 1000-digit Fibonacci Number" /><published>2024-12-14T00:01:36-08:00</published><updated>2024-12-14T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2024/12/14/project-euler-25-1000-digit-fibonacci-number</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/12/14/project-euler-25-1000-digit-fibonacci-number.html"><![CDATA[<p>This was also not so bad. At least the naive way to do this? I had a method that added two arrays together and returned the number of digits in the sum.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">add_two_arrays</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">sum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">an</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bn</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// least significant digit is at index 0</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">carry</span><span class="p">;</span>
        <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="n">total</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">carry</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">carry</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>I then used this array to sum the first two terms of fibonacci. The first two terms were saved in the arrays f1 and f2. The result will be saved in array sum. After we’re done, we copy f2 into f1 and then copy sum into f2 and repeat for another iteration until we reach the required the number of digits.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">f2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">an</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">5000</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">add_two_arrays</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">sum</span><span class="p">,</span> <span class="n">an</span><span class="p">,</span> <span class="n">bn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"we are done this is index = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">3</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">f1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f2</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">f2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">an</span> <span class="o">=</span> <span class="n">bn</span><span class="p">;</span>
	<span class="n">bn</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>One small optimization I can think of is to avoid copying sum into f2 and f2 into f1 and instead use pointers to these arrays to just figure out which two arrays to sum.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=25">Project Euler - 25</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This was also not so bad. At least the naive way to do this? I had a method that added two arrays together and returned the number of digits in the sum. int add_two_arrays(int *a, int *b, int *sum, int an, int bn) { // least significant digit is at index 0 int max = std::max(an, bn); int i = 0; int carry = 0; for (; i &lt; max; i++) { int total = a[i] + b[i] + carry; sum[i] = total % 10; carry = total / 10; } sum[i] = carry; if (carry == 0) { return i; } return i+1; } I then used this array to sum the first two terms of fibonacci. The first two terms were saved in the arrays f1 and f2. The result will be saved in array sum. After we’re done, we copy f2 into f1 and then copy sum into f2 and repeat for another iteration until we reach the required the number of digits. f1[0] = 1; f2[0] = 1; int an = 1, bn = 1; for (int k = 0; k &lt; 5000; k++) { int n = add_two_arrays(f1, f2, sum, an, bn); if (n == 1000) { printf("we are done this is index = %d\n", k+3); return 0; } for (int i = 0; i &lt; n; i++) { f1[i] = f2[i]; f2[i] = sum[i]; } an = bn; bn = n; } One small optimization I can think of is to avoid copying sum into f2 and f2 into f1 and instead use pointers to these arrays to just figure out which two arrays to sum. References Project Euler - 25]]></summary></entry><entry><title type="html">Project Euler: 24 Lexicographic Permutations</title><link href="http://localhost:4000/jekyll/update/2024/12/13/project-euler-24-lexicographic-permutations.html" rel="alternate" type="text/html" title="Project Euler: 24 Lexicographic Permutations" /><published>2024-12-13T00:01:36-08:00</published><updated>2024-12-13T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2024/12/13/project-euler-24-lexicographic-permutations</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/12/13/project-euler-24-lexicographic-permutations.html"><![CDATA[<p>We want to generate the millionth lexicographic permutation of the digits 0,1,2,3,4,5,6,7,8 and 9. While this can be done easily with the standard library’s own next_permutation as follows</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">()))</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
I think the point of the exercise is to implement this on our own or come up with a much faster method. I was more interested in seeing how next permutation is implemented or the idea behind it. I wrote about it <a href="https://strncat.github.io/jekyll/update/2024/12/02/next-permutation.html">here</a> and used my own implementation to solve the problem. The next step is to come up with a faster algorithm to do this!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=24">Project Euler - 24</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[We want to generate the millionth lexicographic permutation of the digits 0,1,2,3,4,5,6,7,8 and 9. While this can be done easily with the standard library’s own next_permutation as follows for (int i = 1; i &lt; 1000000; i++) { if (!std::next_permutation(a.begin(), a.end())) { break; } } I think the point of the exercise is to implement this on our own or come up with a much faster method. I was more interested in seeing how next permutation is implemented or the idea behind it. I wrote about it here and used my own implementation to solve the problem. The next step is to come up with a faster algorithm to do this! References Project Euler - 24]]></summary></entry><entry><title type="html">Project Euler: 23 Non-Abundant Sums</title><link href="http://localhost:4000/jekyll/update/2024/12/12/project-euler-23-non-abundant-sums.html" rel="alternate" type="text/html" title="Project Euler: 23 Non-Abundant Sums" /><published>2024-12-12T00:01:36-08:00</published><updated>2024-12-12T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2024/12/12/project-euler-23-non-abundant-sums</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/12/12/project-euler-23-non-abundant-sums.html"><![CDATA[<p>An abundant number \(n\) is a number for which the sum of its proper divisors is greater than \(n\).
<br />
<br />
We’re given that any number greater than 28123 can be expressed as a sum of two abundant numbers.
<br />
<br />
We want to find the sum of all numbers that can’t be expressed as a the sum of two abundant numbers. So we can limit ourselves to checking the numbers below the limit 28123.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Finding If a Number is Abundant</b></h4>
<p>We can find if a number is an abundant number by simply summing the proper divisors and seeing if the sum exceeds \(n\)</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"> <span class="kt">bool</span> <span class="nf">is_abundant</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//printf("n = %d\n", n);</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">divisors_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// it's a divisor</span>
            <span class="n">divisors_sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// add the other divisor</span>
                <span class="n">divisors_sum</span> <span class="o">+=</span> <span class="n">n</span><span class="o">/</span><span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">divisors_sum</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Finding If a Number is a Sum of Two Abundant Numbers</b></h4>
<p>The naive way to do this is by having two loops and checking all possible sums. A better way to do is given an integer \(n\) and an abundant number \(i\), we check if \(n - i\) is abundant. If \(n - i\) is abundant, then \(n\) can be a written as a sum of two abundant numbers.
<br />
<br />
To implement this, we then need two lists:</p>
<ul>
	<li> A list of all abundant numbers below 28123.</li>
	<li> An array of booleans to indicate whether a given number is abundant. We need this to check if \(n - i\) is abundant </li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_abundant</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">abundant</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">abundant_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>We can now implement our idea below</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">28123</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Find if i can be expressed as a sum of two abundant numbers</span>
    <span class="kt">bool</span> <span class="n">abundant_sum</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">abundant_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">abundant_numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">abundant</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">abundant_numbers</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span> <span class="p">{</span>
            <span class="n">abundant_sum</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span> <span class="c1">// exist early, this number can be written as a sum of two abundant numbers</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">abundant_sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>I’m a fan of adding both of these segments to keep track of the time.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">clock_t</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">time_spent</span><span class="p">;</span>
<span class="n">begin</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
<span class="c1">// SOLUTION</span>
<span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">();</span>
<span class="n">time_spent</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)(</span><span class="n">end</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span> <span class="o">/</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"time spent = %f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">time_spent</span><span class="p">);</span></code></pre></figure>

<p>For this solution, the time spent was 0.032616 so well below 1 second.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=23">Project Euler - 23</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[An abundant number \(n\) is a number for which the sum of its proper divisors is greater than \(n\). We’re given that any number greater than 28123 can be expressed as a sum of two abundant numbers. We want to find the sum of all numbers that can’t be expressed as a the sum of two abundant numbers. So we can limit ourselves to checking the numbers below the limit 28123. Finding If a Number is Abundant We can find if a number is an abundant number by simply summing the proper divisors and seeing if the sum exceeds \(n\) bool is_abundant(int n) { //printf("n = %d\n", n); int max = sqrt(n); int divisors_sum = 0; for (int i = 1; i &lt;= max; i++) { if (n % i == 0) { // it's a divisor divisors_sum += i; if (n / i != i &amp;&amp; i != 1) { // add the other divisor divisors_sum += n/i; } } } if (divisors_sum &gt; n) { return true; } return false; } Finding If a Number is a Sum of Two Abundant Numbers The naive way to do this is by having two loops and checking all possible sums. A better way to do is given an integer \(n\) and an abundant number \(i\), we check if \(n - i\) is abundant. If \(n - i\) is abundant, then \(n\) can be a written as a sum of two abundant numbers. To implement this, we then need two lists: A list of all abundant numbers below 28123. An array of booleans to indicate whether a given number is abundant. We need this to check if \(n - i\) is abundant for (int i = 1; i &lt;= N; i++) { if (is_abundant(i)) { abundant[i] = true; abundant_numbers.push_back(i); } } We can now implement our idea below int sum = 0; for (int i = 1; i &lt; 28123; i++) { // Find if i can be expressed as a sum of two abundant numbers bool abundant_sum = false; for (int j = 0; j &lt; abundant_numbers.size() &amp;&amp; abundant_numbers[j] &lt; i; j++) { if (abundant[i - abundant_numbers[j]]) { abundant_sum = true; break; // exist early, this number can be written as a sum of two abundant numbers } } if (!abundant_sum) { sum += i; } }]]></summary></entry><entry><title type="html">Project Euler</title><link href="http://localhost:4000/jekyll/update/2024/12/11/project-euler.html" rel="alternate" type="text/html" title="Project Euler" /><published>2024-12-11T08:01:36-08:00</published><updated>2024-12-11T08:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2024/12/11/project-euler</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/12/11/project-euler.html"><![CDATA[<ol>
	   <li>Multiples of 3 or 5</li> 
	   <li>Even Fibonacci Numbers</li>
	   <li>Largest Prime Factor</li>
	   <li>Largest Palindrome Product</li>	   
	   <li>Smallest Multiple</li>
	   <li>Sum Square Difference</li>
	   <li>10001st Prime</li>
	   <li>Largest Product in a Series</li>
	   <li>Special Pythagorean Triplet</li>
	   <li>Summation of Primes</li>
	   <li>Largest Product in a Grid</li>
	   <li>Highly Divisible Triangular Number</li>
	   <li>Large Sum</li>
	   <li>Longest Collatz Sequence</li>
	   <li>Lattice Paths</li>
	   <li>Power Digit Sum</li>
	   <li>Number Letter Counts</li>
	   <li>Maximum Path Sum I</li>
	   <li>Counting Sundays</li>
	   <li>Factorial Digit Sum</li>
	   <li>Amicable Numbers</li>	   
	   <li><a href="/jekyll/update/2024/12/10/project-euler-22-names-scores.html">
        Names Scores
       </a></li>
	   <li><a href="/jekyll/update/2024/12/12/project-euler-23-non-abundant-sums.html">
        Non-Abundant Sums
       </a></li>
	   <li><a href="/jekyll/update/2024/12/13/project-euler-24-lexicographic-permutations.html">
        Lexicographic Permutations
       </a></li>
	   <li><a href="/jekyll/update/2024/12/14/project-euler-25-1000-digit-fibonacci-number.html">
        1000-digit Fibonacci Number
       </a></li>
	   <li><a href="/jekyll/update/2025/01/02/project-euler-26-reciprocal-cycles.html">
        Reciprocal Cycles
       </a></li>
   </ol>
<p><br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Multiples of 3 or 5 Even Fibonacci Numbers Largest Prime Factor Largest Palindrome Product Smallest Multiple Sum Square Difference 10001st Prime Largest Product in a Series Special Pythagorean Triplet Summation of Primes Largest Product in a Grid Highly Divisible Triangular Number Large Sum Longest Collatz Sequence Lattice Paths Power Digit Sum Number Letter Counts Maximum Path Sum I Counting Sundays Factorial Digit Sum Amicable Numbers Names Scores Non-Abundant Sums Lexicographic Permutations 1000-digit Fibonacci Number Reciprocal Cycles]]></summary></entry><entry><title type="html">Project Euler: 22 Names Scores</title><link href="http://localhost:4000/jekyll/update/2024/12/10/project-euler-22-names-scores.html" rel="alternate" type="text/html" title="Project Euler: 22 Names Scores" /><published>2024-12-10T00:01:36-08:00</published><updated>2024-12-10T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2024/12/10/project-euler-22-names-scores</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/12/10/project-euler-22-names-scores.html"><![CDATA[<p>This was pretty straightforward. The first thing that I wanted to do is to point my input stream at the file we’re given. So just the following line.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">freopen</span><span class="p">(</span><span class="s">"0022_names.txt"</span> <span class="p">,</span> <span class="s">"r"</span> <span class="p">,</span> <span class="n">stdin</span><span class="p">);</span></code></pre></figure>

<p>The next thing we want is to read the chunk of names all at once so</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span></code></pre></figure>

<p>The chunk saved in str will look this</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="s">"MARY"</span><span class="p">,</span><span class="s">"PATRICIA"</span><span class="p">,</span><span class="s">"LINDA"</span><span class="p">,</span><span class="s">"BARBARA"</span><span class="p">,</span><span class="s">"ELIZABETH"</span><span class="p">,</span><span class="s">"JENNIFER"</span><span class="p">,</span><span class="s">"MARIA"</span><span class="p">,</span><span class="s">"SUSAN"</span><span class="p">,</span><span class="s">"MARGARET"</span><span class="p">,</span><span class="s">"DOROTHY"</span><span class="p">,</span>
<span class="s">"LISA"</span><span class="p">,</span><span class="s">"NANCY"</span><span class="p">,</span><span class="s">"KAREN"</span><span class="p">,</span><span class="s">"BETTY"</span><span class="p">,</span><span class="s">"HELEN"</span><span class="p">,</span><span class="s">"SANDRA"</span><span class="p">,</span><span class="s">"DONNA"</span><span class="p">,</span><span class="s">"CAROL"</span><span class="p">,</span><span class="s">"RUTH"</span><span class="p">,</span><span class="s">"SHARON"</span><span class="p">,</span><span class="s">"MICHELLE"</span><span class="p">,</span>
<span class="s">"LAURA"</span><span class="p">,</span><span class="s">"SARAH"</span><span class="p">,</span><span class="s">"KIMBERLY"</span><span class="p">,</span><span class="s">"DEBORAH"</span><span class="p">,</span><span class="s">"JESSICA"</span><span class="p">,</span><span class="s">"SHIRLEY"</span><span class="p">,</span><span class="s">"CYNTHIA"</span><span class="p">,</span><span class="s">"ANGELA"</span><span class="p">,</span><span class="s">"MELISSA"</span><span class="p">,</span><span class="s">"BRENDA"</span><span class="p">,</span><span class="s">"AMY"</span><span class="p">,</span>
<span class="s">"ANNA"</span><span class="p">,</span><span class="s">"REBECCA"</span><span class="p">,</span><span class="s">"VIRGINIA"</span><span class="p">,</span><span class="s">"KATHLEEN"</span><span class="p">,.....</span></code></pre></figure>

<p>Now we want to split them based on the delimiter “,” and we also want to take out the first and last character</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">names</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="nf">ss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">token</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">','</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">names</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">token</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">));</span>
<span class="p">}</span></code></pre></figure>

<p>Next, we want to sort the list of names. We can just use std::sort. I’m assuming years ago, this was painful to do.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">names</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">names</span><span class="p">.</span><span class="n">end</span><span class="p">());</span></code></pre></figure>

<p>Finally, we want to calculate the score as follows. (Remember that “A-A=0”, so we can just subtract “A” to get the score we want for each letter in the name).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">names</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="sc">'A'</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">score</span> <span class="o">*=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">score</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">score</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"score sum = %lld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=22">Project Euler - 22</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This was pretty straightforward. The first thing that I wanted to do is to point my input stream at the file we’re given. So just the following line. freopen("0022_names.txt" , "r" , stdin);]]></summary></entry><entry><title type="html">Abstract Algebra</title><link href="http://localhost:4000/jekyll/update/2024/12/05/number-theory.html" rel="alternate" type="text/html" title="Abstract Algebra" /><published>2024-12-05T08:01:36-08:00</published><updated>2024-12-05T08:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2024/12/05/number-theory</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/12/05/number-theory.html"><![CDATA[<!------------------------ [1] Algebraic Themes --------------------------->
<h4> [1] Algebraic Themes </h4>
<ol style="list-style-type:none;">
       <!--
	   <li><a href="/jekyll/update/2024/11/12/1.2-symmetries.html">
       [1.2] Symmetries
       </a></li>
	   -->
       <li><a href="/jekyll/update/2024/11/13/1.5-permutations.html">
       [1.5] Permutations (Representing Symmetries)
       </a></li>
	   <li><a href="/jekyll/update/2024/11/01/1.6-z.html">
        [1.6] Z (1.6.1 - 1.6.2)
       </a></li>
	   <li><a href="/jekyll/update/2024/11/02/1.6-primes.html">
        [1.6] Prime Numbers (1.6.4 - 1.6.7)
       </a></li>
	   <li><a href="/jekyll/update/2024/11/04/1.6-gcd.html">
        [1.6] Greatest Common Divisor (1.6.8 - 1.6.13)
       </a></li>
	   <li><a href="/jekyll/update/2024/11/05/1.6-relatively-prime.html">
        [1.6] Relatively Prime Integers (1.6.14 - 1.6.21)
       </a></li>	   
	   <li><a href="/jekyll/update/2024/11/06/1.6-gcd-many.html">
        [1.6] Greatest Common Divisor of Many Integers (1.6.22 - 1.6.25)
       </a></li>
	   <li><a href="/jekyll/update/2024/11/07/1.7-modular-arthmetic.html">
        [1.7] Modular Arithmetic
       </a></li>
   </ol>
<p><br />
<!------------------------ [2] Basic Theory of Groups ---------------------------></p>
<h4> [2] Basic Theory of Groups </h4>
<ol style="list-style-type:none;">
	   <li><a href="/jekyll/update/2024/11/09/2.1-first-results.html">
        [2.1] First Results
       </a></li>
	   <li><a href="/jekyll/update/2024/11/10/2.2-subgroups.html">
        [2.2] Subgroups and Cyclic Groups
       </a></li>
	   <li><a href="/jekyll/update/2024/11/11/2.4-homomorphisms-isomorphisms.html">
        [2.4] Homomorphisms and Isomorphisms
       </a></li>
	   <li><a href="/jekyll/update/2025/01/01/2.5-cosets-lagrange.html">
        [2.5] Cosets and Lagrange’s Theorem
       </a></li>
   </ol>
<p><br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[[1] Algebraic Themes [1.5] Permutations (Representing Symmetries) [1.6] Z (1.6.1 - 1.6.2) [1.6] Prime Numbers (1.6.4 - 1.6.7) [1.6] Greatest Common Divisor (1.6.8 - 1.6.13) [1.6] Relatively Prime Integers (1.6.14 - 1.6.21) [1.6] Greatest Common Divisor of Many Integers (1.6.22 - 1.6.25) [1.7] Modular Arithmetic [2] Basic Theory of Groups [2.1] First Results [2.2] Subgroups and Cyclic Groups [2.4] Homomorphisms and Isomorphisms [2.5] Cosets and Lagrange’s Theorem]]></summary></entry></feed>