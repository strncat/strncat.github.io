<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Knapsack | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Knapsack" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction The Knapsack problem is a classic dynamic programming problem. In this problem, we are given a knapsack of size for some integer and a list of items. Each item has an integer weight and an integer value, . The goal is to maximize the value of the knapsack under the constraint . There are many variations of the Knapsack problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack in the knapsack. So we either select an item or we don’t. There is also the unbounded knaspack where you have multiple/unbounded copies of each item. 2 Unbounded Knapsack Let’s focus now on the unbounded knapsack problem and let’s start with an example. Suppose we have an unbounded number of tacos, each of weight 2 and value 4. We also have burritos each of weight 6 and value 17. Suppose now that we have a knapsack of size, . The optimal solution is to pack 2 burritos and 1 taco which will give an optimal value of . 2.1 How to solve the Knapsack problem? The first thought that comes to mind is to try a greedy approach. Perhaps there is some way to pick the items at each step until the knapsack is filled? One might try a simple greedy algorithm of say always picking the item with the best value/weight ratio. In the example, we’ll pick 2 burritos of value which is not an optimal value! 2.2 Complete Search We can also try a complete search of every possible combinations of items. I’m not sure about the thought process here but I was thinking the following should give us an upper bound. For each item with weight and value , we insert copies of to a new list of items. If we original had items, we could potentially insert items. Give this this list. For each item in the list, we can either select the item to be in the knapsack or not. Therefore, the running time will be . 2.3 Dynamic Programming As we saw above, greedy doesn’t work and exhaustive search takes exponential time. It turns out we can do much better with dynamic programming! To use dynamic programming we need to find an optimal substructure. An optimal substructure means that the solution to the problem will contain within it solutions to smaller subproblems. It turns out we have a beautiful optimal substructure for the Knapsack problem. Let be the optimal value for capacity . We will have the following recursive substructure: $$ \begin{align*} K[x] = \max_i\{K[x - w_i] + v_i\} \end{align*} $$ In other words, suppose we have unlimited copies of the following items, . Assume now that the optimal solution contains some item . Then we will see that , meaning that the optimal solution for contains within it optimal solutions to smaller subproblems. 2.4 Implementation typedef struct item { int w; int v; item(int weight, int value) { w = weight; v = value; } } item; int unbounded_knapsack(std::vector&lt;item&gt; &amp;bag, int W) { std::vector&lt;std::vector&lt;int&gt;&gt; items; std::vector&lt;int&gt; K; for (int i = 0; i &lt;= W; i++) { K.push_back(0); items.push_back(std::vector&lt;int&gt;()); } // base case, k[0] = 0 for (int w = 1; w &lt;= W; w++) { // for each weight w for (int i = 0; i &lt; bag.size(); i++) { // for each item i if (bag[i].w &lt;= w &amp;&amp; bag[i].v + K[w - bag[i].w] &gt; K[w]) { // maybe there is a more effient way? items[w].clear(); items[w].push_back(i); items[w].insert(items[w].end(), items[w-bag[i].w].begin(), items[w-bag[i].w].end()); K[w] = bag[i].v + K[w - bag[i].w]; } } } // print items for (int i = 0; i &lt; items[W].size(); i++) { printf(&quot;(%d %d) &quot;, bag[items[W][i]].w, bag[items[W][i]].v); } printf(&quot;\n&quot;); printf(&quot;Optimal value = %d\n&quot;, K[W]); return K[W]; } 2.5 Proof of Correctness We claim that our recursive substructure we’ve shown earlier is optimal. Proof: Suppose that we have a knapsack of size and suppose that we have unbounded copies of items available to us. Now suppose that we know the optimal value to the knapsack is and that the optimal solution contains one copy of item for some natural number . We claim that is an optimal value for a knapsack of size . That is, . We will prove our claim by contradiction. Suppose that is not an optimal value and that the optimal value is . Since we know that the optimal solution to the knapsack of size contains a copy of item , we can therefore add to to obtain an optimal value . But . This is a contradiction since we assumed that is an optimal value. Therefore, must be an optimal value for a knapsack of size . 2.6 Running Time: Assume we have items and the knapsack is of size . The runtime is . 3 0/1 Knapsack Let’s focus now on the 0/1 knapsack problem and let’s start with an example. Suppose we have a taco of weight 3 and value 10. We also a burrito of weight 6 and value 14 and a enchilada of weight 5 and value 11. Suppose now that we have a knapsack of size, . The optimal solution is to pack a taco and an enchilada for a total value of 27. 3.1 Solutions? Complete Search A greedy approach won’t work similar to the unbounded knapsack. We can instead do an exhaustive search. We can check every possible combination of the items we have. We will have 2 choices for each item. We either select the item or we don’t. Therefore, we have possible subsets to check and the running time is . 3.2 Dynamic Programming Unfortunately we can’t use the same recursive substructure in the unbounded knapsack above. In this problem, we need to also keep track of which items are available at each step since some might have been taken. So if the smaller subproblem is using an item , the larger problem must know not to re-take it which is a violation to the constraint of having one copy only per item. Therefore, our subproblems must track both the size of the knapsack and the items allowed so far and therefore, we need a two dimensional table! we’ll let to indicate the knapsack size and to indicate that we’re using the first items. Suppose we know the optimal solution to for a knapsack of size using items . There are two cases: Case 1: does not use item . In this case, . Case 2: We do use item . In this case, we claim that . We can therefore, summarize it in: $$ \begin{align*} K[x,y] = \max\{K[x, y-1], K[x - w_y, y-1] + v_y\} \end{align*} $$ With the base case of and . 3.3 Proof of Correctness The proof is very similar to the structure of our earlier proof to the unbounded knapsack problem. If we can have a better solution to the subproblem then we can have even a better solution to the optimal solution to the larger problem which is a contradiction. I might write it later?. 3.3 Implementation int knapsack_01(std::vector&lt;item&gt; &amp;bag, int W) { int K[100][100] = {0}; // base case k[0][j] = 0, K[i][0] = 0 for (int w = 1; w &lt;= W; w++) { // for each weight w for (int i = 1; i &lt;= bag.size(); i++) { // for each item i: // case 1: item i is not in the optimal solution K[w][i] = K[w][i-1]; // case 2: item i is in the optimal solution if (bag[i-1].w &lt;= w &amp;&amp; bag[i-1].v + K[w - bag[i-1].w][i-1] &gt; K[w][i]) { K[w][i] = bag[i-1].v + K[w - bag[i-1].w][i-1]; } } } // print items int res = K[W][bag.size()]; printf(&quot;%d\n&quot;, res); int cur_w = W; int cur_v = K[W][bag.size()]; for (int i = (int)bag.size(); i &gt; 0 &amp;&amp; res &gt; 0; i--) { if (cur_v != K[cur_w][i-1]) { printf(&quot;%d %d\n&quot;, bag[i-1].w, bag[i-1].v); cur_v -= bag[i-1].v; cur_w -= bag[i-1].w; } } printf(&quot;\n&quot;); printf(&quot;Optimal value = %d\n&quot;, K[W][bag.size()]); return K[W][bag.size()]; } 6 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/knapsack.cpp" />
<meta property="og:description" content="0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction The Knapsack problem is a classic dynamic programming problem. In this problem, we are given a knapsack of size for some integer and a list of items. Each item has an integer weight and an integer value, . The goal is to maximize the value of the knapsack under the constraint . There are many variations of the Knapsack problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack in the knapsack. So we either select an item or we don’t. There is also the unbounded knaspack where you have multiple/unbounded copies of each item. 2 Unbounded Knapsack Let’s focus now on the unbounded knapsack problem and let’s start with an example. Suppose we have an unbounded number of tacos, each of weight 2 and value 4. We also have burritos each of weight 6 and value 17. Suppose now that we have a knapsack of size, . The optimal solution is to pack 2 burritos and 1 taco which will give an optimal value of . 2.1 How to solve the Knapsack problem? The first thought that comes to mind is to try a greedy approach. Perhaps there is some way to pick the items at each step until the knapsack is filled? One might try a simple greedy algorithm of say always picking the item with the best value/weight ratio. In the example, we’ll pick 2 burritos of value which is not an optimal value! 2.2 Complete Search We can also try a complete search of every possible combinations of items. I’m not sure about the thought process here but I was thinking the following should give us an upper bound. For each item with weight and value , we insert copies of to a new list of items. If we original had items, we could potentially insert items. Give this this list. For each item in the list, we can either select the item to be in the knapsack or not. Therefore, the running time will be . 2.3 Dynamic Programming As we saw above, greedy doesn’t work and exhaustive search takes exponential time. It turns out we can do much better with dynamic programming! To use dynamic programming we need to find an optimal substructure. An optimal substructure means that the solution to the problem will contain within it solutions to smaller subproblems. It turns out we have a beautiful optimal substructure for the Knapsack problem. Let be the optimal value for capacity . We will have the following recursive substructure: $$ \begin{align*} K[x] = \max_i\{K[x - w_i] + v_i\} \end{align*} $$ In other words, suppose we have unlimited copies of the following items, . Assume now that the optimal solution contains some item . Then we will see that , meaning that the optimal solution for contains within it optimal solutions to smaller subproblems. 2.4 Implementation typedef struct item { int w; int v; item(int weight, int value) { w = weight; v = value; } } item; int unbounded_knapsack(std::vector&lt;item&gt; &amp;bag, int W) { std::vector&lt;std::vector&lt;int&gt;&gt; items; std::vector&lt;int&gt; K; for (int i = 0; i &lt;= W; i++) { K.push_back(0); items.push_back(std::vector&lt;int&gt;()); } // base case, k[0] = 0 for (int w = 1; w &lt;= W; w++) { // for each weight w for (int i = 0; i &lt; bag.size(); i++) { // for each item i if (bag[i].w &lt;= w &amp;&amp; bag[i].v + K[w - bag[i].w] &gt; K[w]) { // maybe there is a more effient way? items[w].clear(); items[w].push_back(i); items[w].insert(items[w].end(), items[w-bag[i].w].begin(), items[w-bag[i].w].end()); K[w] = bag[i].v + K[w - bag[i].w]; } } } // print items for (int i = 0; i &lt; items[W].size(); i++) { printf(&quot;(%d %d) &quot;, bag[items[W][i]].w, bag[items[W][i]].v); } printf(&quot;\n&quot;); printf(&quot;Optimal value = %d\n&quot;, K[W]); return K[W]; } 2.5 Proof of Correctness We claim that our recursive substructure we’ve shown earlier is optimal. Proof: Suppose that we have a knapsack of size and suppose that we have unbounded copies of items available to us. Now suppose that we know the optimal value to the knapsack is and that the optimal solution contains one copy of item for some natural number . We claim that is an optimal value for a knapsack of size . That is, . We will prove our claim by contradiction. Suppose that is not an optimal value and that the optimal value is . Since we know that the optimal solution to the knapsack of size contains a copy of item , we can therefore add to to obtain an optimal value . But . This is a contradiction since we assumed that is an optimal value. Therefore, must be an optimal value for a knapsack of size . 2.6 Running Time: Assume we have items and the knapsack is of size . The runtime is . 3 0/1 Knapsack Let’s focus now on the 0/1 knapsack problem and let’s start with an example. Suppose we have a taco of weight 3 and value 10. We also a burrito of weight 6 and value 14 and a enchilada of weight 5 and value 11. Suppose now that we have a knapsack of size, . The optimal solution is to pack a taco and an enchilada for a total value of 27. 3.1 Solutions? Complete Search A greedy approach won’t work similar to the unbounded knapsack. We can instead do an exhaustive search. We can check every possible combination of the items we have. We will have 2 choices for each item. We either select the item or we don’t. Therefore, we have possible subsets to check and the running time is . 3.2 Dynamic Programming Unfortunately we can’t use the same recursive substructure in the unbounded knapsack above. In this problem, we need to also keep track of which items are available at each step since some might have been taken. So if the smaller subproblem is using an item , the larger problem must know not to re-take it which is a violation to the constraint of having one copy only per item. Therefore, our subproblems must track both the size of the knapsack and the items allowed so far and therefore, we need a two dimensional table! we’ll let to indicate the knapsack size and to indicate that we’re using the first items. Suppose we know the optimal solution to for a knapsack of size using items . There are two cases: Case 1: does not use item . In this case, . Case 2: We do use item . In this case, we claim that . We can therefore, summarize it in: $$ \begin{align*} K[x,y] = \max\{K[x, y-1], K[x - w_y, y-1] + v_y\} \end{align*} $$ With the base case of and . 3.3 Proof of Correctness The proof is very similar to the structure of our earlier proof to the unbounded knapsack problem. If we can have a better solution to the subproblem then we can have even a better solution to the optimal solution to the larger problem which is a contradiction. I might write it later?. 3.3 Implementation int knapsack_01(std::vector&lt;item&gt; &amp;bag, int W) { int K[100][100] = {0}; // base case k[0][j] = 0, K[i][0] = 0 for (int w = 1; w &lt;= W; w++) { // for each weight w for (int i = 1; i &lt;= bag.size(); i++) { // for each item i: // case 1: item i is not in the optimal solution K[w][i] = K[w][i-1]; // case 2: item i is in the optimal solution if (bag[i-1].w &lt;= w &amp;&amp; bag[i-1].v + K[w - bag[i-1].w][i-1] &gt; K[w][i]) { K[w][i] = bag[i-1].v + K[w - bag[i-1].w][i-1]; } } } // print items int res = K[W][bag.size()]; printf(&quot;%d\n&quot;, res); int cur_w = W; int cur_v = K[W][bag.size()]; for (int i = (int)bag.size(); i &gt; 0 &amp;&amp; res &gt; 0; i--) { if (cur_v != K[cur_w][i-1]) { printf(&quot;%d %d\n&quot;, bag[i-1].w, bag[i-1].v); cur_v -= bag[i-1].v; cur_w -= bag[i-1].w; } } printf(&quot;\n&quot;); printf(&quot;Optimal value = %d\n&quot;, K[W][bag.size()]); return K[W][bag.size()]; } 6 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/knapsack.cpp" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/07/02/knapsack.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/07/02/knapsack.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-02T07:01:36-07:00" />
<script type="application/ld+json">
{"description":"0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction The Knapsack problem is a classic dynamic programming problem. In this problem, we are given a knapsack of size for some integer and a list of items. Each item has an integer weight and an integer value, . The goal is to maximize the value of the knapsack under the constraint . There are many variations of the Knapsack problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack in the knapsack. So we either select an item or we don’t. There is also the unbounded knaspack where you have multiple/unbounded copies of each item. 2 Unbounded Knapsack Let’s focus now on the unbounded knapsack problem and let’s start with an example. Suppose we have an unbounded number of tacos, each of weight 2 and value 4. We also have burritos each of weight 6 and value 17. Suppose now that we have a knapsack of size, . The optimal solution is to pack 2 burritos and 1 taco which will give an optimal value of . 2.1 How to solve the Knapsack problem? The first thought that comes to mind is to try a greedy approach. Perhaps there is some way to pick the items at each step until the knapsack is filled? One might try a simple greedy algorithm of say always picking the item with the best value/weight ratio. In the example, we’ll pick 2 burritos of value which is not an optimal value! 2.2 Complete Search We can also try a complete search of every possible combinations of items. I’m not sure about the thought process here but I was thinking the following should give us an upper bound. For each item with weight and value , we insert copies of to a new list of items. If we original had items, we could potentially insert items. Give this this list. For each item in the list, we can either select the item to be in the knapsack or not. Therefore, the running time will be . 2.3 Dynamic Programming As we saw above, greedy doesn’t work and exhaustive search takes exponential time. It turns out we can do much better with dynamic programming! To use dynamic programming we need to find an optimal substructure. An optimal substructure means that the solution to the problem will contain within it solutions to smaller subproblems. It turns out we have a beautiful optimal substructure for the Knapsack problem. Let be the optimal value for capacity . We will have the following recursive substructure: $$ \\begin{align*} K[x] = \\max_i\\{K[x - w_i] + v_i\\} \\end{align*} $$ In other words, suppose we have unlimited copies of the following items, . Assume now that the optimal solution contains some item . Then we will see that , meaning that the optimal solution for contains within it optimal solutions to smaller subproblems. 2.4 Implementation typedef struct item { int w; int v; item(int weight, int value) { w = weight; v = value; } } item; int unbounded_knapsack(std::vector&lt;item&gt; &amp;bag, int W) { std::vector&lt;std::vector&lt;int&gt;&gt; items; std::vector&lt;int&gt; K; for (int i = 0; i &lt;= W; i++) { K.push_back(0); items.push_back(std::vector&lt;int&gt;()); } // base case, k[0] = 0 for (int w = 1; w &lt;= W; w++) { // for each weight w for (int i = 0; i &lt; bag.size(); i++) { // for each item i if (bag[i].w &lt;= w &amp;&amp; bag[i].v + K[w - bag[i].w] &gt; K[w]) { // maybe there is a more effient way? items[w].clear(); items[w].push_back(i); items[w].insert(items[w].end(), items[w-bag[i].w].begin(), items[w-bag[i].w].end()); K[w] = bag[i].v + K[w - bag[i].w]; } } } // print items for (int i = 0; i &lt; items[W].size(); i++) { printf(&quot;(%d %d) &quot;, bag[items[W][i]].w, bag[items[W][i]].v); } printf(&quot;\\n&quot;); printf(&quot;Optimal value = %d\\n&quot;, K[W]); return K[W]; } 2.5 Proof of Correctness We claim that our recursive substructure we’ve shown earlier is optimal. Proof: Suppose that we have a knapsack of size and suppose that we have unbounded copies of items available to us. Now suppose that we know the optimal value to the knapsack is and that the optimal solution contains one copy of item for some natural number . We claim that is an optimal value for a knapsack of size . That is, . We will prove our claim by contradiction. Suppose that is not an optimal value and that the optimal value is . Since we know that the optimal solution to the knapsack of size contains a copy of item , we can therefore add to to obtain an optimal value . But . This is a contradiction since we assumed that is an optimal value. Therefore, must be an optimal value for a knapsack of size . 2.6 Running Time: Assume we have items and the knapsack is of size . The runtime is . 3 0/1 Knapsack Let’s focus now on the 0/1 knapsack problem and let’s start with an example. Suppose we have a taco of weight 3 and value 10. We also a burrito of weight 6 and value 14 and a enchilada of weight 5 and value 11. Suppose now that we have a knapsack of size, . The optimal solution is to pack a taco and an enchilada for a total value of 27. 3.1 Solutions? Complete Search A greedy approach won’t work similar to the unbounded knapsack. We can instead do an exhaustive search. We can check every possible combination of the items we have. We will have 2 choices for each item. We either select the item or we don’t. Therefore, we have possible subsets to check and the running time is . 3.2 Dynamic Programming Unfortunately we can’t use the same recursive substructure in the unbounded knapsack above. In this problem, we need to also keep track of which items are available at each step since some might have been taken. So if the smaller subproblem is using an item , the larger problem must know not to re-take it which is a violation to the constraint of having one copy only per item. Therefore, our subproblems must track both the size of the knapsack and the items allowed so far and therefore, we need a two dimensional table! we’ll let to indicate the knapsack size and to indicate that we’re using the first items. Suppose we know the optimal solution to for a knapsack of size using items . There are two cases: Case 1: does not use item . In this case, . Case 2: We do use item . In this case, we claim that . We can therefore, summarize it in: $$ \\begin{align*} K[x,y] = \\max\\{K[x, y-1], K[x - w_y, y-1] + v_y\\} \\end{align*} $$ With the base case of and . 3.3 Proof of Correctness The proof is very similar to the structure of our earlier proof to the unbounded knapsack problem. If we can have a better solution to the subproblem then we can have even a better solution to the optimal solution to the larger problem which is a contradiction. I might write it later?. 3.3 Implementation int knapsack_01(std::vector&lt;item&gt; &amp;bag, int W) { int K[100][100] = {0}; // base case k[0][j] = 0, K[i][0] = 0 for (int w = 1; w &lt;= W; w++) { // for each weight w for (int i = 1; i &lt;= bag.size(); i++) { // for each item i: // case 1: item i is not in the optimal solution K[w][i] = K[w][i-1]; // case 2: item i is in the optimal solution if (bag[i-1].w &lt;= w &amp;&amp; bag[i-1].v + K[w - bag[i-1].w][i-1] &gt; K[w][i]) { K[w][i] = bag[i-1].v + K[w - bag[i-1].w][i-1]; } } } // print items int res = K[W][bag.size()]; printf(&quot;%d\\n&quot;, res); int cur_w = W; int cur_v = K[W][bag.size()]; for (int i = (int)bag.size(); i &gt; 0 &amp;&amp; res &gt; 0; i--) { if (cur_v != K[cur_w][i-1]) { printf(&quot;%d %d\\n&quot;, bag[i-1].w, bag[i-1].v); cur_v -= bag[i-1].v; cur_w -= bag[i-1].w; } } printf(&quot;\\n&quot;); printf(&quot;Optimal value = %d\\n&quot;, K[W][bag.size()]); return K[W][bag.size()]; } 6 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/knapsack.cpp","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/07/02/knapsack.html","headline":"Knapsack","dateModified":"2019-07-02T07:01:36-07:00","datePublished":"2019-07-02T07:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/07/02/knapsack.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Knapsack</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-07-02T07:01:36-07:00" itemprop="datePublished">Jul 2, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><b>0 References</b><br />
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>1 Introduction</b><br />
The Knapsack problem is a classic dynamic programming problem. In this problem, we are given a knapsack of size <script type="math/tex">W</script> for some integer <script type="math/tex">W</script> and a list of items. Each item <script type="math/tex">x_i</script> has an integer weight <script type="math/tex">w_i</script> and an integer value, <script type="math/tex">v_i</script>. The goal is to maximize the value of the knapsack under the constraint <script type="math/tex">W</script>. There are many variations of the Knapsack problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack in the knapsack. So we either select an item <script type="math/tex">x_i</script> or we don’t. There is also the unbounded knaspack where you have multiple/unbounded copies of each item.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2 Unbounded Knapsack</b><br />
Let’s focus now on the unbounded knapsack problem and let’s start with an example. Suppose we have an unbounded number of tacos, each of weight 2 and value 4. We also have burritos each of weight 6 and value 17. Suppose now that we have a knapsack of size, <script type="math/tex">W=14</script>. The optimal solution is to pack 2 burritos and 1 taco which will give an optimal value of <script type="math/tex">2*17+1*4=38</script>. 
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2.1 How to solve the Knapsack problem?</b><br />
The first thought that comes to mind is to try a greedy approach. Perhaps there is some way to pick the items at each step until the knapsack is filled? One might try a simple greedy algorithm of say always picking the item with the best value/weight ratio. In the example, we’ll pick 2 burritos of value <script type="math/tex">2*17=34</script> which is not an optimal value!
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2.2 Complete Search</b>
<br />
We can also try a complete search of every possible combinations of items. I’m not sure about the thought process here but I was thinking the following should give us an upper bound. For each item <script type="math/tex">x_i</script> with weight <script type="math/tex">w_i</script> and value <script type="math/tex">v_i</script>, we insert <script type="math/tex">\lceil W/x_i \rceil</script> copies of <script type="math/tex">x_i</script> to a new list of items. If we original had <script type="math/tex">n</script> items, we could potentially insert <script type="math/tex">O(n^2)</script> items. Give this this list. For each item in the list, we can either select the item to be in the knapsack or not. Therefore, the running time will be <script type="math/tex">O(2^{n^2})</script>.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2.3 Dynamic Programming</b>
<br />
As we saw above, greedy doesn’t work and exhaustive search takes exponential time. It turns out we can do much better with dynamic programming! To use dynamic programming we need to find an optimal substructure. An optimal substructure means that the solution to the problem will contain within it solutions to smaller subproblems. It turns out we have a beautiful optimal substructure for the Knapsack problem.
<br />
<br />
Let <script type="math/tex">K[x]</script> be the optimal value for capacity <script type="math/tex">x</script>. We will have the following recursive substructure:</p>
<div center="">
$$
\begin{align*}
K[x] = \max_i\{K[x - w_i] + v_i\}
\end{align*}
$$
</div>
<p>In other words, suppose we have unlimited copies of the following <script type="math/tex">n</script> items, <script type="math/tex">\{\{w_0,v_0\},\{w_1,v_0\},...,\{w_n,v_n\}\}</script>. Assume now that the optimal solution contains some item <script type="math/tex">x_i</script>. Then we will see that <script type="math/tex">K[x-w_i] = k[x] - v_i</script>, meaning that the optimal solution for <script type="math/tex">K[x]</script> contains within it optimal solutions to smaller subproblems.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2.4 Implementation</b>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">item</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">w</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">item</span><span class="p">(</span><span class="kt">int</span> <span class="n">weight</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">weight</span><span class="p">;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">item</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">unbounded_knapsack</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">bag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">items</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">K</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">K</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">items</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="c1">// base case, k[0] = 0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each weight w</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each item i</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">])</span> <span class="p">{</span>
                <span class="c1">// maybe there is a more effient way?</span>
                <span class="n">items</span><span class="p">[</span><span class="n">w</span><span class="p">].</span><span class="n">clear</span><span class="p">();</span>
                <span class="n">items</span><span class="p">[</span><span class="n">w</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                <span class="n">items</span><span class="p">[</span><span class="n">w</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">w</span><span class="p">].</span><span class="n">end</span><span class="p">(),</span> <span class="n">items</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">].</span><span class="n">begin</span><span class="p">(),</span> <span class="n">items</span><span class="p">[</span><span class="n">w</span><span class="o">-</span><span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">].</span><span class="n">end</span><span class="p">());</span>
                <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">]</span> <span class="o">=</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">w</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// print items</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">items</span><span class="p">[</span><span class="n">W</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"(%d %d) "</span><span class="p">,</span> <span class="n">bag</span><span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">i</span><span class="p">]].</span><span class="n">w</span><span class="p">,</span> <span class="n">bag</span><span class="p">[</span><span class="n">items</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">i</span><span class="p">]].</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Optimal value = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">];</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2.5 Proof of Correctness</b><br />
We claim that our recursive substructure we’ve shown earlier is optimal. 
<br />
<i>Proof:</i> <br />
Suppose that we have a knapsack of size <script type="math/tex">W</script> and suppose that we have unbounded copies of <script type="math/tex">n</script> items available to us. Now suppose that we know the optimal value to the knapsack is <script type="math/tex">K[W]</script> and that the optimal solution contains one copy of item <script type="math/tex">x_k</script> for some natural number <script type="math/tex">k</script>. We claim that <script type="math/tex">K[W] - v_k</script> is an optimal value for a knapsack of size <script type="math/tex">W - x_k</script>. That is, <script type="math/tex">K[W - x_k] = K[W] - v_k</script>.
<br /><br />
We will prove our claim by contradiction. Suppose that <script type="math/tex">K[W] - v_k</script> is not an optimal value and that the optimal value is <script type="math/tex">T^{\prime}</script>. Since we know that the optimal solution to the knapsack of size <script type="math/tex">W</script> contains a copy of item <script type="math/tex">x_k</script>, we can therefore add <script type="math/tex">x_k</script> to <script type="math/tex">K[W - x_k]</script> to obtain an optimal value <script type="math/tex">T^{\prime} + v_k</script>. But <script type="math/tex">T^{\prime} + v_k >  K[W] - v_k + v_k = K[W]</script>. This is a contradiction since we assumed that <script type="math/tex">K[W]</script> is an optimal value. Therefore, <script type="math/tex">K[W] - v_k</script> must be an optimal value for a knapsack of size <script type="math/tex">W - x_k</script>. <script type="math/tex">\blacksquare</script>
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2.6 Running Time:</b> <br />
Assume we have <script type="math/tex">n</script> items and the knapsack is of size <script type="math/tex">W</script>. The runtime is <script type="math/tex">O(nW)</script>.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3 0/1 Knapsack</b><br />
Let’s focus now on the 0/1 knapsack problem and let’s start with an example. Suppose we have a taco of weight 3 and value 10. We also a burrito of weight 6 and value 14 and a enchilada of weight 5 and value 11. Suppose now that we have a knapsack of size, <script type="math/tex">W=9</script>. The optimal solution is to pack a taco and an enchilada for a total value of 27.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3.1 Solutions? Complete Search</b><br />
A greedy approach won’t work similar to the unbounded knapsack. We can instead do an exhaustive search. We can check every possible combination of the items we have. We will have 2 choices for each item. We either select the item or we don’t. Therefore, we have <script type="math/tex">2^n</script> possible subsets to check and the running time is <script type="math/tex">O(2^n)</script>. 
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3.2 Dynamic Programming</b>
<br />
Unfortunately we can’t use the same recursive substructure in the unbounded knapsack above. In this problem, we need to also keep track of which items are available at each step since some might have been taken. So if the smaller subproblem is using an item <script type="math/tex">x</script>, the larger problem must know not to re-take it which is a violation to the constraint of having one copy only per item.
<br />
<br />
Therefore, our subproblems must track both the size of the knapsack and the items allowed so far and therefore, we need a two dimensional table! we’ll let <script type="math/tex">x</script> to indicate the knapsack size and <script type="math/tex">y</script> to indicate that we’re using the first <script type="math/tex">y</script> items.
<br />
<br />
Suppose we know the optimal solution to <script type="math/tex">K[x,y]</script> for a knapsack of size <script type="math/tex">x</script> using items <script type="math/tex">0,..y</script>.
<br />
There are two cases:
<br />
Case 1: <script type="math/tex">K[x,y]</script> does not use item <script type="math/tex">y</script>. In this case, <script type="math/tex">K[x,y] = K[x,y-1]</script>.
<br />
Case 2: We do use item <script type="math/tex">y</script>. In this case, we claim that <script type="math/tex">K[x,y] = K[x-w_y,y-1] + y_k</script>.
<br />
We can therefore, summarize it in:</p>
<div center="">
$$
\begin{align*}
K[x,y] = \max\{K[x, y-1], K[x - w_y, y-1] + v_y\}
\end{align*}
$$
</div>
<p>With the base case of <script type="math/tex">K[x,0]=0</script> and <script type="math/tex">K[0,y]=0</script>.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3.3 Proof of Correctness</b><br />
The proof is very similar to the structure of our earlier proof to the unbounded knapsack problem. If we can have a better solution to the subproblem then we can have even a better solution to the optimal solution to the larger problem which is a contradiction. I might write it later?.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3.3 Implementation</b>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">knapsack_01</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">bag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">K</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="c1">// base case k[0][j] = 0, K[i][0] = 0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each weight w</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each item i:</span>
            <span class="c1">// case 1: item i is not in the optimal solution</span>
            <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="c1">// case 2: item i is in the optimal solution</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// print items</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">cur_w</span> <span class="o">=</span> <span class="n">W</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cur_v</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_v</span> <span class="o">!=</span> <span class="n">K</span><span class="p">[</span><span class="n">cur_w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">,</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
            <span class="n">cur_v</span> <span class="o">-=</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
            <span class="n">cur_w</span> <span class="o">-=</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Optimal value = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()]);</span>
    <span class="k">return</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>6 Full Implementation:</b> <br />
https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/knapsack.cpp
<br />
<br /></p>


  </div><a class="u-url" href="/jekyll/update/2019/07/02/knapsack.html" hidden></a>
</article>

		
	 
    	 
		 
		 
      </div>
	  
	  
	  
	 
    </main>
	
	
	 

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
