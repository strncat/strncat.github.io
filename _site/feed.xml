<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-12T17:22:01-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">nemo’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Project Euler: 27 Quadratic Primes</title><link href="http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes.html" rel="alternate" type="text/html" title="Project Euler: 27 Quadratic Primes" /><published>2025-01-11T00:01:36-08:00</published><updated>2025-01-11T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes.html"><![CDATA[<p>I was so scared when I read the problem description! so I was shocked when I just got this on the first try. Admittedly, my solution is just the naive solution but it was fast enough. Basically we want to know \(a\) and \(b\) that will make the equation \(f(n) = n^2 + an + b\) produce the longest sequence of prime numbers. To do so, we need a fast way to check whether a number is prime. For that we can just borrow the sieve algorithm we implemented for problem 7.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
After this, it is pretty straight forward. Just check all possible the values for \(a\) and \(b\). Both variables will range from -999 to 999.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">sieve</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// f(n) = n^2 + an + b</span>
        <span class="c1">// f(0) = b is the initial value</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">fn</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">n</span><span class="o">++</span><span class="p">;</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
            <span class="n">max_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">max_b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"a = %d, b = %d, a*b = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max_a</span><span class="p">,</span> <span class="n">max_b</span><span class="p">,</span> <span class="n">max_a</span> <span class="o">*</span> <span class="n">max_b</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=27">Project Euler - 27</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I was so scared when I read the problem description! so I was shocked when I just got this on the first try. Admittedly, my solution is just the naive solution but it was fast enough. Basically we want to know \(a\) and \(b\) that will make the equation \(f(n) = n^2 + an + b\) produce the longest sequence of prime numbers. To do so, we need a fast way to check whether a number is prime. For that we can just borrow the sieve algorithm we implemented for problem 7. void sieve() { int s[N]; // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { primes[i] = 1; } s[0] = s[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (primes[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { primes[i] = 0; } } } } After this, it is pretty straight forward. Just check all possible the values for \(a\) and \(b\). Both variables will range from -999 to 999. sieve(); int max_count = 0, max_a = 0, max_b = 0; for (int a = -999; a &lt; 1000; a++) { for (int b = -999; b &lt; 1000; b++) { // f(n) = n^2 + an + b // f(0) = b is the initial value int n = 0; int fn = b; int count = 0; while (primes[fn]) { count++; n++; fn = n*n + a*n + b; } if (count &gt; max_count) { max_count = count; max_a = a; max_b = b; } } } printf("a = %d, b = %d, a*b = %d\n", max_a, max_b, max_a * max_b); References Project Euler - 27]]></summary></entry><entry><title type="html">Project Euler: 7 10001st Prime</title><link href="http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime.html" rel="alternate" type="text/html" title="Project Euler: 7 10001st Prime" /><published>2025-01-10T00:01:36-08:00</published><updated>2025-01-10T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime.html"><![CDATA[<p>This is just Sieve’s algorithm to find all primes until we reach the 10001st prime. I don’t know know if there is a faster algorithm to do this.
In Sieve’s algorithm, we mark all numbers up to our limit \(N\) as potential primes. Then starting at 2, we mark all multiples of 2 as non prime. When we’re done, we move to the next potenial prime and repeat the same process.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define N 1000000
</span><span class="kt">int</span> <span class="n">primes</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">primes</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// the 10001st prime is primes[10000]</span>
<span class="p">}</span></code></pre></figure>

<p><br />
This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm).
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=7">Project Euler - 07</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This is just Sieve’s algorithm to find all primes until we reach the 10001st prime. I don’t know know if there is a faster algorithm to do this. In Sieve’s algorithm, we mark all numbers up to our limit \(N\) as potential primes. Then starting at 2, we mark all multiples of 2 as non prime. When we’re done, we move to the next potenial prime and repeat the same process. #define N 1000000 int primes[N]; void sieve() { int s[N]; // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { s[i] = 1; } s[0] = s[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (s[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { s[i] = 0; } } } int index = 0; for (int i = 0; i &lt; N; i++) { if (s[i] == 1) { primes[index++] = i; } } // the 10001st prime is primes[10000] } This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm). References Project Euler - 07]]></summary></entry><entry><title type="html">Project Euler: 8 Largest Product in a Series</title><link href="http://localhost:4000/jekyll/update/2025/01/09/project-euler-08-largest-product-in-a-series.html" rel="alternate" type="text/html" title="Project Euler: 8 Largest Product in a Series" /><published>2025-01-09T00:01:36-08:00</published><updated>2025-01-09T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/09/project-euler-08-largest-product-in-a-series</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/09/project-euler-08-largest-product-in-a-series.html"><![CDATA[<p>I did this the naive way of just iterating through the numbers and calculating the product of 13 numbers from every possible position, so the product starting at position 0, 1, 2 etc.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"</span><span class="p">;</span>

<span class="c1">// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">max_product</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="o">-</span><span class="mi">13</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">product</span> <span class="o">*=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="sc">'0'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&gt;</span> <span class="n">max_product</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_product</span> <span class="o">=</span> <span class="n">product</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"max product = %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max_product</span><span class="p">);</span></code></pre></figure>

<p><br />
This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm).
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=8">Project Euler - 08</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I did this the naive way of just iterating through the numbers and calculating the product of 13 numbers from every possible position, so the product starting at position 0, 1, 2 etc. std::string s = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";]]></summary></entry><entry><title type="html">Project Euler: 15 Lattice Paths</title><link href="http://localhost:4000/jekyll/update/2025/01/08/project-euler-15-lattice-paths.html" rel="alternate" type="text/html" title="Project Euler: 15 Lattice Paths" /><published>2025-01-08T00:01:36-08:00</published><updated>2025-01-08T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/08/project-euler-15-lattice-paths</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/08/project-euler-15-lattice-paths.html"><![CDATA[<p>We have a grid of size \(20 \times 20\). We can reach the last step in 40 exactly steps. 20 of these steps must be down steps and the other 20 must be right steps. So we have a sequence of 40 steps total and we want to find all possible sequences of these steps. Suppose we first chose the down steps in the configuration below</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>1</td>
    <td>2</td>
    <td>3</td>
	<td>4</td>
	<td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
	<td>9</td>
	<td>10</td>
    <td>11</td>
    <td>12</td>
	<td>13</td>
    <td>14</td>
    <td>15</td>
    <td>16</td>
	<td>...</td>
  </tr>
  <tr>
    <td>D</td>
    <td> </td>
    <td>D</td>
	<td>D</td>
	<td> </td>
    <td> </td>
    <td>D</td>
    <td>D</td>
	<td> </td>
	<td>D</td>
    <td> </td>
    <td>D</td>
	<td>D</td>
    <td> </td>
    <td>D</td>
    <td>D</td>
	<td>...</td>
  </tr>
</table>
</div>
<p>So steps 1,3,4,7,8 … all are down steps. Then, automatically we know that the rest of the steps are just right steps. So once we determine the right steps, we’re done. The remaining steps will be down steps. So we’re only choosing 20 of the 40 steps. The number of ways to choose 20 steps out of 40 is given by the binomial coefficient.</p>
<div>
	$$
	\begin{align*}
	\binom{40}{20} = \frac{40!}{20!20!}
	\end{align*}
	$$
</div>
<!------------------------------------------------------------------------------------>
<h4><b>A Dynamic Programming Solution</b></h4>
<p>Another way to do this problem is with dynamic programming. Why do it this way? maybe just to practice? Suppose we’re at very last step. We could have come from the step above or the step to the left. Let ways\([i][j]\) be a matrix representing the numbers. So the number of the ways to generate the sequence of 40 steps is the sum of all ways if came from a step above plus all the ways if we came from a step on the left. Therefore, we naturally have a recurrence that we can implement below</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ways</span><span class="p">[</span><span class="mi">25</span><span class="p">][</span><span class="mi">25</span><span class="p">];</span>
<span class="n">memset</span><span class="p">(</span><span class="n">ways</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ways</span><span class="p">));</span>
<span class="n">ways</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">ways</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">ways</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"reach(21,21) in %llu steps</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ways</span><span class="p">[</span><span class="mi">21</span><span class="p">][</span><span class="mi">21</span><span class="p">]);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=16">Project Euler - 16</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[We have a grid of size \(20 \times 20\). We can reach the last step in 40 exactly steps. 20 of these steps must be down steps and the other 20 must be right steps. So we have a sequence of 40 steps total and we want to find all possible sequences of these steps. Suppose we first chose the down steps in the configuration below 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... D D D D D D D D D D ... So steps 1,3,4,7,8 … all are down steps. Then, automatically we know that the rest of the steps are just right steps. So once we determine the right steps, we’re done. The remaining steps will be down steps. So we’re only choosing 20 of the 40 steps. The number of ways to choose 20 steps out of 40 is given by the binomial coefficient. $$ \begin{align*} \binom{40}{20} = \frac{40!}{20!20!} \end{align*} $$ A Dynamic Programming Solution Another way to do this problem is with dynamic programming. Why do it this way? maybe just to practice? Suppose we’re at very last step. We could have come from the step above or the step to the left. Let ways\([i][j]\) be a matrix representing the numbers. So the number of the ways to generate the sequence of 40 steps is the sum of all ways if came from a step above plus all the ways if we came from a step on the left. Therefore, we naturally have a recurrence that we can implement below unsigned long long ways[25][25]; memset(ways, 0, sizeof(ways)); ways[0][0] = 0; ways[1][0] = 1; ways[0][1] = 0; for (int i = 1; i &lt; 25; i++) { for (int j = 1; j &lt; 25; j++) { ways[i][j] = ways[i-1][j] + ways[i][j-1]; } } printf("reach(21,21) in %llu steps\n", ways[21][21]); References Project Euler - 16]]></summary></entry><entry><title type="html">Project Euler: 16 Power Digit Sum</title><link href="http://localhost:4000/jekyll/update/2025/01/07/project-euler-16-power-digit-sum.html" rel="alternate" type="text/html" title="Project Euler: 16 Power Digit Sum" /><published>2025-01-07T00:01:36-08:00</published><updated>2025-01-07T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/07/project-euler-16-power-digit-sum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/07/project-euler-16-power-digit-sum.html"><![CDATA[<p>In this one, we want to find the sum of the digits of \(2^{1000}\). I did this naively where I just multiply by 2 every iteration until we reach \(2^{1000}\). Of course to do so in c\(++\), we need to use arrays. Let <i>s</i> hold the result and initialize to 2. Then
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// multiply 2</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">carry</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">carry</span><span class="p">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
Finally, we just need to sum the digits
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=16">Project Euler - 16</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this one, we want to find the sum of the digits of \(2^{1000}\). I did this naively where I just multiply by 2 every iteration until we reach \(2^{1000}\). Of course to do so in c\(++\), we need to use arrays. Let s hold the result and initialize to 2. Then int s[N], carry = 0; memset(s, 0, sizeof(s)); s[N-1] = 2; for (int m = 1; m &lt; 1000; m++) { // multiply 2 int i = N-1; for (; i &gt;= 0; i--) { int sum = s[i] * 2; s[i] = (sum + carry) % 10; carry = sum / 10; } s[i] += carry; carry = 0; } } Finally, we just need to sum the digits int sum = 0; for (int i = 0; i &lt; N; i++) { sum += s[i]; } printf("sum = %d\n", sum); References Project Euler - 16]]></summary></entry><entry><title type="html">Project Euler: 20 Factorial Digit Sum</title><link href="http://localhost:4000/jekyll/update/2025/01/06/project-euler-20-factorial-digit-sum.html" rel="alternate" type="text/html" title="Project Euler: 20 Factorial Digit Sum" /><published>2025-01-06T00:01:36-08:00</published><updated>2025-01-06T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/06/project-euler-20-factorial-digit-sum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/06/project-euler-20-factorial-digit-sum.html"><![CDATA[<p>In this one, we want to find the sum of all the digits in the number \(100!\). I did this naively where I just calculate</p>
<div>
	$$
	\begin{align*}
	 100! = 100 \times 99 \times 98 \times ... \times 1
	\end{align*}
	$$
</div>
<p>But of course at least in c\(++\), we’ll need an array to hold the sum. Let <i>result</i> be the array that will hold the final outcome. Before iterating, we’ll store \(24 = 4 \times 3 \times 2 \times 1\) in <i>result</i>. The choice here is arbitrary. We’ll save the least significant digit at index 0. So in <i>result</i>, index 0 will hold the digit 4 and index 1 will hold the digit 2. We’ll also use an array \(a\) that will hold the number we’re going to multiply with. So for example \(a\) will be 5 in the next iteration since we want to calculate \(24 \times 5\). Then at each iteration we’ll do the following</p>
<ul>
	<li>Copy the array <i>result</i> into array \(b\).</li>
	<li>Add one to array \(a\).</li>
	<li>Multiply arrays \(a\) and \(b\) and save the outcome in <i>result</i>.</li>
</ul>
<!------------------------------------------------------------------------------------>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// copy result to b</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">add_one</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
    <span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
The implementation of adding 1 to an array is pretty straight forward
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">add_one</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">an</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// least significant digit is at index 0</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">an</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
We then have the implementation of multiply. This one needed a little more work but eventually it wasn’t too bad.
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">an</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// an + bn</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// least significant digit is at index 0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">an</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bn</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">carry_position</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">product</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
            <span class="n">result</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="n">carry_position</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
Finally, we just need to sum the digits
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">, "</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=20">Project Euler - 20</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this one, we want to find the sum of all the digits in the number \(100!\). I did this naively where I just calculate $$ \begin{align*} 100! = 100 \times 99 \times 98 \times ... \times 1 \end{align*} $$ But of course at least in c\(++\), we’ll need an array to hold the sum. Let result be the array that will hold the final outcome. Before iterating, we’ll store \(24 = 4 \times 3 \times 2 \times 1\) in result. The choice here is arbitrary. We’ll save the least significant digit at index 0. So in result, index 0 will hold the digit 4 and index 1 will hold the digit 2. We’ll also use an array \(a\) that will hold the number we’re going to multiply with. So for example \(a\) will be 5 in the next iteration since we want to calculate \(24 \times 5\). Then at each iteration we’ll do the following Copy the array result into array \(b\). Add one to array \(a\). Multiply arrays \(a\) and \(b\) and save the outcome in result. for (int num = 5; num &lt;= 100; num++) { // copy result to b for (int i = 0; i &lt; N; i++) { b[i] = result[i]; } add_one(a, N); multiply(a, N, b, N, result); } The implementation of adding 1 to an array is pretty straight forward void add_one(int *a, int an) { // least significant digit is at index 0 a[0] += 1; for (int i = 0; i &lt; an; i++) { int sum = a[i]; if (sum &lt; 10) { break; } a[i] = sum % 10; a[i+1] += sum / 10; } } We then have the implementation of multiply. This one needed a little more work but eventually it wasn’t too bad. void multiply(int *a, int an, int *b, int bn, int *result) { for (int i = 0; i &lt; N; i++) { // an + bn result[i] = 0; } // least significant digit is at index 0 for (int i = 0; i &lt; an; i++) { for (int j = 0; j &lt; bn; j++) { int product = a[i] * b[j]; int position = i + j; int carry_position = i + j + 1; int sum = product + result[position]; result[position] = sum % 10; result[carry_position] += sum / 10; } } } Finally, we just need to sum the digits int sum = 0; for (int i = N-1; i &gt;= 0; i--) { sum += result[i]; } printf("sum = %d\n, ", sum); References Project Euler - 20]]></summary></entry><entry><title type="html">Project Euler: 21 Amicable Numbers</title><link href="http://localhost:4000/jekyll/update/2025/01/05/project-euler-21-amicable-numbers.html" rel="alternate" type="text/html" title="Project Euler: 21 Amicable Numbers" /><published>2025-01-05T00:01:36-08:00</published><updated>2025-01-05T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/05/project-euler-21-amicable-numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/05/project-euler-21-amicable-numbers.html"><![CDATA[<p>We are given that \(d(n)\) is the sum of proper divisors of \(n\) (So \(n\) itself is not included). If \(d(a) = b\) and \(d(b) = a\) where \(a \neq b\), then \(a\) and \(b\) are amicable numbers. Suppose that \(a = 220\) and \(b = 284\). Observe that</p>
<div>
	$$
	\begin{align*}
	 d(220) &amp;= 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284 \\
	 d(284) &amp;= 1 + 2 + 4 + 71 + 142 = 220.
	\end{align*}
	$$
</div>
<p>Since \(d(220) = 284\) and \(d(284) = 220\), then 284 and 220 are amicable numbers.
<br />
<br />
<!------------------------------------------------------------------------------------>
The problem wants us to find the sum of all amicable numbers under 10000.
<br />
<br />
<!------------------------------------------------------------------------------------>
It should be obvious that the first thing we need to do is to have a table where each entry \(i\) is the sum of proper divisors of \(i\) for all \(i &lt; 10000\). We can do this right at the beginning with:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">fill_amicable_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// it's a divisor</span>
            <span class="n">amicable_sum</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// add the other divisor</span>
                <span class="n">amicable_sum</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span><span class="o">/</span><span class="n">i</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>Next, we want to iterate over all the numbers \(i\) from 1 to 10000. For each \(i\)</p>
<ul>
   <li>Let \(a =\) amicable_sum[i].</li>
   <li>Check that amicable_sum[a] is equal to \(i\).</li>
   <li>If the condition above holds, then we want to mark both \(\text{amicable}[i] = \text{amicable}[a] = true\)</li>
</ul>
<p>So suppose that \(i = 220\). Then we’ll let \(a =\)amicable_sum\([i] =\)amicable_sum\([220] = 284\) and then we’ll check that amicable_sum[284] is in fact equal to \(i = 220\).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amicable</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">amicable_sum</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="c1">// in the example, this is 284</span>
    <span class="c1">// now we need to check, that amicable_sum[284] == i</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">amicable_sum</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d and %d are amicable because amicable[%d]=%d, amicable[%d]=%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">amicable_sum</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="p">,</span> <span class="n">amicable_sum</span><span class="p">[</span><span class="n">a</span><span class="p">]);</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">amicable</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">amicable</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The reason why we mark a number as amicable is because we don’t want double count. So if we marked 220 and 284 as amicable. Then on the iteration where \(i = 284\), we’ll just skip this number.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=21">Project Euler - 21</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[We are given that \(d(n)\) is the sum of proper divisors of \(n\) (So \(n\) itself is not included). If \(d(a) = b\) and \(d(b) = a\) where \(a \neq b\), then \(a\) and \(b\) are amicable numbers. Suppose that \(a = 220\) and \(b = 284\). Observe that $$ \begin{align*} d(220) &amp;= 1 + 2 + 4 + 5 + 10 + 11 + 20 + 22 + 44 + 55 + 110 = 284 \\ d(284) &amp;= 1 + 2 + 4 + 71 + 142 = 220. \end{align*} $$ Since \(d(220) = 284\) and \(d(284) = 220\), then 284 and 220 are amicable numbers. The problem wants us to find the sum of all amicable numbers under 10000. It should be obvious that the first thing we need to do is to have a table where each entry \(i\) is the sum of proper divisors of \(i\) for all \(i &lt; 10000\). We can do this right at the beginning with: void fill_amicable_sum(int n) { int max = sqrt(n); for (int i = 1; i &lt;= max; i++) { if (n % i == 0) { // it's a divisor amicable_sum[n] += i; if (n / i != i &amp;&amp; i != 1) { // add the other divisor amicable_sum[n] += n/i; } } } } Next, we want to iterate over all the numbers \(i\) from 1 to 10000. For each \(i\) Let \(a =\) amicable_sum[i]. Check that amicable_sum[a] is equal to \(i\). If the condition above holds, then we want to mark both \(\text{amicable}[i] = \text{amicable}[a] = true\) So suppose that \(i = 220\). Then we’ll let \(a =\)amicable_sum\([i] =\)amicable_sum\([220] = 284\) and then we’ll check that amicable_sum[284] is in fact equal to \(i = 220\). int sum = 0; for (int i = 1; i &lt;= N; i++) { if (amicable[i]) { continue; } int a = amicable_sum[i]; // in the example, this is 284 // now we need to check, that amicable_sum[284] == i if (i == amicable_sum[a] &amp;&amp; i != a) { printf("%d and %d are amicable because amicable[%d]=%d, amicable[%d]=%d\n", i, a, i, amicable_sum[i], a, amicable_sum[a]); sum += i + a; amicable[i] = true; amicable[a] = true; } } The reason why we mark a number as amicable is because we don’t want double count. So if we marked 220 and 284 as amicable. Then on the iteration where \(i = 284\), we’ll just skip this number. References Project Euler - 21]]></summary></entry><entry><title type="html">Reptend Prime</title><link href="http://localhost:4000/jekyll/update/2025/01/05/reptend-prime.html" rel="alternate" type="text/html" title="Reptend Prime" /><published>2025-01-05T00:01:36-08:00</published><updated>2025-01-05T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/05/reptend-prime</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/05/reptend-prime.html"><![CDATA[<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
A Full Reptend Prime is a prime $$p$$ for which $$1/p$$ has $$p-1$$ digits in its decimal expansion. Moreover, a prime \(p\) is full reptend if and only if 10 is a primitive root modulo \(p\). This means that
$$
\begin{align*}
10^k \equiv 1 (mod p)
\end{align*}
$$
for \(k = p - 1\) and not \(k\) less than that. In other words, the multiplicative order of \(10\) modulo \(p\) is \(p-1\).
</div>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>Recall that the <a href="">multiplicative order</a> of \(a\) when \(a\) is coprime to \(n\), is the smallest \(k\) such that \(a^k \equiv 1 \mod n\). Here set \(n = p\) and \(a = 10\), the multiplicative order of \(10\) modulo \(p\) is then the smallest \(k\) for which \(10^k \equiv 1 (\mod p)\).
<br />
<br />
As an example, set \(p = 7\), observe that</p>
<div>
$$
\begin{align*}
10^1 &amp;\equiv 3 (mod 7) \\
10^2 &amp;\equiv 2 (mod 7) \\
10^3 &amp;\equiv 6 (mod 7) \\
10^4 &amp;\equiv 4 (mod 7) \\
10^5 &amp;\equiv 5 (mod 7) \\
10^6 &amp;\equiv 1 (mod 7) \\
\end{align*}
$$
</div>
<p>So the multiplicative order of 10 modulo 7 is 6 which is \(7-1\). So 7 is a full reptend prime.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Multiplicative_order">Wikipedia</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition A Full Reptend Prime is a prime $$p$$ for which $$1/p$$ has $$p-1$$ digits in its decimal expansion. Moreover, a prime \(p\) is full reptend if and only if 10 is a primitive root modulo \(p\). This means that $$ \begin{align*} 10^k \equiv 1 (mod p) \end{align*} $$ for \(k = p - 1\) and not \(k\) less than that. In other words, the multiplicative order of \(10\) modulo \(p\) is \(p-1\). Example Recall that the multiplicative order of \(a\) when \(a\) is coprime to \(n\), is the smallest \(k\) such that \(a^k \equiv 1 \mod n\). Here set \(n = p\) and \(a = 10\), the multiplicative order of \(10\) modulo \(p\) is then the smallest \(k\) for which \(10^k \equiv 1 (\mod p)\). As an example, set \(p = 7\), observe that $$ \begin{align*} 10^1 &amp;\equiv 3 (mod 7) \\ 10^2 &amp;\equiv 2 (mod 7) \\ 10^3 &amp;\equiv 6 (mod 7) \\ 10^4 &amp;\equiv 4 (mod 7) \\ 10^5 &amp;\equiv 5 (mod 7) \\ 10^6 &amp;\equiv 1 (mod 7) \\ \end{align*} $$ So the multiplicative order of 10 modulo 7 is 6 which is \(7-1\). So 7 is a full reptend prime. References Wikipedia]]></summary></entry><entry><title type="html">Multiplicative Order</title><link href="http://localhost:4000/jekyll/update/2025/01/04/multiplicative-order.html" rel="alternate" type="text/html" title="Multiplicative Order" /><published>2025-01-04T00:01:36-08:00</published><updated>2025-01-04T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/04/multiplicative-order</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/04/multiplicative-order.html"><![CDATA[<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Given a positive integer \(n\) and an integer \(a\) coprime to \(n\), the multiplicative order of \(a\) modulo \(n\) is the smallest positive integer \(k\) such that 
$$
\begin{align*}
a^k \equiv 1 (mod n)
\end{align*}
$$
</div>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>

<p>Suppose n = 7 and a = 3, then</p>
<div>
$$
\begin{align*}
3^1 &amp;= 3 \equiv 3 (mod n) \\
3^2 &amp;= 6 \equiv 6 (mod n) \\
3^3 &amp;= 9 \equiv 2 (mod n) \\
3^4 &amp;= 81 \equiv 4 (mod n) \\
3^5 &amp;= 243 \equiv 5 (mod n) \\
3^6 &amp;= 729 \equiv 1 (mod n) \\
\end{align*}
$$
</div>
<p>So the multiplicative order of 3 modulo 7 is 6. Similarly for a = 4 and n = 7</p>
<div>
$$
\begin{align*}
4^1 &amp;= 4 \equiv 4 (mod n) \\
4^2 &amp;= 16 \equiv 2 (mod n) \\
4^3 &amp;= 64 \equiv 1 (mod n) \\
\end{align*}
$$
</div>
<p>So the multiplicative order of 4 modulo 7 is 3.</p>

<!------------------------------------------------------------------------------------>
<h4><b>References</b></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Multiplicative_order">Wikipedia</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition Given a positive integer \(n\) and an integer \(a\) coprime to \(n\), the multiplicative order of \(a\) modulo \(n\) is the smallest positive integer \(k\) such that $$ \begin{align*} a^k \equiv 1 (mod n) \end{align*} $$ Example]]></summary></entry><entry><title type="html">Project Euler: 26 Reciprocal Cycles</title><link href="http://localhost:4000/jekyll/update/2025/01/02/project-euler-26-reciprocal-cycles.html" rel="alternate" type="text/html" title="Project Euler: 26 Reciprocal Cycles" /><published>2025-01-02T00:01:36-08:00</published><updated>2025-01-02T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/02/project-euler-26-reciprocal-cycles</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/02/project-euler-26-reciprocal-cycles.html"><![CDATA[<p>In order to find the longest cycle, we first need to find a way to compute the length of a cycle. To do so, we need to find a way to count the digits in the decimal expansion of a given number. Take \(\frac{1}{7} = 0.(142857)\) for instance. We want a way to iterate through the digits 1,4,2,8,5,7,…. How do we do it? To simplify, let’s assume that we want to iterate over exactly 6 digits of the decimal expansion of \(\frac{1}{7}\). What can we do? The easiest way to do this is to multiply 1 by \(10^6\) and divide to get</p>
<div>
	$$
	\begin{align*}
1,000,000 / 7 = 142,857.143
	\end{align*}
	$$
</div>
<p>But if the cycle is of length 300? So we can’t just multiply the numerator by a huge number all at once. Luckily, we can simulate this long division one step at a time, multiplying the remainder each time by 10 and dividing by 7. So the single division above will be broken into the following steps:</p>

<p>Step 1:
Multiply 1 by 10 and divide to get 10 / 7 = 1 with remainder 3.
<br />
Step 2:
Multiply 3 by 10 and divide to get 30 / 7 = 4 with remainder 2.
<br />
Step 3:
Multiply 2 by 10 and divide to get 20 / 7 = 2 with remainder 6.
<br />
Step 4:
Multiply 6 by 10 and divide to get 60 / 7 = 8 with remainder 4.
<br />
Step 5:
Multiply 4 by 10 and divide to get 40 / 7 = 5 with remainder 5.
<br />
Step 6:
Multiply 5 by 10 and divide to get 50 / 7 = 7 with remainder 1.
<br />
<br />
At this point, we have a reminder that we’ve seen before. We know what we’ll see exactly in step 7 and we know this will repeat for the next 5 steps. So we can stop here and declare that the cycle length is exactly 6.
<br />
<br />
We can simulate this simple long division for all the integers below 1000 to see what integer \(d\) has the longest cycle. We can easily do this with some hash table (unordered_map in c++ for example) to keep track of the remainders we’ve seen so far. Since we’re only checking for up to 1000, we can also put a limit on how many steps in long division we’re willing to do. Playing around with this, it doesn’t seem like any integers below 1000 will have a cycle longer than 1000 digits. So the following is enough to solve this problem
<br />
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">long_division</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">seen</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">numerator</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cycle_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// let the maximum cycle length be 1000</span>
        <span class="kt">int</span> <span class="n">remainder</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">%</span> <span class="n">number</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">seen</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cycle ends</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">seen</span><span class="p">[</span><span class="n">remainder</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="n">remainder</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">cycle_len</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">cycle_len</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Other Ideas</b></h4>
<p>So far we have a solution that is fast and acceptable but is there more to this? Take a look at the longest cycle for all numbers up to 1000 and observe that when d = 7, 1/d has d-1=6 digits, when d = 17, 1/d has d-1=16 digits. Furthermore, when d = 19, 1/d has 19-1=18 digits. Same for 1/23 which has 23-1=22 digits. All of these are prime numbers. But when we take d = 11, 1/11 has only two digits in its cycle. So what’s special about 7, 17, 19, 23 …? It turns out these special primes have a special name. These special primes are <a href="">Full Reptend Primes</a>.
<br />
<br />
Since for any full reptend prime \(p\), the the cycle length is \(p - 1\), then a potenial idea is just finding the maximum full reptend prime less than 1000. In fact, the maximum full reptend prime less than 1000 is 983. But does this mean that any other number between 983 and 999 won’t have more digits in its decimal expansion? I don’t know the answer to this question.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ol>
<li><a href="https://projecteuler.net/problem=26">Project Euler - 26</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reciprocals_of_primes">Wikipedia: Reciprocals of Primes</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reciprocals_of_primes">Wikipedia: Reciprocals of Primes</a></li>
</ol>
<p><br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In order to find the longest cycle, we first need to find a way to compute the length of a cycle. To do so, we need to find a way to count the digits in the decimal expansion of a given number. Take \(\frac{1}{7} = 0.(142857)\) for instance. We want a way to iterate through the digits 1,4,2,8,5,7,…. How do we do it? To simplify, let’s assume that we want to iterate over exactly 6 digits of the decimal expansion of \(\frac{1}{7}\). What can we do? The easiest way to do this is to multiply 1 by \(10^6\) and divide to get $$ \begin{align*} 1,000,000 / 7 = 142,857.143 \end{align*} $$ But if the cycle is of length 300? So we can’t just multiply the numerator by a huge number all at once. Luckily, we can simulate this long division one step at a time, multiplying the remainder each time by 10 and dividing by 7. So the single division above will be broken into the following steps:]]></summary></entry></feed>