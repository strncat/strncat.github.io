<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-08-06T14:08:49-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>hello</subtitle><entry><title type="html">Closest Pair of Points</title><link href="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html" rel="alternate" type="text/html" title="Closest Pair of Points" /><published>2019-07-29T07:01:36-07:00</published><updated>2019-07-29T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/29/closest-pair</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Problem&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we are given a list of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; two dimensional points &lt;script type=&quot;math/tex&quot;&gt;\{\{x_1,y_1\},\{x_2,y_2\},...\{x_n,y_n\}\}&lt;/script&gt; and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; since we have &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; possible pairs. What else can we do?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Divide and Conquer&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we have the final result. As a starting point we will sort the points by their x-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We will also sort the points by their y-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;. We will be using &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; later in the algorithm.
&lt;img src=&quot;http://localhost:4000/assets/closest/1.png&quot; width=&quot;100%&quot; /&gt;
Given &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We can start applying the the following divide and conquer idea. Repeatedly divide &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/closest/2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How do we combine the results to find the single true closest pair? we need to consider that the closest pair might have a point in the left half and a point in the right half. We call this pair a &lt;b&gt;split pair&lt;/b&gt;. So in the combine step we need to do two things, we find the split pair with the minimum distance. And then we need to find the minimum pair of the three pairs we have, the left pair, the right pair and the split pair. The following pseudo-code implements this idea.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Px sorted by x-coordinate, Py by y-coordinate&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;less&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;three&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
       &lt;span class=&quot;c1&quot;&gt;// just use the naive algorithm &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we will divide Px into two arrays left and right&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// median = Px[n/2-1]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_px_around_the_median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// We want to sort each of left_x and right_x by the y-coordinate.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// discussed next&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort_left_and_right_by_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we find the closest pair in each half&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// delta_left and delta_right are the minimum distances in the left and right halfs&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we'll discuss this soon!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
We sorted the array upfront twice in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; time. We divide the input repeatedly in half until we reached the base case. We then combined the results by finding the split pair and returning the pair with the minimum distance. So we have a recurrence that looks like this:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 T(n) = aT(n/b) + n^c \\
 T(n) = 2T(n/2) + n^c
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; constant depends on the work we’re doing in each level. We first create the four arrays &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. This takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;. We then find the split pair. If we find the split pair in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;c = 2&lt;/script&gt; and by the master theorem, the total runtime is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. This defeats the purpose since the naive solution runs in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. We also know that we initially sorted the array in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; so the final runtime is at least &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;. So roughly we know that we need to find the split pair really fast in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; to have &lt;script type=&quot;math/tex&quot;&gt;c = 1&lt;/script&gt; and therefore, keeping our runtime at &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 How to repeatedly sort &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; by the x-coordinate and the y-coordinate &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time? &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
So we’re claiming that we’re sorting once only and then somehow we’re are repeatedly passing the two halfs of the &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; sorted by the x-coordinate and by the y-coordinate. How?! For sorting by the x-coordinate, we simply split &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; in half by calculating the median in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; time and then iterating over &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; to split the array into &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. That takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the current size of &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Now that we have both &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. We want to create two arrays &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; but sorted by the y-coordinate. We also want &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; sorted by the y-coordinate. How do we do this in just &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time? This is when we will use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;! We will iterate over &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; and if we see an element with an x-coordinate below or equal to the median then this element belongs to &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; otherwise it belongs to &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. Remember that &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; is just &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; but sorted by the y-coordinate. We are also assuming for the sake of simplicity that the points are distinct. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Finding the split pair in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/closest/3.png&quot; width=&quot;100%&quot; /&gt;
Let’s assume that the minimum pair not a left pair or a right pair and it is a split pair. In the algorithm we described above, let the left minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; (shown above) and let the right minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; be the minimum of &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Also let the right most point in the left array be &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. Now construct &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; to be an array with all the points that have x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x} + \delta&lt;/script&gt; sorted by their y-coordinate (we can use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; with a linear scan to insert any point that has an x-coordinate that fits our criteria). This linear scan costs &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time which is fine by us!
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;p=(x_1,y_1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q=(x_2,y_2)&lt;/script&gt; be the split pair points we’re trying to find where &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is in the left half and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; is in the right half. We claim the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;At most 6 points are between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in M.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
So, assuming the above is correct (we’ll prove it formally), we now have a constant number of pairs to look at. Basically, for each point, we will look at 7 points and therefore, we only have &lt;script type=&quot;math/tex&quot;&gt;7n&lt;/script&gt; pairs and so we can find the split pair in only &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
But why why why the above is the correct? let’s look at the first claim.
&lt;br /&gt;&lt;br /&gt;
Proof:&lt;br /&gt;
We want to show that if the closest pair of points is a split pair then our algorithm will find it. Since our algorithm only searches &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, then we want to show that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;. So assuming that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are the closest pair, we then know that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
d(p,q) &lt; \delta %]]&gt;&lt;/script&gt;. From here we can expand the euclidean distance definition:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 \delta &amp;amp;&amp;gt; d(p,q) \\
  &amp;amp;= \sqrt{(y_2-y_1)^2 + (x_2-x_1)^2} \\
  &amp;amp;\geq \sqrt{\max\{(y_2-y_1)^2, (x_2-x_1)^2}\} \\
  &amp;amp;= \max\{(y_2-y_1), (x_2-x_1)\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This says that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; in both their &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; coordinates!! So &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
|x_2-x_1| &lt; \delta %]]&gt;&lt;/script&gt;. We also know that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are a split pair and so by definition we have &lt;script type=&quot;math/tex&quot;&gt;x_1 \leq \bar{x}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 &gt; \bar{x}&lt;/script&gt;. Therefore, we must have &lt;script type=&quot;math/tex&quot;&gt;x_1 \geq \bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 \leq \bar{x} + \delta&lt;/script&gt;. Finally, since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is defined to include all points such that the x-coordinate satisfies &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta \leq x \leq \bar{x} + \delta&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; and thererfore, we will find them. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Let’s move to the second claim. why must we have 6 points only between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
Proof:
&lt;br /&gt;
Without the loss of generality, assume that &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; has the lower y-coordinate. We do know that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;’s x and y coordinates differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;’s x and y coordinates respectively. What do we know about the points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted by the y-coordinate, we do know that any point that comes between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;, this makes the y-coordinate of any of these points be in between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1 \leq y_2 + \delta&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We know that any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have an x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x}-\delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x}+\delta&lt;/script&gt; by our construction of &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using the above restrictions, any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must be in one of the following boxes. (again, if you look at the x-axis, &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; only allow points within &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. If you look vertically, the fact that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted makes the points between &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and that gap is also less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;!!).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/closest/4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next question is how many points do we have in each box?
&lt;br /&gt;&lt;br /&gt;
We claim that each box has only 1 point. Proof: Suppose it doesn’t and some box in the diagram above has 2 points. Let these points be &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. This means than &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; are both a left pair or a right pair. Moreover, the distance between &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is at most &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sqrt{(\delta/2)^2 + (\delta/2)^2} = \delta/\sqrt{2} &lt; \delta %]]&gt;&lt;/script&gt;. This is a contradiction, since by assumption we said both &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt; are greater than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;. Therefore, we must have 1 point in each box and so there are only 6 points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; Wonderful!!&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!! 1 Problem Suppose we are given a list of two dimensional points and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of since we have possible pairs. What else can we do? 2 Divide and Conquer The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we have the final result. As a starting point we will sort the points by their x-coordinate and let that array be . We will also sort the points by their y-coordinate and let that array be . We will be using later in the algorithm. Given . We can start applying the the following divide and conquer idea. Repeatedly divide into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.</summary></entry><entry><title type="html">Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html" rel="alternate" type="text/html" title="Random Variables" /><published>2019-07-26T07:01:36-07:00</published><updated>2019-07-26T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/26/random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes from CS109 at Stanford.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;What is a Random Variable?&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
A random variable is a real-valued function defined on a sample space. Sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some &lt;b&gt;function of the outcome&lt;/b&gt;. For example we could be interested in &lt;i&gt;counting&lt;/i&gt; the number of heads in &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt; trials of flipping a coin. We can define a random variable &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to represent the number of heads in 5 trials. Using &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;, we can now refer to the probability of seeing two heads in 5 trials as &lt;script type=&quot;math/tex&quot;&gt;P(Y=2)&lt;/script&gt; and the probability of seeing at least 3 heads as &lt;script type=&quot;math/tex&quot;&gt;P(Y\geq3)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
We also should note the difference between an event and a random variable. An &lt;b&gt;event&lt;/b&gt; is just a particular assignment of a random variable while a random variable takes on numeric values that can be assigned to &lt;i&gt;groups&lt;/i&gt; of outcomes in our sample space. Another example is grouping all the outcomes in rolling two dice that sum to 7. We define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 sd &lt;script type=&quot;math/tex&quot;&gt;P(X=7)&lt;/script&gt; which is really the probability of seening any of these outcomes: &lt;script type=&quot;math/tex&quot;&gt;(3,4),(4,3),(2,5),(5,2),(1,6),(6,1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Example:\&lt;/p&gt;

&lt;p&gt;The union of all possible assignments cover the sample space?
mutually exclusive?
[ P(\bigcup_{i}(Y=i)) = \sum_i P(Y=i) = 1 ] 
\end{mdframed}&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Anatomy of a Flow Network&lt;/b&gt;
&lt;img src=&quot;http://localhost:4000/assets/flow/1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ford&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fulkerson&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Initialize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;residual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gf&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;have&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;augmenting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;augment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!--
&lt;div center&gt;
$$
\begin{align*}
0 \leq f(u,v) \leq c(u,v)
\end{align*}
$$
&lt;/div&gt;
--&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes from CS109 at Stanford. What is a Random Variable? A random variable is a real-valued function defined on a sample space. Sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some function of the outcome. For example we could be interested in counting the number of heads in trials of flipping a coin. We can define a random variable to represent the number of heads in 5 trials. Using , we can now refer to the probability of seeing two heads in 5 trials as and the probability of seeing at least 3 heads as . We also should note the difference between an event and a random variable. An event is just a particular assignment of a random variable while a random variable takes on numeric values that can be assigned to groups of outcomes in our sample space. Another example is grouping all the outcomes in rolling two dice that sum to 7. We define a random variable to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 sd which is really the probability of seening any of these outcomes: . Example:\</summary></entry><entry><title type="html">Ford-Fulkerson’s Maximum Flow</title><link href="http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson.html" rel="alternate" type="text/html" title="Ford-Fulkerson's Maximum Flow" /><published>2019-07-22T07:01:36-07:00</published><updated>2019-07-22T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes on chapter 26 in CLRS.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we want to ship oranges from NYC to SF because we have a current shortage of oranges in SF. We want to ship as many oranges as possible. Everything needs to be shipped by ground. We have different routes of different capacities. The total number of oranges that enter a city &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;, must be equal to the number of the oranges leaving city &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. In other words, cities can’t withhold oranges. We want to find the maximum number of oranges we can ship to SF. How can we solve can this problem? Let’s start by modeling this problem.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Anatomy of a Flow Network&lt;/b&gt;
&lt;img src=&quot;http://localhost:4000/assets/flow/1.png&quot; width=&quot;100%&quot; /&gt;
A flow network &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; is a directed graph where &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We have two distinguished vertices, the source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and the sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;Each edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; has a non-negative capacity &lt;script type=&quot;math/tex&quot;&gt;c(u,v) \geq 0&lt;/script&gt;. (edge capacities are in black above) &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If we have edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;For any vertex &lt;script type=&quot;math/tex&quot;&gt;v \in V&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;(v,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt;, then we can assume that &lt;script type=&quot;math/tex&quot;&gt;c(u,v)=0&lt;/script&gt;.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected and so &lt;script type=&quot;math/tex&quot;&gt;|E| \geq |V| - 1&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 What is Flow?&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/flow/2.png&quot; width=&quot;100%&quot; /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;f(u,v)&lt;/script&gt; be the flow from vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; to vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; (marked in purple above). &lt;br /&gt;
A &lt;b&gt;flow&lt;/b&gt; is a real valued function &lt;script type=&quot;math/tex&quot;&gt;f : V \times V \rightarrow \mathbb{R}&lt;/script&gt; that satisfies:&lt;br /&gt;
(1) &lt;b&gt;Capacity constraint:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u, v \in V&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
0 \leq f(u,v) \leq c(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the flow on every edge must not exceed its capacity. Also in other words, if the route from city &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to city &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; has a capacity of 5 oranges then we can’t ship more than 5 oranges on this route. 
&lt;br /&gt;&lt;br /&gt;
(2) &lt;b&gt;Flow Conservation:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u \in V - \{s,t\}&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the total flow coming into &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is equal to the total flow leaving &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;. Also in other words, citities can’t withhold oranges. If the number of oranges coming in city &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is 15 then the number of oranges leaving &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; must equal to 15 (5 to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, 8 to &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and 2 to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;).
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 The Maximum Flow Problem&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;!--
Let $$|f|$$ be the flow value defined as
&lt;div center&gt;
$$
\begin{align*}
|f| = \sum_{v \in V}f(s,v) = \sum_{v \in V} f(v,s)
\end{align*}
$$
&lt;/div&gt;
In other words, the flow value is the total flow coming out of the source minus the total flow coming into the source. 
--&gt;

&lt;p&gt;In the maximum-flow problem we are given a flow network &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with a source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and a sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; and we are asked to find the maximum flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. In the above graph the current flow is 15 oranges from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;, can we do better?
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Greedy Approach&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
One greedy approach we might try is to push as much flow as possible starting from the source node. This approach will not work. Suppose we have the below graph &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now suppose we apply the greedy strategy. We generate the flow below.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This flow is not optimal. In order to find the optimal flow we need to have a way to reduce the amount we’re pushing on &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; and then push more instead on &lt;script type=&quot;math/tex&quot;&gt;(s,b)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How do implement this or keep track of the original edges and edges where want to reverse the flow? That’s where Ford-Fulkerson comes (at least that’s where I knew about it first). We instead create a &lt;i&gt;residual graph&lt;/i&gt; which we’ll define formally next. Residual graphs provide a way for us to augment paths in the original graph with more flow or reverse the flow we pushed to create more flow in other paths.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Residual Graphs&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a flow network with source &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and sink &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; be a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. For any vertices &lt;script type=&quot;math/tex&quot;&gt;u,v \in V&lt;/script&gt;. The &lt;b&gt;residual capacity&lt;/b&gt; &lt;script type=&quot;math/tex&quot;&gt;c_f(u,v)&lt;/script&gt; by
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 c_f(u,v) = \Bigg \{ \begin{array}{@{}lr@{}}
                     c(u,v) - f(u,v)   \text{ if} (u,v) \in E,\\
                     f(v,u) \text{ if} (v,u) \in E, \\
					 0  \text{ otherwise.}
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The &lt;b&gt;residual network&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; induced by &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;G_f=(V,E_f)&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;E_f = \{(u,v) \in V \times V : c_f(u,v) &gt; 0\}&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Creating a Residual Graph&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Based on the formal definition above, we want to consider all possible pairs of vertices (&lt;script type=&quot;math/tex&quot;&gt;V*(V-1)&lt;/script&gt; different pairs) and evaluate the formal definition. For example, in the following graph &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, let’s consider what happens to vertices &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/flow/fix2.png&quot; width=&quot;100%&quot; /&gt;
We first consider the pair &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;(a,t) \in E&lt;/script&gt;. Therefore, we create a new edge in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; with capacity &lt;script type=&quot;math/tex&quot;&gt;c_f(a,t) = c(a,t) - f(a,t) = 7 - 2 = 5&lt;/script&gt;. This just means that we can still possibly push 5 oranges on this path.
&lt;img src=&quot;http://localhost:4000/assets/flow/at1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We next consider the pair &lt;script type=&quot;math/tex&quot;&gt;(t,a)&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;(t,a) \not\in E&lt;/script&gt;. Therefore, we create a new edge in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; with capacity &lt;script type=&quot;math/tex&quot;&gt;c_f(t,a) = f(a,t) = 2&lt;/script&gt;. This means that if we decide to push two oranges on this path then this really means that we decreased the flow in the original graph by 2 oranges.
&lt;img src=&quot;http://localhost:4000/assets/flow/at2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We repeat the process for all pairs to generate the following graph. (Remember that we omit edges with capacities 0 (they are implied)).
&lt;img src=&quot;http://localhost:4000/assets/flow/gf.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Augmenting Paths&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
So now that we have a graph &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with some flow &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and it’s residual graph &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;, we can talk about flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. The gist or  intuition is that whatever flow we can send from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; will result in additional flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. How and why this works?
&lt;br /&gt;&lt;br /&gt;
First, define &lt;script type=&quot;math/tex&quot;&gt;f \uparrow f'&lt;/script&gt; as the augmentation of flow &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;f'&lt;/script&gt; to be a function from &lt;script type=&quot;math/tex&quot;&gt;V \times V&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; where&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 (f \uparrow f')(u,v) = \Bigg \{ \begin{array}{@{}lr@{}}
                     f(u,v) + f'(u,v) - f'(v,u)   \text{ if} (u,v) \in E,\\
					 0  \text{ otherwise.}
        \end{array}
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;Based on this, we claim the following:&lt;br /&gt;&lt;br /&gt;
Lemma: &lt;script type=&quot;math/tex&quot;&gt;|f \uparrow f'| = |f| + |f'|&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Proof in CLRS but basically we need to verify that &lt;script type=&quot;math/tex&quot;&gt;f \uparrow f'&lt;/script&gt; obeys the capacity constraint and flow conversation in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and then prove that both are equal.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 The Ford-Fulkerson’s Method&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
Ford-Fulkerson starts with &lt;script type=&quot;math/tex&quot;&gt;f(u,v)=0&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; and incrementally increases the flow value. It does so by finding an augmenting path in the residual network &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;?&lt;/p&gt;

&lt;p&gt;This what Ford-Fulerkson is essentially doing. We will augment flow
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ford&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fulkerson&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Initialize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;residual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gf&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;have&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;augmenting&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Gf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;augment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes on chapter 26 in CLRS. 1 Introduction Suppose we want to ship oranges from NYC to SF because we have a current shortage of oranges in SF. We want to ship as many oranges as possible. Everything needs to be shipped by ground. We have different routes of different capacities. The total number of oranges that enter a city , must be equal to the number of the oranges leaving city . In other words, cities can’t withhold oranges. We want to find the maximum number of oranges we can ship to SF. How can we solve can this problem? Let’s start by modeling this problem. 2 Anatomy of a Flow Network A flow network is a directed graph where We have two distinguished vertices, the source vertex and the sink vertex . Each edge has a non-negative capacity . (edge capacities are in black above) If we have edge then we must have . For any vertex , . If , then we can assume that . is connected and so . 3 What is Flow? Let be the flow from vertex to vertex (marked in purple above). A flow is a real valued function that satisfies: (1) Capacity constraint: For all , we require $$ \begin{align*} 0 \leq f(u,v) \leq c(u,v) \end{align*} $$ In other words, the flow on every edge must not exceed its capacity. Also in other words, if the route from city to city has a capacity of 5 oranges then we can’t ship more than 5 oranges on this route. (2) Flow Conservation: For all , we require $$ \begin{align*} \sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v) \end{align*} $$ In other words, the total flow coming into is equal to the total flow leaving . Also in other words, citities can’t withhold oranges. If the number of oranges coming in city is 15 then the number of oranges leaving must equal to 15 (5 to , 8 to and 2 to ). 4 The Maximum Flow Problem</summary></entry><entry><title type="html">Worst Case vs Expected Case vs Average Case</title><link href="http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case.html" rel="alternate" type="text/html" title="Worst Case vs Expected Case vs Average Case" /><published>2019-07-19T07:01:36-07:00</published><updated>2019-07-19T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
(1) Class study notes from http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
(2) CLRS (Chapter 5)
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
These are my notes on Chapter 5. I got really confused the first time I read chapter 5 and definitely had to re-read several parts multiple times.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Average Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs. In, CLRS 5.2, we perform an expected-runtime over the average input is performed 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Worst Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we take the worst possible input and then analyze the running time of our algorithm against this input However the adversary here also chooses the randomness of the algorithm so even though QuickSort . For example, to build a binary search tree, the worst possible input is a sorted array. Insert an element in a binary search tree takes &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; and when the array is sorted. The height of the tree is &lt;script type=&quot;math/tex&quot;&gt;(n)&lt;/script&gt;. Therefore, building a binary search tree will require &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Average Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs and therefore it is called an average case analysis.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Worst Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this case, we take the worst possible input and then analyze the running time of our algorithm against this input. For example, to build a binary search tree, the worst possible input is a sorted array. We know the running time in
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Expected Case Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
 we must use knowledge of, or make assumptions about, the distribution of the inputs. Then we analyze our algorithm, computing an average-case running time, where we take the average over the distribution of the possible inputs. Thus we are, in effect, averaging the running time over all possible inputs. When reporting such a running time, we will refer to it as the average-case running time.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;</content><author><name></name></author><summary type="html">0 References (1) Class study notes from http://web.stanford.edu/class/cs161/schedule.html (2) CLRS (Chapter 5) Introduction These are my notes on Chapter 5. I got really confused the first time I read chapter 5 and definitely had to re-read several parts multiple times. Average Case Running Time In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs. In, CLRS 5.2, we perform an expected-runtime over the average input is performed Worst Case Running Time In this case, we take the worst possible input and then analyze the running time of our algorithm against this input However the adversary here also chooses the randomness of the algorithm so even though QuickSort . For example, to build a binary search tree, the worst possible input is a sorted array. Insert an element in a binary search tree takes and when the array is sorted. The height of the tree is . Therefore, building a binary search tree will require . Average Case Running Time In this case, we must have some assumption about the distribution of the input given to us. If we do then we can take the average over the distribution of the possible inputs and therefore it is called an average case analysis. Worst Case Running Time In this case, we take the worst possible input and then analyze the running time of our algorithm against this input. For example, to build a binary search tree, the worst possible input is a sorted array. We know the running time in Expected Case Running Time we must use knowledge of, or make assumptions about, the distribution of the inputs. Then we analyze our algorithm, computing an average-case running time, where we take the average over the distribution of the possible inputs. Thus we are, in effect, averaging the running time over all possible inputs. When reporting such a running time, we will refer to it as the average-case running time.</summary></entry><entry><title type="html">Merge Sort Analysis</title><link href="http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html" rel="alternate" type="text/html" title="Merge Sort Analysis" /><published>2019-07-18T07:01:36-07:00</published><updated>2019-07-18T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/18/merge-sort-analysis.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call &lt;i&gt;MergeSort&lt;/i&gt; again on each half. Once we’re done, we can combine the halfs in &lt;i&gt;Merge&lt;/i&gt;. The follow pesudo-code shows this (Based on CLRS)&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;floor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;MergeSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Merge&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;(1) The Recursion Tree Method&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling &lt;i&gt;MergeSort&lt;/i&gt; on each half until we reach the base case. And then we will go all way up calling &lt;i&gt;Merge&lt;/i&gt; in every level until the final &lt;i&gt;Merge&lt;/i&gt; call to combine the two halfs of the array and finally exiting MergeSort.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Level 0:&lt;/i&gt;
&lt;br /&gt;
At the top level, we have the whole input, array &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; of size &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. We will recursively call MergeSort on each half of the &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level 1:&lt;/i&gt;
&lt;br /&gt;
In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/2.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level 2:&lt;/i&gt;
&lt;br /&gt;
In level 2, we will have 4 calls. Each call is on an array of size &lt;script type=&quot;math/tex&quot;&gt;n/4&lt;/script&gt;. We also notice here that the total number of elements is also &lt;script type=&quot;math/tex&quot;&gt;n/4+n/4+n/4+n/4=n&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/3.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;:&lt;/i&gt;
&lt;br /&gt;
At the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th level, we will have &lt;script type=&quot;math/tex&quot;&gt;2^t&lt;/script&gt; calls to MergeSort. Each of the arrays passed to MergeSort is of size &lt;script type=&quot;math/tex&quot;&gt;n/2^t&lt;/script&gt;. Again, the total number of elements is also &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/merge/4.png&quot; width=&quot;100%&quot; /&gt;
&lt;i&gt;Level ?:&lt;/i&gt;
&lt;br /&gt;
When do we stop dividing/recursively calling MergeSort? Our base case happens when &lt;script type=&quot;math/tex&quot;&gt;first == last&lt;/script&gt;. This means that we stop the recursion when each call has an array of size 1. How many times do we divide &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. &lt;script type=&quot;math/tex&quot;&gt;log_d(n)&lt;/script&gt; is the number of times that we divide &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!)
&lt;br /&gt;&lt;br /&gt;
Therefore, the answer is: at the &lt;script type=&quot;math/tex&quot;&gt;log_2(n)&lt;/script&gt; level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together!
&lt;img src=&quot;http://localhost:4000/assets/merge/5.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
Now let’s climb up the recursion tree. We will assume that Merge performs &lt;script type=&quot;math/tex&quot;&gt;cn&lt;/script&gt; operations where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the size of the array and &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is a positive constant.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Level &lt;script type=&quot;math/tex&quot;&gt;log(n):&lt;/script&gt;&lt;/i&gt;
&lt;img src=&quot;http://localhost:4000/assets/merge/5.png&quot; width=&quot;100%&quot; /&gt;
We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
first &lt; last %]]&gt;&lt;/script&gt; to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; for all calls. 
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Level &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;:&lt;/i&gt;
&lt;img src=&quot;http://localhost:4000/assets/merge/4.png&quot; width=&quot;100%&quot; /&gt;
At the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th level, we have &lt;script type=&quot;math/tex&quot;&gt;2^t&lt;/script&gt; arrays. Each of these arrays is of size &lt;script type=&quot;math/tex&quot;&gt;n/2^t&lt;/script&gt;. We will perform &lt;script type=&quot;math/tex&quot;&gt;n/2^t * c&lt;/script&gt; operations per call. Summing everything, we have &lt;script type=&quot;math/tex&quot;&gt;2^t * n/2^t * c = cn&lt;/script&gt; operations. 
&lt;br /&gt;
&lt;br /&gt;
So at each level we’re doing at most &lt;script type=&quot;math/tex&quot;&gt;cn&lt;/script&gt; operations.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Putting it all together&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let’s now summarize everything in a nice table:
&lt;img src=&quot;http://localhost:4000/assets/merge/final.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;? Well, we have &lt;script type=&quot;math/tex&quot;&gt;log(n)+1&lt;/script&gt; levels and in each level we’re doing &lt;script type=&quot;math/tex&quot;&gt;cn&lt;/script&gt; operations, therefore MergeSort performs &lt;script type=&quot;math/tex&quot;&gt;cn(\log(n)+1)&lt;/script&gt; operations.
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;f(n) = cn(\log(n)+1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;g(n) = n\log(n)&lt;/script&gt;. To see that &lt;script type=&quot;math/tex&quot;&gt;f(n) = O(g(n))&lt;/script&gt;, recall that we need to find &lt;script type=&quot;math/tex&quot;&gt;c', n_0 &gt; 0&lt;/script&gt; such that for all &lt;script type=&quot;math/tex&quot;&gt;n \geq n_0&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;0 \leq f(n) \leq c'g(n)&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Choose &lt;script type=&quot;math/tex&quot;&gt;c'=2c&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;n_0=2&lt;/script&gt; and so for all &lt;script type=&quot;math/tex&quot;&gt;n \geq n_0&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c' = 2c&lt;/script&gt; we need to prove:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
0 \leq cn(\log(n)+1) &amp;amp;\leq c'n\log(n) = (2cn)\log(n) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Solving for &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; (&lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is positive)&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\log(n)+1 &amp;amp;\leq 2\log(n) \\
\log(n) &amp;amp;\geq 1 \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is certainly true for all &lt;script type=&quot;math/tex&quot;&gt;n \geq 2&lt;/script&gt; and so we are done.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;(2) The Substitution Method&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
TODO&lt;/p&gt;

&lt;!--
Now let's take a step back and forget about the recursion tree. Also assume that we don't know the master theorem. We know that MergeSort divides the input into halfs and performs $$cn$$ operations in Merge. Therefore, we have the following recurrence:
&lt;div center&gt;
$$
\begin{align*}
T(n) = 2T(\frac{n}{2}) + cn
\end{align*}
$$
&lt;/div&gt;
How do we go about solving this? The substituition method says generate a guess and prove it formally by induction! How do we guess the solution? One way is expand the recurrence multiple times to help us find a pattern.
&lt;br&gt;&lt;br&gt;
Let's guess that $$T(n) = O(n\log(n))$$. In order to prove it formally though, we need to find $$c' &gt; 0$$ and $$n_0 &gt; 0$$ such that for all $$n \geq n_0$$, we have $$T(n) \leq c'n\log(n)$$. In order to find $$c'$$, we can &lt;b&gt;substitute&lt;/b&gt; our guess and solve for $$c'$$
&lt;div center&gt;
$$
\begin{align*}
T(n) &amp;= 2T(\frac{n}{2}) + cn \\
&amp;\leq 2c'\frac{n}{2}\log(\frac{n}{2}) + cn \\
&amp;= c'n\log(\frac{n}{2}) + cn \\
&amp;= c'n\log(n)-c'n\log(2) + cn \\
&amp;= c'n\log(n)-c'n + cn \\
&amp;\leq c'n\log(n) + cn \\
\end{align*}
$$
&lt;/div&gt;
--&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html and CLRS Introduction In this note, we would like to analyze the running time of MergeSort. Recall that MergeSort is a divide and conquer algorithm where we repeatedly split the input into two halfs and then call MergeSort again on each half. Once we’re done, we can combine the halfs in Merge. The follow pesudo-code shows this (Based on CLRS) MergeSort(A, first, last) { if (first &amp;lt; last) { mid = floor((first+last)/2) MergeSort(A,first,mid) MergeSort(A,mid+1,last) Merge(A,first,mid,last) } } (1) The Recursion Tree Method How long does MergeSort take? How many operations are we performing? Let’s look at what MergeSort is doing at each level of of the recursion tree. We will first go all way down splitting the array and calling MergeSort on each half until we reach the base case. And then we will go all way up calling Merge in every level until the final Merge call to combine the two halfs of the array and finally exiting MergeSort. Level 0: At the top level, we have the whole input, array of size . We will recursively call MergeSort on each half of the . Level 1: In this level, we have two calls to MergeSort. Each call is on one half of the array. The total number of elements from all calls though is still . Level 2: In level 2, we will have 4 calls. Each call is on an array of size . We also notice here that the total number of elements is also . Level : At the ‘th level, we will have calls to MergeSort. Each of the arrays passed to MergeSort is of size . Again, the total number of elements is also . Level ?: When do we stop dividing/recursively calling MergeSort? Our base case happens when . This means that we stop the recursion when each call has an array of size 1. How many times do we divide by 2 (we’re dividing the array into two halfs at each step) to reach 1? This is precisely what logs give us. is the number of times that we divide by to reach 1. The first time I heard this, something clicked in my brain. I felt like I was missing so much before thinking of logs this way! (Thanks Professor Mary!) Therefore, the answer is: at the level, each array is of size 1 and this is we stop calling MergeSort again. After this we will start calling Merge now to combine everything together! Now let’s climb up the recursion tree. We will assume that Merge performs operations where is the size of the array and is a positive constant. Level We know that each array is of size 1 and so it’s already sorted. The only thing we do at this level is to check if to determine that the size is 1. After that we just return from MergeSort. So the total number of operations is for all calls. Level : At the ‘th level, we have arrays. Each of these arrays is of size . We will perform operations per call. Summing everything, we have operations. So at each level we’re doing at most operations. Putting it all together Let’s now summarize everything in a nice table: So now that we know how much work we’re doing per level, what is total number of operations for all levels? basically how many operations does MergeSort perform for an array of size ? Well, we have levels and in each level we’re doing operations, therefore MergeSort performs operations. Let and . To see that , recall that we need to find such that for all , we have</summary></entry><entry><title type="html">Binary Heaps</title><link href="http://localhost:4000/jekyll/update/2019/07/12/binary-heaps.html" rel="alternate" type="text/html" title="Binary Heaps" /><published>2019-07-12T07:01:36-07:00</published><updated>2019-07-12T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/12/binary-heaps</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/12/binary-heaps.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes / summary on chapter 6 in CLRS.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/heaps/1.png&quot; width=&quot;100%&quot; /&gt;
The heap data structure is an array &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; that can be viewed as an almost complete binary tree. Each node in the tree is represented by an element in the array. &lt;script type=&quot;math/tex&quot;&gt;A[1]&lt;/script&gt; is the root of the tree which is 17 in the above graph.
&lt;br /&gt;&lt;br /&gt;
Because the heap is based on a complete binary tree, the height of a heap of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; elements is &lt;script type=&quot;math/tex&quot;&gt;\Theta(n)&lt;/script&gt;. As a reminder, the height of a node is the longest path down from the node  to a leaf and the height of the tree is the height of the root of the tree. This observation is crucial in proving that many operations on heaps run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Finding the Parent, Left and Right Children &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Given an element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Its parent is located at &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor i/2 \rfloor]&lt;/script&gt;. For example the parent of 2 (index 7) is &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor 7/2 \rfloor]=A[3]=11&lt;/script&gt;. The left child is &lt;script type=&quot;math/tex&quot;&gt;A[2*i]&lt;/script&gt; and the right child is &lt;script type=&quot;math/tex&quot;&gt;A[2*i+1]&lt;/script&gt;. For example the right child of 13 (index 2) is &lt;script type=&quot;math/tex&quot;&gt;A[2*2 + 1] = A[5] = 3&lt;/script&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we know that i/2 is rounded down so we don't need to floor&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2*i;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2*i+1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 The Heap Property &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;There are two kinds of binary heaps, min heaps and max heaps. Depending on the heap type the array must satisfy a &lt;b&gt;heap property&lt;/b&gt; which is, for any given element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; we must have:&lt;/p&gt;

&lt;p&gt;If this is a max-heap:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A[parent(i)] \geq A[i]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If this is a min-heap:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A[parent(i)] \leq A[i]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The heap property is crucial. Because of it, we know that the root of the heap must be the smallest or the largest element in the heap and therefore, extracting the minimum or the maximum depending on the heap type can be done in constant time!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Maintaining the Max-Heap Property&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we have an element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; that is smaller than its children. This is a violation of the max-heap property, how do we fix this? First we will assume that both children of &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; maintain the heap property. We know in constant time that the children are &lt;script type=&quot;math/tex&quot;&gt;A[2*i]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;A[2*i+1]&lt;/script&gt;. We can then swap &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; with the larger of the two children. Finally, we recursively call the function on the larger child we just swapped &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Let’s look at a simple implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) check if the left child is greater&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) check if the right child is greater&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if one of the children is greater, swap it&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// with i and then call heapify again on the child&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we swapped with&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;How long does max_heapify take? Well, in the worst case, we will go down all the way to a leaf and so the runtime is &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;O(log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Building a Max-Heap&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Based on how we store the heap elements in the array, the leaves of the tree are located stating at &lt;script type=&quot;math/tex&quot;&gt;A[n/2+1], A[n/2+2],...,n&lt;/script&gt;. (proof?). Therefore, if we go over the remaining nodes in the tree and ran max-heapify, it will be enough to gaurantee that every element of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; maintains the heap property. And so we can write the following to build a max-heap:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;build_max_heap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5.1 Example&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let’s run through this to see how this might work. We’re given the following array and we want to build a max-heap out of it.
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/heaps/e1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
To build a max-heap we’ll only consider the non-leaf nodes, highlighted below.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e2.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
We’ll start with index 3 (node 5) and call max_heapify. In max_heapify, we’ll swap both node 5 and node 11 and then recusively call max_heapify again on the index 6 (where 5 moved).
&lt;img src=&quot;http://localhost:4000/assets/heaps/e3.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
5 is now a leaf node so we can’t push it further down the tree and so we’ll move to the next index 2 (node 3). 
&lt;img src=&quot;http://localhost:4000/assets/heaps/e4.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Node 3 above will be swapped with the larger of its children, node 13.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e5.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Next we will recursively call max_heapify on index 4 but index 4 is already a leaf node. The final node in the build_max_heap for loop is node 1 (index 1).
&lt;img src=&quot;http://localhost:4000/assets/heaps/e6.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
We will swap node 1 with the larger of its children, node 13.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e7.png&quot; width=&quot;100%&quot; /&gt;
We will then recusively call max_heapify on node 1, in its new location, index 2.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e8.png&quot; width=&quot;100%&quot; /&gt;
And finally we will swap 1 with the larger of its children, node 7.
&lt;img src=&quot;http://localhost:4000/assets/heaps/e9.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Finally, you can see now that the tree/array is a max-heap:
&lt;img src=&quot;http://localhost:4000/assets/heaps/e10.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Building a Max-Heap (Proof of Correctness)&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Why should we believe that build_max_heap works? This is going to be exactly what it’s in CLRS (my notes for myself to quickly remember). We’ll show that it works by proving that the following loop invariant is maintained prior to the first iteration, before each iteration and when the loop terminates.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;At the start of each iteration of the for loop in build_max_heap, each node &lt;script type=&quot;math/tex&quot;&gt;i+1, i+2, ..., n&lt;/script&gt; is the root of a max_heap.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;b&gt;Initialization&lt;/b&gt;:
Before the first iteration that starts at &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor n/2 \rfloor]&lt;/script&gt;, the nodes &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor n/2 \rfloor + 1], A[\lfloor n/2 \rfloor + 2],...A[n]&lt;/script&gt; are leaf nodes and therefore each node is a root of a max-heap.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Maintenance&lt;/b&gt;: (so the gist here is that max_heapify will maintain that node &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; follows the heap property because indices &lt;script type=&quot;math/tex&quot;&gt;2*i, 2*i+1&lt;/script&gt; are higher than &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and therefore already maintain the heap property).
&lt;br /&gt;
At each iteration, we call max-heapify on the node &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. The children of node &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; are at &lt;script type=&quot;math/tex&quot;&gt;A[2*i]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;A[2*i+1]&lt;/script&gt;. Since both have a higher index than &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; then this means that both of these nodes are already roots of max-heaps by the loop invariant. Recall that max_heapify requires that the children maintain the heap property. Also we know that max_heapify maintains the heap property for any nodes to follow &lt;script type=&quot;math/tex&quot;&gt;i+1, i+2, ..., n&lt;/script&gt;. Therefore, when we decrement &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;, the loop invariant will be established before the next iteration.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Termination&lt;/b&gt;:
At termination when &lt;script type=&quot;math/tex&quot;&gt;i=0&lt;/script&gt;, we know by the loop invariant that the nodes &lt;script type=&quot;math/tex&quot;&gt;1, 2,...,n&lt;/script&gt; are all roots of max-heaps. So we are done.
&lt;br /&gt;
&lt;br /&gt;
I would obviously recommend looking at CLRS’s way unless I’m in a rush and this is easily accessible on my phone. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Building a Max-Heap (Running Time)&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
The most exciting question is how long will building a max heap takes. We know that max_heapify takes &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time for each node. How many iterations do we have have in build_max_heap? To answer this, we need a little refresher (I do) on some properties of complete binary trees.
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/heaps/2.png&quot; width=&quot;100%&quot; /&gt;
A complete binary tree is a tree in which all the leaves have the same depth and all internal nodes have degree 2. Notice that at level 1 we have 2 children. At level 2 we have 4 children and at level &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; we have &lt;script type=&quot;math/tex&quot;&gt;2^t&lt;/script&gt; children. Therefore, the number of leaves is just &lt;script type=&quot;math/tex&quot;&gt;2^h&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; is the height/depth of the tree. If we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; leaves then the height of a complete binary tree is &lt;script type=&quot;math/tex&quot;&gt;\log_2(n)&lt;/script&gt;. 
&lt;br /&gt;&lt;br /&gt;
What about the number of internal nodes? Given that the height is &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt;, we know that the number of leaves is &lt;script type=&quot;math/tex&quot;&gt;2^h&lt;/script&gt;. Therefore, the number of internal nodes is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
1 + 2 + 4 + ... + 2^{h-1} &amp;amp;= \sum_{i=0}^{h-1}2^i = \frac{2^h-1}{2-1} = 2^h-1
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Back to build_max_heap. The for loop runs for only the internal nodes and so&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
1 + 2 + 4 + ... + 2^{h-1} &amp;amp;= \sum_{i=0}^{h-1}2^i = \frac{2^h-1}{2-1} = 2^h-1
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Heapsort&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Hello&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes / summary on chapter 6 in CLRS. 1 Introduction The heap data structure is an array that can be viewed as an almost complete binary tree. Each node in the tree is represented by an element in the array. is the root of the tree which is 17 in the above graph. Because the heap is based on a complete binary tree, the height of a heap of elements is . As a reminder, the height of a node is the longest path down from the node to a leaf and the height of the tree is the height of the root of the tree. This observation is crucial in proving that many operations on heaps run in time. 2 Finding the Parent, Left and Right Children Given an element . Its parent is located at . For example the parent of 2 (index 7) is . The left child is and the right child is . For example the right child of 13 (index 2) is .</summary></entry><entry><title type="html">Fenwick Trees</title><link href="http://localhost:4000/jekyll/update/2019/07/11/fenwick-trees.html" rel="alternate" type="text/html" title="Fenwick Trees" /><published>2019-07-11T07:01:36-07:00</published><updated>2019-07-11T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/11/fenwick-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/11/fenwick-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/bellman/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
(1) 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
K
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Bellman-Ford&lt;/b&gt;
&lt;br /&gt;
K&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References (1) 1 Introduction K 2 Bellman-Ford K</summary></entry><entry><title type="html">Topological Sort</title><link href="http://localhost:4000/jekyll/update/2019/07/10/topological-sort.html" rel="alternate" type="text/html" title="Topological Sort" /><published>2019-07-10T12:01:36-07:00</published><updated>2019-07-10T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/10/topological-sort</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/10/topological-sort.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt; be a directed acyclic graph consisting of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. Topological Sort is an ordering of the vertices of the graph such that for any given vertices &lt;script type=&quot;math/tex&quot;&gt;u \in V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v \in V&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; must come before &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in the ordering.
&lt;br /&gt;&lt;br /&gt;
In other words, we might have some dependency graph of classes and their prerequisites and we would like to find an ordering of the classes such that if class &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is a prerequisite to class &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; comes before &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; in the sorted list.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Revisiting Depth First Search&lt;/b&gt;
&lt;br /&gt;
Let’s take a look at the depth first search code again. When we see a node for the first time, we mark its start time. When we are done processing the node, then mark its finish time. It’s very important to notice here that we only mark a node as finished after we have called DFS on all of its children and their descendants. Intuitively, this means that once we mark a node finished, then it’s impossible for this node to have unvisited neighbors and so this means that all the descendants of this node will have a lower finish time than the node it self!! (we’ll prove this). Therefore, we can utilize this idea by pushing the nodes whenever we’re done processing them into the front of a linked list or a stack and end up with the sorted vertices as required!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// mark the start time for v&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// mark the finish time for v&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we can push the nodes here onto a stack!!! yay&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/topo/1.png&quot; alt=&quot;my photo&quot; /&gt;
Let’s explore the graph above with dfs again to see how the start and finish times are set again. We will start from &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; (arbitrarily chosen), mark its start time as zero and visit &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;. We will mark &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;’s start time and then recursively call DFS on &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;. We will set its start time. At this point, we don’t have more neighbors and so we mark its finish time as well. When we come back, &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; won’t have more neighbors and so we will mark its finish time. We do the same thing with &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and we’ll end up with the graph below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/topo/2.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next we will start from &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and visit &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; and mark both their start and finish times. Finally we will visit &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and mark its times as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/topo/3.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notice how if we ordered the nodes by their finishing times (&lt;script type=&quot;math/tex&quot;&gt;a, c, b, f, e, d&lt;/script&gt;) descendingly then we’ll have a valid ordering of the nodes. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Proof of Correctness&lt;/b&gt;
&lt;br /&gt;
The first time I saw Topological Sort I didn’t believe. It seemed strange to just be able to sort the vertices by just doing a DFS. What do we need to show to prove that topological sort works? what is the intuition here? Let’s think about this. We need to prove that for any two vertices &lt;script type=&quot;math/tex&quot;&gt;a \in V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b \in V&lt;/script&gt;, if there is an edge from &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; will come before &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; in the sorted output. 
&lt;br /&gt;&lt;br /&gt;
How do we prove this? Well we know that topological sort relies on the finishing times of vertices and we know that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;’s finishing time gets marked after its children and so this means that we want to prove that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;’s finishing time is greater than &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;’s finishing time. So to summarize, we really want to prove the following claim: For any two vertices &lt;script type=&quot;math/tex&quot;&gt;a \in V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b \in V&lt;/script&gt;, if there is an edge from &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;’s finishing time is greater than &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;’s finishing time.&lt;/p&gt;

&lt;p&gt;In order to prove the above claim we will use a theorem calling the Parenthesis Theorem from CLRS (proof in CLRS). The parenthesis theorem claims that in a depth first search of a graph &lt;script type=&quot;math/tex&quot;&gt;G = (V,E)&lt;/script&gt; and for any vertices &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, exactly one of the following conditions holds:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;the intervals [u.start_time, u.finish_time] and [v.start_time, v.finish_time] are disjoint and neither &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is a descendant of the other in the depth-first forest.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [u.start_time, u.finish_time] is contained within the interval [v.start_time, v.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in the depth-first tree.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [v.start_time, v.finish_time] is contained within the interval [u.start_time, u.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; in the depth-first tree.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Proof: TODO!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Now we are ready to prove our earlier claim.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G = (V,E)&lt;/script&gt; be a directed acyclic graph. For any two vertices &lt;script type=&quot;math/tex&quot;&gt;a, b \in V&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;(a,b) \in E&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;.finish_time &amp;gt; &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;.finish_time.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof:&lt;br /&gt;
Let’s consider the DFS tree generated after running DFS and let’s apply the Parenthesis Theorem. According to the theorem one of three conditions must hold:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [a.start_time, a.finish_time] is contained within the interval [b.start_time, b.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; in the depth-first tree. We claim that this case is impossible because by assumption, we know that &lt;script type=&quot;math/tex&quot;&gt;(a,b) \in E&lt;/script&gt; and so if &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is descendant of &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; must have a cycle. This is a contradiction since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is acyclic.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [b.start_time, b.finish_time] is contained within the interval [a.start_time, a.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; in the depth-first tree. This immediately shows that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b.finish_time &lt; a.finish_time %]]&gt;&lt;/script&gt; as we wanted to show.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the intervals [a.start_time, a.finish_time] and [b.start_time, b.finish_time] are disjoint and neither &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is a descendant of the other in the depth-first forest. In this case, we claim that we must have explored &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; first before &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. Because if we have explored &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; first then we would have explored &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;(a,b) \in E&lt;/script&gt; and so we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b.finish_time &lt; a.finish_time %]]&gt;&lt;/script&gt; as required. Beautiful isn’t it?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We conclude from all three cases that we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b.finish_time &lt; a.finish_time %]]&gt;&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Simple Implementation&lt;/b&gt;
&lt;br /&gt;
Let’s rewrite DFS to push the nodes onto a stack and let’s forget about the start and finishing times since we only care about returning an ordering of the vertices in this specific case. Let’s call this version topological sort! Here is a simple implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// node is done, we can push it on the ordered stack&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;topological_sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// perform dfs until there are no more unvisited nodes&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
It is just DFS! so the total time is &lt;script type=&quot;math/tex&quot;&gt;O(V+E)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt;
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/topological-search
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction Let be a directed acyclic graph consisting of vertices and edges. Topological Sort is an ordering of the vertices of the graph such that for any given vertices and , if , then must come before in the ordering. In other words, we might have some dependency graph of classes and their prerequisites and we would like to find an ordering of the classes such that if class is a prerequisite to class , then comes before in the sorted list. 2 Revisiting Depth First Search Let’s take a look at the depth first search code again. When we see a node for the first time, we mark its start time. When we are done processing the node, then mark its finish time. It’s very important to notice here that we only mark a node as finished after we have called DFS on all of its children and their descendants. Intuitively, this means that once we mark a node finished, then it’s impossible for this node to have unvisited neighbors and so this means that all the descendants of this node will have a lower finish time than the node it self!! (we’ll prove this). Therefore, we can utilize this idea by pushing the nodes whenever we’re done processing them into the front of a linked list or a stack and end up with the sorted vertices as required! int dfs(int v, int current_time, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph, std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; &amp;amp;times, std::vector&amp;lt;int&amp;gt; &amp;amp;visited) { times[v].first = current_time++; // mark the start time for v visited[0] = true; for (int i = 0; i &amp;lt; graph[v].size(); i++) { int u = graph[v][i]; if (visited[u] == false) { current_time = dfs(u, current_time, graph, times, visited); current_time++; } } times[v].second = current_time; // mark the finish time for v // we can push the nodes here onto a stack!!! yay return current_time; } 3 Example Let’s explore the graph above with dfs again to see how the start and finish times are set again. We will start from (arbitrarily chosen), mark its start time as zero and visit . We will mark ’s start time and then recursively call DFS on . We will set its start time. At this point, we don’t have more neighbors and so we mark its finish time as well. When we come back, won’t have more neighbors and so we will mark its finish time. We do the same thing with and we’ll end up with the graph below.</summary></entry><entry><title type="html">Cycles in Graphs</title><link href="http://localhost:4000/jekyll/update/2019/07/09/cycles.html" rel="alternate" type="text/html" title="Cycles in Graphs" /><published>2019-07-09T12:01:36-07:00</published><updated>2019-07-09T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/09/cycles</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/09/cycles.html">&lt;!--
&lt;b&gt;0 References&lt;/b&gt;&lt;br&gt;
?
&lt;br&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;br&gt;
--&gt;

&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/cycle/1.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We are given a graph &lt;script type=&quot;math/tex&quot;&gt;G = (V,E)&lt;/script&gt; and we want to know if there exists a cycle in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Undirected Graphs&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
This is extremely simple. We already keep track of nodes visited so far. If it happens during our search that we come across a visited node then we’re done! there must exists a cycle otherwise, we won’t ever re-visit any vertex in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;bfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// CYCLE&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Directed Graph&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
In a typical DFS, we assign a start time to a node and then traverse all the nodes that it can reach and then at the very end when we have visited all the nodes possible, we mark it’s end time. Let’s traverse the above graph starting at node &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. We will mark its start time. Say we visit &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; next. We will also mark its start time and then visit &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; and mark its start time. from &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; we will visit &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; and again mark its start time. From &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; we will visit &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;. At this point, we know we’ve already seen &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and marked c’s start time (it’s not null). In a typical DFS, we would see that &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; doesn’t have any other unvisited neighbors and mark &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;’s finish time. We will end up with the below graph:
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/cycle/3.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Let’s go back to the moment when we marked &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;’s start time and we saw &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;. What does this mean for &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;? Let’s recall that the paranthesis theorem (CLRS) says that for any pair of nodes, in this case &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;, one of three cases can happen:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;the intervals [c.start_time, c.finish_time] and [e.start_time, e.finish_time] are disjoint and neither &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; is a descendant of the other in the depth-first forest. This doesn’t apply as the intervals are not disjoint.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [c.start_time, c.finish_time] is contained within the interval [e.start_time, e.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;
is a descendant of &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; in the depth-first tree. This doesn’t apply either (above graph).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [e.start_time, e.finish_time] is contained within the interval [c.start_time, c.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; in the depth-first tree. Aha! this one applies!&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Only the third case applies and we can conclude that &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; must be a descendant of node &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;let’s use colors. All nodes will be colored black initially. When we visit a node for the first time, we will color it gray. When we’re done visiting all the reachable nodes, we will mark it done by coloring it white.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/cycle/2.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// CYCLE&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we are done with the node for good&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Proof&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Implementations&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/cycles
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Patricia Tries</title><link href="http://localhost:4000/jekyll/update/2019/07/08/patricia-trie.html" rel="alternate" type="text/html" title="Patricia Tries" /><published>2019-07-08T12:01:36-07:00</published><updated>2019-07-08T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/08/patricia-trie</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/08/patricia-trie.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs166/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Now that we have seen the &lt;a href=&quot;/jekyll/update/2019/07/06/tries.html&quot;&gt;trie&lt;/a&gt; data structure, let’s look at a more efficient solution to the problem we discussed before. As a reminder, we are given &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and a string pattern &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. We want to find all the strings that match  &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. With a regular trie we solved it with &lt;script type=&quot;math/tex&quot;&gt;\langle O(m),O(n) \rangle&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; is the preprocessing step of building the trie out of all the strings we’re given. The &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time is the look up time for each pattern of length &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. Can we make it faster?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 The Patricia Trie Data Structure&lt;/b&gt;
&lt;br /&gt;
Give the trie below:
&lt;img src=&quot;http://localhost:4000/assets/trie/3.png&quot; width=&quot;100%&quot; /&gt;
In a Patricia trie we instead merge any node (with the exception of the root) that has only one child with its parent. Let’s look at the result.
&lt;img src=&quot;http://localhost:4000/assets/trie/4.png&quot; width=&quot;100%&quot; /&gt;
That’s it! This trie is called a Patricia trie! we basically merge internal nodes that have one child only into their parents to optimize the space needed to store all keys.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Properties of Patricia Tries&lt;/b&gt;
&lt;br /&gt;
Can we upper bound the number of nodes in a Patricia trie? Yes!&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim: the number of nodes in a Patricia trie with &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; words is &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt; nodes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof:&lt;br /&gt;
We know that we have at most &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; nodes that mark the end of a valid word in a patricia trie. Let’s remove all internal nodes so now we have &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; clusters and let’s add the internal nodes one at a time. Each internal node added will combine two clusters together. This will mean there are &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt; internal nodes total. (If not then an internal node will end up having only one child which is a contradiction). Therefore, the total number of nodes is &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Search&lt;/b&gt;
&lt;br /&gt;
S
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
How long does search takes? oh only the length of the key or pattern!! so &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Insert&lt;/b&gt;
&lt;br /&gt;
S
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So insert takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time as well!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
W
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt; 
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References http://web.stanford.edu/class/cs166/ 1 Introduction Now that we have seen the trie data structure, let’s look at a more efficient solution to the problem we discussed before. As a reminder, we are given strings of total length and a string pattern of length . We want to find all the strings that match . With a regular trie we solved it with time where is the preprocessing step of building the trie out of all the strings we’re given. The time is the look up time for each pattern of length . Can we make it faster? 2 The Patricia Trie Data Structure Give the trie below: In a Patricia trie we instead merge any node (with the exception of the root) that has only one child with its parent. Let’s look at the result. That’s it! This trie is called a Patricia trie! we basically merge internal nodes that have one child only into their parents to optimize the space needed to store all keys. 3 Properties of Patricia Tries Can we upper bound the number of nodes in a Patricia trie? Yes!</summary></entry></feed>