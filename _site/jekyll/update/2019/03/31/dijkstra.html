<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat&apos;s notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/euclid/">Euclid&#39;s Elements</a><a class="page-link" href="/math/">Math</a><a class="page-link" href="/about/">About</a></div>
      </nav></div>
  
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Dijkstra</h1>
    <!--
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-31T12:01:36-07:00" itemprop="datePublished">Mar 31, 2019
      </time></p>
     -->
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <svg width="700" height="300" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="286.5" cy="93.5" rx="30" ry="30" />
	<text x="282.5" y="99.5" font-family="Times New Roman" font-size="20">a</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="164.5" cy="234.5" rx="30" ry="30" />
	<text x="160.5" y="240.5" font-family="Times New Roman" font-size="20">s</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="505.5" cy="93.5" rx="30" ry="30" />
	<text x="500.5" y="99.5" font-family="Times New Roman" font-size="20">b</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="388.5" cy="234.5" rx="30" ry="30" />
	<text x="384.5" y="240.5" font-family="Times New Roman" font-size="20">c</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="622.5" cy="234.5" rx="30" ry="30" />
	<text x="619.5" y="240.5" font-family="Times New Roman" font-size="20">t</text>
	<polygon stroke="black" stroke-width="1" points="184.13,211.813 266.87,116.187" />
	<polygon fill="black" stroke-width="1" points="266.87,116.187 257.855,118.965 265.417,125.508" />
	<text x="230.5" y="184.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="304.084,117.807 370.916,210.193" />
	<polygon fill="black" stroke-width="1" points="370.916,210.193 370.279,200.781 362.176,206.642" />
	<text x="343.5" y="156.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="194.5,234.5 358.5,234.5" />
	<polygon fill="black" stroke-width="1" points="358.5,234.5 350.5,229.5 350.5,239.5" />
	<text x="271.5" y="255.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="316.5,93.5 475.5,93.5" />
	<polygon fill="black" stroke-width="1" points="475.5,93.5 467.5,88.5 467.5,98.5" />
	<text x="391.5" y="114.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="524.657,116.587 603.343,211.413" />
	<polygon fill="black" stroke-width="1" points="603.343,211.413 602.082,202.064 594.386,208.45" />
	<text x="548.5" y="184.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="418.5,234.5 592.5,234.5" />
	<polygon fill="black" stroke-width="1" points="592.5,234.5 584.5,229.5 584.5,239.5" />
	<text x="500.5" y="255.5" font-family="Times New Roman" font-size="20">6</text>
	<polygon stroke="black" stroke-width="1" points="407.657,211.413 486.343,116.587" />
	<polygon fill="black" stroke-width="1" points="486.343,116.587 477.386,119.55 485.082,125.936" />
	<text x="452.5" y="184.5" font-family="Times New Roman" font-size="20">4</text>
</svg>
<p>Given a graph $G=(E,V)$ and a source node $s$. Dijkstra finds the shortest weighted path from $s$ to every other node in the graph. The graph however needs to only have non-negative edge weights. In the above graph the shortest path between nodes $s$ and $t$ is $s \rightarrow a \rightarrow b \rightarrow t$. Dikstra is extremely fast. It can run in amortized time $O(n\log(n) + m)$ if we implement Dijkstra with a fiponacci heap. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>How does Dijkstra work? Using the above example, we maintain a set of <i>not-sure</i> nodes ${a, b, c, t, s}$. We let $d[v]$ be the current distance from $s$ to $v$. Initially we let $d[v] = \infty$ for any node in <i>not-sure</i> and $d[s] = 0$ for the source node only.
<br />
<br />
In the first iteration of Dijkstra, we extract the node with the minimum distance in the <i>not-sure</i> list. This node is $s$. We then update the distance of each neighbor based on the following,</p>
<div center="">
$$
\begin{align*}
d[u] &amp;= min(d[u], d[u]+weight(s,u))
\end{align*}
$$
</div>
<p>After updating each neightbor, we mark $s$ as sure. We should see the following values after this iteration.</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>s</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract $s$)</td>
      <td>0</td>
      <td>2</td>
      <td>$\infty$</td>
      <td>1</td>
      <td>$\infty$</td>
    </tr>
  </tbody>
</table>

<p><i>Iteration 1</i><br />
We extract the node with the minimum distance again from the not-sure list. This time we extract $c$. We update all the neighbors and at the end of this iteration, we mark $c$ as sure.</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>s</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract $s$)</td>
      <td>0</td>
      <td>2</td>
      <td>$\infty$</td>
      <td>1</td>
      <td>$\infty$</td>
    </tr>
    <tr>
      <td>1 (extract $c$)</td>
      <td>0</td>
      <td>2</td>
      <td>5</td>
      <td>1</td>
      <td>7</td>
    </tr>
  </tbody>
</table>

<p><i>Final iteration</i><br />
We continue the same process. We extract the node $a$ and update its neighbors. We then mark it as sure, meaning that the distance from node $s$ to node $a$ is 2 and will not change again. We next extract $b$ and update the neighbors again. We then mark $b$ as sure. We finally extract $t$ which has no out-going edges. At the end of the algorithm, we see that we generated all the shortest paths from $s$ to all the other nodes in the graph.</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>s</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract $s$)</td>
      <td>0</td>
      <td>2</td>
      <td>$\infty$</td>
      <td>1</td>
      <td>$\infty$</td>
    </tr>
    <tr>
      <td>1 (extract $c$)</td>
      <td>0</td>
      <td>2</td>
      <td>5</td>
      <td>1</td>
      <td>7</td>
    </tr>
    <tr>
      <td>2 (extract $a$)</td>
      <td>0</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
      <td>7</td>
    </tr>
    <tr>
      <td>3 (extract $b$)</td>
      <td>0</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>4 (extract $t$)</td>
      <td>0</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
      <td>5</td>
    </tr>
  </tbody>
</table>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Pseudocode</b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Set</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">to</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span>
<span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">infinity</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">V</span>
<span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">there</span> <span class="n">are</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span> <span class="n">nodes</span> <span class="p">{</span>
	<span class="n">pick</span> <span class="n">the</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span> <span class="n">node</span> <span class="n">u</span> <span class="n">with</span> <span class="n">the</span> <span class="n">smallest</span> <span class="n">estimate</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">].</span>
	<span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="n">v</span> <span class="n">of</span> <span class="n">u</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// It is cheaper to reach v from u than the current path</span>
			<span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">Mark</span> <span class="n">u</span> <span class="n">as</span> <span class="n">sure</span>
	<span class="c1">// at this point we know that d[u] = distance(s,v) (proof below)</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<h4><b>Extracting the path</b></h4>
<p>To reconstruct the actuall path take, we just maintain a pointer to the parent node. We simply keep an additional array $p$ and modify the update step as follows:
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">V</span>
<span class="k">while</span> <span class="n">there</span> <span class="n">are</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span> <span class="n">nodes</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// we maintain a parent link</span>
		<span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/dijkstra/dijkstra.cpp">Full Implementation on Github</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Proof of Correctness</b></h4>
<p>Why does Dijkstra work? We need to prove two important claims in order to prove that Dijkstra is correct.
<br /></p>

<table>
  <tbody>
    <tr>
      <td>Claim 1: For all $v$, $d[v] \geq d(s,v)$. That is, $d[v]$ will never be an underestimate for any node $v$.</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> <br />
<b>Inducive Hypothesis:</b> After $t$ iterations, $d[v] \geq d(s,v)$ for all $v$. <br /></p>

<p><b>Base Case:</b> After 0 iterations, the algorithms sets $d[s]= 0 = d(s,s)$ and sets $d[v]$ to $\infty$ for all $v \neq s$ and therefore we have $d[v] \geq d(s,v)$, as required.<br /></p>

<p><b>Inductive Step:</b> Assume that after $t$ iterations, $d[v] \geq d(s,v)$ for all $v$. We will prove the inequality holds after $t+1$ iterations. At iteration $t+1$, we pick the minimum not-sure node $u$ and then update all neighbors $v$ such that:
$d[v] = min(d[v], d[u]+w(u,v))$. To see that $d[v] \geq d(s,v)$, notice that: <br />
(1) $d[v] \geq d(s,v)$ by the inductive hypothesis. <br />
(2) $d[u] + w(u,v) \geq d(s,v)$. This is because we know that $d(s,v) \leq d(s,u) + d(u,v)$ and we also know that $d[u] \geq d(s,u)$ by the inductive hypothesis. Therefore, $d(s,v) \leq d[u] + d(u,v)$.</p>

<p><b>Conclusion:</b> 
After the algorithm terminates, we have $d[v] \geq d(s,v)$ for all $v$ in $V$, as required. $\blacksquare$
<br /></p>

<table>
  <tbody>
    <tr>
      <td>Claim 2: When a vertex $u$ is marked sure, $d[u] = d(s,u)$</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> <br />
<b>Inducive Hypothesis:</b> When the t’th vertex $v$ is marked as sure, $d[v] = d(s,v)$. <br /></p>

<p><b>Base Case:</b> When the first vertex $s$ is marked sure, we know that $d[s]=0=d(s,s)$, as required. <br /></p>

<p><b>Inductive Step:</b> Suppose we’re about to mark vertex $u$ as sure, and assume every vertex already marked as sure has $d[v]=d(s,v)$. We will show that $d[u]=d(s,u)$. Consider a shortest path from $s$ to $u$.</p>

<svg width="800" height="200" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="101.5" cy="106.5" rx="30" ry="30" />
	<text x="97.5" y="112.5" font-family="Times New Roman" font-size="20">s</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="366.5" cy="122.5" rx="30" ry="30" />
	<text x="362.5" y="128.5" font-family="Times New Roman" font-size="20">z</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="235.5" cy="65.5" rx="30" ry="30" />
	<ellipse stroke="black" stroke-width="1" fill="none" cx="516.5" cy="65.5" rx="30" ry="30" />
	<text x="510.5" y="71.5" font-family="Times New Roman" font-size="20">z'</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="645.5" cy="106.5" rx="30" ry="30" />
	<text x="640.5" y="112.5" font-family="Times New Roman" font-size="20">u</text>
	<polygon stroke="black" stroke-width="1" points="130.187,97.723 206.813,74.277" />
	<polygon fill="black" stroke-width="1" points="206.813,74.277 197.7,71.837 200.626,81.399" />
	<polygon stroke="black" stroke-width="1" points="394.544,111.843 488.456,76.157" />
	<polygon fill="black" stroke-width="1" points="488.456,76.157 479.202,74.324 482.754,83.672" />
	<polygon stroke="black" stroke-width="1" points="263.009,77.469 338.991,110.531" />
	<polygon fill="black" stroke-width="1" points="338.991,110.531 333.65,102.754 329.661,111.923" />
	<polygon stroke="black" stroke-width="1" points="545.091,74.587 616.909,97.413" />
	<polygon fill="black" stroke-width="1" points="616.909,97.413 610.8,90.225 607.771,99.755" />
</svg>
<p>We want to prove that $d[u]=d(s,u)$. Suppose toward a contradiction that our claim is not true and that $u$ has the wrong estimate. Also suppose that node $z$ is the last node with a correct estimate before node $u$ and that vertex $z’$ is the vertex after $z$ in the shortest path above. We can see that <br /></p>
<div center="">
$$ d[z] = d(s,z) \leq d(s,u) \leq d[u] $$ <br />
</div>
<p>This is because we assumed $z$ has a correct estimate and we also know that $d(s,z) \leq d(s,u)$ because first, sub-paths of shortest paths are shortest paths (can be proved by contradiction). Second, the distance from $z$ to $u$ is non-negative because all edges have non-negative weights and therefore $d(s,z) \leq d(s,u)$. The last part $d(s,u) \leq d[u]$ follows from claim 1!
<br />
<br />
So now, we have $d[z] \leq d[u]$. There are two cases: <br />
Case 1: If $d[z] = d[u]$. In this case, since we assumed $z$ has a correct estimate then $u$ must have a correct estimate and we’re done! <br />
Case 2: If $d[z] &lt; d[u]$. In this case, since $u$ was the smallest not-sure node, then $z$ must be sure. Otherwise we would have picked $z$ as the smallest not-sure node. Since $z$ is sure then we must have updated $z$’s neighbors. In particular, we know that $z’$ comes after $z$ so,</p>
<div center="">
$$
\begin{align*}
d[z'] &amp;\leq d[z] + w(z,z') \\
&amp;= d(s,z) + w(z,z') \ \ \text{This is because } z \text{ is a sure node so by IH } d[z] = d(s,z) \\ 
&amp;= d(s,z') \ \ \text{ Subpaths of shortest paths are shortest paths} \\
&amp;\leq d[z'] \ \ \text{ By claim 1}
\end{align*}
$$
</div>
<p>This means that $z’$ has a correct estimate. This is a contradiction because we assumed that $z$ is the last node with a good estimate and therefore, $u$ must have the correct estimate, as required.</p>

<p><b>Conclusion:</b> 
After the last node is marked sure, we have $d[v] = d(s,v)$ for all $v$ in $V$, as we wanted to show. $\blacksquare$
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Running Time</b></h4>
<p>What are we doing in this algorithm? For each vertex in the not-sure list, we <br />
(1) find the minimum vertex. <br />
(2) remove that vertex. <br />
(3) update all neighbors with lower estimates if possible.<br />
<br />
Therefore we see that if we have $n$ vertices and $m$ edges:</p>
<div center="">
$$
\begin{align*}
TotalTime &amp;= \sum_{u \in V} \big\{ T(findMin) + \big(\sum_{v \in u.neighbors} T(updateKey)\big) + T(removeMin) \big\} \\
&amp;= n(T(findMin) + T(removeMin)) + m(T(updateKey))

\end{align*}
$$
</div>
<p>Now it is clear that it really depends on how we implement the list that holds the not-sure nodes. Let’s consider different data structures</p>
<ul>
  <li>Arrays
    <ul>
      <li>findMin will run in $O(n)$</li>
      <li>RemoveMin will run in $O(n)$</li>
      <li>UpdateKey will run in $O(1)$<br />
Therefore, the total time will be $O(n(2n) + m) = O(n^2 + m) = O(n^2)$</li>
    </ul>
  </li>
  <li>Red Black Tree
    <ul>
      <li>findMin will run in $O(\log(n))$</li>
      <li>RemoveMin will run in $O(\log(n))$</li>
      <li>UpdateKey will run in $O(\log(n))$<br />
Therefore, the total time will be $O(n\log(n) + m\log(n)) = O((n+m)\log(n))$. <br />
Notice here, if the graph is dense, meaning that $m=O(n^2)$, then this is worse than arrays! if it’s sparse, then it’s better.</li>
    </ul>
  </li>
  <li>Fibonacci Heaps
    <ul>
      <li>findMin will run in $O(1)$, amortized time.</li>
      <li>RemoveMin will run in $O(\log(n))$, amortized time.</li>
      <li>UpdateKey will run in $O(1)$, amortized time.<br />
Therefore, the total time will be $O(n\log(n) + m)$, amortized time.
<br />
<br />
<!------------------------------------------------------------------------------------></li>
    </ul>
  </li>
</ul>
<h4><b>Handling Negative Weights</b></h4>
<p>TODO!!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="http://web.stanford.edu/class/cs161/schedule.html">CS161 Stanford</a>
<br />
<br /></p>


  </div><div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = /jekyll/update/2019/03/31/dijkstra.html;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier =  /jekyll/update/2019/03/31/dijkstra; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://strncat-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="u-url" href="/jekyll/update/2019/03/31/dijkstra.html" hidden></a>
</article>
		 
      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>personal study notes</p>
      </div>
    </div>

  </div>

</footer>
-->

	
  </body>

</html>
