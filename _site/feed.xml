<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-04-01T15:06:07-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strcat’s notebook</title><subtitle>Hello.</subtitle><entry><title type="html">Dijkstra</title><link href="http://localhost:4000/jekyll/update/2019/03/31/dijkstra.html" rel="alternate" type="text/html" title="Dijkstra" /><published>2019-03-31T12:01:36-07:00</published><updated>2019-03-31T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/31/dijkstra</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/31/dijkstra.html">&lt;svg width=&quot;700&quot; height=&quot;300&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;286.5&quot; cy=&quot;93.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;282.5&quot; y=&quot;99.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;164.5&quot; cy=&quot;234.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;160.5&quot; y=&quot;240.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;s&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;505.5&quot; cy=&quot;93.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;500.5&quot; y=&quot;99.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;388.5&quot; cy=&quot;234.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;384.5&quot; y=&quot;240.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;622.5&quot; cy=&quot;234.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;619.5&quot; y=&quot;240.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;t&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;184.13,211.813 266.87,116.187&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.87,116.187 257.855,118.965 265.417,125.508&quot; /&gt;
	&lt;text x=&quot;230.5&quot; y=&quot;184.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;304.084,117.807 370.916,210.193&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;370.916,210.193 370.279,200.781 362.176,206.642&quot; /&gt;
	&lt;text x=&quot;343.5&quot; y=&quot;156.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;194.5,234.5 358.5,234.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;358.5,234.5 350.5,229.5 350.5,239.5&quot; /&gt;
	&lt;text x=&quot;271.5&quot; y=&quot;255.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;316.5,93.5 475.5,93.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;475.5,93.5 467.5,88.5 467.5,98.5&quot; /&gt;
	&lt;text x=&quot;391.5&quot; y=&quot;114.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;524.657,116.587 603.343,211.413&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;603.343,211.413 602.082,202.064 594.386,208.45&quot; /&gt;
	&lt;text x=&quot;548.5&quot; y=&quot;184.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;418.5,234.5 592.5,234.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;592.5,234.5 584.5,229.5 584.5,239.5&quot; /&gt;
	&lt;text x=&quot;500.5&quot; y=&quot;255.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;6&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;407.657,211.413 486.343,116.587&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;486.343,116.587 477.386,119.55 485.082,125.936&quot; /&gt;
	&lt;text x=&quot;452.5&quot; y=&quot;184.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;4&lt;/text&gt;
&lt;/svg&gt;

&lt;p&gt;&lt;b&gt;1.1 Introduction&lt;/b&gt;
&lt;br /&gt;
Dijkstra solves the shortest weighted path problem in a weighted graph with non-negative edge weights. If we want to find the shortest path between nodes &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in the above graph then the shortest path is &lt;script type=&quot;math/tex&quot;&gt;s \rightarrow c \rightarrow b \rightarrow t&lt;/script&gt;.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1.2 Algorithm&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infinity&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;estimate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// It is cheaper to reach v from u than the current path&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Mark&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// at this point we know that d[u] = distance(s,v) (proof below)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1.3 Example&lt;/b&gt;
&lt;br /&gt;
In the above graph, we maintain a set of not-sure nodes &lt;script type=&quot;math/tex&quot;&gt;\{s, a, b, c, t\}&lt;/script&gt;. We then assign &lt;script type=&quot;math/tex&quot;&gt;d[v] = \infty&lt;/script&gt; for all nodes. For the source node, we update its estimate to zero. &lt;script type=&quot;math/tex&quot;&gt;d[s] = 0&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
&lt;i&gt;Iteration 0&lt;/i&gt;&lt;br /&gt;
We extract the minimum not-sure not &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. We we now update each neighbor according to the algorithm. After updating each neightbor we get the following the values. Also, after updating all neighbors, we mark &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; as sure.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Iteration&lt;/th&gt;
      &lt;th&gt;s&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;c&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Iteration 1&lt;/i&gt;&lt;br /&gt;
We extract the minimum again from the not-sure nodes. This time we extract &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;. We update all the neighbors and at the end of this iteration, we mark &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; as sure.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Iteration&lt;/th&gt;
      &lt;th&gt;s&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;c&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;i=0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Final iteration&lt;/i&gt;&lt;br /&gt;
We continue with the same process. We extract the node &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and update its neighbors. We then mark it as sure, meaning that the distance from node &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to node &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is 2. We next extract &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; and update the neighbors again. We then mark &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; as sure. We finally extract &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; which has no out-going edges. At the end of the algorithm, we see that we generated all the shortest paths from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to all the other nodes in the graph.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Iteration&lt;/th&gt;
      &lt;th&gt;s&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;c&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;i=0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;b&gt;Extracting the path&lt;/b&gt;
To reconstruct the actuall path take, we just maintain a pointer to the parent node. We simply keep an additional array &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and modify the update step as follows:
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// we maintain a parent link&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1.4 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
Why does Dijkstra work? We need to prove two important claims in order to prove that Dijkstra is correct.
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim 1: For all &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt;. That is, &lt;script type=&quot;math/tex&quot;&gt;d[v]&lt;/script&gt; will never be an underestimate for any node &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
&lt;b&gt;Inducive Hypothesis:&lt;/b&gt; After &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; iterations, &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case:&lt;/b&gt; After 0 iterations, the algorithms sets &lt;script type=&quot;math/tex&quot;&gt;d[s]= 0 = d(s,s)&lt;/script&gt; and sets &lt;script type=&quot;math/tex&quot;&gt;d[v]&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;v \neq s&lt;/script&gt; and therefore we have &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt;, as required.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Inductive Step:&lt;/b&gt; Assume that after &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; iterations, &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. We will prove the inequality holds after &lt;script type=&quot;math/tex&quot;&gt;t+1&lt;/script&gt; iterations. At iteration &lt;script type=&quot;math/tex&quot;&gt;t+1&lt;/script&gt;, we pick the minimum not-sure node &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and then update all neighbors &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; such that:
&lt;script type=&quot;math/tex&quot;&gt;d[v] = min(d[v], d[u]+w(u,v))&lt;/script&gt;. To see that &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt;, notice that: &lt;br /&gt;
(1) &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; by the inductive hypothesis. &lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;d[u] + w(u,v) \geq d(s,v)&lt;/script&gt;. This is because we know that &lt;script type=&quot;math/tex&quot;&gt;d(s,v) \leq d(s,u) + d(u,v)&lt;/script&gt; and we also know that &lt;script type=&quot;math/tex&quot;&gt;d[u] \geq d(s,u)&lt;/script&gt; by the inductive hypothesis. Therefore, &lt;script type=&quot;math/tex&quot;&gt;d(s,v) \leq d[u] + d(u,v)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Conclusion:&lt;/b&gt; 
After the algorithm terminates, we have &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; for all $v$ in $V$, as required. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim 2: When a vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is marked sure, &lt;script type=&quot;math/tex&quot;&gt;d[u] = d(s,u)&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
&lt;b&gt;Inducive Hypothesis:&lt;/b&gt; When the t’th vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is marked as sure, &lt;script type=&quot;math/tex&quot;&gt;d[v] = d(s,v)&lt;/script&gt;. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case:&lt;/b&gt; When the first vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is marked sure, we know that &lt;script type=&quot;math/tex&quot;&gt;d[s]=0=d(s,s)&lt;/script&gt;, as required. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Inductive Step:&lt;/b&gt; Suppose we’re about to mark vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; as sure, and assume every vertex already marked as sure has &lt;script type=&quot;math/tex&quot;&gt;d[v]=d(s,v)&lt;/script&gt;. We will show that &lt;script type=&quot;math/tex&quot;&gt;d[u]=d(s,u)&lt;/script&gt;. Consider a shortest path from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;.&lt;/p&gt;

&lt;svg width=&quot;800&quot; height=&quot;200&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;101.5&quot; cy=&quot;106.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;97.5&quot; y=&quot;112.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;s&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;366.5&quot; cy=&quot;122.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;362.5&quot; y=&quot;128.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;z&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;235.5&quot; cy=&quot;65.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;516.5&quot; cy=&quot;65.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;510.5&quot; y=&quot;71.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;z'&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;645.5&quot; cy=&quot;106.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;640.5&quot; y=&quot;112.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;u&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;130.187,97.723 206.813,74.277&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;206.813,74.277 197.7,71.837 200.626,81.399&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;394.544,111.843 488.456,76.157&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;488.456,76.157 479.202,74.324 482.754,83.672&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;263.009,77.469 338.991,110.531&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;338.991,110.531 333.65,102.754 329.661,111.923&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;545.091,74.587 616.909,97.413&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;616.909,97.413 610.8,90.225 607.771,99.755&quot; /&gt;
&lt;/svg&gt;
&lt;p&gt;We want to prove that &lt;script type=&quot;math/tex&quot;&gt;d[u]=d(s,u)&lt;/script&gt;. Suppose toward a contradiction that our claim is not true and that &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; has the wrong estimate. Also suppose that node &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; is the last node with a correct estimate before node &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and that vertex &lt;script type=&quot;math/tex&quot;&gt;z'&lt;/script&gt; is the vertex after &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; in the shortest path above. We can see that &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ d[z] = d(s,z) \leq d(s,u) \leq d[u] $$ &lt;br /&gt;
&lt;/div&gt;
&lt;p&gt;This is because we assumed &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; has a correct estimate and we also know that &lt;script type=&quot;math/tex&quot;&gt;d(s,z) \leq d(s,u)&lt;/script&gt; because first, sub-paths of shortest paths are shortest paths (can be proved by contradiction). Second, the distance from &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is non-negative because all edges have non-negative weights and therefore &lt;script type=&quot;math/tex&quot;&gt;d(s,z) \leq d(s,u)&lt;/script&gt;. The last part &lt;script type=&quot;math/tex&quot;&gt;d(s,u) \leq d[u]&lt;/script&gt; follows from claim 1!
&lt;br /&gt;
&lt;br /&gt;
So now, we have &lt;script type=&quot;math/tex&quot;&gt;d[z] \leq d[u]&lt;/script&gt;. There are two cases: &lt;br /&gt;
Case 1: If &lt;script type=&quot;math/tex&quot;&gt;d[z] = d[u]&lt;/script&gt;. In this case, since we assumed &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; has a correct estimate then &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; must have a correct estimate and we’re done! &lt;br /&gt;
Case 2: If &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
d[z] &lt; d[u] %]]&gt;&lt;/script&gt;. In this case, since &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; was the smallest not-sure node, then &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; must be sure. Otherwise we would have picked &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; as the smallest not-sure node. Since &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; is sure then we must have updated &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;’s neighbors. In particular, we know that &lt;script type=&quot;math/tex&quot;&gt;z'&lt;/script&gt; comes after &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; so,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
d[z'] &amp;amp;\leq d[z] + w(z,z') \\
&amp;amp;= d(s,z) + w(z,z') \ \ \text{This is because } z \text{ is a sure node so by IH } d[z] = d(s,z) \\ 
&amp;amp;= d(s,z') \ \ \text{ Subpaths of shortest paths are shortest paths} \\
&amp;amp;\leq d[z'] \ \ \text{ By claim 1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This means that &lt;script type=&quot;math/tex&quot;&gt;z'&lt;/script&gt; has a correct estimate. This is a contradiction because we assumed that &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; is the last node with a good estimate and therefore, &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; must have the correct estimate, as required.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Conclusion:&lt;/b&gt; 
After the last node is marked sure, we have &lt;script type=&quot;math/tex&quot;&gt;d[v] = d(s,v)&lt;/script&gt; for all $v$ in $V$, as we wanted to show. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1.5 Running Time:&lt;/b&gt; 
What are we doing in this algorithm algorithm? For each vertex in the not-sure list, we &lt;br /&gt;
(1) find the minimum vertex. &lt;br /&gt;
(2) remove that vertex. &lt;br /&gt;
(3) update all neighbors with lower estimates if possible.&lt;br /&gt;
&lt;br /&gt;
Therefore we see that if we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
TotalTime &amp;amp;= \sum_{u \in V} \big\{ T(findMin) + \big(\sum_{v \in u.neighbors} T(updateKey)\big) + T(removeMin) \big\} \\
&amp;amp;= n(T(findMin) + T(removeMin)) + m(T(updateKey))

\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Now it is clear that it really depends on how we implement the list that holds the not-sure nodes. Let’s consider different data structures&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Arrays
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n(2n) + m) = O(n^2 + m) = O(n^2)&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Red Black Tree
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n) + m\log(n)) = O((n+m)\log(n))&lt;/script&gt;. &lt;br /&gt;
Notice here, if the graph is dense, meaning that &lt;script type=&quot;math/tex&quot;&gt;m=O(n^2)&lt;/script&gt;, then this is worse than arrays! if it’s sparse, then it’s better.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fibonacci Heaps
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;, amortized time.&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;, amortized time.&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;, amortized time.&lt;br /&gt;
Therefore, the total time will be $$O(n\log(n) + m), amortized time. &lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1.6 Negative weight edges:&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html&lt;/p&gt;</content><author><name></name></author><summary type="html">a s b c t 2 1 1 2 1 6 4</summary></entry><entry><title type="html">10154 - Weights and Measures</title><link href="http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures.html" rel="alternate" type="text/html" title="10154 - Weights and Measures" /><published>2019-03-29T12:01:36-07:00</published><updated>2019-03-29T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry><entry><title type="html">10069 - Distinct Subsequences</title><link href="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html" rel="alternate" type="text/html" title="10069 - Distinct Subsequences" /><published>2019-03-27T12:01:36-07:00</published><updated>2019-03-27T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html">&lt;p&gt;&lt;b&gt;Solution&lt;/b&gt;
&lt;br /&gt;
To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”.
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
 c[p] = \sum_i\left\{\begin{array}{@{}lr@{}}
        \sum_{j &amp;lt; i}c[p_0...p_{i-1}] &amp;amp; \text{if }x_i = p_i\\
        0                       &amp;amp; \text{otherwise} 
        \end{array}\right\}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Why does this work?&lt;/b&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be a string and let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be the string we want to count the occurences of in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; be the length of &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. Assume that we know the optimal count of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and suppose toward a contradiction that the count of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n}&lt;/script&gt; is not optimal. Since there are more ocurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt;, then naturally this means that there are more ocurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n}&lt;/script&gt;. This is a contradiction because we assumed that the number of occurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt; is optimal. Therefore our solution must be optimal.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Implementation Details&lt;/b&gt;
&lt;br /&gt;
Base Case: Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be a string and let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be the string that we are looking for. We initialize an array &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; to store 1 if we see &lt;script type=&quot;math/tex&quot;&gt;p[0]&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; otherwise, we store 0.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;From this point, we iterate through &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; starting at index &lt;script type=&quot;math/tex&quot;&gt;i=1&lt;/script&gt; and apply the above recurrence. At each step we need row “i-1” to produce row “i”. Instead of maintaining two arrays or a two dimensional array, we simply maintain a sum variable to keep track of the sum of the previous row and also reset the cells as we go. 
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// starting matching p[i] at i&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;bignum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;i=0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">Solution To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”. $$ c[p] = \sum_i\left\{\begin{array}{@{}lr@{}} \sum_{j &amp;lt; i}c[p_0...p_{i-1}] &amp;amp; \text{if }x_i = p_i\\ 0 &amp;amp; \text{otherwise} \end{array}\right\} $$ Why does this work? Let be a string and let be the string we want to count the occurences of in . Let be the length of . Assume that we know the optimal count of in and suppose toward a contradiction that the count of is not optimal. Since there are more ocurrences of , then naturally this means that there are more ocurrences of . This is a contradiction because we assumed that the number of occurrences of is optimal. Therefore our solution must be optimal. Implementation Details Base Case: Let be a string and let be the string that we are looking for. We initialize an array to store 1 if we see in otherwise, we store 0.</summary></entry><entry><title type="html">10003 - Cutting Sticks</title><link href="http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks.html" rel="alternate" type="text/html" title="10003 - Cutting Sticks" /><published>2019-03-25T12:01:36-07:00</published><updated>2019-03-25T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry></feed>