<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-03-27T08:02:06-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Radians</title><link href="http://localhost:4000/jekyll/update/2024/03/26/radians.html" rel="alternate" type="text/html" title="Radians" /><published>2024-03-26T01:01:36-07:00</published><updated>2024-03-26T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2024/03/26/radians</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/03/26/radians.html"><![CDATA[<p style="text-align:center;"><img src="http://localhost:4000/assets/math/trig/radian.png" width="50%" class="center" /></p>
<p>From wikipedia, “One radian is defined as the angle subtended from the center of a circle which intercepts an arc equal in length to the radius of the circle”. Some additional facts:</p>
<ul>
<li> The ratio of the circumference ($c$) to the diameter ($d$) of the circle (any circle) is the constant $\pi$. </li>
	<div>
	$$
	\begin{align*}
	\pi = \frac{c}{d} = \frac{c}{2r}.
	\end{align*}
	$$
    </div>

<li> This means that the circumference is given by, </li>
	\begin{align}
	c = 2\pi r.
	\end{align}

<li> Since the circumference is $2\pi r$, then there are $2\pi r / r = 2\pi$ such arcs of length $r$ in any circle each. This is about 6.28 arcs! (see below)</li>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/trig/arcs.png" width="55%" class="center" /></p>
	


<li> So, we have $2\pi$ arcs of length $r$ that cover the whole circle. Each of their angles is measured at 1 radian. This means that to go a whole rotation around the entire circle we need $2\pi * 1 = 2\pi$ radians. </li>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/trig/2pi.png" width="50%" class="center" /></p>



<li> So, a 360 degrees measure is equal to $2\pi$ radians or in other words, 1 radian is equal to 57.2958 degrees and that's where the conversion formula between degrees and radians come from. </li>
</ul>

<p><br /></p>
<h4><b>References</b></h4>
<ul>
<li>
<a href="https://en.wikipedia.org/wiki/Radian">Radians</a>
</li>
<li>
<a href="https://www.youtube.com/watch?v=cgPYLJ-s5II">Radians and Degrees (video)</a>
</li>
</ul>
<p><br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[From wikipedia, “One radian is defined as the angle subtended from the center of a circle which intercepts an arc equal in length to the radius of the circle”. Some additional facts: The ratio of the circumference ($c$) to the diameter ($d$) of the circle (any circle) is the constant $\pi$. $$ \begin{align*} \pi = \frac{c}{d} = \frac{c}{2r}. \end{align*} $$]]></summary></entry><entry><title type="html">Euclid Proposition 2</title><link href="http://localhost:4000/jekyll/update/2024/03/24/euclid-pr2.html" rel="alternate" type="text/html" title="Euclid Proposition 2" /><published>2024-03-24T07:01:36-07:00</published><updated>2024-03-24T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2024/03/24/euclid-pr2</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/03/24/euclid-pr2.html"><![CDATA[<p><b>Proposition 2</b>: “From a given point, to draw a straight line equal to a given finite straight line”. In other words, given a point $A$ and another finite straight line $CB$, draw a line equal to $CB$ at $A$.
<br /></p>
<hr />

<p><br />
<b>Proof.</b><br />
Let the given point be $A$ and the given finite line be $CB$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr2/1.png" width="40%" class="center" /></p>
<p>Use postule 1 to draw a line between $A$ and one of the end points say $B$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr2/2.png" width="40%" class="center" /></p>
<p>Next, use <a href="https://strncat.github.io/jekyll/update/2024/03/23/euclid-pr1.html">proposition 1</a> to draw an equilateral triangle from the drawn line $AB$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr2/3.png" width="40%" class="center" /></p>
<p>Next, describe a circle with center $B$ and radius $CB$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr2/5.png" width="40%" class="center" /></p>
<p>Extend the line DB all the way till intersects the circle at $E$ using <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/post2.html">postulate 2</a>.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr2/6.png" width="45%" class="center" /></p>
<p>Now describe another circle with center $D$ and radius $DE$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr2/7.png" width="55%" class="center" /></p>
<p>Extend the line DA until it intersects the circle at $F$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr2/8.png" width="55%" class="center" /></p>
<p>The claim is that $AF = BC$ which is what we want. To see this, we know that $DF=DE$ by <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/defI15.html">definition 15</a>. We know by $DA = DB$ by construction. Therefore, $BE = AF$ by <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/cn.html">axiom 3</a>. But $CB = BE$ by definition 15 and so $CB = AF$ (axiom 1) as required. 
<br />
<br /></p>
<hr />

<p><br />
<b>Refererences:</b></p>
<ul>
<li><a href="https://www.amazon.com/dp/B09ZYVSSTP/ref=sspa_dk_detail_0?psc=1&amp;pd_rd_i=B09ZYVSSTP&amp;pd_rd_w=c4vZJ&amp;content-id=amzn1.sym.f734d1a2-0bf9-4a26-ad34-2e1b969a5a75&amp;pf_rd_p=f734d1a2-0bf9-4a26-ad34-2e1b969a5a75&amp;pf_rd_r=WK3ER8B42S7VAPMGWWPZ&amp;pd_rd_wg=8i8vz&amp;pd_rd_r=789c12b3-868b-4990-85da-a643782719d6&amp;sp_csd=d2lkZ2V0TmFtZT1zcF9kZXRhaWw">Oliver Byrne's Elements of Euclid</a></li>
<li><a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/post3.html">David E. Joyce's Elements of Euclid</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Proposition 2: “From a given point, to draw a straight line equal to a given finite straight line”. In other words, given a point $A$ and another finite straight line $CB$, draw a line equal to $CB$ at $A$. Proof. Let the given point be $A$ and the given finite line be $CB$. Use postule 1 to draw a line between $A$ and one of the end points say $B$. Next, use proposition 1 to draw an equilateral triangle from the drawn line $AB$. Next, describe a circle with center $B$ and radius $CB$. Extend the line DB all the way till intersects the circle at $E$ using postulate 2. Now describe another circle with center $D$ and radius $DE$. Extend the line DA until it intersects the circle at $F$. The claim is that $AF = BC$ which is what we want. To see this, we know that $DF=DE$ by definition 15. We know by $DA = DB$ by construction. Therefore, $BE = AF$ by axiom 3. But $CB = BE$ by definition 15 and so $CB = AF$ (axiom 1) as required. Refererences: Oliver Byrne's Elements of Euclid David E. Joyce's Elements of Euclid]]></summary></entry><entry><title type="html">Euclid Proposition 1</title><link href="http://localhost:4000/jekyll/update/2024/03/23/euclid-pr1.html" rel="alternate" type="text/html" title="Euclid Proposition 1" /><published>2024-03-23T01:01:36-07:00</published><updated>2024-03-23T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2024/03/23/euclid-pr1</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2024/03/23/euclid-pr1.html"><![CDATA[<p><b>Proposition</b>: To construct an equilateral triangle on a given finite straight line.
<br /></p>
<hr />

<p><br />
<b>Proof.</b></p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr1/1.png" width="40%" class="center" /></p>
<p>Let the finit straight line be $AB$ above. By <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/post3.html">postulate 3</a>, describe a cricle with center $A$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr1/2.png" width="50%" class="center" /></p>
<p>By <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/post3.html">postulate 3</a>, describe another circle with center $B$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr1/3.png" width="60%" class="center" /></p>
<p>Using <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/post1.html">postulate 1</a>, draw two lines from $A$ and from $B$ to point $C$ (the intersection of the two circles).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/euclid/pr1/4.png" width="60%" class="center" /></p>
<p>We know that $AB = AC$ and $AB = BC$ by <a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/defI15.html">definition 15</a>. Therefore, $BC = AC$ by <a href="http://aleph0.clarku.edu/~djoyce/elements/bookI/cn.html">axiom 1</a>. We see now that $AB = BC = AC$ and therefore the triangle is equaliteral as required.
<br />
<br /></p>
<hr />

<p><br />
<b>Refererences:</b></p>
<ul>
<li><a href="https://www.amazon.com/dp/B09ZYVSSTP/ref=sspa_dk_detail_0?psc=1&amp;pd_rd_i=B09ZYVSSTP&amp;pd_rd_w=c4vZJ&amp;content-id=amzn1.sym.f734d1a2-0bf9-4a26-ad34-2e1b969a5a75&amp;pf_rd_p=f734d1a2-0bf9-4a26-ad34-2e1b969a5a75&amp;pf_rd_r=WK3ER8B42S7VAPMGWWPZ&amp;pd_rd_wg=8i8vz&amp;pd_rd_r=789c12b3-868b-4990-85da-a643782719d6&amp;sp_csd=d2lkZ2V0TmFtZT1zcF9kZXRhaWw">Oliver Byrne's Elements of Euclid</a></li>
<li><a href="http://aleph0.clarku.edu/~djoyce/java/elements/bookI/post3.html">David E. Joyce's Elements of Euclid</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Proposition: To construct an equilateral triangle on a given finite straight line. Proof. Let the finit straight line be $AB$ above. By postulate 3, describe a cricle with center $A$. By postulate 3, describe another circle with center $B$. Using postulate 1, draw two lines from $A$ and from $B$ to point $C$ (the intersection of the two circles). We know that $AB = AC$ and $AB = BC$ by definition 15. Therefore, $BC = AC$ by axiom 1. We see now that $AB = BC = AC$ and therefore the triangle is equaliteral as required. Refererences: Oliver Byrne's Elements of Euclid David E. Joyce's Elements of Euclid]]></summary></entry><entry><title type="html">Bezier Curves</title><link href="http://localhost:4000/jekyll/update/2023/12/05/bezier-curves.html" rel="alternate" type="text/html" title="Bezier Curves" /><published>2023-12-05T00:01:36-08:00</published><updated>2023-12-05T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2023/12/05/bezier-curves</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/12/05/bezier-curves.html"><![CDATA[<!------------------------------------------------------------------------------------>
<h4><b>Bezier Curves</b></h4>
<p>From <a href="https://www.youtube.com/watch?v=jvPPXbo87ds"> The Continuity of Splines</a>, I learned that starting with two points $p_0$ and $p_1$ we can create a path between them by linearly interpolating between the two points using</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/00-line.png" width="60%" class="center" /></p>
<div>
$$
\begin{align*}
P(t) = (1-t)P_0 + tP_1
\end{align*}
$$
</div>
<p>where $t$ is a value between 0 and 1. So for $t=0$, we get $P_0$ and for $t=1$, we get $P_1$. For any other $t$ value, we get a point on the line between the two end points. So now that we have this, we can add a second point and also interpolate between the second and third point using the same $t$ in</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/01-secondline.png" width="60%" class="center" /></p>
<div>
$$
\begin{align*}
P'(t) = (1-t)P_1 + tP_2
\end{align*}
$$
</div>
<p>And now interpolate between the brand new two points $(1-t)P_0 + tP_1$ and (1-t)P_1 + tP_2.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/01-secondline.png" width="60%" class="center" /></p>
<div>
$$
\begin{align*}
P(t) &amp;= (1-t)((1-t)P_0 + tP_1) + t((1-t)P_1 + tP_2) \\
&amp;= (1-t)^2P_0 + 2(1-t)tP_1 + t^2P_2
\end{align*}
$$
</div>
<p>This is called a quadractic Bezier curve and it generates a nice smooth curve!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Cubic Bezier Curve</b></h4>
<p>We don’t have to stop at the quadratic Bezier curve. Let’s add a third point and again interpolate between the second and third point</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/01-secondline.png" width="60%" class="center" /></p>
<p>and let’s connect all the new points</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/01-secondline.png" width="60%" class="center" /></p>
<p>and again connect the last two points</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/01-secondline.png" width="60%" class="center" /></p>
<p>The curve generated is a smooth curve and called the cubic Bezier curve! Combining and labeling everything. We have:</p>
<div>
$$
\begin{align*}
a &amp;= (1-t)P_0 + tP_1 \\
b &amp;= (1-t)P_1 + tP_2 \\
c &amp;= (1-t)P_2 + tP_3 \\
d &amp;= (1-t)a + tb \\
e &amp;= (1-t)b + tc \\
P(t) &amp;= (1-t)d + te
\end{align*}
$$
</div>
<p>This is known as the DeCasteljau algorithm. There is another form of these points written a weighted sum of the control points themselves,</p>
<div>
$$
\begin{align*}
P &amp;= P_0(-t^3 + 3t^2 - 3t + 1) \\
 &amp;+  P_1(3t^3 - 6t^2 + 3t)  \\
 &amp;+  P_2(-3t^3 + 3t^2) \\
 &amp;+  P_3(t^3)
\end{align*}
$$
</div>
<p>This is the Bernstein form of the Bezier curve. This form is so interesting in that at the beginning when $t=0$, It’s just $P_0$ as you move along the weights will get adjusted but they will all add up to 1 at any point until you reach the end when $t=1$ and we’re at 100% of $P_3$. This weighted sum is also called a convex combination.
<br />
<br />
But there is yet another form which re-arranges the points around the $t$ coefficients</p>
<div>
$$
\begin{align*}
P &amp;= P_0 \\
 &amp;+  t(-3P_0 + 3P_1)  \\
 &amp;+  t^2 (3P_0 - 6P_1 + 3P_2) \\
 &amp;+  t^3 (-P_0 + 3P_1 - 3P_2 + P_3)
\end{align*}
$$
</div>
<p>And finally, the forth form which is the matrix form.</p>
<div>
$$
\begin{align*}
P &amp;= [1 t t^2 t^3][ 1 0 0 0]
                  [-3 3 0 0]
				  [3 -6 3 0]
				  [-1 3 -3 1]
				  [p_0 p_1 p_2 p_3]
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Bezier Curves of Higher Degrees</b></h4>
<p>We can keep adding more and more control points to form the curve that we want but as we add more points, it gets more expensive to calculate and also harder to manipulate as moving a single control point affects the entire curve. For this reason, instead of adding more degrees, we instead connect these bezier curves together to form a Bezier Spline!
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>
<a href="https://www.youtube.com/watch?v=jvPPXbo87ds">The Continuity of Splines</a>
</li>
<li>
<a href="https://www.youtube.com/watch?v=6jjLSkp0Y7I&amp;list=PLplnkTzzqsZTfYh4UbhLGpI5kGd5oW_Hh&amp;index=10&amp;t=535s">Intro to Graphics 09 - Curves (Part 1) by Cem Yuksel</a>
</li>
<!--
<li>
<a href="https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390">Fundamentals of Computer Graphics</a>
</li>
<li>
<a href="https://gfxcourses.stanford.edu/cs248a">Computer Graphics by Kayvon Fatahalian</a>
</li>
-->
</ul>
<p><br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Bezier Curves From The Continuity of Splines, I learned that starting with two points $p_0$ and $p_1$ we can create a path between them by linearly interpolating between the two points using $$ \begin{align*} P(t) = (1-t)P_0 + tP_1 \end{align*} $$ where $t$ is a value between 0 and 1. So for $t=0$, we get $P_0$ and for $t=1$, we get $P_1$. For any other $t$ value, we get a point on the line between the two end points. So now that we have this, we can add a second point and also interpolate between the second and third point using the same $t$ in $$ \begin{align*} P'(t) = (1-t)P_1 + tP_2 \end{align*} $$ And now interpolate between the brand new two points $(1-t)P_0 + tP_1$ and (1-t)P_1 + tP_2. $$ \begin{align*} P(t) &amp;= (1-t)((1-t)P_0 + tP_1) + t((1-t)P_1 + tP_2) \\ &amp;= (1-t)^2P_0 + 2(1-t)tP_1 + t^2P_2 \end{align*} $$ This is called a quadractic Bezier curve and it generates a nice smooth curve! Cubic Bezier Curve We don’t have to stop at the quadratic Bezier curve. Let’s add a third point and again interpolate between the second and third point and let’s connect all the new points and again connect the last two points The curve generated is a smooth curve and called the cubic Bezier curve! Combining and labeling everything. We have: $$ \begin{align*} a &amp;= (1-t)P_0 + tP_1 \\ b &amp;= (1-t)P_1 + tP_2 \\ c &amp;= (1-t)P_2 + tP_3 \\ d &amp;= (1-t)a + tb \\ e &amp;= (1-t)b + tc \\ P(t) &amp;= (1-t)d + te \end{align*} $$ This is known as the DeCasteljau algorithm. There is another form of these points written a weighted sum of the control points themselves, $$ \begin{align*} P &amp;= P_0(-t^3 + 3t^2 - 3t + 1) \\ &amp;+ P_1(3t^3 - 6t^2 + 3t) \\ &amp;+ P_2(-3t^3 + 3t^2) \\ &amp;+ P_3(t^3) \end{align*} $$ This is the Bernstein form of the Bezier curve. This form is so interesting in that at the beginning when $t=0$, It’s just $P_0$ as you move along the weights will get adjusted but they will all add up to 1 at any point until you reach the end when $t=1$ and we’re at 100% of $P_3$. This weighted sum is also called a convex combination. But there is yet another form which re-arranges the points around the $t$ coefficients $$ \begin{align*} P &amp;= P_0 \\ &amp;+ t(-3P_0 + 3P_1) \\ &amp;+ t^2 (3P_0 - 6P_1 + 3P_2) \\ &amp;+ t^3 (-P_0 + 3P_1 - 3P_2 + P_3) \end{align*} $$ And finally, the forth form which is the matrix form. $$ \begin{align*} P &amp;= [1 t t^2 t^3][ 1 0 0 0] [-3 3 0 0] [3 -6 3 0] [-1 3 -3 1] [p_0 p_1 p_2 p_3] \end{align*} $$ Bezier Curves of Higher Degrees We can keep adding more and more control points to form the curve that we want but as we add more points, it gets more expensive to calculate and also harder to manipulate as moving a single control point affects the entire curve. For this reason, instead of adding more degrees, we instead connect these bezier curves together to form a Bezier Spline! References The Continuity of Splines Intro to Graphics 09 - Curves (Part 1) by Cem Yuksel]]></summary></entry><entry><title type="html">Mesh Representation</title><link href="http://localhost:4000/jekyll/update/2023/12/05/mesh-geometry.html" rel="alternate" type="text/html" title="Mesh Representation" /><published>2023-12-05T00:01:36-08:00</published><updated>2023-12-05T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2023/12/05/mesh-geometry</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/12/05/mesh-geometry.html"><![CDATA[<!------------------------------------------------------------------------------------>
<h4><b>Mesh Representation</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/00-line.png" width="60%" class="center" /></p>
<p>We can represent meshes using different ways. One way to represent a mesh is to simply store the triangles the mesh is made up. Another representation is storing the list of vertices and then the list of indexed triangles so for example</p>
<div>
$$
\begin{align*}
Vertices: \\
0: x_0, y_0, z_0 \\
1: x_1, y_1, z_1 \\
Triangles: \\
0, 1, 2, \\
0, 1, 3
\end{align*}
$$
</div>
<p>Note here that we can have the same set of vertices represent two different mesh topologies. so take this square for example. We can represent it with the two triangles or the other two triangles.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/curves/01-secondline.png" width="60%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Mesh Representation</b></h4>
<p>2D manifolds are surfaces such that when cut with a small sphere, it will always yields a disk or half a disk on the boundary. Manfolds have some important properties like</p>
<ul>
  <li>an edge connects two faces exactly.</li>
  <li>an edge connects two vertices only.</li>
  <li>a face consists of a ring edges and vertices.</li>
  <li>….</li>
</ul>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>
<a href="https://gfxcourses.stanford.edu/cs248a">Computer Graphics by Kayvon Fatahalian</a>
</li>
</ul>
<p><br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Mesh Representation We can represent meshes using different ways. One way to represent a mesh is to simply store the triangles the mesh is made up. Another representation is storing the list of vertices and then the list of indexed triangles so for example $$ \begin{align*} Vertices: \\ 0: x_0, y_0, z_0 \\ 1: x_1, y_1, z_1 \\ Triangles: \\ 0, 1, 2, \\ 0, 1, 3 \end{align*} $$ Note here that we can have the same set of vertices represent two different mesh topologies. so take this square for example. We can represent it with the two triangles or the other two triangles. Mesh Representation 2D manifolds are surfaces such that when cut with a small sphere, it will always yields a disk or half a disk on the boundary. Manfolds have some important properties like an edge connects two faces exactly. an edge connects two vertices only. a face consists of a ring edges and vertices. ….]]></summary></entry><entry><title type="html">Bresenham Line-Drawing Algorithm</title><link href="http://localhost:4000/jekyll/update/2023/11/16/bresenham.html" rel="alternate" type="text/html" title="Bresenham Line-Drawing Algorithm" /><published>2023-11-16T00:01:36-08:00</published><updated>2023-11-16T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2023/11/16/bresenham</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/11/16/bresenham.html"><![CDATA[<p>I’m going to write my notes here while learning the Bresenham’s line drawing algorithm from the two sources I’ve listed at the bottom of the page. We want to draw on screen the line given by the two points $(x_1,y_1)$ and $(x_2,y_2)$. To simplify things, we will restrict ourselves to positive slopes that are less than 1 and so $m = \Delta y/\Delta x &lt; 1$. Therefore $\Delta x &gt; \Delta y$. For this reason, we’re going to step in the right direction from $x_1$ to $x_2$ since we have more steps in $x$ than in $y$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/bresenham/1.png" width="55%" class="center" /></p>
<p>We’re going to start by the drawing the very first point at $(x,y)=(x_1,y_1)$. Next we’re going to move right to to $x+1$ (We will always move in $x$ in each iteration and so we’ll have two choices for which point to draw. It will either be the point $(x+1,y)$ or the point $(x+1,y+1)$). As we keep moving in the x-direction, we’ll accumulate the error in the y direction in a new variable $\epsilon$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/bresenham/errors.png" width="55%" class="center" /></p>
<p>Notice above that if we always draw the point $(x+1,y)$ and never do anything with the y-coordinate, then we’ll draw the shaded yellow points above while our error term will just keep increasing forever. We don’t want that. What should the error term be then? Let’s zoom in at the first case when we draw the point $(x+1,y)$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/bresenham/first-case.png" width="40%" class="center" /></p>
<p>Notice here, that $y$ on the line is really the $y$ that we drew plus the error term that we want to keep track of. Moreover, recall that the slope is just $\Delta y/\Delta x$. $\Delta x$ is 1 here since we moved from x to $x+1$. So $m=(y+\epsilon-y)/1=\epsilon$. This means that we can just add $m$ to the error term as move in the right direction! åWe will decide whether to move up to $y+1$ versus stay on $y$ if the error term is greater that 0.5. Suppose now, the error is actually greater than 0.5 and we moved $y$ one step up, how should be adjust the error term?</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/bresenham/second-case.png" width="55%" class="center" /></p>
<p>As before, we first (always) move one step forward in the $x$ direction. We add $m$ to our error term like we explained in the previous paragram. Now the error term is greater than $0.5$. We move in the $y$ direction one step. Notice here that the error term is now decreased by 1 since we moved one step up. So we just drecrement $\epsilon$ by 1. The overall procedure will be:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">draw_line</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">dy</span><span class="o">/</span><span class="n">dx</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">)</span>
        <span class="n">draw_point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">eps</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">eps</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span>  <span class="p">{</span>
          <span class="c1">// error is too big so move up in the y direction</span>
          <span class="n">y</span><span class="o">++</span> 
          <span class="n">eps</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1">// take 1 from the error term</span>
        <span class="p">}</span>
        <span class="n">x</span><span class="o">++</span> <span class="c1">// we always move 1 step right in each iteration</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Integers Only!</b></h4>
<p>The above procedure works really well but we don’t want floats. We want integers only. What can we do to avoid calculating the slope $m$. In every iteration, notice that we’re adding $m$ to $\epsilon$ and then directly comparing it again the threadshold $0.5$. Let’s expand the terms and see where we can go.</p>
<div>
$$
\begin{align*}
\epsilon + m &amp;&lt; 0.5 \\
\epsilon + \Delta y/\Delta x &amp;&lt; 0.5 \\
\Delta x\epsilon + \Delta y &amp;&lt; 0.5\Delta x \\
2\Delta x\epsilon + 2\Delta y &amp;&lt; \Delta x \\
2(\epsilon' + \Delta y) &amp;&lt; \Delta x\\
\end{align*}
$$
</div>
<p>where $\epsilon’ = \Delta x\epsilon$ above. So when we first update the error to add $m$ to it. Instead of adding $m$, we will add $\Delta y$. To see why let’s expand the term again.</p>
<div>
$$
\begin{align*}
\epsilon &amp;= \epsilon + m \\
\epsilon &amp;= \epsilon + \Delta y/\Delta \\
\Delta x\epsilon &amp;= \Delta x\epsilon + \Delta y \\
\epsilon' &amp;= \epsilon' + \Delta y
\end{align*}
$$
</div>
<p>And when we decrement 1, we can do the same and expand to see.</p>
<div>
$$
\begin{align*}
\epsilon &amp;= \epsilon - 1 \\
\epsilon' / \Delta x &amp;= \epsilon' \ \Delta x - 1 \\
\epsilon' &amp;= \epsilon' - \Delta x \\
\end{align*}
$$
</div>
<p>Here is the procedure again with the lines changed marked with “CHANGED”.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">draw_line</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">dy</span><span class="o">/</span><span class="n">dx</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span>
    <span class="n">eps</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">)</span>
        <span class="n">draw_point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
        <span class="n">eps</span> <span class="o">+=</span> <span class="n">dy</span> <span class="c1">// CHANGED</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">eps</span> <span class="o">&gt;</span> <span class="n">dx</span><span class="p">)</span>  <span class="p">{</span> <span class="c1">// CHANGED</span>
          <span class="c1">// error is too big so move up in the y direction</span>
          <span class="n">y</span><span class="o">++</span> 
          <span class="n">eps</span> <span class="o">-=</span> <span class="n">dx</span> <span class="c1">// CHANGED</span>
        <span class="p">}</span>
        <span class="n">x</span><span class="o">++</span> <span class="c1">// we always move 1 step right in each iteration</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Generalizing The Algorithm</b></h4>
<p>So far we have code that works for the first octant ONLY! where the slope is positive and is less than 1. How do we handle the other cases? We’re going to handle the case when the $\Delta x$ is still larger in magnitude than $\Delta y$.
<br />
<br /></p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/bresenham/fourth-octant.png" width="60%" class="center" /></p>
<p>Let’s start with the fourth octant. Here $|m| &lt; 1$ but $x_1$ is greater than $x_2$. This shouldn’t be too bad right? While we draw we’re going to decrement $x$ in each iteration (instead of incrementing). This can be easily done if we introduce a variable xstep and make it equal to -1 whenever $x_1 &gt; x_2$. Additionally, we will need to flip the sign of $\Delta x$ to be positive again. This way the slope is positive and we can use the same exact code for the first octant.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/bresenham/eighth-octant.png" width="50%" class="center" /></p>
<p>For the fifth octant. This time $\Delta y$ is negative so we want to flip that and also move $y$ down instead of up. So we’ll introduce a variable $ystep$ and set it to -1 whenever $y_1 &gt; y_2$. Notice here that $\Delta x$ is still larger than $\Delta x$. So the same exact code still works!</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/bresenham/fifth-octant.png" width="50%" class="center" /></p>
<p>What about the eigth octant? The magnitude of the slope is still between 0 and 1. But now we have both $\Delta x$ and $\Delta y$ negative. We just need to flip these! along with making $xstep$ and $ystep$ both be -1.
<br />
<br />
Next, we’ll handle all the remaining octants where the magnitude of the slope is greate than 1. Here we have more steps in $y$ than in $x$. So we need instead to move in the $y$ direction while keeping the error term to track the error in $x$ instead of $y$. So the same exact code still but we just need to swap $x$ and $y$! of course we will still need to adjust value of xstep and ystep similar to the above cases that we discussed.
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.cs.helsinki.fi/group/goa/mallinnus/lines/bresenh.html">Bresenham Line-Drawing Algorithm</a>
<br />
<a href="https://www.youtube.com/watch?v=y_SPO_b-WXk&amp;t=604s">Bresenham’s Line Algorithm</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I’m going to write my notes here while learning the Bresenham’s line drawing algorithm from the two sources I’ve listed at the bottom of the page. We want to draw on screen the line given by the two points $(x_1,y_1)$ and $(x_2,y_2)$. To simplify things, we will restrict ourselves to positive slopes that are less than 1 and so $m = \Delta y/\Delta x &lt; 1$. Therefore $\Delta x &gt; \Delta y$. For this reason, we’re going to step in the right direction from $x_1$ to $x_2$ since we have more steps in $x$ than in $y$. We’re going to start by the drawing the very first point at $(x,y)=(x_1,y_1)$. Next we’re going to move right to to $x+1$ (We will always move in $x$ in each iteration and so we’ll have two choices for which point to draw. It will either be the point $(x+1,y)$ or the point $(x+1,y+1)$). As we keep moving in the x-direction, we’ll accumulate the error in the y direction in a new variable $\epsilon$. Notice above that if we always draw the point $(x+1,y)$ and never do anything with the y-coordinate, then we’ll draw the shaded yellow points above while our error term will just keep increasing forever. We don’t want that. What should the error term be then? Let’s zoom in at the first case when we draw the point $(x+1,y)$. Notice here, that $y$ on the line is really the $y$ that we drew plus the error term that we want to keep track of. Moreover, recall that the slope is just $\Delta y/\Delta x$. $\Delta x$ is 1 here since we moved from x to $x+1$. So $m=(y+\epsilon-y)/1=\epsilon$. This means that we can just add $m$ to the error term as move in the right direction! åWe will decide whether to move up to $y+1$ versus stay on $y$ if the error term is greater that 0.5. Suppose now, the error is actually greater than 0.5 and we moved $y$ one step up, how should be adjust the error term? As before, we first (always) move one step forward in the $x$ direction. We add $m$ to our error term like we explained in the previous paragram. Now the error term is greater than $0.5$. We move in the $y$ direction one step. Notice here that the error term is now decreased by 1 since we moved one step up. So we just drecrement $\epsilon$ by 1. The overall procedure will be: void draw_line(x1, y1, x2, y2) { dx = x2 - x1, dy = y2 - y1 m = dy/dx x = x1, y = y1 eps = 0 while (x &lt; x2) draw_point(x,y) eps += m if (eps &gt; 0.5) { // error is too big so move up in the y direction y++ eps -= 1 // take 1 from the error term } x++ // we always move 1 step right in each iteration } } Integers Only! The above procedure works really well but we don’t want floats. We want integers only. What can we do to avoid calculating the slope $m$. In every iteration, notice that we’re adding $m$ to $\epsilon$ and then directly comparing it again the threadshold $0.5$. Let’s expand the terms and see where we can go. $$ \begin{align*} \epsilon + m &amp;&lt; 0.5 \\ \epsilon + \Delta y/\Delta x &amp;&lt; 0.5 \\ \Delta x\epsilon + \Delta y &amp;&lt; 0.5\Delta x \\ 2\Delta x\epsilon + 2\Delta y &amp;&lt; \Delta x \\ 2(\epsilon' + \Delta y) &amp;&lt; \Delta x\\ \end{align*} $$ where $\epsilon’ = \Delta x\epsilon$ above. So when we first update the error to add $m$ to it. Instead of adding $m$, we will add $\Delta y$. To see why let’s expand the term again. $$ \begin{align*} \epsilon &amp;= \epsilon + m \\ \epsilon &amp;= \epsilon + \Delta y/\Delta \\ \Delta x\epsilon &amp;= \Delta x\epsilon + \Delta y \\ \epsilon' &amp;= \epsilon' + \Delta y \end{align*} $$ And when we decrement 1, we can do the same and expand to see. $$ \begin{align*} \epsilon &amp;= \epsilon - 1 \\ \epsilon' / \Delta x &amp;= \epsilon' \ \Delta x - 1 \\ \epsilon' &amp;= \epsilon' - \Delta x \\ \end{align*} $$ Here is the procedure again with the lines changed marked with “CHANGED”. void draw_line(x1, y1, x2, y2) { dx = x2 - x1, dy = y2 - y1 m = dy/dx x = x1, y = y1 eps = 0 while (x &lt; x2) draw_point(x,y) eps += dy // CHANGED if (2*eps &gt; dx) { // CHANGED // error is too big so move up in the y direction y++ eps -= dx // CHANGED } x++ // we always move 1 step right in each iteration } } Generalizing The Algorithm So far we have code that works for the first octant ONLY! where the slope is positive and is less than 1. How do we handle the other cases? We’re going to handle the case when the $\Delta x$ is still larger in magnitude than $\Delta y$. Let’s start with the fourth octant. Here $|m| &lt; 1$ but $x_1$ is greater than $x_2$. This shouldn’t be too bad right? While we draw we’re going to decrement $x$ in each iteration (instead of incrementing). This can be easily done if we introduce a variable xstep and make it equal to -1 whenever $x_1 &gt; x_2$. Additionally, we will need to flip the sign of $\Delta x$ to be positive again. This way the slope is positive and we can use the same exact code for the first octant. For the fifth octant. This time $\Delta y$ is negative so we want to flip that and also move $y$ down instead of up. So we’ll introduce a variable $ystep$ and set it to -1 whenever $y_1 &gt; y_2$. Notice here that $\Delta x$ is still larger than $\Delta x$. So the same exact code still works! What about the eigth octant? The magnitude of the slope is still between 0 and 1. But now we have both $\Delta x$ and $\Delta y$ negative. We just need to flip these! along with making $xstep$ and $ystep$ both be -1. Next, we’ll handle all the remaining octants where the magnitude of the slope is greate than 1. Here we have more steps in $y$ than in $x$. So we need instead to move in the $y$ direction while keeping the error term to track the error in $x$ instead of $y$. So the same exact code still but we just need to swap $x$ and $y$! of course we will still need to adjust value of xstep and ystep similar to the above cases that we discussed. References Bresenham Line-Drawing Algorithm Bresenham’s Line Algorithm]]></summary></entry><entry><title type="html">Advanced Rendering</title><link href="http://localhost:4000/jekyll/update/2023/11/02/advanced-rendering.html" rel="alternate" type="text/html" title="Advanced Rendering" /><published>2023-11-02T01:01:36-07:00</published><updated>2023-11-02T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/11/02/advanced-rendering</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/11/02/advanced-rendering.html"><![CDATA[<!------------------------------------------------------------------------------------>
<h4><b>Note</b></h4>
<p>These are my rough notes based on attending CS148. They might contain errors so proceed with caution!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Motion Blur</b></h4>
<p>What causes motion blue? When the camera shutter (which limits the amount of light that hits the sensor) is open while an object is moving, the light coming in is hitting many different spots causing a streak. One fix is to have the shutter open and close extremely fast (although we don’t get enough light here).
<br />
<br />
In ray tracing, we can account for motion blur by animating objects during a time iterval $[T_0,T_1]$ when the shutter is open. We animate the object by specifying a transform as a function of time $F(t)$ for time $t \in [T_0,T_1]$. 
So we start with one transformation at $T_0$ and end up with another transformation at $T_1$ and in the time in between we interpolate. For example we can:
Assign a random time</p>
<div>
$$
\begin{align*}
t_{ray} = (1 - \alpha)T_0 + \alpha T_1.
\end{align*}
$$
</div>
<p>place the object into its time $t_{ray}$ location given by the transform $F(t_{ray})$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Depth of Field</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/advanced-rendering/focal-length.png" width="80%" class="center" /></p>
<p>Given some camera lens, the focal length is the distance it takes for a lens to bring parallel rays into focus (see above figure). To focus on an object you want to place</p>

<p><br />
<br /></p>

<div>
$$
\begin{align*}
F(k) = \int_{-\infty}^{\infty} f(x)e^{-2\pi ikx} dx.
\end{align*}
$$
</div>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390">Fundamentals of Computer Graphics, 4th Edition</a>
<br />
<a href="https://web.stanford.edu/class/cs148/lectures.html"> CS148 Lectures </a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Note These are my rough notes based on attending CS148. They might contain errors so proceed with caution! Motion Blur What causes motion blue? When the camera shutter (which limits the amount of light that hits the sensor) is open while an object is moving, the light coming in is hitting many different spots causing a streak. One fix is to have the shutter open and close extremely fast (although we don’t get enough light here). In ray tracing, we can account for motion blur by animating objects during a time iterval $[T_0,T_1]$ when the shutter is open. We animate the object by specifying a transform as a function of time $F(t)$ for time $t \in [T_0,T_1]$. So we start with one transformation at $T_0$ and end up with another transformation at $T_1$ and in the time in between we interpolate. For example we can: Assign a random time $$ \begin{align*} t_{ray} = (1 - \alpha)T_0 + \alpha T_1. \end{align*} $$ place the object into its time $t_{ray}$ location given by the transform $F(t_{ray})$. Depth of Field Given some camera lens, the focal length is the distance it takes for a lens to bring parallel rays into focus (see above figure). To focus on an object you want to place]]></summary></entry><entry><title type="html">Sampling</title><link href="http://localhost:4000/jekyll/update/2023/10/31/sampling.html" rel="alternate" type="text/html" title="Sampling" /><published>2023-10-31T01:01:36-07:00</published><updated>2023-10-31T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/10/31/sampling</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/10/31/sampling.html"><![CDATA[<!------------------------------------------------------------------------------------>
<h4><b>Overview</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/00-coverage.png" width="80%" class="center" /></p>
<p>See the above figure. The sensor (which mimics the eye) gets a signal based on how much area is covered by an object. For the first black square we have full coverage and the object is covering the entire sensor and so we get a black signal. The third square is half covered and we’ll get a gray signal. Basically, the sensor averages the information it gets and sends a single based on that. However when perform ray tracing and send a ray out, we’re only sending a ray from the center of the pixel. So for the last square for example, we’re going to see white only instead of some shade of gray and hence we’re losing some information.
<!--
<br>
<br>
There is one more issue. Besides the fact that the signal is averaging what we see, sometimes we don't even collect everything. There will some spots that we completely ignore. So what do we do here? how do mimic the same behavior and lose information when it's appropriate?-->
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Aliasing</b></h4>
<p><b>Sampling</b> is just testing a single point by sending a ray from the center of the pixel only. <b>Aliasing</b> on the other hand is caused by sampling. <b>Anti-Aliasing</b> is then the solution to aliasing and that’s our goal.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/01-aliasing.png" width="50%" class="center" /></p>
<p>For example, see the above figure. We’re trying to draw a quadrilateral so we send a single ray from each pixel’s center. Do our intersection test with the geometry and find out the centers that do intersect. We color these pixels and end up with a shape that’s completely different (purple squares). Testing the center of the pixel only therefore causes jagged edges often called <b>jaggies</b>. Aliasing can also occur not just with rasterization but also when computing the normal vectors since w’re not computing every single normal which could cause erroneous sparking highlights. Other artifacts causing by sampling include the wagon wheel effect, moire and many more.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Super Sampling</b></h4>
<p>One solution to the aliasing issue is to increase the number of samples (per unit area). We can do this by increasing the number of pixels in the image but now we’ll take longer to render and the file will be much bigger. So far, we’ve used one sample per pixel but now we’ll take 2x2 samples per pixel and then average the result and save that instead for the pixel. This is what super sampling mean. And so instead of Jaggies, we’ll see this</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/super-sample-1.png" width="30%" class="center" />             <img src="http://localhost:4000/assets/graphics/sampling/super-sample-2.png" width="30%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Sampling Rate</b></h4>
<p>Supersampling is great but what we really want to do in general is to find the lowest possible sampling rate that will not result in noticeable artifacts. Take the cosine function example. See below that whether we chose 4 samples or 2 samples per period, we still don’t lose any information when we reconstruct it from the samples we took.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/02-4samples.png" width="50%" class="center" /><img src="http://localhost:4000/assets/graphics/sampling/03-2samples.png" width="50%" class="center" /></p>
<p>However, if our sample rate was only 1, then we see that we’ve lost information and so it appears that we would need 2 samples ata minimum.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/04-1sample.png" width="60%" class="center" /></p>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Anti Aliasing</b></h4>

<ul>
  <li>
    <p>Nyquist-Shannon Sampling Theorem says that if $f(t)$ contains no frequencies higher than $W$ hertz, it can be completely determined by samples spaced $1/2W$ seconds apart. So we need 2 samples per period.</p>
  </li>
  <li>
    <p>The Nyquist frequency is defined as half the sampling frequency. If the function being sampled has no frequencies above the Nyquist frequency, then no aliasing occurs.</p>
  </li>
  <li>
    <p>Real world frequencies above the Nyquist frequency appears as aliases to the sampler.</p>
  </li>
  <li>
    <p>Before sampling, remove frequencies higher than the Nyquist frequency.</p>
  </li>
</ul>

<p><br />
It needs to be before sampling, otherwise these higher frequencies will get reconstructed as low frequency and get mixed with the real low frequency waves and so we won’t be to differentiate between the two. To remove these frequencies, we use the Fourier Transform.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Fourier Transform</b></h4>
<p>Transforms between the spatial domain $f(x)$ and the frequency domain $F(k)$.
Frequency Domain $F(x)$:</p>
<div>
$$
\begin{align*}
F(k) = \int_{-\infty}^{\infty} f(x)e^{-2\pi ikx} dx.
\end{align*}
$$
</div>
<p>Spatial Domain $f(x)$:</p>
<div>
$$
\begin{align*}
F(k) = \int_{-\infty}^{\infty} f(x)e^{2\pi ikx} dx.
\end{align*}
$$
</div>
<p>where</p>
<div>
$$
\begin{align*}
e^{i\theta} = \cos \theta + i \sin \theta
\end{align*}
$$
</div>
<p>and</p>
<div>
$$
\begin{align*}
\cos \theta = \frac{e^{i\theta} + e^{-i\theta}}{2}, \sin \theta = \frac{e^{i\theta} - e^{-i\theta}}{2^i}
\end{align*}
$$
</div>
<p>Examples of functions and their Fourier transform below</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/05-gaussian.png" width="80%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Anti-Aliasing</b></h4>
<p>Suppose we have this function with $F(k)$,</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/06-nyquist.png" width="90%" class="center" /></p>
<p>So we first have to identify the nyquist bounds</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/07-bounds.png" width="50%" class="center" /></p>
<p>and then remove them (low pass filter) and find the inverse of the Fourier transform</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/08-remove.png" width="90%" class="center" /></p>
<p>the summary of this process is: Sampling causes higher frequencies to masquerade as lower frequencies and so after sampling, we can no longer untangle the high/low frequencies. So remove these high frequencies to avoid aliasing. Part of the signal will be lost but that’s unavoidable anyways.
<br />
<br />
This is an example of what happens after removing the high frequencies:</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/09-removed.png" width="90%" class="center" /></p>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Images</b></h4>
<p>Images have discrete values unlike continuos functions and so we need to use discrete Fourier transform. The Fast Fourier Transform (FFT) computes the discrete Fourier transform and its inverse in $O(nlogn)$ where $n$ is the number of samples. Since images are 2D, we need a 2D discrete transform using 1D transforms after each dimension. Two Example:</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/example1.png" width="90%" class="center" /></p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/sampling/example2.png" width="90%" class="center" /></p>
<p>More interesting examples in the slides!
The Pat’s examples shows how edges in images have the highest frequencies! which makes sense since this is where we have the jagged lines.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Convolution</b></h4>
<p>So now we have all the geometry in the scene. We need to get rid of the high frequencies before running the ray tracer or before projecting into screen space!! sending rays from the pixel center is sampling so we need to do this before to avoid getting the high and low frequencies mixed (or high frequencies masquerading as low frequencies). So what we need is to first find a way to run a Fourier transform on the world. hmmm (the world is not a function or an image) …. We can’t do this but what we can do is apply a convolution … A convolution is a way to get the same answer as if we went into the frequency domain. 
<br />
<br />
Let $f$ and $g$ be functions in the spatial domain (e.g. images). When we push $f$ and $g$ into the frequency domain, we’ll call them $F(f)$ and $F(g)$ (transformations of $f$ and $g$ into the frequency domain). In the previous example, $f$ was the image (left) and $F(f)$ was the frequency domain version (right).
<br />
<br />
Running a low pass filter or removing high frequencies of $F(f)$ is done by multiplying by a Heaviside function $F(g)$ where it’s 1 for low frequencies and 0 for higher frequencies.. The inverse transform will then be $F^{-1}(F(f)F(g))$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390">Fundamentals of Computer Graphics, 4th Edition</a>
<br />
<a href="https://web.stanford.edu/class/cs148/lectures.html"> CS148 Lectures </a>
<br />
<a href="https://gfxcourses.stanford.edu/cs248a">Computer Graphics by Kayvon Fatahalian</a>
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Overview See the above figure. The sensor (which mimics the eye) gets a signal based on how much area is covered by an object. For the first black square we have full coverage and the object is covering the entire sensor and so we get a black signal. The third square is half covered and we’ll get a gray signal. Basically, the sensor averages the information it gets and sends a single based on that. However when perform ray tracing and send a ray out, we’re only sending a ray from the center of the pixel. So for the last square for example, we’re going to see white only instead of some shade of gray and hence we’re losing some information. Aliasing Sampling is just testing a single point by sending a ray from the center of the pixel only. Aliasing on the other hand is caused by sampling. Anti-Aliasing is then the solution to aliasing and that’s our goal. For example, see the above figure. We’re trying to draw a quadrilateral so we send a single ray from each pixel’s center. Do our intersection test with the geometry and find out the centers that do intersect. We color these pixels and end up with a shape that’s completely different (purple squares). Testing the center of the pixel only therefore causes jagged edges often called jaggies. Aliasing can also occur not just with rasterization but also when computing the normal vectors since w’re not computing every single normal which could cause erroneous sparking highlights. Other artifacts causing by sampling include the wagon wheel effect, moire and many more. Super Sampling One solution to the aliasing issue is to increase the number of samples (per unit area). We can do this by increasing the number of pixels in the image but now we’ll take longer to render and the file will be much bigger. So far, we’ve used one sample per pixel but now we’ll take 2x2 samples per pixel and then average the result and save that instead for the pixel. This is what super sampling mean. And so instead of Jaggies, we’ll see this Sampling Rate Supersampling is great but what we really want to do in general is to find the lowest possible sampling rate that will not result in noticeable artifacts. Take the cosine function example. See below that whether we chose 4 samples or 2 samples per period, we still don’t lose any information when we reconstruct it from the samples we took. However, if our sample rate was only 1, then we see that we’ve lost information and so it appears that we would need 2 samples ata minimum. Anti Aliasing]]></summary></entry><entry><title type="html">Photon Mapping</title><link href="http://localhost:4000/jekyll/update/2023/10/26/photon-mapping.html" rel="alternate" type="text/html" title="Photon Mapping" /><published>2023-10-26T01:01:36-07:00</published><updated>2023-10-26T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/10/26/photon-mapping</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/10/26/photon-mapping.html"><![CDATA[<!------------------------------------------------------------------------------------>
<h4><b>Note</b></h4>
<p>These are my rough notes based on attending CS148. They might contain errors so proceed with caution!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Overview</b></h4>
<p>In the global illumination lecture we talked about bidirectional ray tracing. It combined both photon tracing (forward) and ray tracking (backward). We said that we will emit photons from the light, bathe these objects in light in order to create a light map. We will then use  this light map when we ray trace the scene to estimate the indirect light instead of just relying on the ambient term.
<br />
<br />
We then discussed the fact that the lighting equation can be used to described any point in any direction and we discovered that it is an implicit equation that can fit into a well known category (Fredholm Integral Equation) and this allowed us to discretize it which wasn’t tractable so we had to rely on radiosity and albedo from computer vision which led to a more tractable form. But today we will instead use Monte Carlo.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Photon Maps</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/photon-mapping/photons.png" width="60%" class="center" /></p>
<p>To create a photon map, we’ll emit photons from light sources and bounce around the scene. In the figure above, we have a number photons photons where each photon is storing the incoming light direction with the strength just like regular lights. If we want to know the pixel color at a point for example (the $L$ viewing direction in the picture), we’ll sum over the light from all the photons nearby and sum over all of these just like regular lights. Note that we’ll still be doing the important sampling and handle direct light with shadow rays and sum this amount as well. We could use a photon map for all lighting but it will require a ton of photons so it’s easier to still do the direct lighting with shadow rays.
<br />
<br /></p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/photon-mapping/01-create-photon.png" width="50%" class="center" /></p>
<p>To create a light map, we will emit a photon like the figure until it intersects something. If we hit direct light, then we ignore it. If it’s not then we have two choices assuming it doesn’t get absorbed (see the two arrows in the figure). So now we need to decide if this photon will get absorbed. If it does, then it’s gone and we don’t care. If it bounces, then we’ll need to determine the probability of it being specul<img src="../../../../../../Desktop/Screenshot%202023-10-28%20at%2010.07.45 AM.png" alt="Screenshot 2023 10 28 At 10.07.45 AM" />ar vs diffuse. Roll some dice and decide! but it has to be one or the other.
<br />
<br />
Next, if this photon hits say a camera and bounces, then that’s two bounces! we’ll bounce it until hits an object and then store the value in the photon map. We’ll take the point of intersection, the incoming light direction and store both in the photon map. This photon might bounce again and if it hits another object, we’ll store that intersection along with the incoming light direction in the map again (another entry for the same photon). Notice here that one we choose diffuse, we are stuck here unlike if we get specular, then we’ll have two choices again.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Tractability</b></h4>

<p>In the global illumination lecture, we discretized surfaces and hemisphere directions. too many chucks (curse of dimensionality).</p>

<p>Another way to solve this is using Monte Carlo integration. Instead of discretizing, we’ll 
functions that generate pseudo random sequences.</p>

<p>Monte Carlo Integration: No curse of dimensionality. Scales to higher dimensions. The purely diffuse lighting assumption is not needed.</p>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example of Monte Carlo Integration</b></h4>

<p>as opposed to Newton-Cote. Consider approximating $\pi$. You need a compass. Draw a circle of with radius of one unit distance. The area is $A=\pi r^2$ and therefore, the area is just $\pi$. So we just need to find the area of the circle. Integrate $f(x,y)=1$ over the unit circle to obtain $\int\int_A f(x,y)dA = \pi$.</p>

<p>For Newton-Cotes, we’ll inscribe triangles inside te circle. Find the sum of the area of the all the triangles.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/photon-mapping/02-newton-cotes.png" width="50%" class="center" /></p>

<p>For Monte Carlo, construct a square with side length 4 containing the circle. Generate $N$ points in the square. Color the points inside the circle blue. Since $\frac{A_{circle}}{A_{box}} = \frac{pi}{16}$, then we can approximate $pi$ ~ 16 \frac{N_{blue}}{N_{blue}+N_{red}}$.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/photon-mapping/03-monte-carlo.png" width="50%" class="center" /></p>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Monte Carlo Methods</b></h4>
<p>Random (pseudo-random) numbers generate sample points that are multiplied by some element size (length, area, volume). Basically each point in enclosed in some sample area size are if we’re working in 2D. They might overlap but that’s find. The error decreases by $1/\sqrt{N}$ where $N$ is the number of samples.  Monte Carlo is good for higher dimensions while Newton-Cote is much better in 1/2/3D.
<br />
<br />
1D example. Consider solving,</p>
<div>
$$
\begin{align*}
\int_a^b f(x)dx.
\end{align*}
$$
</div>
<p>Generate $N$ random samples $X_i$ in the interval $[a, b]$. A Monte-Carlo estimate for the integral is</p>
<div>
$$
\begin{align*}
F_N &amp;= \sum_{i=1}^N \frac{b-a}{N}f(X_i) \\
&amp;= (b - a)\frac{\sum_{i=1}^N f(X_i)}{N}
\end{align*}
$$
</div>
<p>This is a simple averaging of all the sample results.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Important Sampling</b></h4>
<p>Sometimes we want to cheat with what samples we want to pick. If we have a function that is flat in some range and not flat in some other range, we’d want to pick samples from the non-flat range. For example, suppose $f(x)$ is only non-zero in $[a_1, b_1] \subset [a,b]$ so that $\int_a^b f(x)dx = \int_{a_1}^{b_1} f(x)dx$. In this case, if $X_i \notin [a_1, b_1]$ doesn’t contribute to the integral.
<br />
<br />
In general, the probability distribution $p(x)$ should prefer samples from areas with higher contribution to the integral (important sampling). Given a $p(x)$ with $\int_a^b p(x)dx = 1$, the Monte Carlo estimate is:</p>
<div>
$$
\begin{align*}
F_N &amp;= \frac{1}{N} \sum_{i=1}^N \frac{1}{p(X_i)}f(X_i) 
\end{align*}
$$
</div>
<p>where $p(x)=1/(b-a)$ (uniform sampling). This reduces to</p>
<div>
$$
\begin{align*}
F_N &amp;= (b -a) \frac{\sum_{i=1}^N f(X_i)}{N}
\end{align*}
$$
</div>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Photon Emission</b></h4>
<p>Photon Strength: We’ll choose some number of photons and divide them amongst the lights (based on relative power). Photons all have the same power but brighter lights will just have more photons. 
<br />
<br />
Photon Position: For point lights, all photons are emitted from a single point. For area lights, we’ll randomly select a point on the surface to emit the photon from. We’ll divide the rectangular light into a uniform 2D grid and emit a set of photons from each grid cell (randomly choosing the position within the cell).
<br />
<br />
Emission Direction: Randomly choose a direction on a sphere, a hemisphere or a subset of the sphere (for point lights). In some cases like the sun, a large number of photons would miss the scene entirely so ignore these photons (don’t emit them) and restrict the light to a sub-light and so on.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Light Map</b></h4>

<ul>
  <li>
    <p>We will have a different photon map for each color.</p>
  </li>
  <li>
    <p>Use a ray tracer and once we intersect an object, then store the intersection point along with the incoming light direction (no need to store the strength if all photons have the same strength). just like what we said earlier. Make a copy of the photon’s data to store it in the light map.</p>
  </li>
  <li>
    <p>To measure absorption, generate a random number between 0 and 1 and compare it to the probability of absorption. If absorbed, then the process stops for this photon. Otherwise, we continue to bounce.</p>
  </li>
  <li>
    <p>To compute a bounce direction, we map BRDF directions into probabilities. For example a purely diffuse BRDF has equal probabilities for every hemisphere direction. We again generate a random number and use it to determine the bounce direction and then we’ll use a ray tracer to trace that path.</p>
  </li>
  <li>
    <p>We will use a pre-determined maximum number of bounces before we terminate.</p>
  </li>
  <li>
    <p>Typically photon maps are stored in an octree or kd-tree structure.</p>
  </li>
</ul>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Separating Diffuse/Specular</b></h4>
<p>It’s more convenient to store diffuse and specular lighting separately. So when bouncing a photon, determine randomly if the photon will</p>
<ul>
  <li>get absorbed</li>
  <li>will be diffuse bounced</li>
  <li>will be specular bounced</li>
  <li>We then determine the bounce direction randomly with the appropriate BRDF (diffuse/specular)</li>
  <li>We will use two light maps
(1) Caustic Maps: stores the photons that have had specular bounces only.
(2) Indirect Lighting Map: store the photons that have had at least one diffuse bounce.</li>
</ul>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Gathering Radiance</b></h4>
<ul>
  <li>Trace rays from the camera and intersect with objects and use shadow rays for direct lighting.</li>
  <li>Estimate radiance contribution to the ray from caustics and indirect lighting using the respective light maps: use the N closest photons to the point of intersection (with the aid of the acceleration structure (octree or kdtree))</li>
</ul>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Color</b></h4>
<ul>
  <li>3 photon maps one for each color. Objects of certain color better absorb photons of differing colors so this gives color bleeding and related effects.</li>
</ul>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390">Fundamentals of Computer Graphics, 4th Edition</a>
<br />
<a href="https://web.stanford.edu/class/cs148/lectures.html"> CS148 Lectures </a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Note These are my rough notes based on attending CS148. They might contain errors so proceed with caution! Overview In the global illumination lecture we talked about bidirectional ray tracing. It combined both photon tracing (forward) and ray tracking (backward). We said that we will emit photons from the light, bathe these objects in light in order to create a light map. We will then use this light map when we ray trace the scene to estimate the indirect light instead of just relying on the ambient term. We then discussed the fact that the lighting equation can be used to described any point in any direction and we discovered that it is an implicit equation that can fit into a well known category (Fredholm Integral Equation) and this allowed us to discretize it which wasn’t tractable so we had to rely on radiosity and albedo from computer vision which led to a more tractable form. But today we will instead use Monte Carlo. Photon Maps To create a photon map, we’ll emit photons from light sources and bounce around the scene. In the figure above, we have a number photons photons where each photon is storing the incoming light direction with the strength just like regular lights. If we want to know the pixel color at a point for example (the $L$ viewing direction in the picture), we’ll sum over the light from all the photons nearby and sum over all of these just like regular lights. Note that we’ll still be doing the important sampling and handle direct light with shadow rays and sum this amount as well. We could use a photon map for all lighting but it will require a ton of photons so it’s easier to still do the direct lighting with shadow rays. To create a light map, we will emit a photon like the figure until it intersects something. If we hit direct light, then we ignore it. If it’s not then we have two choices assuming it doesn’t get absorbed (see the two arrows in the figure). So now we need to decide if this photon will get absorbed. If it does, then it’s gone and we don’t care. If it bounces, then we’ll need to determine the probability of it being specular vs diffuse. Roll some dice and decide! but it has to be one or the other. Next, if this photon hits say a camera and bounces, then that’s two bounces! we’ll bounce it until hits an object and then store the value in the photon map. We’ll take the point of intersection, the incoming light direction and store both in the photon map. This photon might bounce again and if it hits another object, we’ll store that intersection along with the incoming light direction in the map again (another entry for the same photon). Notice here that one we choose diffuse, we are stuck here unlike if we get specular, then we’ll have two choices again. Tractability]]></summary></entry><entry><title type="html">(9) Global Illumination</title><link href="http://localhost:4000/jekyll/update/2023/10/24/global-illumination.html" rel="alternate" type="text/html" title="(9) Global Illumination" /><published>2023-10-24T01:01:36-07:00</published><updated>2023-10-24T01:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2023/10/24/global-illumination</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2023/10/24/global-illumination.html"><![CDATA[<!------------------------------------------------------------------------------------>
<h4><b>Note</b></h4>
<p>These are my rough notes based on attending CS148. They might contain errors so proceed with caution!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Photon Tracing</b></h4>
<p>Photons come out of the light and then bounce around. One idea for rendering an image is to just follow every photon around and see where it goes. Some will bounce and hit an object like a chair and then get absorbed so they’re gone. Some will go through the camera aperture and hit the film and this is when we can see their contribution. So basically:</p>
<ul>
  <li>For each light, choose a number of directions and emit a photon in each direction. 
(1) Let the photon travel in a straight line until it hit object. Then:
(2) If the object hit was the camera, record its contribution to the final image.
(3) If absorbed, terminate this photon. we’re done.
(4) If reflected/transmitted/scattered: the photon then will go in a new direction. Go to step (1).</li>
</ul>

<p>Issues:</p>
<ul>
  <li>Most of these photons will not hit the tree so it’s impractical/efficient.</li>
</ul>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>(Backward) Path Tracing</b></h4>
<p>The solution to the photon tracing problem is to send only a subset of photons. One idea is to start at the film and go backwards (just like a ray tracer). But there is an issue here is that if we go backward and then hit an object. We still don’t know where the photon could come from. It could come from any direction on the hemisphere. (Similar to the BRDF, we had many incoming directions and one outgoing direction to the viewer/pixel)
<br />
<br />
So now from the hemisphere, send like 100 rays/photons (sampling). So for each ray follow it along its path. If it hits an object, then again we’ll need to send another 100 photon rays all over again. We continue this until eventually, some ray will hit the light source. Once we’re here at the light then we know the exact path that started at the light and ended up at the film.
<br />
<br />
The problem with the above solution is the potential exponential growth. For example, most of the time the light sources are not really facing the camera or the eye directly. They’re pointing away but providing enough lighting everywhere. This immediately indicates that we’re going to send many photons that will bounce over and over again until we hit the actual light source.
<br />
<br />
The ray tracer that we discussed was doing this with <b>important sampling</b>. We send a ray until it intersects an object. And then instead of sending photon rays in all directions on the hemisphere, we send one ray directly to the light source because we just assume that there will be a lot of photons in this direction. Why? because the ray that will hit a chair for example before hitting the light source will not contain as many photons. Many of these photons will get absorbed by the chair while the ray hitting the light source with no obstructions will have the most photons. So in the first ray tracer that we did, we just picked the most important ray (direct illumination) and forget about all the others since their contribution will be much smaller.
<br />
<br />
In the recursive ray tracing lecture, we added more rays. We looked at the reflected and transmitted rays. A shiny object will bounce a lot more photons in the reflected direction rather than the other directions. The transmitted and reflected rays are still grouped here under directed illumination or <b>important sampling</b> even though they’re not direct rays. They’re important enough!
<br />
<br />
To summarize, a ray tracer does direct illumination with the shadow rays and some indirect illumination with the transmitted and reflected rays. The downside with ray tracing is that we’re missing lots of other light.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Bidirectional Ray Tracing</b></h4>
<p>This approach combines both Photon Tracing and Ray Tracing. So not just the backward tracing in ray tracing but also the forward path in photon tracing. 
<br />
<br />
So how do we do it?</p>

<p>(1) Emit photons from the light, bathe objects in these photons, the result is a light map. Light maps don’t change when the camera moves so they can be precomputed. How do we accomplish this?</p>

<ul>
  <li>Take the area light, break it into chunks like a grid. For each chunk or small piece, pick a hemisphere and shoot photons out of this hemisphere.</li>
  <li>How many photons? Pick some number, maybe higher for brighter lights and lower for dimmer lights?</li>
  <li>Next the photon will come out and hit some object. We’ll test and see if this photon will get absorbed or if it bounces. If it bounces, then it will bounce in a hemisphere and go somewhere else. We’ll then again shoot photons in a hemisphere and so on.</li>
  <li>We’ll save this intersection point (with X,Y,Z coordinates). Later on, when we’re trying to color this point, we’ll see that there was a photon that hit that location. To know from where, we’ll put a sphere around this point and get all the photons in that sphere and then I can use that light in the ray tracer. This is what we called a photon mapping.</li>
</ul>

<p>(2) Ray trace the scene using the light map to estimate the indirect light.</p>

<p>It’s important to note that we’re still going to use the ray tracer to do important sampling (shadow rays, reflected rays and transmitted rays). We need this because if we don’t have enough photons, the picture won’t look good. So still do the important sampling and then use the photon mapping for the secondary indirect lighting. 
<br />
<br />
Light maps are great for soft shadows, color bleeding and can generate other interesting effects too. (TODO: Prism example)
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>The Equation of Light Revisited</b></h4>
<p>Recall the lighting equation from the optics lecture</p>
<div>
$$
\begin{align*}
L_o(\omega_o) = \int_{\text{i \in in}} BRDF(\omega_i, \omega_w) L_i \cos\theta_i d\omega_i
\end{align*}
$$
</div>
<p>This was the simplified version. We’re now going to add back the position (surface location $x$) and incoming angle $\omega_i$. We also add an emission term $L_e$.</p>
<div>
$$
\begin{align*}
L_o(x, \omega_o) = L_e(x, \omega_o) + \int_{\text{i \in hemi}} BRDF(x, \omega_i, \omega_w) L_i(x, \omega_i) \cos\theta_i d\omega_i
\end{align*}
$$
</div>
<p>The incoming light from direction $\omega_i$ left some other surface point $x’$ going in direction $-\omega_i$ so replace $L_i(x,\omega_i)$ with $L_o(x’, -\omega_i)$.</p>
<div>
$$
\begin{align*}
L_o(x, \omega_o) = L_e(x, \omega_o) + \int_{\text{i \in hemi}} BRDF(x, \omega_i, \omega_w) L_o(x', -\omega_i) \cos\theta_i d\omega_i
\end{align*}
$$
</div>
<p>So here in this equation we know the terms:</p>
<ul>
  <li>The BRDF value $BRDF(x, \omega_i, \omega_w)$</li>
  <li>The emission term $L_e(x, \omega_o)$</li>
  <li>The incidence angle $\cos\theta_i$
What we don’t know is</li>
  <li>The reflected light term inside $L_o(x’, -\omega_i)$</li>
  <li>The reflected light term outside $L_o(x, \omega_o)$
We basically don’t know what light was reflected out of those objects in order to know the light coming out of this point. But luckily this is a known physics equation (Fredholm Integral Equation of the second kind)</li>
</ul>
<div>
$$
\begin{align*}
l(u) = e(u) + \int l(v) k(u,v)dv
\end{align*}
$$
</div>
<p>One additional note here is that we’re still simplifying the light here because we’re assuming that we’re in a vacuum, while in reality there are particles in the air that scatter these photons. So technically, we should be putting a sphere around points not just on objects but on every point in the space!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Discretization of the integral equation</b></h4>
<p>We will solve the above problem with discretization. Cut up the surface into chuncks and choose a few points and a few directions:</p>

<ul>
  <li>
    <p>Choose $p$ points, each representing a chunck of surface area. (for the classroom for example, just choose a bunch of samples. If we care about objects for example then we’ll pick points $p$ on objects). Basically sample the room we’re tring to render.</p>
  </li>
  <li>
    <p>For each point $p$, choose $q$ outgoing directions, each representing a chunck of solid angles of the hemisphere (or sphere). (2d discretization).</p>
  </li>
</ul>

<p>Checkpoint: if we do that: pick $p$ and $q$. Look at the previous integral. We’re trying to know something that varies based on where it is $p$ and the direction where the light is going $q$. So we have $p * q$ different combinations of positions and directions there are.</p>

<ul>
  <li>
    <p>$L_o$ and $L_e$ then each have $p * q$ unknowns. $L_o$ and $L_e$ can be column vectors $L$ and $E$ of length $p * q$. We can solve this system to know how much light is going in each of those directions.</p>
  </li>
  <li>
    <p>The light transport “kernel” matrix $K$ has size $p * q$ by $p * q$. hmmmm ???</p>
  </li>
  <li>
    <p>The linear system of equations is the following where $K$ and $E$ are known. $I$ is the identity matrix,</p>
  </li>
</ul>
<div>
$$
\begin{align*}
L &amp;= E + KL \\
(I - K)L &amp;= E
\end{align*}
$$
</div>
<p>and the solution to this equation is</p>
<div>
$$
\begin{align*}
L = (I - K)^{-1}E = (I + K + K^2 + ...)E
\end{align*}
$$
</div>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Power Series</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/global-illumination/00-power-series.png" width="80%" class="center" /></p>

<div>
$$
\begin{align*}
L = E + KE + K^2E + K^3E + ...
\end{align*}
$$
</div>
<ul>
  <li>E is anything that is directly coming from the light source (emission term).</li>
  <li>KE means it bounced once. It hit the floor maybe and then our eyes. (direct illumination).</li>
  <li>K^2E means it bounced twice (global illumination  (indirect lighting)).</li>
  <li>K^3E means it bounced three times (global illumination  (indirect lighting)) and so on.
<br />
<br />
<!------------------------------------------------------------------------------------></li>
</ul>
<h4><b>Tractability</b></h4>

<p>Issues with the power series:</p>
<ul>
  <li>A typical scene might have tens of thousands of area chunks. So $p$ could be $1e3, 1e4..$.</li>
  <li>Incoming light could vary significantly across the hemisphere. For each $p$, we could be again a crazy amount of directions.</li>
  <li>$L$ and $E$ would then range in length from 1e5 to 1e10</li>
  <li>The matrix $K$ would be really huge. $K$ could have have between $1e10$ and $1e20$ entries!</li>
  <li>This tractability analysis is for the 4D problem (5D is even worse)</li>
  <li>The curse of dimensionality makes problems in 4D and 5D (and higher) hard to discretize (with numerical quadrature)</li>
</ul>

<p>So this isn’t possible. How to fix this?
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Addressing Tractability</b></h4>
<p>Idea: Separate the diffuse and specular contribution.</p>

<p>Diffuse:</p>
<ul>
  <li>Assume all materials are purely diffuse (no specular contribution).</li>
  <li>Compute the view-independent global illumination for the entire scene.</li>
  <li>We can do this in a pre-processing step.</li>
</ul>

<p>Specular:</p>
<ul>
  <li>Compute (view dependent) specular illumination on the fly as the camera moves using phong shading or any other model.</li>
</ul>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Radiosity and Albedo</b></h4>
<p>This is what we typically work with in computer vision.</p>
<ul>
  <li>Radiosity: power per unit surface area leaving a surface (similar to irradiance, but outgoing instead of incoming):</li>
</ul>
<div>
$$
\begin{align*}
B(x) = \frac{d\phi}{dA} = \int_{\text{hemi}} L_o(x, \omega_o)\cos \theta_o d\omega_o
\end{align*}
$$
</div>
<p>But if $L_o$ is independent of $\omega_o$ (i.e. purely diffuse)</p>
<div>
$$
\begin{align*}
B(x) = \frac{d\phi}{dA} = L(x) \int_{\text{hemi}} \cos \theta_o d\omega_o = \pi L(x)
\end{align*}
$$
</div>
<ul>
  <li>Albedo: a “reflection coefficient” relating incoming light hitting a surface patch (irradiance $E_i$) to outgoing light emitted in all possible directions</li>
</ul>
<div>
$$
\begin{align*}
p(x) = \int BRDF(x, \omega_o, \omega_i) \cos \theta_o d\omega_o
\end{align*}
$$
</div>
<p>But when the BRDF is independent of $\omega_o$ and $\omega_i$ (purely diffuse)</p>
<div>
$$
\begin{align*}
p(x) = BRDF(x) \int \cos \theta_o d\omega_o = \pi BRDF(x)
\end{align*}
$$
</div>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>(Purly Diffuse) Lighting Equation</b></h4>
<p>So now we can bring back the lighting equation from above,</p>
<div>
$$
\begin{align*}
L_o(x, \omega_o) = L_e(x, \omega_o) + \int_{\text{i \in hemi}} BRDF(x, \omega_i, \omega_w) L_o(x', -\omega_i) \cos\theta_i d\omega_i
\end{align*}
$$
</div>
<p>and we’re going to multiply everything by $\cos\theta_o d\omega_o$ and if you integrate, you will get</p>
<div>
$$
\begin{align*}
B(x) = E(x) + \int_{\text{i \in hemi}} B(x') BRDF(x, \omega_i, \omega_w)  \cos\theta_i d\omega_i
\end{align*}
$$
</div>
<p>…. TODO ….</p>
<div>
$$
\begin{align*}
B(x) = E(x) + \frac{p(x)}{pi} \int_{\text{i \in hemi}} B(x')\cos\theta_i d\omega_i
\end{align*}
$$
</div>
<p>From the solid angle definition, we know that</p>
<div>
$$
\begin{align*}
d\omega = \frac{dA\cos\theta}{r^2} = \frac{dA\cos\theta}{\left\lVert x - x' \right\rVert_2^2} 
\end{align*}
$$
</div>
<p>…. SO MUCH TO DO HERE ….
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Understanding the Form Factor</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/graphics/global-illumination/00-form-factor.png" width="80%" class="center" /></p>
<ul>
  <li>Place a unit hemisphere at a surface point $x_i$.</li>
  <li>Project the other surface on the hemisphere, nothing that</li>
</ul>
<div>
$$
\begin{align*}
d\omega = \frac{dA\cos\theta}{r^2} = \frac{dA\cos\theta}{\left\lVert x - x' \right\rVert_2^2} 
\end{align*}
$$
</div>
<p>Project the result downwards onto the circular base of the hemisphere which multiplies by $\cos \theta_i$.</p>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://www.amazon.com/Fundamentals-Computer-Graphics-Steve-Marschner/dp/1482229390">Fundamentals of Computer Graphics, 4th Edition</a>
<br />
<a href="https://web.stanford.edu/class/cs148/lectures.html"> CS148 Lectures </a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Note These are my rough notes based on attending CS148. They might contain errors so proceed with caution! Photon Tracing Photons come out of the light and then bounce around. One idea for rendering an image is to just follow every photon around and see where it goes. Some will bounce and hit an object like a chair and then get absorbed so they’re gone. Some will go through the camera aperture and hit the film and this is when we can see their contribution. So basically: For each light, choose a number of directions and emit a photon in each direction. (1) Let the photon travel in a straight line until it hit object. Then: (2) If the object hit was the camera, record its contribution to the final image. (3) If absorbed, terminate this photon. we’re done. (4) If reflected/transmitted/scattered: the photon then will go in a new direction. Go to step (1).]]></summary></entry></feed>