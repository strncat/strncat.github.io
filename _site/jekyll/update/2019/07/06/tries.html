<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Tries (Prefix Trees) | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Tries (Prefix Trees)" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="0 References Algorithms by Robert Sedgwick and Kevin Wayne http://web.stanford.edu/class/cs166/ 1 Introduction Consider the following problem: Given strings of total length and a string pattern of length . We want to find all the strings that match . The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take time. However, suppose that we now we have patterns, then this approach will take time which is really slow, especially if we’re displaying auto-complete live results to the user as they type their queries. In the RMQ notation, we will write where is the preprocessing time and is the query time. So how can we make it faster? 2 The Trie Data Structure The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider. Let’s start with studying some properties of tries: &lt;&gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &lt;&gt; Each node will have pointers or children where is the alphabet size. &lt;&gt; Edges represent letters. For example, the root node has one edge () to the node below. &lt;&gt; Each node also has only one parent. Let’s look at what a trie really looks like: You can see above, the root has only edge/link. From , we can traverse to either or . From we can add or only and from we can add or and so on. 3 Prefix Search How do we search for prefixes now? given a pattern we want to output all possible matches. We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word. Let’s look at search first: node* search(std::string word) { long m = word.length(); node *current = root; for (int i = 0; i &lt; m; i++) { int index = word[i] - &#39;a&#39;; if (!current-&gt;children[index]) { // null pointer return NULL; // not found } // move to the child current = current-&gt;children[index]; } return current; } Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix: // prefix match: print all possible matches int words_with_prefix(std::string prefix) { node *current = search(prefix); if (current == NULL) { return 0; } // no matches std::queue&lt;std::string&gt; q; collect(current, prefix, q); while (!q.empty()) { printf(&quot;%s\n&quot;, q.front().c_str()); q.pop(); } return current-&gt;value; // total matches } Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect: // collect matches recursively from all branches // save them in q void collect(node *current, std::string prefix, std::queue&lt;std::string&gt; &amp;q) { if (current == NULL) { return; } if (current-&gt;marker) { q.push(prefix); } for (int i = 0; i &lt; SIZE; i++) { if (current-&gt;children[i] != NULL) { char c = i + &#39;a&#39;; collect(current-&gt;children[i], prefix + c, q); } } } Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue. How long does search takes? oh only the length of the key or pattern!! so ! 4 Insert To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter. void insert(std::string word) { if (search(word)) { // word exists return; } int length = (int) word.length(); node *current = root; current-&gt;value++; // increment word count for (int i = 0; i &lt; length; i++) { int index = word[i] - &#39;a&#39;; if (!current-&gt;children[index]) { // this letter doesn&#39;t exist, create it current-&gt;children[index] = new node(); } // this letter has a link already, follow it along current = current-&gt;children[index]; current-&gt;value++; } // mark the last node, this is the end of our word // this is a marker of an end to a valid word current-&gt;marker = true; } So insert takes time as well! 5 Delete To be added. 6 Longest Prefix To be added 7 Running Time We mentioned above that insert and search both take time where is the length of the pattern. How long does it take to build a trie to represent all words of total length ? We need to make insertions each of which will take size of each word. Since the total length of all words is , then the total time is which happens only once initially. Therefore, in the RMQ notation we will have which is a lot better than the naive solution. 8 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp" />
<meta property="og:description" content="0 References Algorithms by Robert Sedgwick and Kevin Wayne http://web.stanford.edu/class/cs166/ 1 Introduction Consider the following problem: Given strings of total length and a string pattern of length . We want to find all the strings that match . The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take time. However, suppose that we now we have patterns, then this approach will take time which is really slow, especially if we’re displaying auto-complete live results to the user as they type their queries. In the RMQ notation, we will write where is the preprocessing time and is the query time. So how can we make it faster? 2 The Trie Data Structure The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider. Let’s start with studying some properties of tries: &lt;&gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &lt;&gt; Each node will have pointers or children where is the alphabet size. &lt;&gt; Edges represent letters. For example, the root node has one edge () to the node below. &lt;&gt; Each node also has only one parent. Let’s look at what a trie really looks like: You can see above, the root has only edge/link. From , we can traverse to either or . From we can add or only and from we can add or and so on. 3 Prefix Search How do we search for prefixes now? given a pattern we want to output all possible matches. We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word. Let’s look at search first: node* search(std::string word) { long m = word.length(); node *current = root; for (int i = 0; i &lt; m; i++) { int index = word[i] - &#39;a&#39;; if (!current-&gt;children[index]) { // null pointer return NULL; // not found } // move to the child current = current-&gt;children[index]; } return current; } Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix: // prefix match: print all possible matches int words_with_prefix(std::string prefix) { node *current = search(prefix); if (current == NULL) { return 0; } // no matches std::queue&lt;std::string&gt; q; collect(current, prefix, q); while (!q.empty()) { printf(&quot;%s\n&quot;, q.front().c_str()); q.pop(); } return current-&gt;value; // total matches } Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect: // collect matches recursively from all branches // save them in q void collect(node *current, std::string prefix, std::queue&lt;std::string&gt; &amp;q) { if (current == NULL) { return; } if (current-&gt;marker) { q.push(prefix); } for (int i = 0; i &lt; SIZE; i++) { if (current-&gt;children[i] != NULL) { char c = i + &#39;a&#39;; collect(current-&gt;children[i], prefix + c, q); } } } Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue. How long does search takes? oh only the length of the key or pattern!! so ! 4 Insert To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter. void insert(std::string word) { if (search(word)) { // word exists return; } int length = (int) word.length(); node *current = root; current-&gt;value++; // increment word count for (int i = 0; i &lt; length; i++) { int index = word[i] - &#39;a&#39;; if (!current-&gt;children[index]) { // this letter doesn&#39;t exist, create it current-&gt;children[index] = new node(); } // this letter has a link already, follow it along current = current-&gt;children[index]; current-&gt;value++; } // mark the last node, this is the end of our word // this is a marker of an end to a valid word current-&gt;marker = true; } So insert takes time as well! 5 Delete To be added. 6 Longest Prefix To be added 7 Running Time We mentioned above that insert and search both take time where is the length of the pattern. How long does it take to build a trie to represent all words of total length ? We need to make insertions each of which will take size of each word. Since the total length of all words is , then the total time is which happens only once initially. Therefore, in the RMQ notation we will have which is a lot better than the naive solution. 8 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp" />
<link rel="canonical" href="https://strncat.github.io/jekyll/update/2019/07/06/tries.html" />
<meta property="og:url" content="https://strncat.github.io/jekyll/update/2019/07/06/tries.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-06T12:01:36-07:00" />
<script type="application/ld+json">
{"description":"0 References Algorithms by Robert Sedgwick and Kevin Wayne http://web.stanford.edu/class/cs166/ 1 Introduction Consider the following problem: Given strings of total length and a string pattern of length . We want to find all the strings that match . The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take time. However, suppose that we now we have patterns, then this approach will take time which is really slow, especially if we’re displaying auto-complete live results to the user as they type their queries. In the RMQ notation, we will write where is the preprocessing time and is the query time. So how can we make it faster? 2 The Trie Data Structure The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider. Let’s start with studying some properties of tries: &lt;&gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &lt;&gt; Each node will have pointers or children where is the alphabet size. &lt;&gt; Edges represent letters. For example, the root node has one edge () to the node below. &lt;&gt; Each node also has only one parent. Let’s look at what a trie really looks like: You can see above, the root has only edge/link. From , we can traverse to either or . From we can add or only and from we can add or and so on. 3 Prefix Search How do we search for prefixes now? given a pattern we want to output all possible matches. We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word. Let’s look at search first: node* search(std::string word) { long m = word.length(); node *current = root; for (int i = 0; i &lt; m; i++) { int index = word[i] - &#39;a&#39;; if (!current-&gt;children[index]) { // null pointer return NULL; // not found } // move to the child current = current-&gt;children[index]; } return current; } Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix: // prefix match: print all possible matches int words_with_prefix(std::string prefix) { node *current = search(prefix); if (current == NULL) { return 0; } // no matches std::queue&lt;std::string&gt; q; collect(current, prefix, q); while (!q.empty()) { printf(&quot;%s\\n&quot;, q.front().c_str()); q.pop(); } return current-&gt;value; // total matches } Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect: // collect matches recursively from all branches // save them in q void collect(node *current, std::string prefix, std::queue&lt;std::string&gt; &amp;q) { if (current == NULL) { return; } if (current-&gt;marker) { q.push(prefix); } for (int i = 0; i &lt; SIZE; i++) { if (current-&gt;children[i] != NULL) { char c = i + &#39;a&#39;; collect(current-&gt;children[i], prefix + c, q); } } } Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue. How long does search takes? oh only the length of the key or pattern!! so ! 4 Insert To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter. void insert(std::string word) { if (search(word)) { // word exists return; } int length = (int) word.length(); node *current = root; current-&gt;value++; // increment word count for (int i = 0; i &lt; length; i++) { int index = word[i] - &#39;a&#39;; if (!current-&gt;children[index]) { // this letter doesn&#39;t exist, create it current-&gt;children[index] = new node(); } // this letter has a link already, follow it along current = current-&gt;children[index]; current-&gt;value++; } // mark the last node, this is the end of our word // this is a marker of an end to a valid word current-&gt;marker = true; } So insert takes time as well! 5 Delete To be added. 6 Longest Prefix To be added 7 Running Time We mentioned above that insert and search both take time where is the length of the pattern. How long does it take to build a trie to represent all words of total length ? We need to make insertions each of which will take size of each word. Since the total length of all words is , then the total time is which happens only once initially. Therefore, in the RMQ notation we will have which is a lot better than the naive solution. 8 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp","@type":"BlogPosting","url":"https://strncat.github.io/jekyll/update/2019/07/06/tries.html","headline":"Tries (Prefix Trees)","dateModified":"2019-07-06T12:01:36-07:00","datePublished":"2019-07-06T12:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://strncat.github.io/jekyll/update/2019/07/06/tries.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://strncat.github.io/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
  
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Tries (Prefix Trees)</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-07-06T12:01:36-07:00" itemprop="datePublished">Jul 6, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><b>0 References</b><br /></p>
<ul>
  <li>Algorithms by Robert Sedgwick and Kevin Wayne
<br /></li>
  <li>http://web.stanford.edu/class/cs166/
<br />
<br /></li>
</ul>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>1 Introduction</b>
<br />
Consider the following problem: Given <script type="math/tex">k</script> strings of total length <script type="math/tex">m</script> and a string pattern <script type="math/tex">p</script> of length <script type="math/tex">n</script>. We want to find all the strings that match  <script type="math/tex">p</script>. The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take <script type="math/tex">O(m)</script> time. However, suppose that we now we have <script type="math/tex">r</script> patterns, then this approach will take <script type="math/tex">O(mr)</script> time which is really slow, especially if we’re displaying auto-complete live results to the user as they type their queries. In the RMQ notation, we will write <script type="math/tex">\langle O(1), O(mr)\rangle</script> where <script type="math/tex">O(1)</script> is the preprocessing time and <script type="math/tex">O(mr)</script> is the query time. So how can we make it faster?
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2 The Trie Data Structure</b>
<br />
<img src="https://strncat.github.io/assets/trie/1.png" width="100%" />
<br />
The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider.
<br />
Let’s start with studying some properties of tries:
<br /><br />
&lt;&gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. <br />
&lt;&gt; Each node will have <script type="math/tex">R</script> pointers or children where <script type="math/tex">R</script> is the alphabet size. <br />
&lt;&gt; Edges represent letters. For example, the root node has one edge (<script type="math/tex">c</script>) to the node below.<br />
&lt;&gt; Each node also has only one parent.<br />
<br />
Let’s look at what a trie really looks like:
<br />
<img src="https://strncat.github.io/assets/trie/2.png" width="100%" />
You can see above, the root has only <script type="math/tex">c</script> edge/link. From <script type="math/tex">c</script>, we can traverse to either <script type="math/tex">a</script> or <script type="math/tex">i</script>. From <script type="math/tex">a</script> we can add <script type="math/tex">k</script> or <script type="math/tex">t</script> only and from <script type="math/tex">i</script> we can add <script type="math/tex">d</script> or <script type="math/tex">v</script> and so on.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3 Prefix Search</b>
<br />
How do we search for prefixes now? given a pattern <script type="math/tex">p</script> we want to output all possible matches. We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word.
<br />
Let’s look at search first:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">node</span><span class="o">*</span> <span class="nf">search</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">m</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// null pointer</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// not found</span>
        <span class="p">}</span>
        <span class="c1">// move to the child</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">current</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// prefix match: print all possible matches</span>
<span class="kt">int</span> <span class="nf">words_with_prefix</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">prefix</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">search</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span> <span class="c1">// no matches</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">collect</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">().</span><span class="n">c_str</span><span class="p">());</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span> <span class="c1">// total matches</span>
<span class="p">}</span></code></pre></figure>

<p>Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// collect matches recursively from all branches</span>
<span class="c1">// save them in q</span>
<span class="kt">void</span> <span class="nf">collect</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">current</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">prefix</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">q</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">marker</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">prefix</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="sc">'a'</span><span class="p">;</span>
            <span class="n">collect</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">prefix</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue.
<br />
How long does search takes? oh only the length of the key or pattern!! so <script type="math/tex">O(n)</script>!
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>4 Insert</b>
<br />
To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter.
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">word</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">search</span><span class="p">(</span><span class="n">word</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// word exists</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">word</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">current</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span> <span class="c1">// increment word count</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">word</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'a'</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">])</span> <span class="p">{</span>
             <span class="c1">// this letter doesn't exist, create it</span>
            <span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">node</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">// this letter has a link already, follow it along</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">children</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
        <span class="n">current</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// mark the last node, this is the end of our word</span>
    <span class="c1">// this is a marker of an end to a valid word</span>
    <span class="n">current</span><span class="o">-&gt;</span><span class="n">marker</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>So insert takes <script type="math/tex">O(n)</script> time as well!
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>5 Delete</b>
<br />
To be added.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>6 Longest Prefix</b>
<br />
To be added
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><b>7 Running Time</b>
<br />
We mentioned above that insert and search both take <script type="math/tex">O(n)</script> time where <script type="math/tex">n</script> is the length of the pattern. How long does it take to build a trie to represent all words of total length <script type="math/tex">m</script>? We need to make <script type="math/tex">k</script> insertions each of which will take <script type="math/tex">O(</script>size of each word<script type="math/tex">)</script>. Since the total length of all words is <script type="math/tex">m</script>, then the total time is <script type="math/tex">O(m)</script> which happens only once initially. Therefore, in the RMQ notation we will have <script type="math/tex">\langle O(m), O(n) \rangle</script> which is a lot better than the naive solution. 
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>8 Full Implementation:</b> 
<br />
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
<br />
<br /></p>


  </div><div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = https://strncat.github.io/jekyll/update/2019/07/06/tries.html;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier =  https://strncat.github.io/jekyll/update/2019/07/06/tries.html; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://strncat-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a class="u-url" href="/jekyll/update/2019/07/06/tries.html" hidden></a>
</article>
		 
      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello</p>
      </div>
    </div>

  </div>

</footer>
-->

	
	    <!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-143936776-1', 'auto');
ga('send', 'pageview');
</script>
<!-- End Google Analytics -->
	    
  </body>

</html>
