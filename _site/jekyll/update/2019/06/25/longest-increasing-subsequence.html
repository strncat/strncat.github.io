<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Longest Increasing Subsequence | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Longest Increasing Subsequence" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1 Introduction Let be an array containing real numbers. A longest increasing subsequence of A is a sequence such that so that is of maximum value. 2 Example Suppose then a longest increasing subsequence could be . Note that it is not unique. 3 The Brute Force Solution We can check every possible subsequence. For each element of , we either select that element or not. Therefore, the total number of possible subsequences is . As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is . 4 Dynamic Programming and the Optimal Substructure To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS). It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let be the length of the longest increasing subsequence ending at , then we will find that $$ \begin{align*} D[i] = 1 + \max({D[k] : k &lt; i \text{ and } A[k] &lt; A[i]}) \end{align*} $$ In other words, the longest increasing subsequence ending at can be found by looking at all where (meaning that comes before ) and (meaning that can extend the subsequence ending at ). We then taking the maximum value of , Proof: Let be a natural number and let be the length of the longest increasing subsequence ending at . Consider the subsequence ending at . We have two cases: Case 1: is the smallest element in . Therefore, the length of the subsequence ending at is 1. Case 2: is not the smallest element in . Let be a natural number where . This means that we can use to extend the subsequence ending at if . Since we are searching for the longest increasing subsequence then we take the maximum value for all possible and so is the maximum value plus 1 as defined above. We claim that is the length of longest increasing subsequence ending at . Suppose it wasn’t and that the longest increasing subsequence ending at is and so . By our definition, we know that where is the longest increasing subsequence ending at . This means that but this is not possible since we’re only adding to the subsequence. Therefore, is optimal. 3 The Implementation int D[n], p[n], max = 0; // maximum subsequence ending at a[i] is initially 1 for (int i = 0; i &lt; n; i++) { D[i] = 1; p[i] = -1; // parent array } // for element a[i], check all the previous subsequences where i &lt; j // and see if a[i] can extend any of them for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { if (A[i] &gt; A[j] &amp;&amp; D[i] &lt; D[j] + 1) { // I can extend the subsequence D[i] = D[j] + 1; p[i] = j; // used for reconstructing the subsequence } } if (D[i] &gt; max) { // maximum subsequence so far max = D[i]; } } return max; 5 Running Time: We’re doing two simple loops to fill arrays and . Therefore, our runtime is just 6 Example: Initially we start with arrays and : Consider again . We initialize to be representing the initial length of the subsequence ending at each possible . Iteration . We look at . We have and so the subsequence is just . Can 8 extend any previous subsequences? We look at and in that case, we see that , meaning that that the subsequence can now include 3 and become . And so now we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ Iteration . We look at . We have and so the subsequence is just . Can 4 extend any previous subsequences? We need to look at and . It turns out that 1 will not be able to extend either subsequence. $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ We continue doing so until we reach the end and we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$ This means that the longest subsequence ends at element 9 or 5. We can then to construct the subsequence. One possible construction will generate: 5 The O(nlg(n)) Solution with Binary Search: The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes! Previously, we said that is the length of the longest subsequence ending at . Now we will consider a completely different substructure. Let to be the smallest element that ends a subsequence of length . For simplicity we will initially let to be and everything else to be . Let’s take the same example where . In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have is . Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of , that must be sorted because this will help us later on. To prove that is sorted, we will prove that is a strictly increasing array and that for any , we have . (We will ignore the placeholder ’s otherwise the proof would not work)" />
<meta property="og:description" content="1 Introduction Let be an array containing real numbers. A longest increasing subsequence of A is a sequence such that so that is of maximum value. 2 Example Suppose then a longest increasing subsequence could be . Note that it is not unique. 3 The Brute Force Solution We can check every possible subsequence. For each element of , we either select that element or not. Therefore, the total number of possible subsequences is . As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is . 4 Dynamic Programming and the Optimal Substructure To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS). It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let be the length of the longest increasing subsequence ending at , then we will find that $$ \begin{align*} D[i] = 1 + \max({D[k] : k &lt; i \text{ and } A[k] &lt; A[i]}) \end{align*} $$ In other words, the longest increasing subsequence ending at can be found by looking at all where (meaning that comes before ) and (meaning that can extend the subsequence ending at ). We then taking the maximum value of , Proof: Let be a natural number and let be the length of the longest increasing subsequence ending at . Consider the subsequence ending at . We have two cases: Case 1: is the smallest element in . Therefore, the length of the subsequence ending at is 1. Case 2: is not the smallest element in . Let be a natural number where . This means that we can use to extend the subsequence ending at if . Since we are searching for the longest increasing subsequence then we take the maximum value for all possible and so is the maximum value plus 1 as defined above. We claim that is the length of longest increasing subsequence ending at . Suppose it wasn’t and that the longest increasing subsequence ending at is and so . By our definition, we know that where is the longest increasing subsequence ending at . This means that but this is not possible since we’re only adding to the subsequence. Therefore, is optimal. 3 The Implementation int D[n], p[n], max = 0; // maximum subsequence ending at a[i] is initially 1 for (int i = 0; i &lt; n; i++) { D[i] = 1; p[i] = -1; // parent array } // for element a[i], check all the previous subsequences where i &lt; j // and see if a[i] can extend any of them for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { if (A[i] &gt; A[j] &amp;&amp; D[i] &lt; D[j] + 1) { // I can extend the subsequence D[i] = D[j] + 1; p[i] = j; // used for reconstructing the subsequence } } if (D[i] &gt; max) { // maximum subsequence so far max = D[i]; } } return max; 5 Running Time: We’re doing two simple loops to fill arrays and . Therefore, our runtime is just 6 Example: Initially we start with arrays and : Consider again . We initialize to be representing the initial length of the subsequence ending at each possible . Iteration . We look at . We have and so the subsequence is just . Can 8 extend any previous subsequences? We look at and in that case, we see that , meaning that that the subsequence can now include 3 and become . And so now we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ Iteration . We look at . We have and so the subsequence is just . Can 4 extend any previous subsequences? We need to look at and . It turns out that 1 will not be able to extend either subsequence. $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ We continue doing so until we reach the end and we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$ This means that the longest subsequence ends at element 9 or 5. We can then to construct the subsequence. One possible construction will generate: 5 The O(nlg(n)) Solution with Binary Search: The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes! Previously, we said that is the length of the longest subsequence ending at . Now we will consider a completely different substructure. Let to be the smallest element that ends a subsequence of length . For simplicity we will initially let to be and everything else to be . Let’s take the same example where . In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have is . Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of , that must be sorted because this will help us later on. To prove that is sorted, we will prove that is a strictly increasing array and that for any , we have . (We will ignore the placeholder ’s otherwise the proof would not work)" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-25T12:01:36-07:00" />
<script type="application/ld+json">
{"description":"1 Introduction Let be an array containing real numbers. A longest increasing subsequence of A is a sequence such that so that is of maximum value. 2 Example Suppose then a longest increasing subsequence could be . Note that it is not unique. 3 The Brute Force Solution We can check every possible subsequence. For each element of , we either select that element or not. Therefore, the total number of possible subsequences is . As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is . 4 Dynamic Programming and the Optimal Substructure To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS). It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let be the length of the longest increasing subsequence ending at , then we will find that $$ \\begin{align*} D[i] = 1 + \\max({D[k] : k &lt; i \\text{ and } A[k] &lt; A[i]}) \\end{align*} $$ In other words, the longest increasing subsequence ending at can be found by looking at all where (meaning that comes before ) and (meaning that can extend the subsequence ending at ). We then taking the maximum value of , Proof: Let be a natural number and let be the length of the longest increasing subsequence ending at . Consider the subsequence ending at . We have two cases: Case 1: is the smallest element in . Therefore, the length of the subsequence ending at is 1. Case 2: is not the smallest element in . Let be a natural number where . This means that we can use to extend the subsequence ending at if . Since we are searching for the longest increasing subsequence then we take the maximum value for all possible and so is the maximum value plus 1 as defined above. We claim that is the length of longest increasing subsequence ending at . Suppose it wasn’t and that the longest increasing subsequence ending at is and so . By our definition, we know that where is the longest increasing subsequence ending at . This means that but this is not possible since we’re only adding to the subsequence. Therefore, is optimal. 3 The Implementation int D[n], p[n], max = 0; // maximum subsequence ending at a[i] is initially 1 for (int i = 0; i &lt; n; i++) { D[i] = 1; p[i] = -1; // parent array } // for element a[i], check all the previous subsequences where i &lt; j // and see if a[i] can extend any of them for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { if (A[i] &gt; A[j] &amp;&amp; D[i] &lt; D[j] + 1) { // I can extend the subsequence D[i] = D[j] + 1; p[i] = j; // used for reconstructing the subsequence } } if (D[i] &gt; max) { // maximum subsequence so far max = D[i]; } } return max; 5 Running Time: We’re doing two simple loops to fill arrays and . Therefore, our runtime is just 6 Example: Initially we start with arrays and : Consider again . We initialize to be representing the initial length of the subsequence ending at each possible . Iteration . We look at . We have and so the subsequence is just . Can 8 extend any previous subsequences? We look at and in that case, we see that , meaning that that the subsequence can now include 3 and become . And so now we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ Iteration . We look at . We have and so the subsequence is just . Can 4 extend any previous subsequences? We need to look at and . It turns out that 1 will not be able to extend either subsequence. $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ We continue doing so until we reach the end and we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$ This means that the longest subsequence ends at element 9 or 5. We can then to construct the subsequence. One possible construction will generate: 5 The O(nlg(n)) Solution with Binary Search: The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes! Previously, we said that is the length of the longest subsequence ending at . Now we will consider a completely different substructure. Let to be the smallest element that ends a subsequence of length . For simplicity we will initially let to be and everything else to be . Let’s take the same example where . In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have is . Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of , that must be sorted because this will help us later on. To prove that is sorted, we will prove that is a strictly increasing array and that for any , we have . (We will ignore the placeholder ’s otherwise the proof would not work)","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html","headline":"Longest Increasing Subsequence","dateModified":"2019-06-25T12:01:36-07:00","datePublished":"2019-06-25T12:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Longest Increasing Subsequence</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-06-25T12:01:36-07:00" itemprop="datePublished">Jun 25, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><b>1 Introduction</b>
<br />
Let <script type="math/tex">A = [a_0, a_1, a_2,...,a_n]</script> be an array containing <script type="math/tex">n</script> real numbers. A longest increasing subsequence of A is a sequence <script type="math/tex">0 \leq i_0 \leq i_1 \leq ... \leq i_k \leq n</script> such that <script type="math/tex">A[i_i] \leq A[i_2] \leq ... \leq A[i_k]</script> so that <script type="math/tex">k</script> is of maximum value.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------>
<b>2 Example</b>
<br />
Suppose <script type="math/tex">A = [3, 8, 1, 2, 7, 9, 6, 4, 5]</script> then a longest increasing subsequence could be <script type="math/tex">[1, 2, 4, 5]</script>. Note that it is not unique.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------>
<b>3 The Brute Force Solution</b>
<br />
We can check every possible subsequence. For each element of <script type="math/tex">A</script>, we either select that element or not. Therefore, the total number of possible subsequences is <script type="math/tex">2^n</script>. As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is <script type="math/tex">O(2^n)</script>.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------>
<b>4 Dynamic Programming and the Optimal Substructure</b>
<br />
To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS).<br />
<br />
It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let <script type="math/tex">D[i]</script> be the length of the longest increasing subsequence ending at <script type="math/tex">A[i]</script>, then we will find that</p>
<div center="">
$$
\begin{align*}
D[i] = 1 + \max({D[k] : k &lt; i \text{ and } A[k] &lt; A[i]})
\end{align*}
$$
</div>
<p>In other words, the longest increasing subsequence ending at <script type="math/tex">A[i]</script> can be found by looking at all <script type="math/tex">D[k]</script> where <script type="math/tex">% <![CDATA[
k < i %]]></script> (meaning that <script type="math/tex">A[k]</script> comes before <script type="math/tex">A[i]</script>) and <script type="math/tex">A[i] > A[k]</script> (meaning that <script type="math/tex">A[i]</script> can extend the subsequence ending at <script type="math/tex">A[k]</script>). We then taking the maximum value of <script type="math/tex">D[k]</script>, 
<br />
<br />
<b>Proof:</b><br />
Let <script type="math/tex">i</script> be a natural number and let <script type="math/tex">D[i]</script> be the length of the longest increasing subsequence ending at <script type="math/tex">A[i]</script>. Consider the subsequence ending at <script type="math/tex">A[i + 1]</script>. We have two cases:
<br />
<br />
Case 1: <script type="math/tex">A[i+1]</script> is the smallest element in <script type="math/tex">A[0...i+1]</script>. Therefore, the length of the subsequence ending at <script type="math/tex">A[i+1]</script> is 1.
<br />
<br />
Case 2: <script type="math/tex">A[i+1]</script> is not the smallest element in <script type="math/tex">A[0...i+1]</script>. Let <script type="math/tex">k</script> be a natural number where <script type="math/tex">% <![CDATA[
k < i+1 %]]></script>. This means that we can use <script type="math/tex">A[i+1]</script> to extend the subsequence ending at <script type="math/tex">A[k]</script> if <script type="math/tex">% <![CDATA[
A[k] < A[i + 1] %]]></script>. Since we are searching for the longest increasing subsequence then we take the maximum value for all possible <script type="math/tex">% <![CDATA[
k < i + 1 %]]></script> and so <script type="math/tex">D[i+1]</script> is the maximum value plus 1 as defined above.
<br />
<br />
We claim that <script type="math/tex">D[i+1]</script> is the length of longest increasing subsequence ending at <script type="math/tex">A[i+1]</script>. Suppose it wasn’t and that the longest increasing subsequence ending at <script type="math/tex">A[i+1]</script> is <script type="math/tex">m</script> and so <script type="math/tex">m > D[i+1]</script>. By our definition, we know that <script type="math/tex">D[i+1] = D[k] + 1</script> where <script type="math/tex">D[k]</script> is the longest increasing subsequence ending at <script type="math/tex">% <![CDATA[
k < i+1 %]]></script>. This means that <script type="math/tex">m > D[k]+1</script> but this is not possible since we’re only adding <script type="math/tex">A[i+1]</script> to the subsequence. Therefore, <script type="math/tex">D[i+1]</script> is optimal.
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------>
<b>3 The <script type="math/tex">O(n^2)</script> Implementation</b></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// maximum subsequence ending at a[i] is initially 1</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// parent array</span>
<span class="p">}</span>
<span class="c1">// for element a[i], check all the previous subsequences where i &lt; j</span>
<span class="c1">// and see if a[i] can extend any of them</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// I can extend the subsequence</span>
            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// used for reconstructing the subsequence</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// maximum subsequence so far</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">max</span><span class="p">;</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>5 Running Time:</b> 
<br />
We’re doing two simple loops to fill arrays <script type="math/tex">c</script> and <script type="math/tex">p</script>. Therefore, our runtime is just <script type="math/tex">O(n^2)</script>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>6 Example:</b> 
<br />
Initially we start with arrays <script type="math/tex">A</script> and <script type="math/tex">D</script>:
Consider again <script type="math/tex">A = [3, 8, 1, 2, 7, 9, 6, 4, 5]</script>. We initialize <script type="math/tex">D</script> to be <script type="math/tex">D = [1, 1, 1, 1, 1, 1, 1, 1, 1]</script> representing the initial length of the subsequence ending at each possible <script type="math/tex">A[i]</script>.
<br /><br />
Iteration <script type="math/tex">i = 1</script>. We look at <script type="math/tex">A[1] = 8</script>. We have <script type="math/tex">D[1]=1</script> and so the subsequence is just <script type="math/tex">\{8\}</script>. Can 8 extend any previous subsequences? We look at <script type="math/tex">j = 0</script> and in that case, we see that <script type="math/tex">A[1] > A[0]</script>, meaning that that the subsequence can now include 3 and become <script type="math/tex">\{3, 8\}</script>. And so now we have:</p>
<div center="">
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$
</div>
<p><br />
Iteration <script type="math/tex">i = 2</script>. We look at <script type="math/tex">A[2] = 1</script>. We have <script type="math/tex">D[2]=1</script> and so the subsequence is just <script type="math/tex">\{1\}</script>. Can 4 extend any previous subsequences? We need to look at <script type="math/tex">j = 0</script> and <script type="math/tex">j = 1</script>. It turns out that 1 will not be able to extend either subsequence.</p>
<div center="">
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$
</div>
<p><br />
We continue doing so until we reach the end and we have:</p>
<div center="">
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$
</div>
<p>This means that the longest subsequence ends at element 9 or 5. We can then <script type="math/tex">p</script> to construct the subsequence. One possible construction will generate: <script type="math/tex">[1, 2, 7, 9]</script>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>5 The O(nlg(n)) Solution with Binary Search:</b> 
<br />
The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes!
<br /><br />
Previously, we said that <script type="math/tex">D[i]</script> is the length of the longest subsequence ending at <script type="math/tex">A[i]</script>. Now we will consider a completely different substructure. Let <script type="math/tex">M[i]</script> to be the smallest element that ends a subsequence of length <script type="math/tex">i</script>. For simplicity we will initially let <script type="math/tex">M[0]</script> to be <script type="math/tex">-\infty</script> and everything else to be <script type="math/tex">\infty</script>. 
<br /><br />
Let’s take the same example where <script type="math/tex">A = [3, 8, 1, 2, 7, 9, 6, 4, 5]</script>. In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have <script type="math/tex">M</script> is <script type="math/tex">[-\infty, 1, 2, 4, 5, \infty, \infty, \infty, \infty]</script>.
<br /><br />
Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of <script type="math/tex">M</script>, that <script type="math/tex">M</script> must be sorted because this will help us later on. To prove that <script type="math/tex">M</script> is sorted, we will prove that <script type="math/tex">M</script> is a strictly increasing array and that for any <script type="math/tex">k</script>, we have <script type="math/tex">% <![CDATA[
M[k] < M[k+1] %]]></script>. (We will ignore the placeholder <script type="math/tex">\infty</script>’s otherwise the proof would not work)
<br /><br /></p>

<table>
  <tbody>
    <tr>
      <td>Claim: M is a strictly increasing array</td>
    </tr>
  </tbody>
</table>

<p><b>Proof:</b><br />
Suppose it is not and that there exists some <script type="math/tex">j</script> where either <script type="math/tex">M[j] = M[j+1]</script> or <script type="math/tex">M[j] > M[j+1]</script>. We will prove neither case is possible.
<br /><br />
First, suppose that <script type="math/tex">M[j] = M[j+1]</script> then this means that we have two strictly increasing subsequences that end in <script type="math/tex">M[j]</script>. Let the first subsequence be <script type="math/tex">\{a_1, a_2,...a_n,M[j]\}</script> of length <script type="math/tex">j</script> and let the second subsequence be <script type="math/tex">\{b_1,b_2,..,b_m,M[j]\}</script> of length <script type="math/tex">j+1</script> and so <script type="math/tex">m = n + 1</script>. Since this is a strictly increasing subsequence, we must have <script type="math/tex">% <![CDATA[
b_m < M[j] %]]></script>. This is a contradiction because by assumption we know that <script type="math/tex">M[j]</script> is the smallest element that ends a subsequence of length <script type="math/tex">j</script> but we just showed that there exists a subsequence, namely, <script type="math/tex">\{b_1,b_2,..,b_m\}</script>, of length <script type="math/tex">j</script> that ends with a smaller element, <script type="math/tex">% <![CDATA[
b_m < M[j] %]]></script>.
<br /><br />
Next, suppose that <script type="math/tex">M[j] > M[j+1]</script>. This is a contradiction for the same reasons above. Let <script type="math/tex">a</script> be the subsequence of length <script type="math/tex">j</script> that ends with <script type="math/tex">M[j]</script> and if we let <script type="math/tex">b</script> the subsequence of length <script type="math/tex">j+1</script> that ends with M[j+1]. Since subsequences are strictly increasing then we can extract all the elements from <script type="math/tex">b</script> except for <script type="math/tex">M[j+1]</script>. This new sequence ends with an element strictly less than <script type="math/tex">M[j]</script> and therefore, we arrive at the same contradiction and conclude that it is not possible.
<br /><br />
Therefore, we can conclude that we must have <script type="math/tex">% <![CDATA[
M[k] < M[k+1] %]]></script> for all <script type="math/tex">k</script> as we wanted to show.
<!-- -->
<br /><br />
<b>Algorithm:</b><br />
Let’s traverse <script type="math/tex">A</script> from left to right. For the base case, we consider <script type="math/tex">i = 0</script> and at this point we know that <script type="math/tex">A[0] > -\infty</script> and so <script type="math/tex">M[1] = A[0]</script>.
<br /><br />
Now let’s consider iteration <script type="math/tex">i</script> and element <script type="math/tex">A[i]</script>. Also, let <script type="math/tex">k</script> be the length of the longest subsequence reached so far, meaning that <script type="math/tex">M[k] \neq \infty</script> and for any <script type="math/tex">j > k</script> we have <script type="math/tex">M[j] = \infty</script>. Let’s consider two cases:
<br /><br />
Case 1: <script type="math/tex">A[i] > M[k]</script>. In this case, we see that it is possible to extend the subsequence ending with element <script type="math/tex">M[k]</script> because <script type="math/tex">A[i]</script> is greater, yay! Now we can set <script type="math/tex">M[k+1] = A[i]</script> and we are done. (But why? don’t we need to check previous subsequences in <script type="math/tex">M</script>? No. Proof: We established previously that <script type="math/tex">M</script> is sorted and so if <script type="math/tex">A[i] > M[k]</script> then <script type="math/tex">A[i] > M[j]</script> for <script type="math/tex">j \leq k</script>. This means that <script type="math/tex">A[i]</script> is not a possible candidate for replacing any of the previous elements because <script type="math/tex">M</script> holds ONLY the minimum possible elements that end each subsequence.)
<br /><br />
Case 2: <script type="math/tex">% <![CDATA[
A[i] < M[k] %]]></script>. This one is tricky. In this case <script type="math/tex">A[i]</script> can’t extend the current subsequence of length <script type="math/tex">k</script> but it can potentially be a better candidate for ending some subsequence of length <script type="math/tex">1,...,k</script>. Recall that <script type="math/tex">M</script> is sorted and is a strictly increasing array. Let <script type="math/tex">j</script> be natural number where <script type="math/tex">j \leq k</script> and <script type="math/tex">M[j]</script> is the smallest element such that <script type="math/tex">% <![CDATA[
A[i] < M[j] %]]></script>. (Note that it might be that <script type="math/tex">j = k</script>). By our construction, this means that <script type="math/tex">A[i] > M[j-1]</script>. (Note that it might be that j-1 = 0). This means that we can take the subsequence of length <script type="math/tex">j-1</script> ending with <script type="math/tex">M[j-1]</script> and end it instead with <script type="math/tex">A[i]</script>, making a new subsequence of length <script type="math/tex">j</script> that has a smaller ending value! So it safe to replace <script type="math/tex">M[j]</script> with <script type="math/tex">A[j]</script>. This is where binary search comes in! since <script type="math/tex">M</script> is sorted, we find this position in just <script type="math/tex">O(\log(n))</script>.
<br /><br />
Could we replace the end of any other subsequence? No. Even though <script type="math/tex">% <![CDATA[
A[i] < M[j] %]]></script> for all <script type="math/tex">j..k</script>, only <script type="math/tex">M[j]</script> can be replaced because <script type="math/tex">A[i] > M[j-1]</script>. Any subsequence of length greater than <script type="math/tex">j</script> already has more elements than just <script type="math/tex">j</script> so <script type="math/tex">A[i]</script> could not end these subsequences. (more formal?)
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------>
<b>3 The <script type="math/tex">O(n\log(n))</script> Implementation</b></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">D</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="c1">// maximum subsequence ending at a[i] is initially 1</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// parent array</span>
<span class="p">}</span>
<span class="c1">// for element a[i], check all the previous subsequences where i &lt; j</span>
<span class="c1">// and see if a[i] can extend any of them</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// I can extend the subsequence</span>
            <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span> <span class="c1">// used for reconstructing the subsequence</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// maximum subsequence so far</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">return</span> <span class="n">max</span><span class="p">;</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
<br /></p>
<hr />

<p><br />
<b>Full Implementation: </b><br /></p>

<!------------------------------------------------------------------------------------>
<p><br /></p>
<hr />

<p><br />
<b>References: </b><br />
These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html and CLRS.</p>


  </div><a class="u-url" href="/jekyll/update/2019/06/25/longest-increasing-subsequence.html" hidden></a>
</article>

      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello.</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
