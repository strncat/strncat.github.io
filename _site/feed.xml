<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-09-05T11:16:27-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Conditional Probability</title><link href="http://localhost:4000/jekyll/update/2019/08/29/conditional-probability.html" rel="alternate" type="text/html" title="Conditional Probability" /><published>2019-08-29T07:01:36-07:00</published><updated>2019-08-29T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/29/conditional-probability</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/29/conditional-probability.html">&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
(1) My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/&lt;br /&gt;
(2) First Course in Probability by Sheldon Ross.
&lt;br /&gt;
&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Conditional Probability&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/condprob/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Conditional probability is the probability that event &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; occurs given that event &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; has already occured written as &lt;script type=&quot;math/tex&quot;&gt;P(E|F)&lt;/script&gt;. In this case:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;b&gt;sample space&lt;/b&gt; consists of all possible outcomes consistent with &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; (events in &lt;script type=&quot;math/tex&quot;&gt;S \cap F&lt;/script&gt;).&lt;/li&gt;
  &lt;li&gt;The &lt;b&gt;event space&lt;/b&gt; consists of all possible outcomes in &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; that are consistent with &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; (events in &lt;script type=&quot;math/tex&quot;&gt;E \cap F&lt;/script&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefore, we have in general&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E|F) = \frac{p(E \cap F)}{p(F)} = \frac{p(EF)}{p(F)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And for equally likely outcomes:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E|F) = \frac{|EF|}{|F|} = \frac{|EF|/|S|}{|F|/|S|} = \frac{p(EF)}{p(F)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Chain Rule&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
From the conditional probability law, we can derive the chain rule!&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(EF) = P(E|F)P(F) = P(F|E)P(E)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And in general if we have multiple events:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E_1E_2...E_n) = P(E_1)P(E_2|E_1)...P(E_n|E_1E_2...E_{n-1})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
Suppose we have an urn with 8 red balls and 4 white balls. What is the probability of choosing two balls that are both red (without replacement). (Source: A First Course in Probability)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E_1&lt;/script&gt; to be the event that the first ball is red. &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E_2&lt;/script&gt; to be the event that the second ball is red. &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E_1E_2) = P(E_1)P(E_2|E_1) = \frac{8}{12}\frac{7}{11} = \frac{14}{33}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Law of Total Probability&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E) &amp;amp;= P(EF) + P(EF^c) \\
P(E) &amp;amp;= P(F)P(E|F) + P(F^c)P(E|F^c) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In general:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E) &amp;amp;= \sum_i^n P(F_i)P(E|F_i)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The law of total probability says that the probability of event &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; is now a weighted average of the conditional probability of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; given event &lt;script type=&quot;math/tex&quot;&gt;F_1&lt;/script&gt; plus the conditional probability of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; given event &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt; and so on. Note that these events &lt;script type=&quot;math/tex&quot;&gt;F_i&lt;/script&gt; must be mutually exclusive. Moreover, &lt;script type=&quot;math/tex&quot;&gt;\sum_iP(F_i) = 1&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
Suppose 25% of students are juniors. Suppose now that if a student is a junior then the probability of being a CS major is 30%, while if a student is not a junior then the probability of being a CS major is 20%. What is the probability of being a CS major? (Class Example)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;CS&lt;/script&gt; to be the event that a student is a CS major. &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;J&lt;/script&gt; to be the event that a student is a junior. &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(CS) &amp;amp;= P(CS | J)P(J) + P(CS | J^c)P(J^c) \\
&amp;amp;= 0.30*0.25 + 0.20*0.75 = 0.225
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Bayes' Theorem&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Common Form:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Expanded Form:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E|F)P(F) + P(E|F^c)P(F^c)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
A test is 98% effective at detecting HIV. The test has a false positive rate of 1%. 0.5% of the US population has HIV. What is the probability that you have HIV given that you tested positive? (class example)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; be that you test positive for HIV with the test&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; be that you actually have HIV. &lt;br /&gt;
We want to find &lt;script type=&quot;math/tex&quot;&gt;P(F|E)&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
First, the probability that the test is positive given that you actually have HIV is 0.98 (true positive). In terms of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;, this is &lt;script type=&quot;math/tex&quot;&gt;P(E|F)=0.98&lt;/script&gt;. Similarly, the probability that we get a false positive is 0.01. In terms of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;, this probability is &lt;script type=&quot;math/tex&quot;&gt;P(E|F^c)&lt;/script&gt;,&lt;/p&gt;

&lt;p&gt;We can now use Bayes’&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E|F)P(F) + P(E|F^c)P(F^c)} \\
&amp;amp;= \frac{(0.98)(0.005)}{(0.98)(0.005) + (0.01)(0.995)} = 0.330
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;The Monty Hall Problem x1000&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have 3 doors. Behind one of the three doors a prize. We choose a door. The host then opens one of the remaining doors that reveals nothing. We are now given the chance to switch our door with the remaining door. Do we switch?
&lt;br /&gt;
&lt;br /&gt;
We want to compare &lt;script type=&quot;math/tex&quot;&gt;P(win)&lt;/script&gt; vs &lt;script type=&quot;math/tex&quot;&gt;P(win|switch)&lt;/script&gt;. We know that if stick with our door, &lt;script type=&quot;math/tex&quot;&gt;P(win)=1/3&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Suppose without the loss of generality that we picked door &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. What is the probability that we win given that we switched? Let’s consider what happens if we switch in each case. 
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;A, B&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; be the events that the prize is behind each door respectively. All three doors are equally likely and so each door has a probability of &lt;script type=&quot;math/tex&quot;&gt;1/3&lt;/script&gt;. Moreover, these events are mutually exlusive since the prize can be behind exactly one door. Also the probability of these events sum up to 1. 
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;:&lt;br /&gt;
In this case the host will open either door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. We will switch and lose. So, &lt;script type=&quot;math/tex&quot;&gt;P(win | \text {switch to B/C}) = 0&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;:&lt;br /&gt;
In this case the host will open door &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. We switch and we win! &lt;script type=&quot;math/tex&quot;&gt;P(win| \text {switch to C})=1&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;:&lt;br /&gt;
In this case the host will open door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. We switch and we win! &lt;script type=&quot;math/tex&quot;&gt;P(win| \text {switch to B})=1&lt;/script&gt;.
&lt;br /&gt;
Using the law of total probability:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(win|switch) &amp;amp;= p(win|\text{switch to A})*P(A) + P(win| \text{switch to B}) + P(win | \text{switch to C})P(C) \\
&amp;amp;= 0(1/3) + 1(1/3) + 1(1/3) = 2/3
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References (1) My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ (2) First Course in Probability by Sheldon Ross. Conditional Probability Conditional probability is the probability that event occurs given that event has already occured written as . In this case: The sample space consists of all possible outcomes consistent with (events in ). The event space consists of all possible outcomes in that are consistent with (events in ).</summary></entry><entry><title type="html">Karger’s Minimum Cut</title><link href="http://localhost:4000/jekyll/update/2019/08/28/min-cut.html" rel="alternate" type="text/html" title="Karger's Minimum Cut" /><published>2019-08-28T03:01:36-07:00</published><updated>2019-08-28T03:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/28/min-cut</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/28/min-cut.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/mincut/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
class notes from following:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs161/schedule.html&lt;/li&gt;
  &lt;li&gt;https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/11/Small11.pdf&lt;/li&gt;
  &lt;li&gt;http://web.stanford.edu/class/archive/cs/cs161/cs161.1172/CS161Lecture16.pdf&lt;/li&gt;
  &lt;li&gt;Algorithm Design (BEST BOOK)
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Introduction&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be an undirected graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. A cut in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a partition of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; into two non-empty sets of vertices &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. The &lt;b&gt;size&lt;/b&gt; of the cut is the number of edges with one end point in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and another in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. A &lt;b&gt;global minimum cut&lt;/b&gt; is a cut of minimum size.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Krager's Algorithm&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Krager’s algorithm starts with picking an edge &lt;script type=&quot;math/tex&quot;&gt;(u,v)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; uniformly at random. It then &lt;b&gt;contracts&lt;/b&gt; this edge by creating a new node &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; that combines both &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. All the edges in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with an end point equal to either &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; now point to &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; instead. Also, any edge between &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is deleted. It repeatedly contracts randomly picked edges until we have two vertices in the graph. We then return the number of edges between the two vertices as the global minimum cut in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Karger's Algorithm Pseudocode&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;karger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Initially&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uniformly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sets&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Example&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we apply the contraction algorithm on the above graph. We start by picking an edge uniformly at random. Suppose we picked the edge &lt;script type=&quot;math/tex&quot;&gt;(d,e)&lt;/script&gt; below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/2.png&quot; width=&quot;100%&quot; /&gt;
We then delete &lt;script type=&quot;math/tex&quot;&gt;(d,e)&lt;/script&gt;. We create a new node &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;. We then point any edge that previously had an end point equal to &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; to point at &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/mincut/3.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/4.png&quot; width=&quot;100%&quot; /&gt;
We delete &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; and create node &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; and fix all the old edges pointing at &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; to point at &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/mincut/5.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(f,g)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/6.png&quot; width=&quot;100%&quot; /&gt;
We’ll repeat the same process by creating &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and fixing the edges below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/7.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(z,x)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/8.png&quot; width=&quot;100%&quot; /&gt;
We’ll again delete the edge, create a new node &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; and fix all the edges below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/9.png&quot; width=&quot;100%&quot; /&gt;
Finally, suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(y,c)&lt;/script&gt; and repeat the same steps. 
&lt;img src=&quot;http://localhost:4000/assets/mincut/10.png&quot; width=&quot;100%&quot; /&gt;
Since we only have 2 vertices then we’re done. We will return the number of edges between the two vertices which is 1 in this case. So the global minimum cut is of size 1 which is correct for this graph.
&lt;img src=&quot;http://localhost:4000/assets/mincut/11.png&quot; width=&quot;100%&quot; /&gt;
Suppose however that instead of picking &lt;script type=&quot;math/tex&quot;&gt;(y,c)&lt;/script&gt; to contract, we picked &lt;script type=&quot;math/tex&quot;&gt;(y,w)&lt;/script&gt;
&lt;img src=&quot;http://localhost:4000/assets/mincut/10a.png&quot; width=&quot;100%&quot; /&gt;
We will end up with a global minimum cut of size 2 instead which is not correct for this graph! This is why Krager’s algorithm is a Monte Carlo algorithm.
&lt;img src=&quot;http://localhost:4000/assets/mincut/11a.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;What is the probability of getting a correct answer?&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have a graph &lt;script type=&quot;math/tex&quot;&gt;G=(E,V)&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; nodes and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges. Suppose the cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt; is a global minimum cut is of size &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. Also let &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; to be the set of &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; edges in the cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt;. So &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; has the edges that have one end point in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and the other end point in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
The probability that the contraction algorithm succeeds is the probability that we don’t make any mistake in the &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; iterations of the algorithm. Suppose we let &lt;script type=&quot;math/tex&quot;&gt;S_i&lt;/script&gt; to be the event that we don’t make a mistake in step &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; or generally succeed in step &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. We want to calculate the following probability:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(success) = Pr(S_1 \cap S_2 \cap S_3 \cap ... \cap S_{n-2})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;These events are not independent! We can further expand this using the chain rule and instead calculate:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(success) = Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-2} | S_1 \cap S_2 \cap ... \cap S_{n-3})
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Success in the iteration 1:&lt;/b&gt;&lt;br /&gt;
Let’s look at how we can calculate each of these. What does it mean to not make a mistake in step 1? It means that we don’t pick an edge that connects a vertex from the set &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to a vertex from the set &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. Because if we did, then &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; will be merged together and we will not be able to return the global minimum cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt;. So we basically want to avoid picking edges from &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;. Therefore, the probability that we don’t make a mistake in step 1 is
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_1) = 1 - \frac{|F|}{|E|} = 1 - \frac{k}{|E|}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;What is &lt;script type=&quot;math/tex&quot;&gt;|E|&lt;/script&gt;? &lt;br /&gt;
We will use &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; to find an upper bound on &lt;script type=&quot;math/tex&quot;&gt;|E|&lt;/script&gt;. We know that the global minimum cut is of size &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;, therefore, we must have:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;For any node &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;degree(v) \geq k&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof: Suppose not, then there exists some node &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
degree(u) &lt; k %]]&gt;&lt;/script&gt;. Pick the minimum cut such that &lt;script type=&quot;math/tex&quot;&gt;A = \{u\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = V - \{u\}&lt;/script&gt;. The cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt; is a global minimum cut of size less than &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; which is a contradiction. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
Based on this, we can conclude that &lt;script type=&quot;math/tex&quot;&gt;|E| \geq \frac{1}{2}kn&lt;/script&gt;. (&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2}&lt;/script&gt; because &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is undirected).
&lt;br /&gt;
&lt;br /&gt;
So now we have:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_1) = 1 - \frac{|F|}{|E|} \geq 1 - \frac{2k}{kn} = 1 - \frac{2}{n}.
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Success in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;:&lt;/b&gt;&lt;br /&gt;
What about the other iterations? What is the probability that we don’t make a mistake in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; given that we haven’t made any mistake in all the previous interations? At iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;n-i&lt;/script&gt; nodes in the graph. Since we haven’t made any mistake yet, we still have &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; edges in &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; and each node is of degree at least &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; (same proof as before). Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_{i+1} | S_1 \cap S_2 \cap ... \cap S_i) \geq 1 - \frac{k}{1/2k(n-j)} = 1 - \frac{2}{n-j}.
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Now we can combine everything together:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\require{cancel}
\begin{align*}
Pr(success) &amp;amp;= Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-2} | S_1 \cap S_2 \cap ... \cap S_{n-3}) \\
&amp;amp;\geq \big(1 - \frac{2}{n}\big)\big(1 - \frac{2}{n-1}\big)...\big(1-\frac{2}{n-j}\big)...\big(1-\frac{2}{3}\big) \\
&amp;amp;= \big(\frac{n-2}{n}\big)\big(\frac{n-3}{n-1}\big)\big(\frac{n-4}{n-2}\big)...\big(\frac{3}{5}\big)\big(\frac{2}{4}\big)\big(\frac{1}{3}\big) \\
&amp;amp;= \big(\frac{\bcancel{n-2}}{n}\big)\big(\frac{\bcancel{n-3}}{n-1}\big)\big(\frac{\bcancel{n-4}}{\bcancel{n-2}}\big)...\big(\frac{\bcancel{3}}{\bcancel{5}}\big)\big(\frac{2}{\bcancel{4}}\big)\big(\frac{1}{\bcancel{3}}\big) \\
&amp;amp;= \frac{2}{n(n-1)}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Can we do better?&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
The probability of success, &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, we found so far is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p &amp;amp;\geq \frac{2}{n(n-1)} = \frac{1}{\binom{n}{2}}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Suppose we run &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; trials of Krager’s algorithm. We then take the minimum cut of all cuts found. These trials are independent. What is the probability of NOT getting the global minimum cut? It is the probability of failing in every trial. Let &lt;script type=&quot;math/tex&quot;&gt;F_i&lt;/script&gt; be the event that we failed to find the global minimum cut in iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(\text{Failure after } T \text{ trials}) &amp;amp;= Pr(F_1 \cap F_2 \cap ... \cap F_T) \\
&amp;amp;= Pr(F_1)Pr(F_2)...Pr(F_T) \text{  (by independence)}\\
&amp;amp;\leq \big(1-\frac{2}{n(n-1)} \big)^{T} \\
&amp;amp;= \big(1-\frac{1}{\binom{n}{2}} \big)^{T}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We also know that for any &lt;script type=&quot;math/tex&quot;&gt;x \geq 1&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\big (1-\frac{1}{x} \big)^x \leq \frac{1}{e}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Suppose we let &lt;script type=&quot;math/tex&quot;&gt;x = \frac{1}{p}&lt;/script&gt;, we see that&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
\big(1-\frac{1}{\binom{n}{2}} \big)^{\binom{n}{2}} \leq \frac{1}{e}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is exactly our expression above with &lt;script type=&quot;math/tex&quot;&gt;T = \binom{n}{2}&lt;/script&gt;. Furthermore, we can let &lt;script type=&quot;math/tex&quot;&gt;T = \ln(n)\binom{n}{2}&lt;/script&gt; to get&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
P(\text{Failure}) \leq \big(1-\frac{1}{\binom{n}{2}} \big)^{\ln(n)\binom{n}{2}} \leq \frac{1}{e}^{\ln(n)} = \frac{1}{n}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In general, if we want the probability of failure to be at most &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; then we need to set &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\ln(1/\delta)\frac{1}{p}&lt;/script&gt; in&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{Failure}) &amp;amp;\leq \big(1-p\big)^{T} \leq \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is because&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{Failure}) &amp;amp;\leq \big(1-p\big)^{\ln(1/\delta)\frac{1}{p}} \leq \frac{1}{e}^{\ln(1/\delta)} = \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Running Time&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; nodes and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges. In the naive implementation, we contract &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; edges until we reach a graph with 2 vertices. Every time we contract an edge, we need to create a new node and also correct all the edges connected to either end of the contracted edge. This could take &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. Therefore, the total running time is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. There are other faster implementations with union-find data structure that reduce the running time to &lt;script type=&quot;math/tex&quot;&gt;O(m * \alpha(n))&lt;/script&gt;. (TODO: More on this?)
&lt;br /&gt;
&lt;br /&gt;
Given that we can get a high success probability if we run Krager’s algorithm for &lt;script type=&quot;math/tex&quot;&gt;O(\log(n)n^2)&lt;/script&gt;. The total running time is therefore &lt;script type=&quot;math/tex&quot;&gt;O(n^4\log(n))&lt;/script&gt;!
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Karger - Stein&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Can we do better than &lt;script type=&quot;math/tex&quot;&gt;O(n^4\log(n))&lt;/script&gt; and still maintain a high success probability? Krager and Stein published an improved result that’s much faster! 
&lt;br /&gt;
&lt;br /&gt;
Observe when running Krager’s algorithm is that the probability of picking the wrong edge (an edge from the edges crossing the cut, the set &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;) gets higher with every iteration. Therefore, we should really just run karger once in the first few iterations and then repeat Karger for the remaining nodes. 
&lt;br /&gt;
&lt;br /&gt;
This is what Karger-Stein’s algorithm is doing. We contract edges until we get &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. We then make copies of the graph and independently contract the edges again for each graph until we get to &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}/\sqrt{2}&lt;/script&gt;. We then return the minimum of both cuts. We repeat this process again until we reach 4 vertices and simply find the minimum cut by brute force. This is illustrated in the below graph:
&lt;img src=&quot;http://localhost:4000/assets/mincut/stein.png&quot; width=&quot;100%&quot; /&gt;
We also summarize it in the following pseudo-code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;brute&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Karger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cut1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cut2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minmum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Karger - Stein Running Time&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Karger-Stein is a recursive algorithm. At each level of the recursion, we perform Karger on &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; until we reach &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. Karger runs in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. Therefore, we have the following recurrence for the running time:&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
T(n) = 2T(n/\sqrt{2}) + O(n^2)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And therefore, the running time is &lt;script type=&quot;math/tex&quot;&gt;O(n^2\log(n))&lt;/script&gt; by the master theorem.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Karger - Stein Probability of Success&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Karger-Stein first contracts the graph from &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; vertices down to &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. Similar to the analysis we did earlier. The probability of success is the probability of not picking the wrong edges in any of the first &lt;script type=&quot;math/tex&quot;&gt;n-n/\sqrt{2}&lt;/script&gt; iterations. Therefore, combining all probabilities:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\require{cancel}
\begin{align*}
Pr(\text{success until } n/\sqrt{2}) &amp;amp;= Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-n\sqrt{2}} | S_1 \cap S_2 \cap ... \cap S_{n-n/\sqrt{2}}) \\
&amp;amp;\geq \big(1 - \frac{2}{n}\big)\big(1 - \frac{2}{n-1}\big)...\big(1-\frac{2}{n-j}\big)...\big(1-\frac{2}{n/\sqrt{2}+1}\big) \\
&amp;amp;= \big(\frac{n-2}{n}\big)\big(\frac{n-3}{n-1}\big)\big(\frac{n-4}{n-2}\big)...\big(\frac{n/\sqrt{2}}{n/\sqrt{2}+2}\big)\big(\frac{n/\sqrt{2}-1}{n/\sqrt{2}+1}\big) \\
&amp;amp;= \big(\frac{\bcancel{n-2}}{n}\big)\big(\frac{\bcancel{n-3}}{n-1}\big)\big(\frac{\bcancel{n-4}}{\bcancel{n-2}}\big)...\big(\frac{n/\sqrt{2}}{\bcancel{n/\sqrt{2}+2}}\big)\big(\frac{n/\sqrt{2}-1}{\bcancel{n/\sqrt{2}+1}}\big) \\
&amp;amp;= \frac{n/\sqrt{2}(n/\sqrt{2}-1)}{n(n-1)} \\
&amp;amp;= \frac{n(n-\sqrt{2})}{2n(n-1)} = \frac{n-\sqrt{2}}{2(n-1)} \approx \frac{1}{2}. \text{ (when n is large)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;If represent these probabilities with a binary tree then we know at each step we have a probability of &lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt; of picking the right path down to a leaf. Since we’re dividing by &lt;script type=&quot;math/tex&quot;&gt;\sqrt{2}&lt;/script&gt;, then we know that the depth of the tree is&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
\log_{\sqrt{2}}(n) = \frac{\log(n)}{\log(\sqrt{2})} = 2\log(n)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And the number of leaves is&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
2^{2\log(n)} = O(n^2)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;To find the overall probability of success, we need to find the probability of picking the right path from the root down to a leaf. Picking the right path means that at every step we pick the right edge. Suppose &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a vertex in this tree and let &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; be the height of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;p_d&lt;/script&gt; be the probability that there exists a path of surviving edges from &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; down to a leaf. Let &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; be the event that there exists a path of surviving edges in the left subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; be the event that there exists a path of surviving edges in the right subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We see that&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
p_d &amp;amp;= \frac{1}{2} * Pr(\text{there is at least one subtree with surviving edges}) \\
&amp;amp;= \frac{1}{2} * Pr(L \cup R) \\
&amp;amp;= \frac{1}{2} * (Pr(R) + Pr(L) - Pr(R \cap L)) \\
&amp;amp;= \frac{1}{2} * (Pr(R) + Pr(L) - Pr(R \cap L)) \\
&amp;amp;= \frac{1}{2} * (p_{d-1} + p_{d-1} - p_{d-1}^2) \\
&amp;amp;= p_{d-1} - \frac{1}{2}p_{d-1}^2 \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The claim is that &lt;script type=&quot;math/tex&quot;&gt;p_d \geq \frac{1}{d+1}&lt;/script&gt;. To see this, we need to prove this by induction by &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; for &lt;script type=&quot;math/tex&quot;&gt;d &gt; 0&lt;/script&gt;. 
&lt;br /&gt;
For the base case, the probability of finding a path of surviving edges when the height is 0 is 1. We also see that &lt;script type=&quot;math/tex&quot;&gt;p_0 \geq \frac{1}{0+1} = 1&lt;/script&gt; as we wanted to show.
&lt;br /&gt;
&lt;br /&gt;
For the inductive hypothesis, suppose it holds for &lt;script type=&quot;math/tex&quot;&gt;d-1&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;p_{d-1} \geq \frac{1}{d}&lt;/script&gt;. We will prove that it holds for &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;.&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
p_d &amp;amp;= p_{d-1} - \frac{1}{2}p_{d-1}^2 \\
&amp;amp;\geq \frac{1}{d} - \frac{1}{2}\frac{1}{d^2} \\
&amp;amp;\geq \frac{1}{d} - \frac{1}{d(d+1)} \quad \text{(} 1/d(d+1) \text{ is strictly greater than } 1/2d^2 \text { for } d \geq 1 \text{)} \\
&amp;amp;= \frac{1}{d+1}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Side Note: I don’t know how I would come up with replacing &lt;script type=&quot;math/tex&quot;&gt;1/d^2&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;1/d(d+1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Finally since the root of the tree has depth &lt;script type=&quot;math/tex&quot;&gt;2\log(n)&lt;/script&gt;, then we know that the probability of success is at least &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2\log(n)+1}&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#EAFAF1; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Karger - Stein Improved Success Rate&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
But how many trials do we need in order to achieve the same success rate as Karger’s original algorithm (with repetition)? We know the probability of success is at least &lt;script type=&quot;math/tex&quot;&gt;p = \frac{1}{2\log(n)+1}&lt;/script&gt;. The probability of failing in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; trials (trials are independent) is the following if we set &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\ln(1/\delta)\frac{1}{p}&lt;/script&gt;&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{failure in }T \text{ trials}) &amp;amp;= (1 - p)^T \leq \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We arrived at this in the previous analysis of Karger’s algorithm. Therefore, we set &lt;script type=&quot;math/tex&quot;&gt;T = (2\log(n)+1)\ln(1/n)&lt;/script&gt; to get a probablity of failure to be at most &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{n}&lt;/script&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">References class notes from following: http://web.stanford.edu/class/cs161/schedule.html https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/11/Small11.pdf http://web.stanford.edu/class/archive/cs/cs161/cs161.1172/CS161Lecture16.pdf Algorithm Design (BEST BOOK) Introduction Let be an undirected graph with vertices and edges. A cut in is a partition of into two non-empty sets of vertices and . The size of the cut is the number of edges with one end point in and another in . A global minimum cut is a cut of minimum size. Krager's Algorithm Krager’s algorithm starts with picking an edge in uniformly at random. It then contracts this edge by creating a new node that combines both and . All the edges in with an end point equal to either and now point to instead. Also, any edge between and is deleted. It repeatedly contracts randomly picked edges until we have two vertices in the graph. We then return the number of edges between the two vertices as the global minimum cut in . Karger's Algorithm Pseudocode void karger(graph&amp;amp; g) { Initially create a set for each node v, S(v) = {v} while (G has more than two nodes) { choose an edge e=(u,v) uniformly at random. create a new node w with S(w) = S(u) union S(v) } return the sets of the last two nodes. } Example Suppose we apply the contraction algorithm on the above graph. We start by picking an edge uniformly at random. Suppose we picked the edge below: We then delete . We create a new node . We then point any edge that previously had an end point equal to or to point at . Suppose we pick next. We delete and create node and fix all the old edges pointing at or to point at . Suppose we pick next. We’ll repeat the same process by creating and fixing the edges below: Suppose we pick next. We’ll again delete the edge, create a new node and fix all the edges below: Finally, suppose we pick and repeat the same steps. Since we only have 2 vertices then we’re done. We will return the number of edges between the two vertices which is 1 in this case. So the global minimum cut is of size 1 which is correct for this graph. Suppose however that instead of picking to contract, we picked We will end up with a global minimum cut of size 2 instead which is not correct for this graph! This is why Krager’s algorithm is a Monte Carlo algorithm. What is the probability of getting a correct answer? Suppose we have a graph with nodes and edges. Suppose the cut is a global minimum cut is of size . Also let to be the set of edges in the cut . So has the edges that have one end point in and the other end point in . The probability that the contraction algorithm succeeds is the probability that we don’t make any mistake in the iterations of the algorithm. Suppose we let to be the event that we don’t make a mistake in step or generally succeed in step . We want to calculate the following probability: $$ \begin{align*} Pr(success) = Pr(S_1 \cap S_2 \cap S_3 \cap ... \cap S_{n-2}) \end{align*} $$ These events are not independent! We can further expand this using the chain rule and instead calculate: $$ \begin{align*} Pr(success) = Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-2} | S_1 \cap S_2 \cap ... \cap S_{n-3}) \end{align*} $$ Success in the iteration 1: Let’s look at how we can calculate each of these. What does it mean to not make a mistake in step 1? It means that we don’t pick an edge that connects a vertex from the set to a vertex from the set . Because if we did, then and will be merged together and we will not be able to return the global minimum cut . So we basically want to avoid picking edges from . Therefore, the probability that we don’t make a mistake in step 1 is $$ \begin{align*} Pr(S_1) = 1 - \frac{|F|}{|E|} = 1 - \frac{k}{|E|}. \end{align*} $$ What is ? We will use to find an upper bound on . We know that the global minimum cut is of size , therefore, we must have:</summary></entry><entry><title type="html">Discrete Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html" rel="alternate" type="text/html" title="Discrete Random Variables" /><published>2019-08-25T07:01:36-07:00</published><updated>2019-08-25T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html">&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;0 References&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Indicator/Bernoulli Random Variable&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; for success and &lt;script type=&quot;math/tex&quot;&gt;1-p&lt;/script&gt; for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
X = \Big\{ \begin{array}{@{}lr@{}}
        1 \quad \text{If even A occurs } \\
        0 \quad \text{otherwise} \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1\}&lt;/script&gt;. Let’s look at the PMF of &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;. Remember that the PMF of a random variable is just the probability that this random variable takes on a value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;R_x&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}}
        p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\
        p(0) = 1 - P(A) \quad \text{if } x = 0 \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;What the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;? Recall that the expected value of a discrete random variable is defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = p(1)*1 + p(0)*0 = p(1) = P(A)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Binomial Random Variable&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;If we on the other hand have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; independent trials of Bernoulli random variables with a probability of success &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can use a binomial random variable to represent the number of successes in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. For example, if we are flipping a coin with probability of getting heads (success) equals to &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can define a binomial random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to represent the number of heads in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. 
&lt;br /&gt;
&lt;br /&gt;
Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt; and the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The expected value, variance and second moment of a binomial random variable:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= np \\
Var(X) &amp;amp;= np(1-p) \\
E[X^2] &amp;amp;= n^2p^2 - np^2 + np
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Poisson Random Variable&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Consider a duration of time where events occur at an average rate of &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt; (number of occurrences per unit time). Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of occurrences in a unit of time. We have &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt; and the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The expected value, variance and second moment of a binomial random variable:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = np \\
Var(X) = np(1-p) \\
E[X^2] = n^2p^2 - np^2 + np
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt; Example 1: &lt;/b&gt;&lt;br /&gt;
Given a web server, suppose that the server load averages 2 hits per second. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of hits received in a second. What is &lt;script type=&quot;math/tex&quot;&gt;P(X=5)?&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;Binomial and Poisson Random Variables&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; be very large and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; very small. Let &lt;script type=&quot;math/tex&quot;&gt;\lambda = np&lt;/script&gt; which is the average number of successes you see in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. Then we will have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\
&amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} (1-\frac{\lambda}{n})^{n-k} \\
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">0 References My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ Indicator/Bernoulli Random Variable If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability for success and for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following: $$ \begin{align*} X = \Big\{ \begin{array}{@{}lr@{}} 1 \quad \text{If even A occurs } \\ 0 \quad \text{otherwise} \\ \end{array} \end{align*} $$ Therefore, . Let’s look at the PMF of . Remember that the PMF of a random variable is just the probability that this random variable takes on a value in . Therefore, $$ \begin{align*} p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}} p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\ p(0) = 1 - P(A) \quad \text{if } x = 0 \\ \end{array} \end{align*} $$ What the expected value of ? Recall that the expected value of a discrete random variable is defined as $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ Therefore, $$ \begin{align*} E[X] = p(1)*1 + p(0)*0 = p(1) = P(A) \end{align*} $$ Binomial Random Variable If we on the other hand have independent trials of Bernoulli random variables with a probability of success , then we can use a binomial random variable to represent the number of successes in trials. For example, if we are flipping a coin with probability of getting heads (success) equals to , then we can define a binomial random variable to represent the number of heads in trials. Therefore, and the PMF of is: $$ \begin{align*} p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k} \end{align*} $$ The expected value, variance and second moment of a binomial random variable: $$ \begin{align*} E[X] &amp;amp;= np \\ Var(X) &amp;amp;= np(1-p) \\ E[X^2] &amp;amp;= n^2p^2 - np^2 + np \end{align*} $$ Poisson Random Variable Consider a duration of time where events occur at an average rate of (number of occurrences per unit time). Let be the number of occurrences in a unit of time. We have and the PMF of is: $$ \begin{align*} p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda} \end{align*} $$ The expected value, variance and second moment of a binomial random variable: $$ \begin{align*} E[X] = np \\ Var(X) = np(1-p) \\ E[X^2] = n^2p^2 - np^2 + np \end{align*} $$ Example 1: Given a web server, suppose that the server load averages 2 hits per second. Let be the number of hits received in a second. What is $$ \begin{align*} P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361 \end{align*} $$ Binomial and Poisson Random Variables Let be very large and very small. Let which is the average number of successes you see in trials. Then we will have $$ \begin{align*} P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\ &amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} (1-\frac{\lambda}{n})^{n-k} \\ \end{align*} $$</summary></entry><entry><title type="html">Prime Numbers</title><link href="http://localhost:4000/jekyll/update/2019/08/23/prime-numbers.html" rel="alternate" type="text/html" title="Prime Numbers" /><published>2019-08-23T07:01:36-07:00</published><updated>2019-08-23T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/23/prime-numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/23/prime-numbers.html">&lt;p&gt;&lt;b&gt;References&lt;/b&gt;&lt;br /&gt;
These study notes are from the following sources: &lt;br /&gt;
(1) http://mathworld.wolfram.com/ &lt;br /&gt;
(2)
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Divisibility&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a,b \in Z&lt;/script&gt;. We say that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; divides &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;a \ | \ b&lt;/script&gt; if for some &lt;script type=&quot;math/tex&quot;&gt;c \in Z&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;b = ac&lt;/script&gt;. In this case, &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is a divisor of &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. If there is no such &lt;script type=&quot;math/tex&quot;&gt;c \in Z&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;b = ac&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; does not divide &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;a \nmid b&lt;/script&gt;.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Prime&lt;/b&gt;&lt;br /&gt;
An Integer &lt;script type=&quot;math/tex&quot;&gt;n &gt; 1&lt;/script&gt; is prime if the only positive divisors of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; are &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is not prime then &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is composite.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Fundamental Theorem of Arithmetic:&lt;/b&gt;&lt;br /&gt; 
Every integer greater than 1 can be represented in exactly one way apart from rearrangement as a product of one or more primes.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Greatest Common Divisor&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a, b \in Z&lt;/script&gt;. Let&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
gcd(a,b) = \max \{ d \in Z : d \ |\  a \ \text{ and } \ d \ | \ b \}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; is the greatest common divisor of both &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Properties of the Greatest Common Divisor&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a, b \in Z&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
gcd(a,b) = gcd(a,b-a) = gcd(a,b+a)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Proof: Let &lt;script type=&quot;math/tex&quot;&gt;gcd(a,b) = d \in Z&lt;/script&gt;. By the defintion of &lt;script type=&quot;math/tex&quot;&gt;gcd&lt;/script&gt; we know that &lt;script type=&quot;math/tex&quot;&gt;d \ | \ a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;d \ | \ b&lt;/script&gt;. Therefore, for some &lt;script type=&quot;math/tex&quot;&gt;x, y \in Z&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a = xd&lt;/script&gt; and, &lt;script type=&quot;math/tex&quot;&gt;b = yd&lt;/script&gt;. From this we have, &lt;script type=&quot;math/tex&quot;&gt;a - b = d(x - y)&lt;/script&gt;. Therefore, we know that &lt;script type=&quot;math/tex&quot;&gt;d = gcd(a,b) \ | \ a - b&lt;/script&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">References These study notes are from the following sources: (1) http://mathworld.wolfram.com/ (2) Divisibility Let . We say that divides or if for some , . In this case, is a divisor of . If there is no such such that then does not divide or . Prime An Integer is prime if the only positive divisors of are and . If is not prime then is composite. Fundamental Theorem of Arithmetic: Every integer greater than 1 can be represented in exactly one way apart from rearrangement as a product of one or more primes. Greatest Common Divisor Let . Let $$ \begin{align*} gcd(a,b) = \max \{ d \in Z : d \ |\ a \ \text{ and } \ d \ | \ b \} \end{align*} $$ is the greatest common divisor of both and . Properties of the Greatest Common Divisor Let , we have $$ \begin{align*} gcd(a,b) = gcd(a,b-a) = gcd(a,b+a) \end{align*} $$ Proof: Let . By the defintion of we know that and . Therefore, for some , we have and, . From this we have, . Therefore, we know that .</summary></entry><entry><title type="html">Congruences</title><link href="http://localhost:4000/jekyll/update/2019/08/22/congruences.html" rel="alternate" type="text/html" title="Congruences" /><published>2019-08-22T07:01:36-07:00</published><updated>2019-08-22T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/22/congruences</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/22/congruences.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes from ?
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tr&gt;&lt;td bgcolor=&quot;#FFFDD0&quot;&gt;
&lt;b&gt;What is a Random Variable?&lt;/b&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p center=&quot;&quot; style=&quot;background-color:#FFFDD0; border:1px; border-style:solid; border-color:#FXFXFX; padding: 1em;&quot;&gt;
The numbers $$a$$ and $$b$$ are congruent module $$m$$ if and only if $$m  \ | \ (a-b)$$ and also if and only if $$m \ | \ (b-a)$$.
$$
\begin{align*}
p_X(k) = P(X = k)
\end{align*}
$$

&lt;br /&gt;
&lt;br /&gt;






















&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes from ? What is a Random Variable? The numbers $$a$$ and $$b$$ are congruent module $$m$$ if and only if $$m \ | \ (a-b)$$ and also if and only if $$m \ | \ (b-a)$$. $$ \begin{align*} p_X(k) = P(X = k) \end{align*} $$</summary></entry><entry><title type="html">Binary Search Correctness Proof</title><link href="http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof.html" rel="alternate" type="text/html" title="Binary Search Correctness Proof" /><published>2019-08-19T07:01:36-07:00</published><updated>2019-08-19T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof.html">&lt;div style=&quot;background-color:#E3E4FA; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
These are my study notes from CLRS and ?
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E3E4FA; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Binary Search&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Given a sorted array &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; integers and a key, we want to return the index of the key in the array or -1 if the key doesn’t exist in the array. Binary search takes advantage of the property that the array is sorted and then iteratively finds which half of the list the key will be located in. After &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; iterations, we will either correctly return that index or return -1 if the key doesn’t exist.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not found&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E3E4FA; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Correctness Proof&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
This is just my attempt to prove that binary search algorithm implemented above is correct. To prove binary search is correct, we want to prove the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;At every iteration binary search is still searching the correct range in the array. This can be achieved with a loop invariant.&lt;/li&gt;
  &lt;li&gt;Binary search terminates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we are able to prove these two then we can conclude that binary search is correct.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E3E4FA; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Preconditions and Postconditions&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
In addition to loop invariants, we also need to describe the preconditions of binary search. Preconditions are just assertions that must be true at the beginning of our function. In our case, &lt;b&gt;our precondition is that the array is sorted in an ascending order&lt;/b&gt;. If the array is not sorted, then we don’t guarantee anything about the outcome.
&lt;br /&gt;
&lt;br /&gt;
In addition to preconditions, we also need to describe our postconditions. Given that we met the preconditions, our loop invariant is correct and our algorithm terminates, our &lt;b&gt;post condition is that we return -1 if the key is not in the array or return the index of the key in the array&lt;/b&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E3E4FA; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Binary Search's Loop Invariant&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
As a reminder from CLRS, loop invariants have three parts that we need to prove:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The invariant is true before the first iteration of the loop. (Initialization)&lt;/li&gt;
  &lt;li&gt;If the invariant is true before iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;, then it is true before iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. (Maintenance)&lt;/li&gt;
  &lt;li&gt;When the loop terminates, the invariant gives us a property to help show that the algorithm is correct. (Termination)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s define the following loop invariant: &lt;br /&gt;
At the start of each iteration of the while loop above the following is true: &lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;1 \leq first \leq last \leq n&lt;/script&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If the key is in the array and so there is some &lt;script type=&quot;math/tex&quot;&gt;index&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;1 \leq index \leq n&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;first \leq index \leq last&lt;/script&gt;. This just means that we are correctly picking the right range to search at every iteration.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;b&gt;Initialization:&lt;/b&gt;
&lt;br /&gt;
Before the first iteration we know that &lt;script type=&quot;math/tex&quot;&gt;first = 1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;last = n-1&lt;/script&gt; and so (1) is trivially true. Also, if the key is in &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; then it must be that &lt;script type=&quot;math/tex&quot;&gt;1 \leq index \leq n-1&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt;. Therefore, we are searching the correct range.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Maintenance:&lt;/b&gt;
&lt;br /&gt;
Suppose the invariant holds before iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and that if our key is in &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; then for some index where &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt; we have &lt;script type=&quot;math/tex&quot;&gt;first \leq index \leq last&lt;/script&gt;. Let’s look at iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. We first calculate the mid point in the range &lt;script type=&quot;math/tex&quot;&gt;[first, last]&lt;/script&gt;. Based on this, we have three cases: 
&lt;br /&gt;
&lt;br /&gt;
(1) &lt;script type=&quot;math/tex&quot;&gt;a[m] == key&lt;/script&gt;. We therefore, return &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and we are done. 
&lt;br /&gt;
&lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm in this case searches the new range &lt;script type=&quot;math/tex&quot;&gt;[first, m-1]&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;first \leq index&lt;/script&gt; by the inductive hypothesis and so we only need to prove that &lt;script type=&quot;math/tex&quot;&gt;index \leq m-1&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt; and since the array is sorted then it must be that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
index &lt; m %]]&gt;&lt;/script&gt; is true otherwise &lt;script type=&quot;math/tex&quot;&gt;a[index]&lt;/script&gt; comes after &lt;script type=&quot;math/tex&quot;&gt;a[m]&lt;/script&gt; which indicates that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is not sorted.
&lt;br /&gt;
&lt;br /&gt;
(3) &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm will then search the new range &lt;script type=&quot;math/tex&quot;&gt;[m+1, last]&lt;/script&gt;. We can use a similar argument to (2) to prove that &lt;script type=&quot;math/tex&quot;&gt;index \in [m+1, last]&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
From (1), (2), (3) we conclude that the invariant holds before iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Termination:&lt;/b&gt;
&lt;br /&gt;
Suppose we know we terminate (proof next), then by the loop invariant we know&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E3E4FA; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Does Binary Search Terminate?&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Will we terminate? we need to prove that if the search range is &lt;script type=&quot;math/tex&quot;&gt;[first_i, last_i]&lt;/script&gt; in iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and the search range in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;[first_{i+1}, last_{i+1}]&lt;/script&gt; then it must be that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
last_{i+1} - first_{i+1} &lt; last_{i} - first_{i} %]]&gt;&lt;/script&gt;. To do so we can use a similar approach to the one we used to prove our maintenance step. We know there are three cases, in each case we can prove that the new range is shrinking.
&lt;br /&gt;
&lt;br /&gt;
Suppose &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; is the midpoint in &lt;script type=&quot;math/tex&quot;&gt;[first_i, last_i]&lt;/script&gt;. There are three cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;a[m] == key&lt;/script&gt;. We therefore, return &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and we are done (binary search terminates).&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm in this case searches the new range &lt;script type=&quot;math/tex&quot;&gt;[first_i, m-1]&lt;/script&gt;. We see here that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
m-1-first_i &lt; last_i-first_i %]]&gt;&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm will then search the new range &lt;script type=&quot;math/tex&quot;&gt;[m+1, last]&lt;/script&gt;. Similarly, we see here that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
last - m + 1 &lt; last_i - first_i %]]&gt;&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the three cases we conclude that binary search must terminate.&lt;/p&gt;</content><author><name></name></author><summary type="html">References These are my study notes from CLRS and ? Binary Search Given a sorted array of integers and a key, we want to return the index of the key in the array or -1 if the key doesn’t exist in the array. Binary search takes advantage of the property that the array is sorted and then iteratively finds which half of the list the key will be located in. After iterations, we will either correctly return that index or return -1 if the key doesn’t exist. int binary_search(int *a, int key, int n) { int m, first = 0, last = n - 1; while (first &amp;lt;= last) { m = (first + (last - first / 2); if (key &amp;gt; a[m]) { first = m + 1; } else if (key &amp;lt; a[m]) { last = m - 1; } else if (key == a[m]) { return m; } } return -1; // not found } Correctness Proof This is just my attempt to prove that binary search algorithm implemented above is correct. To prove binary search is correct, we want to prove the following: At every iteration binary search is still searching the correct range in the array. This can be achieved with a loop invariant. Binary search terminates.</summary></entry><entry><title type="html">Closest Pair of Points</title><link href="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html" rel="alternate" type="text/html" title="Closest Pair of Points" /><published>2019-07-29T07:01:36-07:00</published><updated>2019-07-29T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/29/closest-pair</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Problem&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we are given a list of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; two dimensional points &lt;script type=&quot;math/tex&quot;&gt;\{\{x_1,y_1\},\{x_2,y_2\},...\{x_n,y_n\}\}&lt;/script&gt; and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; since we have &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; possible pairs. What else can we do?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Divide and Conquer&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we arrive at the final result. As a starting point we will sort the points by their x-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We will also sort the points by their y-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;. We will be using &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; later in the algorithm.
&lt;img src=&quot;http://localhost:4000/assets/closest/1.png&quot; width=&quot;100%&quot; /&gt;
Given &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We can start by applying the following divide and conquer idea. Repeatedly divide &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/closest/2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How do we combine the results to find the single true closest pair? we need to consider that the closest pair might have a point in the left half and a point in the right half. We call this pair a &lt;b&gt;split pair&lt;/b&gt;. So in the combine step we need to do two things, we find the split pair with the minimum distance. We then return the minimum pair of the three pairs we have, the left pair, the right pair and the split pair. The following pseudo-code implements this idea.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Px sorted by x-coordinate, Py by y-coordinate&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;less&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;three&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
       &lt;span class=&quot;c1&quot;&gt;// just use the naive algorithm &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we will divide Px into two arrays left and right&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// median = Px[n/2-1]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_px_around_the_median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// We want to sort each of left_x and right_x by the y-coordinate.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// discussed next&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort_left_and_right_by_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we find the closest pair in each half&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// delta_left and delta_right are the minimum distances in the left and right halfs&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we'll discuss this soon!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
We sorted the array upfront twice in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; time. We divide the input repeatedly in half until we reached the base case. We then combined the results by finding the split pair and returning the pair with the minimum distance. So we have a recurrence that looks like this:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 T(n) = aT(n/b) + n^c \\
 T(n) = 2T(n/2) + n^c
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; constant depends on the work we’re doing in each level. We first create the four arrays &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. This takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. We then find the split pair. If we find the split pair in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;c = 2&lt;/script&gt; and by the master theorem, the total runtime is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. This defeats the purpose since the naive solution runs in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. We also know that we initially sorted the array in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; so the final runtime is at least &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;. So roughly we know that we need to find the split pair really fast in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; to have &lt;script type=&quot;math/tex&quot;&gt;c = 1&lt;/script&gt; and therefore, keeping our runtime at &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 How to repeatedly sort &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; by the x-coordinate and the y-coordinate &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time? &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
So we’re claiming that we’re sorting once only and then somehow we’re are repeatedly passing the two halfs of the &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; sorted by the x-coordinate and by the y-coordinate. How?! For sorting by the x-coordinate, we simply split &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; in half by calculating the median in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; time and then iterating over &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; to split the array into &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. That takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the current size of &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Now that we have both &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. We want to create two arrays &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; but sorted by the y-coordinate. We also want &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; sorted by the y-coordinate. How do we do this in just &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time? This is when we will use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;! We will iterate over &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; and if we see an element with an x-coordinate below or equal to the median then this element belongs to &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; otherwise it belongs to &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. Remember that &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; is just &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; but sorted by the y-coordinate. We are also assuming for the sake of simplicity that the points are distinct. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Finding the split pair in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/closest/3.png&quot; width=&quot;100%&quot; /&gt;
Let’s assume that the minimum pair is not a left pair or a right pair and it is a split pair. In the algorithm we described above, let the left minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; (shown above) and let the right minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; be the minimum of &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Also let the right most point in the left array be &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. Now construct &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; to be an array with all the points that have x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x} + \delta&lt;/script&gt; sorted by their y-coordinate (we can use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; with a linear scan to insert any point that has an x-coordinate that fits our criteria). This linear scan costs &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time which is fine by us!
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;p=(x_1,y_1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q=(x_2,y_2)&lt;/script&gt; be the split pair points we’re trying to find where &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is in the left half and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; is in the right half. We claim the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;At most 6 points are between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in M.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
So, assuming the above is correct (we’ll prove it formally), we now have a constant number of pairs to look at. Basically, for each point, we will look at 7 points and therefore, we only have &lt;script type=&quot;math/tex&quot;&gt;7n&lt;/script&gt; pairs and so we can find the split pair in only &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
But why why why the above is the correct? let’s look at the first claim.
&lt;br /&gt;&lt;br /&gt;
Proof:&lt;br /&gt;
We want to show that if the closest pair of points is a split pair then our algorithm will find it. Since our algorithm only searches &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, then we want to show that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;. So assuming that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are the closest pair, we then know that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
d(p,q) &lt; \delta %]]&gt;&lt;/script&gt;. From here we can expand the euclidean distance definition:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 \delta &amp;amp;&amp;gt; d(p,q) \\
  &amp;amp;= \sqrt{(y_2-y_1)^2 + (x_2-x_1)^2} \\
  &amp;amp;\geq \sqrt{\max\{(y_2-y_1)^2, (x_2-x_1)^2}\} \\
  &amp;amp;= \max\{(y_2-y_1), (x_2-x_1)\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This says that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; in both their &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; coordinates!! So &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
|x_2-x_1| &lt; \delta %]]&gt;&lt;/script&gt;. We also know that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are a split pair and so by definition we have &lt;script type=&quot;math/tex&quot;&gt;x_1 \leq \bar{x}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 &gt; \bar{x}&lt;/script&gt;. Therefore, we must have &lt;script type=&quot;math/tex&quot;&gt;x_1 \geq \bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 \leq \bar{x} + \delta&lt;/script&gt;. Finally, since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is defined to include all points such that the x-coordinate satisfies &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta \leq x \leq \bar{x} + \delta&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; and thererfore, we will find them. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Let’s move to the second claim. why must we have 6 points only between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
Proof:
&lt;br /&gt;
Without the loss of generality, assume that &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; has the lower y-coordinate. We do know that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;’s x and y coordinates differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;’s x and y coordinates respectively. What do we know about the points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted by the y-coordinate, we do know that any point that comes between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;, this makes the y-coordinate of any of these points be in between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1 \leq y_2 + \delta&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We know that any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have an x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x}-\delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x}+\delta&lt;/script&gt; by our construction of &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using the above restrictions, any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must be in one of the following boxes. (again, if you look at the x-axis, &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; only allow points within &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. If you look vertically, the fact that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted makes the points between &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and that gap is also less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;!!).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/closest/4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next question is how many points do we have in each box?
&lt;br /&gt;&lt;br /&gt;
We claim that each box has only 1 point. Proof: Suppose it doesn’t and some box in the diagram above has 2 points. Let these points be &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. This means than &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; are both a left pair or a right pair. Moreover, the distance between &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is at most &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sqrt{(\delta/2)^2 + (\delta/2)^2} = \delta/\sqrt{2} &lt; \delta %]]&gt;&lt;/script&gt;. This is a contradiction, since by assumption we said both &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt; are greater than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;. Therefore, we must have 1 point in each box and so there are only 6 points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; Wonderful!!&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!! 1 Problem Suppose we are given a list of two dimensional points and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of since we have possible pairs. What else can we do? 2 Divide and Conquer The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we arrive at the final result. As a starting point we will sort the points by their x-coordinate and let that array be . We will also sort the points by their y-coordinate and let that array be . We will be using later in the algorithm. Given . We can start by applying the following divide and conquer idea. Repeatedly divide into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.</summary></entry><entry><title type="html">Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html" rel="alternate" type="text/html" title="Random Variables" /><published>2019-07-26T07:01:36-07:00</published><updated>2019-07-26T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/26/random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html">&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188// &lt;br /&gt;
Specifically: http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/lectures/06_random_variables.pdf
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;What is a Random Variable?&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A random variable is a real-valued function defined on a sample space. Why define a random variable? sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some groups of the outcomes or more formally some &lt;b&gt;function of the outcome&lt;/b&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 1:&lt;/b&gt;
&lt;br /&gt; 
Suppose we’re interested in &lt;i&gt;counting&lt;/i&gt; the number of heads in &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt; trials of flipping a coin. We can define a random variable &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to represent the number of heads in 5 trials. Using &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;, we can now refer to the probability of seeing two heads in 5 trials as &lt;script type=&quot;math/tex&quot;&gt;P(Y=2)&lt;/script&gt;. This is much simpler that listing the exact outcomes we’re interested in which are getting heads in trial 1 and 2 or getting heads in 1 or 3 or getting heads in trials 1 and 4 only and so on. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 2:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice and we’re interested in the sum of the two dice. We define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 as &lt;script type=&quot;math/tex&quot;&gt;P(X=7)&lt;/script&gt;. This is much simpler that saying that we want the probability of seeing any of these outcomes: &lt;script type=&quot;math/tex&quot;&gt;(3,4),(4,3),(2,5),(5,2),(1,6),(6,1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Discrete Random Variables&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
If our random variable takes on countable values &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, x_3,...,x_n&lt;/script&gt;, we call it a discrete random variable. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Probability Mass Function&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; that takes on a discrete values in &lt;script type=&quot;math/tex&quot;&gt;R_X = \{k_1, k_2,...,k_n\}&lt;/script&gt;. Define the probability mass function &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; to be the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; takes on a particular value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. In other words, the PMF is defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p_X(k) = P(X = k)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Furthermore, the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; satisfies:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=1}^{\infty} p_X(k_i) = 1
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This also means that for any value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; that is not in &lt;script type=&quot;math/tex&quot;&gt;R_X&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;p_X(k) = 0&lt;/script&gt;, in other words,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 P(X=k) = \Big\{ \begin{array}{@{}lr@{}}
        p_X(k) \quad \text{ for } k \in R_X \\
        0 \quad \quad \quad \text{ otherwise} \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We can also refer to &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; as just &lt;script type=&quot;math/tex&quot;&gt;p(k)&lt;/script&gt; if the random variable is clear from the context. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 2:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll the two dice again from example 2. Define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be to the sum of the two dice. We know &lt;script type=&quot;math/tex&quot;&gt;R_X = \{2,3,4,5,6,7,8,9,10,11,12\}&lt;/script&gt;. Below is a graph of the &lt;script type=&quot;math/tex&quot;&gt;PMF&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; for all values in &lt;script type=&quot;math/tex&quot;&gt;R_X&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/random/pmf.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Cumulative Distribution Function&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Now instead of defining the probability that a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; takes on a particular value, we define a new function, the cumulative distribution function (CDF) that gives the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is less than or equal to a particular value.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = F(k) = P(X \leq k), \quad \text{ where } -\infty &amp;lt; k &amp;lt; \infty
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;For a discrete random variable, this will be just the sum of all variables&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = F(k) = \sum_{\text{ all } i \leq k} p(i)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Expectation&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
The expectation or expected value of a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is defined as:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the expected value is a weighted average of the value of the random variable (values weighted by their probabilities).
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 4:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice again from example 2 and 3. Define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be to the sum of the two dice. We can use our PMF from the previous section to compute the expected value as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= 2*P(X=2) + 3*P(X=3) + 4*P(X=4) + 5 * P(X=5) * 6*P(X=6) + 7*P(X=7) \\
\\ &amp;amp;+ 8*P(X=8) + 9*P(X=9) + 10*P(X=10) + 11*P(X=11) * 12*P(X=12) \\
E[X] &amp;amp;= 2*\frac{1}{36} + 3*\frac{2}{36} + 4*\frac{3}{36} + 5*\frac{4}{36} + 6*\frac{5}{36} + 7*\frac{6}{36} + 8*\frac{5}{36} + 9*\frac{4}{36} + 10*\frac{3}{36} \\
&amp;amp;+ 11*\frac{2}{36} + 12*\frac{1}{36} = 7
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Expectation of a function of a random variable&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; and we have a function &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; is real-valued function. Suppose we want to calculate the expected value of &lt;script type=&quot;math/tex&quot;&gt;g(X)&lt;/script&gt;. Define&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[g(X)] = E[Y] &amp;amp;= \sum_j y_jp(y_j) \\
&amp;amp;= \sum_i g(x_i) p(x_i) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;PROOF?
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 5:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll a die and define &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be the value on the die. Define a new random variable &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;X^2&lt;/script&gt;. What is &lt;script type=&quot;math/tex&quot;&gt;E[Y]&lt;/script&gt;?&lt;br /&gt;
&lt;br /&gt;
Using the above, &lt;script type=&quot;math/tex&quot;&gt;E[Y] = E[X^2] = \sum_i (k_i^2)p(k_i) = 1/6*(1+4+9+16+25+36) \approx 15.167&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Properties of Expectation&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Two important properties of expectation are the following: &lt;br /&gt;
(1) Linearity of expectation:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[aX + b] &amp;amp;= aE[X] + b 
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;(2) Expectation of the sum of two random variables is the sum of expectation of the two random variables:&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[X + Y] &amp;amp;= E[X] + E[Y]
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Example 6:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll a die and let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable representing the outcome of the roll. Suppose also that you will a number of dollars equals to &lt;script type=&quot;math/tex&quot;&gt;3X+5&lt;/script&gt;. What is the expected value of your winnings? We can let &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; be a random variable representing our winnings. Now we have&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Y] = E[6X^2+5] &amp;amp;= \sum_i (3x_i + 5)p(x_i) \\
&amp;amp;= \frac{1}{6} \sum_{i=1}^6 3x_i+5 \\
&amp;amp;= \frac{1}{6} (8+11+14+17+20+23) = 15.5
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;However using the linearity of expectation, we know that &lt;script type=&quot;math/tex&quot;&gt;E[X]=3.5&lt;/script&gt;. Therefore we could do the following:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Y] = E[3X+5] &amp;amp;= 3E[X]+5  \\
&amp;amp;= 3(3.5) + 5 = 15.5
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Example 7:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice again and we’re interested in the expectation of the sum of two dice. We calculated this value previously in example 4 using the PMF. Let’s use the second property of expectation. Let &lt;script type=&quot;math/tex&quot;&gt;X_1&lt;/script&gt; be a random variable representing the value of the first die and &lt;script type=&quot;math/tex&quot;&gt;X_2&lt;/script&gt; be a random variable representing the sum value of the second die. Let the sum of the two dice be &lt;script type=&quot;math/tex&quot;&gt;X_1 + X_2&lt;/script&gt;.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X_1 + X_2] = E[X_1] + E[X_2] = 7
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Example 8: St. Petersburg Paradox&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A fair coin comes up heads with &lt;script type=&quot;math/tex&quot;&gt;p = 0.5&lt;/script&gt;. We flip the coin until we see the first tails. We will then win &lt;script type=&quot;math/tex&quot;&gt;2^n&lt;/script&gt; dollars where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the number of heads seen before the first tail. How much would you pay to play?
&lt;br /&gt;
&lt;br /&gt;
Let’s define the following random variables: &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; be the number of “heads” before the the first “tails”.&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; be a random variable representing our winnings. &lt;script type=&quot;math/tex&quot;&gt;W = 2^Y&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
What is the probability of seeing &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; heads before seeing the first tail on the &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;th trial? &lt;script type=&quot;math/tex&quot;&gt;P(Y = i) = (1/2) * (1/2) * ... = (1/2)^{i+1}&lt;/script&gt;. This is because  we stop at the &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; flip which is a tail. Each outcome has a probability equals to &lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
What is the expected value of our winnings?&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[W] = E[2^Y] &amp;amp;= \sum_i 2^i P(Y=i) =  \sum_i 2^i p(i) \\
&amp;amp;= (\frac{1}{2})^1 2^0 + (\frac{1}{2})^2 2^1 +  (\frac{1}{2})^3 2^2 + ... \\
&amp;amp;= \sum_i^{\infty} (\frac{1}{2})^{i+1} 2^i = \infty
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Example 9: Roulette&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Consider an even money bet (betting “Red” in Roulette). &lt;script type=&quot;math/tex&quot;&gt;p=18/38&lt;/script&gt; you win &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; dollars, otherwise &lt;script type=&quot;math/tex&quot;&gt;1-p&lt;/script&gt; you lose &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; dollars. Consider the following strategy:
(1) Let &lt;script type=&quot;math/tex&quot;&gt;Y=1&lt;/script&gt;. &lt;br /&gt;
(2) Bet &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;.&lt;br /&gt;
(3) If win then stop.&lt;br /&gt;
(4) else let &lt;script type=&quot;math/tex&quot;&gt;Y=2Y&lt;/script&gt; go to step 2.&lt;br /&gt;
&lt;br /&gt;
What is the expected value of our winning? &lt;br /&gt;
Define &lt;script type=&quot;math/tex&quot;&gt;Z&lt;/script&gt; to be the winnings until we stop.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Z] &amp;amp;= p*1 + (1-p)p*(2-1) + (1-p)^2p*(4-2-1) + ... \\
&amp;amp;= \sum_{i=0}^{\infty} p(1-p)^i(2^i - \sum_{j=0}^{i-1}2^j) \\
&amp;amp;= p\sum_{i=0}^{\infty} (1-p)^i = p\frac{1}{1-(1-p)} = 1
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188// Specifically: http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/lectures/06_random_variables.pdf What is a Random Variable? A random variable is a real-valued function defined on a sample space. Why define a random variable? sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some groups of the outcomes or more formally some function of the outcome. Example 1: Suppose we’re interested in counting the number of heads in trials of flipping a coin. We can define a random variable to represent the number of heads in 5 trials. Using , we can now refer to the probability of seeing two heads in 5 trials as . This is much simpler that listing the exact outcomes we’re interested in which are getting heads in trial 1 and 2 or getting heads in 1 or 3 or getting heads in trials 1 and 4 only and so on. Example 2: Suppose we roll two dice and we’re interested in the sum of the two dice. We define a random variable to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 as . This is much simpler that saying that we want the probability of seeing any of these outcomes: . Discrete Random Variables If our random variable takes on countable values , we call it a discrete random variable. Probability Mass Function Suppose we have a random variable that takes on a discrete values in . Define the probability mass function to be the probability that takes on a particular value . In other words, the PMF is defined as $$ \begin{align*} p_X(k) = P(X = k) \end{align*} $$ Furthermore, the PMF of satisfies: $$ \begin{align*} \sum_{i=1}^{\infty} p_X(k_i) = 1 \end{align*} $$ This also means that for any value that is not in , we have , in other words, $$ \begin{align*} P(X=k) = \Big\{ \begin{array}{@{}lr@{}} p_X(k) \quad \text{ for } k \in R_X \\ 0 \quad \quad \quad \text{ otherwise} \\ \end{array} \end{align*} $$ We can also refer to as just if the random variable is clear from the context. Example 2: Suppose we roll the two dice again from example 2. Define a random variable to be to the sum of the two dice. We know . Below is a graph of the of , for all values in . Cumulative Distribution Function Now instead of defining the probability that a random variable takes on a particular value, we define a new function, the cumulative distribution function (CDF) that gives the probability that is less than or equal to a particular value. $$ \begin{align*} F_X(k) = F(k) = P(X \leq k), \quad \text{ where } -\infty &amp;lt; k &amp;lt; \infty \end{align*} $$ For a discrete random variable, this will be just the sum of all variables $$ \begin{align*} F_X(k) = F(k) = \sum_{\text{ all } i \leq k} p(i) \end{align*} $$ Expectation The expectation or expected value of a random variable is defined as: $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ In other words, the expected value is a weighted average of the value of the random variable (values weighted by their probabilities). Example 4: Suppose we roll two dice again from example 2 and 3. Define a random variable to be to the sum of the two dice. We can use our PMF from the previous section to compute the expected value as $$ \begin{align*} E[X] &amp;amp;= 2*P(X=2) + 3*P(X=3) + 4*P(X=4) + 5 * P(X=5) * 6*P(X=6) + 7*P(X=7) \\ \\ &amp;amp;+ 8*P(X=8) + 9*P(X=9) + 10*P(X=10) + 11*P(X=11) * 12*P(X=12) \\ E[X] &amp;amp;= 2*\frac{1}{36} + 3*\frac{2}{36} + 4*\frac{3}{36} + 5*\frac{4}{36} + 6*\frac{5}{36} + 7*\frac{6}{36} + 8*\frac{5}{36} + 9*\frac{4}{36} + 10*\frac{3}{36} \\ &amp;amp;+ 11*\frac{2}{36} + 12*\frac{1}{36} = 7 \end{align*} $$ Expectation of a function of a random variable Suppose we have a random variable and we have a function where is real-valued function. Suppose we want to calculate the expected value of . Define $$ \begin{align*} E[g(X)] = E[Y] &amp;amp;= \sum_j y_jp(y_j) \\ &amp;amp;= \sum_i g(x_i) p(x_i) \\ \end{align*} $$ PROOF? Example 5: Suppose we roll a die and define to be the value on the die. Define a new random variable to be . What is ? Using the above, Properties of Expectation Two important properties of expectation are the following: (1) Linearity of expectation: $$ \begin{align*} E[aX + b] &amp;amp;= aE[X] + b \end{align*} $$</summary></entry><entry><title type="html">Ford-Fulkerson’s Maximum Flow</title><link href="http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson.html" rel="alternate" type="text/html" title="Ford-Fulkerson's Maximum Flow" /><published>2019-07-22T07:01:36-07:00</published><updated>2019-07-22T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/22/ford-fulkerson.html">&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
These are my study notes covering chapter 26 in CLRS and chapter 7 in Algorithm Design.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Introduction&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we want to ship oranges from NYC to SF. We have different routes of different capacities. The total number of oranges entering some city &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; must be equal to the number of the oranges leaving &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. In other words, cities can’t withhold oranges. We want to find the maximum number of oranges we can ship to SF. This is just one example where we would use a flow network to solve the problem.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Flow Networks&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/flow/1.png&quot; width=&quot;100%&quot; /&gt;
A flow network &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; is a directed graph where &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We have two distinguished vertices, the source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and the sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;Each edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; has a non-negative capacity &lt;script type=&quot;math/tex&quot;&gt;c(u,v) \geq 0&lt;/script&gt;. (edge labels above) &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If we have edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;For any vertex &lt;script type=&quot;math/tex&quot;&gt;v \in V&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;(v,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected and so &lt;script type=&quot;math/tex&quot;&gt;|E| \geq |V| - 1&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;What is Flow?&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/flow/2.png&quot; width=&quot;100%&quot; /&gt;
A &lt;b&gt;flow&lt;/b&gt; is a real valued function &lt;script type=&quot;math/tex&quot;&gt;f : V \times V \rightarrow \mathbb{R}&lt;/script&gt;. We say &lt;script type=&quot;math/tex&quot;&gt;f(u,v)&lt;/script&gt; is a flow from vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; to vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; or the flow carried by the edge &lt;script type=&quot;math/tex&quot;&gt;(u,v)&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;f(u,v)&lt;/script&gt; must satisfy: 
&lt;br /&gt;&lt;br /&gt;
(1) &lt;b&gt;Capacity constraint:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u, v \in V&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
0 \leq f(u,v) \leq c(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the flow on every edge must not exceed its capacity.
&lt;br /&gt;&lt;br /&gt;
(2) &lt;b&gt;Flow Conservation:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u \in V - \{s,t\}&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the total flow coming into &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is equal to the total flow leaving &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;. Nodes don’t withhold flow.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Flow Value&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;|f|&lt;/script&gt; be the value of the flow defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
|f| = \sum_{v \in V}f(s,v) - \sum_{v \in V} f(v,s)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the flow value is the total flow coming out of the source minus the total flow coming into the source. Notice how the flow value is a natural upper bound on the maximum flow we can push from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. Algorithm Design uses the notation &lt;script type=&quot;math/tex&quot;&gt;v(f)&lt;/script&gt; instead of &lt;script type=&quot;math/tex&quot;&gt;|f|&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;The Maximum Flow Problem&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
In the maximum-flow problem we are given a flow network &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with a source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and a sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; and we are asked to find a flow of maximum value. In the above graph, the current flow is 15. Is this a maximum flow and how can we find a maximum flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;A Greedy Idea&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
One greedy approach we might try is to push as much flow as possible starting from the source node. Suppose we have the below graph &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix1.png&quot; width=&quot;100%&quot; /&gt;
We’ll apply the strategy above by pushing as much as we can starting from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix2.png&quot; width=&quot;100%&quot; /&gt;
This flow is not optimal. In order to find the optimal flow we need to have a way to reduce the amount we’re pushing on &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; and then push more instead on &lt;script type=&quot;math/tex&quot;&gt;(s,b)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/fix3.png&quot; width=&quot;100%&quot; /&gt;
How do we implement the idea of removing flow from one part and adding it to another part in the graph? That’s what residual graphs are for! Residual graphs provide a way for us to increment or decrement flow in the original flow. Next, we’ll define formally what residual graphs are.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Residual Graphs&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a flow network with source &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and sink &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; be a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. For any vertices &lt;script type=&quot;math/tex&quot;&gt;u,v \in V&lt;/script&gt;. The &lt;b&gt;residual capacity&lt;/b&gt; &lt;script type=&quot;math/tex&quot;&gt;c_f(u,v)&lt;/script&gt; by
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 c_f(u,v) = \Bigg \{ \begin{array}{@{}lr@{}}
                     c(u,v) - f(u,v)  \ \text{ if} (u,v) \in E,\\
                     f(v,u) \ \ \quad \quad \quad \text{ if} (v,u) \in E, \\
					 0  \text{ otherwise.}
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is the most confusing definition I’ve come across in CLRS. Algorithm Design however makes it super clear. The intution is that for every edge in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, we want to create two edges.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A &lt;b&gt;forward edge&lt;/b&gt; to signify that we can still push more flow on this edge. So the capacity on the forward edge is &lt;script type=&quot;math/tex&quot;&gt;c(u,v)-f(u,v)&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;A &lt;b&gt;backward edge&lt;/b&gt; to signify that we can decrease the flow on this edge by pushing back flow. So the capacity on the backward edge is naturally &lt;script type=&quot;math/tex&quot;&gt;f(u,v)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
In summary, the &lt;b&gt;residual network&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; induced by &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;G_f=(V,E_f)&lt;/script&gt; where&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E_f = \{(u,v) \in V \times V : c_f(u,v) &amp;gt; 0\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Residual Graphs: Example&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Let’s create a residual graph for the flow below:
&lt;img src=&quot;http://localhost:4000/assets/flow/fix2.png&quot; width=&quot;100%&quot; /&gt;
Let’s start with the edge &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;f(a,t) = 2&lt;/script&gt;. Therefore we need to create two edges in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. The first edge is a forward edge with capacity &lt;script type=&quot;math/tex&quot;&gt;c_f(a,t) = c(a,t) - f(a,t) = 7 - 2 = 5&lt;/script&gt; which means that we can still possibly push 5 oranges on this path.
&lt;img src=&quot;http://localhost:4000/assets/flow/at1.png&quot; width=&quot;100%&quot; /&gt;
The other edge is a backward edge with a capacity &lt;script type=&quot;math/tex&quot;&gt;c_f(t,a) = f(a,t) = 2&lt;/script&gt;. This will be very useful of we want to decrement the flow on the edge &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt; in the original graph.
&lt;img src=&quot;http://localhost:4000/assets/flow/at2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We repeat the process for all edges to generate the following graph. (Remember that we omit edges with capacity 0).
&lt;img src=&quot;http://localhost:4000/assets/flow/gf.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Flow in the Residual Graph&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose now we take &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; from the previous example and suppose we find a flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; below
&lt;img src=&quot;http://localhost:4000/assets/flow/aug.png&quot; width=&quot;100%&quot; /&gt;
The claim is that this new flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;, call it &lt;script type=&quot;math/tex&quot;&gt;f^{\prime}&lt;/script&gt; is actually a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. Moreover this new flow will result in an increased flow value in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;! How is this even possible? To prove this we need to formalize this idea of adding the flow in the residual graph to &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; itself.
&lt;br /&gt;
&lt;br /&gt;
Formally, CLRS defines a new function, &lt;b&gt; the augmentation of flow &lt;/b&gt;&lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;f^{\prime}&lt;/script&gt; to be a function from &lt;script type=&quot;math/tex&quot;&gt;V \times V&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; defined by&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 (f \uparrow f')(u,v) = \Bigg \{ \begin{array}{@{}lr@{}}
                     f(u,v) + f'(u,v) - f'(v,u)  \quad \text{ if } (u,v) \in E,\\
					 0  \quad \quad \quad \quad \quad \quad \quad \quad \quad \ \ \text{ otherwise.}
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This looks absolutely scary but all it’s saying is that suppose we take the edge &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. We are sending two units of flow on &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt;. In the residual graph above, we’re sending 5 on the forward edge &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt; and 0 units on the backward edge &lt;script type=&quot;math/tex&quot;&gt;(t,a)&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
(f \uparrow f')(a,t) = f(u,v) + f'(u,v) - f'(v,u) = 2 + 5 - 0 = 7
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And this is how we augment the flow on &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt; (&lt;script type=&quot;math/tex&quot;&gt;f(a,t)&lt;/script&gt;) by the flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; (&lt;script type=&quot;math/tex&quot;&gt;f'(a,t) - f'(t,a)&lt;/script&gt;).
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Augmenting Flow&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Now we now that we have a formal definition of how we can augment the flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; by the flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. We want to prove that it is a valid flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and also that it is a better flow than the original flow. 
&lt;br /&gt;&lt;br /&gt;
Let’s first prove that it is a valid flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. Given &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. Also given that &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and that &lt;script type=&quot;math/tex&quot;&gt;f^{\prime}&lt;/script&gt; is a flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;, we claim that &lt;script type=&quot;math/tex&quot;&gt;|f \uparrow f'|&lt;/script&gt; is a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and that it has value:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
|f \uparrow f'| = |f| + |f^{\prime}|
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Proof:&lt;/b&gt;&lt;br /&gt;
Proof in CLRS consists of first verifying that &lt;script type=&quot;math/tex&quot;&gt;f \uparrow f'&lt;/script&gt; obeys the capacity constraint and flow conversation in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. After that, the proof computes the value of &lt;script type=&quot;math/tex&quot;&gt;f \uparrow f'&lt;/script&gt;. The proof proceeds as follows: &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;V_1&lt;/script&gt; include any vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;(s,v) \in E&lt;/script&gt; and let &lt;script type=&quot;math/tex&quot;&gt;V_2&lt;/script&gt; include any vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;(v,s) \in E&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; doesn’t allow parallel edges by definition, then we know that &lt;script type=&quot;math/tex&quot;&gt;V_1 \cap V_2 = \emptyset&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
|f \uparrow f'| &amp;amp;= \sum_{v \in V} (f \uparrow f')(s,v) - \sum_{v \in V} (f \uparrow f')(v, s) \\
&amp;amp;= \sum_{v \in V_1} (f \uparrow f')(s,v) - \sum_{v \in V_2} (f \uparrow f')(v, s)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The proof proceeds with expanding each term and then finally concluding&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
|f \uparrow f'| &amp;amp;= \sum_{v \in V} f(s,v) - \sum_{v \in V} f(v, s) + \sum_{v \in V} f^{\prime}(s,v) - \sum_{v \in V} f^{\prime}(v, s) \\
|f \uparrow f'| &amp;amp;=  |f| + |f^{\prime} |
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This concludes that the new flow that resulted from combining both flows is a valid flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;! But is this flow better that &lt;script type=&quot;math/tex&quot;&gt;|f|&lt;/script&gt;? We want to prove that &lt;script type=&quot;math/tex&quot;&gt;|f^{\prime}|&gt;0&lt;/script&gt;. To do so, we’ll define augmenting paths next. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Augmenting Paths&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
An augmenting path is a simple path &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in the residual graph &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. Define its residual capacity or bottleneck (Algorithm Design) as follow:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
c_f(p) = min\{c_f(u,v): \{u,v\} \text{ is on }p\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;So the bottleneck is just the minimum edge capacity on the path &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. To see this with an example, suppose we take the above residual graph from the previous example and find a simple path &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. Suppose we picked the following shaded path:
&lt;img src=&quot;http://localhost:4000/assets/flow/aug.png&quot; width=&quot;100%&quot; /&gt;
We can see that its bottleneck is 5 or &lt;script type=&quot;math/tex&quot;&gt;c_f(p) = 5&lt;/script&gt;. Next let’s define a new function &lt;script type=&quot;math/tex&quot;&gt;f_p&lt;/script&gt; by&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
f_p(u,v) = \Bigg \{ \begin{array}{@{}lr@{}}
                     c_f(p) \text{ if }(u,v) \in p \\
					 0 \text{ otherwise}
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Based on this definition, we see that &lt;script type=&quot;math/tex&quot;&gt;f_p&lt;/script&gt; is a flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; with value 
&lt;script type=&quot;math/tex&quot;&gt;|f_p| = c_f(p)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c_f(p) &gt; 0&lt;/script&gt;. Therefore, &lt;script type=&quot;math/tex&quot;&gt;|f \uparrow f_p| =  |f| + |f_p| &gt; |f|&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
So far we formalized the idea of augmenting flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; by flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. We proved that this flow is a valid flow. We also introduced the idea of augmenting paths used to create flow in the residual graph and therefore, additional flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. We also proved that this new flow is also a larger flow than the original flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. What’s left is to see how we can find augmenting paths and increase flow in action!
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Augmenting Flow with New Flow in The Residual Graph &lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
We can find an augmenting path by doing a breadth first search in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. Once we have a path, how do we actually update &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with the new updated flow? We illustrate below the process below:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;augment_flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we first find the bottleneck or residual capacity of p in gf&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bottleneck&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;For&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// e is a forward edge&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// increase f(u,v) by b in g&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// (v,u) is is G // backward edge&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// decrease f(v,u) by b in g&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;To see an example, consider again the same shaded path we found in the previous example.
&lt;img src=&quot;http://localhost:4000/assets/flow/aug.png&quot; width=&quot;100%&quot; /&gt;
Let’s now add this flow back in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. In this example, we see that &lt;script type=&quot;math/tex&quot;&gt;(s,b)&lt;/script&gt; is a forward edge (blue). Therefore, we increment &lt;script type=&quot;math/tex&quot;&gt;(s,b)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; by 5. Next, we see that &lt;script type=&quot;math/tex&quot;&gt;(b,a)&lt;/script&gt; is a backward edge and so we decrement &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; by 5. Similarly &lt;script type=&quot;math/tex&quot;&gt;(a,t)&lt;/script&gt; is a forward edge and so we decrement it in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; by 5. Let’s at &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; after augmenting &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Now, let’s see what the new flow looks like in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; after calling the above method. This flow has a higher value of &lt;script type=&quot;math/tex&quot;&gt;20&lt;/script&gt; than the orignal flow!
&lt;img src=&quot;http://localhost:4000/assets/flow/aug2.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;The Ford-Fulkerson's Method&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Now that we know how to add flow back to &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, we can describe the Ford-Fulkerson method. The Ford-Fulkerson method iteratively increases the value of the flow. We initially start with &lt;script type=&quot;math/tex&quot;&gt;f(u,v)=0&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; and incrementally increase the flow value.
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Ford&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Fulkerson&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// initialize stuff&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Initialize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;residual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;For&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// find an augemnting path and then augment flow in G&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;simple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;augment_flow&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;But do we ever terminate? and how do we know we have the optimal flow when we terminate?
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Cuts in Flow Networks&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Note in the above method that we stop when no longer have augmenting paths. So if Ford-Fulkerson is right, it must be that a flow is maximum when we don’t any more augmenting paths. How do we prove this?
&lt;br /&gt;
&lt;br /&gt;
We need to explore yet another concept. A &lt;b&gt;cut&lt;/b&gt; &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; of a flow network &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; is a partition of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;T = V - S&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;s \in S&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;t \in T&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; be a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
The &lt;b&gt;net flow&lt;/b&gt; &lt;script type=&quot;math/tex&quot;&gt;f(S,T)&lt;/script&gt; across the cut &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt;.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
f(S,T) = \sum_{u \in S}\sum_{v \in T}f(u,v) - \sum_{u \in S}\sum_{v \in T}f(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The &lt;b&gt;capacity&lt;/b&gt; of the cut &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
c(S,T) = \sum_{u \in S}\sum_{v \in T}c(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Suppose we have the following flow with the following cut where &lt;script type=&quot;math/tex&quot;&gt;S = \{s, b\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;T = \{a,c,t\}&lt;/script&gt;. Wee see that the net flow is &lt;script type=&quot;math/tex&quot;&gt;15+5-5=15&lt;/script&gt;. The capacity of the cut is &lt;script type=&quot;math/tex&quot;&gt;20&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/flow/cut.png&quot; width=&quot;100%&quot; /&gt;
Lastly, define a &lt;b&gt;minimum cut&lt;/b&gt; of a network to be a cut whose capacity is minimum over all cuts.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Cuts and Flow&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
We first want to establish that the flow we generate is a flow of maximum value. In order to do so, we need to prove smaller results that we will use in the main proof in the next section. Let’s prove the following
&lt;br /&gt;
&lt;br /&gt;
Suppose &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is a flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and let &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; be any cut in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; then the net flow across &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;f(S,T)=|f|&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof&lt;/b&gt;&lt;br /&gt;
The proof isn’t too bad really. It starts with the definition of the value of the flow and adds the following: &lt;script type=&quot;math/tex&quot;&gt;\sum_{v \in V}f(u,v)-\sum_{v \in V}f(v,u) = 0&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;v \in V-\{s,t\}&lt;/script&gt; which is true because of the conservation law. It also uses the fact that &lt;script type=&quot;math/tex&quot;&gt;S \cap T = \emptyset&lt;/script&gt; to further break the summations into smaller ones. Eventually we will arrive at &lt;script type=&quot;math/tex&quot;&gt;f(S,T)&lt;/script&gt;. (TODO: it’s long but maybe add it later)
&lt;br /&gt;
&lt;br /&gt;
The next thing CLRS proves is that the value of any flow &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; in a flow network &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is bounded from above by the capacity of any cut of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof&lt;/b&gt;&lt;br /&gt;
This one is extremely short because it uses what we proved above.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
|f| &amp;amp;= f(S,T) \\
&amp;amp;= \sum_{u \in S}\sum_{v \in T}f(u,v) - \sum_{u \in S}\sum_{v \in T}f(u,v) \\
&amp;amp;\leq \sum_{u \in S}\sum_{v \in T}f(u,v) \\
&amp;amp;\leq c(S,T). \blacksquare
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;The Max-Flow Min-Cut Theorem&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
FINALLY, we are ready to prove the &lt;b&gt;max-flow min-cut theorem&lt;/b&gt; below: &lt;br /&gt;
If &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is a flow in &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; with source &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and sink &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; then the following conditions are equivalent:&lt;br /&gt;
(1) &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is a maximum flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. &lt;br /&gt;
(2) The residual network &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; contains no augmenting paths. &lt;br /&gt;
(3) &lt;script type=&quot;math/tex&quot;&gt;|f|=c(S,T)&lt;/script&gt; for some cut &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof&lt;/b&gt;&lt;br /&gt;
We have several directions: &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;1 \rightarrow 2&lt;/script&gt;:&lt;br /&gt;
Let the maximum flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; be &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and for the sake of contradiction, suppose that there exists some augmenting path &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;f_p&lt;/script&gt; be the flow in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; as we defined previously. We proved earlier that &lt;script type=&quot;math/tex&quot;&gt;|f \uparrow f_p| =  |f| + |f_p| &gt; |f|&lt;/script&gt;. Therefore, the new flow founded by augmenting &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;f_p&lt;/script&gt; is strictly greater than &lt;script type=&quot;math/tex&quot;&gt;|f|&lt;/script&gt;. This is a contradiction since we assumed &lt;script type=&quot;math/tex&quot;&gt;|f|&lt;/script&gt; is of maximum value.
&lt;br /&gt;
&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;2 \rightarrow 3&lt;/script&gt;:&lt;br /&gt;
This part is sneaky. Suppose we don’t have augmenting paths in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. This means that we don’t have a path from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. Based on this, define &lt;script type=&quot;math/tex&quot;&gt;S = \{u \in V:&lt;/script&gt; there exists a path from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; &lt;script type=&quot;math/tex&quot;&gt;\}&lt;/script&gt; and let &lt;script type=&quot;math/tex&quot;&gt;T = V - S&lt;/script&gt;. We know &lt;script type=&quot;math/tex&quot;&gt;s \in S&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;t \not\in S&lt;/script&gt;. Therefore, the partition &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; is a cut. 
&lt;br /&gt;
&lt;br /&gt;
Now for any vertices &lt;script type=&quot;math/tex&quot;&gt;u \in S&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v \in T&lt;/script&gt;. There are two cases:
&lt;br /&gt;
&lt;br /&gt;
Case 1: If &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt;, then we must have &lt;script type=&quot;math/tex&quot;&gt;f(u,v) = c(u,v)&lt;/script&gt;. This is because if &lt;script type=&quot;math/tex&quot;&gt;f(u,v) \leq c(u,v)&lt;/script&gt; then this means that &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E_f&lt;/script&gt; (Remember “capacity-flow &amp;gt; 0” in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; creates forward edges in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;). Therefore, &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; must be in &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; and this can’t be by assumption.
&lt;br /&gt;
&lt;br /&gt;
Case 2: If &lt;script type=&quot;math/tex&quot;&gt;(v,u) \in E&lt;/script&gt;, then we must have &lt;script type=&quot;math/tex&quot;&gt;f(v,u) = 0&lt;/script&gt;. This is because if &lt;script type=&quot;math/tex&quot;&gt;f(v,u) &gt; 0&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E_f&lt;/script&gt; (Remember flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; creates backward edges in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;). Therefore, &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; must be in &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; and this can’t be by assumption.
&lt;br /&gt;
&lt;br /&gt;
Case 3: If &lt;script type=&quot;math/tex&quot;&gt;(v,u) \not\in E&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;f(u,v) = f(v,u) = 0&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Therefore, combing everything and utilizing the fact that &lt;script type=&quot;math/tex&quot;&gt;|f| = f(S,T)&lt;/script&gt;:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
|f| &amp;amp;= f(S,T) \\
&amp;amp;= \sum_{u \in S}\sum_{v \in T}f(u,v) - \sum_{u \in S}\sum_{v \in T}f(u,v) \\
&amp;amp;= \sum_{u \in S}\sum_{v \in T}c(u,v) - 0 \\
&amp;amp;= c(S,T).
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;3 \rightarrow 1&lt;/script&gt;:&lt;br /&gt;
We established previously that &lt;script type=&quot;math/tex&quot;&gt;|f| \leq c(S,T)&lt;/script&gt; for any cut &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. Therefore, if &lt;script type=&quot;math/tex&quot;&gt;|f| = c(S,T)&lt;/script&gt; for some cut &lt;script type=&quot;math/tex&quot;&gt;(S,T)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; then it must be that &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; is a flow of maximum value. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Does Ford-Fulkerson Terminate?&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
An essential component in the proof that Ford-Fulkerson terminates is the assumption that the capacities in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; are integers otherwise we might not converge to the optimal flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. So given that we integer capacities, we need to prove three components:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The flow values and the capacities in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt; remain integers in every iteration.&lt;/li&gt;
  &lt;li&gt;In each iteration of Ford-Fulkerson, the flow value increases.&lt;/li&gt;
  &lt;li&gt;There is an upper bound on the maximum flow value.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Given a flow network &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and its residual network &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. For (1) given an augmenting path, we know that the bottleneck value or the residual capacity is just the minimum value of all the edge capacities on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;. Therefore, the new flow must have an integer value.
&lt;br /&gt;
&lt;br /&gt;
For (2), we defined formally the augmentation of &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; by &lt;script type=&quot;math/tex&quot;&gt;f^{\prime}&lt;/script&gt; and we proved that for any augmenting path and flow &lt;script type=&quot;math/tex&quot;&gt;f_p&lt;/script&gt;, we must have &lt;script type=&quot;math/tex&quot;&gt;|f| + |f_p| &gt; |f|&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
For (3), we can simply use the upper bound from the definition of the value of flow itself. Recall that&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
|f| &amp;amp;= \sum_{v \in V}f(s,v) - \sum_{v \in V}f(v,s) \\
&amp;amp;\leq \sum_{v \in V}f(s,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We can therefore, let &lt;script type=&quot;math/tex&quot;&gt;C = \sum_{v \in V}f(s,v)&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;|f| \leq C&lt;/script&gt;. Along with (1) and (2), we can conclude that Ford-Fulkerson must terminate in at most &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; iterations.&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Running Time&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
We know that &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected and so finding an augmenting path using a depth first search or a breadth first search will run in &lt;script type=&quot;math/tex&quot;&gt;O(E + V) = O(E)&lt;/script&gt; time. Updating the augmenting path in each iteration costs &lt;script type=&quot;math/tex&quot;&gt;O(E)&lt;/script&gt; time. How many times do we loop? Given that the capacities are integers and depending on the maximum value of flow, &lt;script type=&quot;math/tex&quot;&gt;|f^*|&lt;/script&gt;, the total running time is &lt;script type=&quot;math/tex&quot;&gt;O(E \ |f^*|)&lt;/script&gt;.&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#E0F8F7; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Edmonds-Karp&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
One way to improve Ford-Fulkerson is by smartly choosing the augmenting path in each iteration. Edmonds-Karp chooses the shortest path from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; where each edge has unit weight. Edmonds-Karp runs in &lt;script type=&quot;math/tex&quot;&gt;O(VE^2)&lt;/script&gt; time. Why?
&lt;br /&gt;
&lt;br /&gt;
TODO&lt;/p&gt;</content><author><name></name></author><summary type="html">References These are my study notes covering chapter 26 in CLRS and chapter 7 in Algorithm Design. Introduction Suppose we want to ship oranges from NYC to SF. We have different routes of different capacities. The total number of oranges entering some city must be equal to the number of the oranges leaving . In other words, cities can’t withhold oranges. We want to find the maximum number of oranges we can ship to SF. This is just one example where we would use a flow network to solve the problem. Flow Networks A flow network is a directed graph where We have two distinguished vertices, the source vertex and the sink vertex . Each edge has a non-negative capacity . (edge labels above) If we have edge then we must have . For any vertex , . is connected and so . What is Flow? A flow is a real valued function . We say is a flow from vertex to vertex or the flow carried by the edge . must satisfy: (1) Capacity constraint: For all , we require $$ \begin{align*} 0 \leq f(u,v) \leq c(u,v) \end{align*} $$ In other words, the flow on every edge must not exceed its capacity. (2) Flow Conservation: For all , we require $$ \begin{align*} \sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v) \end{align*} $$ In other words, the total flow coming into is equal to the total flow leaving . Nodes don’t withhold flow. Flow Value Let be the value of the flow defined as $$ \begin{align*} |f| = \sum_{v \in V}f(s,v) - \sum_{v \in V} f(v,s) \end{align*} $$ In other words, the flow value is the total flow coming out of the source minus the total flow coming into the source. Notice how the flow value is a natural upper bound on the maximum flow we can push from to . Algorithm Design uses the notation instead of . The Maximum Flow Problem In the maximum-flow problem we are given a flow network with a source vertex and a sink vertex and we are asked to find a flow of maximum value. In the above graph, the current flow is 15. Is this a maximum flow and how can we find a maximum flow in ? A Greedy Idea One greedy approach we might try is to push as much flow as possible starting from the source node. Suppose we have the below graph . We’ll apply the strategy above by pushing as much as we can starting from . This flow is not optimal. In order to find the optimal flow we need to have a way to reduce the amount we’re pushing on and then push more instead on and . How do we implement the idea of removing flow from one part and adding it to another part in the graph? That’s what residual graphs are for! Residual graphs provide a way for us to increment or decrement flow in the original flow. Next, we’ll define formally what residual graphs are. Residual Graphs Let be a flow network with source and sink . Let be a flow in . For any vertices . The residual capacity by $$ \begin{align*} c_f(u,v) = \Bigg \{ \begin{array}{@{}lr@{}} c(u,v) - f(u,v) \ \text{ if} (u,v) \in E,\\ f(v,u) \ \ \quad \quad \quad \text{ if} (v,u) \in E, \\ 0 \text{ otherwise.} \end{array} \end{align*} $$ This is the most confusing definition I’ve come across in CLRS. Algorithm Design however makes it super clear. The intution is that for every edge in , we want to create two edges. A forward edge to signify that we can still push more flow on this edge. So the capacity on the forward edge is . A backward edge to signify that we can decrease the flow on this edge by pushing back flow. So the capacity on the backward edge is naturally . In summary, the residual network of induced by is where $$ \begin{align*} E_f = \{(u,v) \in V \times V : c_f(u,v) &amp;gt; 0\} \end{align*} $$ Residual Graphs: Example Let’s create a residual graph for the flow below: Let’s start with the edge . We know that . Therefore we need to create two edges in . The first edge is a forward edge with capacity which means that we can still possibly push 5 oranges on this path. The other edge is a backward edge with a capacity . This will be very useful of we want to decrement the flow on the edge in the original graph.</summary></entry><entry><title type="html">Average-Case, Expected-Case and Worst-Case Running Time</title><link href="http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case.html" rel="alternate" type="text/html" title="Average-Case, Expected-Case and Worst-Case Running Time" /><published>2019-07-19T07:01:36-07:00</published><updated>2019-07-19T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/19/worst-average-expected-case.html">&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Class study notes from http://web.stanford.edu/class/cs161/schedule.html and CLRS (chapter 5).
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Average-Case Running Time (probability distribution is over the input)&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
In this case, we must have some assumption about the distribution of the input given to us. We can then take the average over the distribution of the possible inputs. This is what CLRS calls an average-case running time.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Expected-Case Running Time (algorithm itself makes random choices)&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose our algorithm randomizes the input using a random number generator. This time we have control over the input and when we analyze the running time, we take the &lt;b&gt;expectation of the running time&lt;/b&gt; over the distribution of values returned by our random number generator. Here, the input’s distribution doesn’t matter. We could have the worst-case input and we will still have the same expectation because the algorithm itself is randomized.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Worst-Case Running Time&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
When CLRS talks about the worst-case runtime, it typically refers to a worst-case input and where the adversary chooses the randomness (we get the unlucky permutation or if we don’t have randomness, we just get the worst possible input). One example is QuickSort. Its average-case running time and expected-case running time are both &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;, while its worst-case running time is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">References Class study notes from http://web.stanford.edu/class/cs161/schedule.html and CLRS (chapter 5). Average-Case Running Time (probability distribution is over the input) In this case, we must have some assumption about the distribution of the input given to us. We can then take the average over the distribution of the possible inputs. This is what CLRS calls an average-case running time. Expected-Case Running Time (algorithm itself makes random choices) Suppose our algorithm randomizes the input using a random number generator. This time we have control over the input and when we analyze the running time, we take the expectation of the running time over the distribution of values returned by our random number generator. Here, the input’s distribution doesn’t matter. We could have the worst-case input and we will still have the same expectation because the algorithm itself is randomized. Worst-Case Running Time When CLRS talks about the worst-case runtime, it typically refers to a worst-case input and where the adversary chooses the randomness (we get the unlucky permutation or if we don’t have randomness, we just get the worst possible input). One example is QuickSort. Its average-case running time and expected-case running time are both , while its worst-case running time is .</summary></entry></feed>