<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-05-01T11:08:56-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Binary Search Trees</title><link href="http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees.html" rel="alternate" type="text/html" title="Binary Search Trees" /><published>2020-04-28T12:01:36-07:00</published><updated>2020-04-28T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/28/binary-search-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/binary-search-tree.png&quot; width=&quot;100%&quot; /&gt;
A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The &lt;b&gt;binary-search-tree property&lt;/b&gt; states that given a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in the tree, every node in the left subtree has a key less than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s key and every node in the right subtree has a key greater than &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s key.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Motivation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;But why invent another data structure? Let’s take a look at sorted arrays. We can search a sorted array for keys in just &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time with binary search. However, inserting and deleting elements takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. Similarly, while inserting elements in a linked list takes only &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; time, searching a linked list takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time in the worst case. Can we do better with binary search trees? yes!
&lt;br /&gt;&lt;br /&gt;
The binary search tree property is really great at allowing us to insert/search and delete in just &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; where is &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists!
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;In Order Walk&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. 
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;in_order_walk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!----------------------&gt;
&lt;p&gt;Proving that it takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof)
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Search&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similar to the in-order walk, we can simply perform a search by using the following
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Minimum, Maximum, Predecessor and Successor&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, we have two cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has a right subtree, then the most left element (tree minimum) of the right subtree is the successor.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; doesn’t have a right subtree, then the next element would be the first ancestor such that &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a left child of it. 
&lt;!----------------------&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;successor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise, find the closest parent where t is a left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
 &lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Insert&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Inserting a node into a binary search tree is pretty simple. We need to follow the following steps:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Create a new node and assign both the left and right pointers to NULL.&lt;/li&gt;
  &lt;li&gt;Similar to search, descend in the tree with pointer &lt;script type=&quot;math/tex&quot;&gt;current&lt;/script&gt; based on the key value, while keeping a trailing pointer &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; to its parent. Once we hit NULL, we know that the &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; will be the parent of our node.
The figure below illustrates the process:
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/insert.png&quot; width=&quot;100%&quot; /&gt;
&lt;!----------------------&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// create a new node x&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x is now the root!&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Delete&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Before discussing delete, we’ll present a helper function that we will use in deleting a node in a binary search three. &lt;i&gt;transplant&lt;/i&gt; replaces a subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; with another subtree rooted at &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, illustrated below, 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/transplant.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// replace subtree u with subtree v&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is the root &lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fix v's parent pointer&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Now, suppose we’re about to delete node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and that are given a pointer to it
We have four different cases that we need to handle:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has no children. We then can simply delete that node and return. This case could be handled implicitly in the next case. 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-1.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has only one child. We then just transplant its child at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s parent and remove &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// one child case&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// delete node x if x has only one child&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its right child&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its left child&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// we're good to remove x's memory using &quot;free&quot; or &quot;delete&quot; or whatever we need&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has two children. The idea here is that the successor of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; will take &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s place to maintain the binary search tree property and then we can just delete &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We do know that the successor is the most left child (minimum node) in &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right subtree. Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be the successor of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. It is also important to note that &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; can’t have left children since it is the most left node by definition. We now break deleting &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; into two sub-cases:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(1) &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is the right child of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.  In this case, we transplant &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s parent. We also move &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s left subtree to be &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;’s left subtree. We then we remove &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-3.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// two children first sub-case (s is a right child of x)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is x's immediate right child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree = x's left subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is in the left subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right child. In this case, it’s a little more complicated. We first want to replace &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; (21 in the example) with its right subtree (25 in the example) (remember &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; can’t have a left subtree). We then assign &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right subtree to be &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;’s right subtree. So now the subtree 29 is the right child of 21. Finally just like in the earlier case, simply replace &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; with its right subtree. In this example, it means to replace 19 with 21!
&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/delete-4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// two children second sub-case (s is not right child of x)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is not x's immediate right child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace s with its right subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's right subtree = x's right subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// repeat steps from above to replace x with its right child (s)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree is now x's left subtree&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
Finally putting everything together in one place:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// one child case&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its right child&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// u is a left child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with its left child&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// two children second sub-case (s is not right child of x)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s is not x's immediate right child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace s with its right subtree&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's right subtree = x's right subtree&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;transplant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// replace x with s&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// s's left subtree is now x's left subtree&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we also fix its parent pointer &lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/binary-search-tree.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The binary-search-tree property states that given a node in the tree, every node in the left subtree has a key less than ’s key and every node in the right subtree has a key greater than ’s key. Motivation But why invent another data structure? Let’s take a look at sorted arrays. We can search a sorted array for keys in just time with binary search. However, inserting and deleting elements takes time. Similarly, while inserting elements in a linked list takes only time, searching a linked list takes time in the worst case. Can we do better with binary search trees? yes! The binary search tree property is really great at allowing us to insert/search and delete in just time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be where is is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists! In Order Walk Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. void in_order_walk(tree *t) { if (t == NULL) { return; } in_order_walk(t-&amp;gt;left); print key in_order_walk(t-&amp;gt;right); } Proving that it takes time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof) Search Similar to the in-order walk, we can simply perform a search by using the following tree* search(tree *t, key) { while (t != NULL &amp;amp;&amp;amp; k != t-&amp;gt;key) { if (key &amp;lt; t-&amp;gt;key) { t = t-&amp;gt;left; } else { t = t-&amp;gt;right; } } return t; } Minimum, Maximum, Predecessor and Successor Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node , we have two cases: If has a right subtree, then the most left element (tree minimum) of the right subtree is the successor. If doesn’t have a right subtree, then the next element would be the first ancestor such that is a left child of it. tree* successor(tree *t) { if (t-&amp;gt;right != NULL) { return tree_minimum(t-&amp;gt;right); }; // otherwise, find the closest parent where t is a left child tree *p = t-&amp;gt;parent; while (p != NULL &amp;amp;&amp;amp; p-&amp;gt;right == t) { t = p; p = t-&amp;gt;parent; } return p; } Insert Inserting a node into a binary search tree is pretty simple. We need to follow the following steps: Create a new node and assign both the left and right pointers to NULL. Similar to search, descend in the tree with pointer based on the key value, while keeping a trailing pointer to its parent. Once we hit NULL, we know that the will be the parent of our node. The figure below illustrates the process: void insert(tree **t, key) { // create a new node x p = NULL; current = *t; while (current != NULL) { p = current; if (x-&amp;gt;key &amp;lt; current-&amp;gt;key) { current = current-&amp;gt;left; } else { current = current-&amp;gt;right; } } x.parent = p; if (p == NULL) { // x is now the root! *t = x; } else if (p-&amp;gt;key &amp;gt; x-&amp;gt;key) { p-&amp;gt;left = x; } else { p-&amp;gt;right = x; } } Delete Before discussing delete, we’ll present a helper function that we will use in deleting a node in a binary search three. transplant replaces a subtree rooted at with another subtree rooted at , illustrated below, // replace subtree u with subtree v void transplant(tree **t, tree *u, tree *v) { if (u.parent == NULL) { // u is the root *t = v; } else if (u == u.parent.left) { // u is a left child u.parent.left = v; } else if (u == u.parent.right) { u.parent.right = v; } if (v != NULL) { // fix v's parent pointer v.parent = u.parent } }</summary></entry><entry><title type="html">Red Black Trees</title><link href="http://localhost:4000/jekyll/update/2020/04/27/red-black-trees.html" rel="alternate" type="text/html" title="Red Black Trees" /><published>2020-04-27T12:01:36-07:00</published><updated>2020-04-27T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/27/red-black-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/27/red-black-trees.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/trees/binary-search-trees/binary-search-tree.png&quot; width=&quot;100%&quot; /&gt;
We previously discussed how binary search trees are great and how the binary search tree property allows us to do tree operations such as insert and delete  in just &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; time. However, if the tree height is of order &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;, then we end up with a worse data structure than just a linked list or a sorted list. What we need is a guarantee that the height is &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;. How can we achieve this?
&lt;br /&gt;&lt;br /&gt;
A red-black tree is binary search tree that is balanced. By only adding one extra bit of storage to store the color of the node (red or black) and some restrictions on how to insert and delete nodes, we can have a balanced binary search tree that guarantees the height to be $$O(\log(n))$. 
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Red-black tree specifications&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;A red-black tree must satisfy the following properties:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Every node is either red or black.&lt;/li&gt;
  &lt;li&gt;The root is black.&lt;/li&gt;
  &lt;li&gt;Every leaf node is black.&lt;/li&gt;
  &lt;li&gt;If a node is red, then its children are black.&lt;/li&gt;
  &lt;li&gt;The number of black nodes must be the same across all simple paths from a node to all its leaf nodes.
Usually all leaf nodes are represented with the same special black node, like the figure below. This representation saves a lot of memory. 
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;Why O(\log(n))?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The most important question is why the above restrictions suddenly means that red-black tree are balanced? First, we know that the number of black nodes across all simple paths from the root to any leaf must be the same.&lt;/p&gt;

&lt;p&gt;The &lt;b&gt;black height&lt;/b&gt; of a node, &lt;script type=&quot;math/tex&quot;&gt;bh(x)&lt;/script&gt;. This notion exists since we know from the previous rules that the number of black nodes&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Rotations&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Operations on red-black trees such as insert and delete modify the tree such that we might violate the red-black tree properties. To restore these properties we perform an essential operation called a rotation. A rotation could be a left or a right roation. 
&lt;!----------------------&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;left_rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tree_minimum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise, find the closest parent where t is a left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tree&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;!----------------------&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/binary-search-tree.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">We previously discussed how binary search trees are great and how the binary search tree property allows us to do tree operations such as insert and delete in just time. However, if the tree height is of order , then we end up with a worse data structure than just a linked list or a sorted list. What we need is a guarantee that the height is . How can we achieve this? A red-black tree is binary search tree that is balanced. By only adding one extra bit of storage to store the color of the node (red or black) and some restrictions on how to insert and delete nodes, we can have a balanced binary search tree that guarantees the height to be $$O(\log(n))$. Red-black tree specifications A red-black tree must satisfy the following properties: Every node is either red or black. The root is black. Every leaf node is black. If a node is red, then its children are black. The number of black nodes must be the same across all simple paths from a node to all its leaf nodes. Usually all leaf nodes are represented with the same special black node, like the figure below. This representation saves a lot of memory. Why O(\log(n))? The most important question is why the above restrictions suddenly means that red-black tree are balanced? First, we know that the number of black nodes across all simple paths from the root to any leaf must be the same.</summary></entry><entry><title type="html">Floyd-Warshall’s Shortest Paths</title><link href="http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall.html" rel="alternate" type="text/html" title="Floyd-Warshall's Shortest Paths" /><published>2020-04-24T07:01:36-07:00</published><updated>2020-04-24T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/24/floyd-warshall.html">&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a directed weighted graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. Floyd-Warshall’s algorithm is a dynamic programming algorithm that solves the all-pairs shortest paths problem in $O(V^3)$ time given that we don’t have negative-weight cycles in the $G$.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Optimal Substructure&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;V = \{1,2,3,...,n\}&lt;/script&gt; and consider a subset &lt;script type=&quot;math/tex&quot;&gt;S = \{1,2,3,...,k\}&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;S \subseteq V&lt;/script&gt; for some &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; be two vertices in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;. Now, consider all the paths from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; whose intermediate vertices are in &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Intermediate vertices on a path are all the vertices on the path except for the start and end vertex. Let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be a shortest path among the paths from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that are drawn from &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. 
&lt;img src=&quot;http://localhost:4000/assets/floyd-warshall/path.png&quot; width=&quot;100%&quot; /&gt;
This is where it gets interesting. There are two cases here. Either &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; or it’s not.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is not on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; then we claim that all the intermediate vertices of &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; are drawn from the set &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is on &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can decompose &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; into two shortest paths. A shortest path &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; with intermediate vertices &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt; and a shortest path &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; with intermediate vertices &lt;script type=&quot;math/tex&quot;&gt;\{1,2,...,k-1\}&lt;/script&gt;.
Therefore, we can derive the following:&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 d_{ij}^{k} =\Big\{ \begin{array}{@{}lr@{}}
        w_{ij} \text{ $\quad \quad \quad \quad \quad \quad \quad$ if $k = 0$}\\
        \min (d_{ij}^{k-1}, d_{ik}^{k-1}+d_{jk}^{k-1}) \text{ if $k \geq 0$}\\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Simple Implementation&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;floyd_warshall&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// O(n^3)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// the shortest path between i and j contains some internal nodes (none repeated, simple path)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// let k be an internal node, either node k is on the optimal path or it's not&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is on the path =&amp;gt; the shortest distance is d[i][k] + d[k][j]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is not on the optimal path =&amp;gt; the shortest distance is dij&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if k is zero, then the shortest distance is just wij (if it exist) otherwise infinity&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) initialize the distance matrix&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// distance from node to itself is zero&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w_ij&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w_ij&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// current edge weight&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this edge doesn't exist, set it to infinity&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) apply floyd-warshall&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// number of internal nodes on the path&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                 &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INT_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
                 &lt;span class=&quot;c1&quot;&gt;// current distance vs distance though k (from i to k then k to j)&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Also,
&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/floyd-warshall.cpp&quot;&gt;Source Code&lt;/a&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS&lt;/p&gt;</content><author><name></name></author><summary type="html">Let be a directed weighted graph with vertices and edges. Floyd-Warshall’s algorithm is a dynamic programming algorithm that solves the all-pairs shortest paths problem in $O(V^3)$ time given that we don’t have negative-weight cycles in the $G$. Optimal Substructure Let and consider a subset such that for some . Let and be two vertices in . Now, consider all the paths from to whose intermediate vertices are in . Intermediate vertices on a path are all the vertices on the path except for the start and end vertex. Let be a shortest path among the paths from to that are drawn from . This is where it gets interesting. There are two cases here. Either is on or it’s not. If is not on then we claim that all the intermediate vertices of are drawn from the set . If is on , then we can decompose into two shortest paths. A shortest path from to with intermediate vertices and a shortest path from to with intermediate vertices . Therefore, we can derive the following: $$ \begin{align*} d_{ij}^{k} =\Big\{ \begin{array}{@{}lr@{}} w_{ij} \text{ $\quad \quad \quad \quad \quad \quad \quad$ if $k = 0$}\\ \min (d_{ij}^{k-1}, d_{ik}^{k-1}+d_{jk}^{k-1}) \text{ if $k \geq 0$}\\ \end{array} \end{align*} $$ Simple Implementation void floyd_warshall(int n) { // O(n^3) // the shortest path between i and j contains some internal nodes (none repeated, simple path) // let k be an internal node, either node k is on the optimal path or it's not // if k is on the path =&amp;gt; the shortest distance is d[i][k] + d[k][j] // if k is not on the optimal path =&amp;gt; the shortest distance is dij // if k is zero, then the shortest distance is just wij (if it exist) otherwise infinity // (1) initialize the distance matrix int distance[N][N]; for (int i = 1; i &amp;lt;= vertices; i++) { for (int j = 1; j &amp;lt;= vertices; j++) { if (i == j) { distance[i][j] = 0; // distance from node to itself is zero } else if (w_ij exists) { distance[i][j] = w_ij; // current edge weight } else { distance[i][j] = INT_MAX; // this edge doesn't exist, set it to infinity } } } // (2) apply floyd-warshall for (int k = 1; k &amp;lt;= n; k++) { // number of internal nodes on the path for (int i = 1; i &amp;lt;= n; i++) { for (int j = 1; j &amp;lt;= n; j++) { if (distance[i][k] == INT_MAX || distance[k][j] == INT_MAX) { continue; } // current distance vs distance though k (from i to k then k to j) distance[i][j] = std::min(distance[i][j], distance[i][k] + distance[k][j]); } } } } Also, Source Code References CLRS</summary></entry><entry><title type="html">Line Segment Intersection</title><link href="http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection.html" rel="alternate" type="text/html" title="Line Segment Intersection" /><published>2020-04-08T12:01:36-07:00</published><updated>2020-04-08T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/04/08/line-segment-intersection.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/segments.png&quot; width=&quot;100%&quot; /&gt;
Suppose we have two line segments in two dimensions. Each line segment is determined by two given points. How can we determine if the two line segments intersect? Before answering this question, let’s review some concepts.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;What is a line segment?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Given two points &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. A line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; is the set of convex combinations of &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. That is for any point &lt;script type=&quot;math/tex&quot;&gt;p_3&lt;/script&gt; on the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
x_{p_3} = \alpha x_{p_1} + (1-\alpha)x_{p_2} \\
y_{p_3} = \alpha y_{p_1} + (1-\alpha)y_{p_2}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;0 \leq \alpha \leq 1&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are the end points of the line segment.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Straddling&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The algorithm CLRS presents is based on the idea of checking whether each line segment &lt;b&gt;straddles&lt;/b&gt; the line containing the other line segment.
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle.png&quot; width=&quot;100%&quot; /&gt;
In the above figure, consider the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; and the line containing the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We say that &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; straddles the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are on opposite sides of the line. Should this check be enough to guarantee the intersection of both segments? No. Consider the following figure,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-not-crossing-segment.png&quot; width=&quot;100%&quot; /&gt;
In this case, segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; straddles the line but it does intersect the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_4p_3}&lt;/script&gt;. We could fix this by also checking whether &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; straddles the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt;. Should this be enough now to handle everything? Unfortunately, we are still missing a case. Consider the following,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-end-point.png&quot; width=&quot;100%&quot; /&gt;
In this case, one of the end points is on the line and so we’re not exactly on opposite sides of the line. Therefore, we need to check whether &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; falls on the line segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_4p_3}&lt;/script&gt;. 
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Pseudocode&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// line 1 = p1,p2 and line 2 = p3,p4&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;segment_intersection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// first check whether each segment straddles the line&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// containing the other segment&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_segment_straddling_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;is_segment_straddling_line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// otherwise check the boundary conditions&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// on_line_segment(px, py, pz) determines if px is &lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// on the line segment pypz&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;on_line_segment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The next questions would be how to check whether a line segment is straddling a line and how to check whether a point falls on a line segment. Both of these questions can be answered utilizing cross product.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Cross Product&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/cross-product.png&quot; width=&quot;100%&quot; /&gt;
Given two vectors &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt;. If the cross product &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1} \times \vec{p_2}&lt;/script&gt; is positive, then we say that &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; is clockwise from/relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt; and we turn right at &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. Similarly, if the cross product is negative then we say that &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1}&lt;/script&gt; is anti-clockwise from/relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2}&lt;/script&gt; and we turn left at &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Proof&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;(This is also exercise &lt;script type=&quot;math/tex&quot;&gt;33.1-1&lt;/script&gt;)
&lt;br /&gt;
If the cross product is positive then we know that &lt;script type=&quot;math/tex&quot;&gt;x_1y_2 - x_2y_1 &gt; 0&lt;/script&gt;.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
x_1y_2 - x_2y_1 &amp;gt; 0 \\
x_1y_2 &amp;gt; x_2y_1  \\
\frac{y_2}{x_2} &amp;gt; \frac{y_1}{x_1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Consider now the angle that both vectors make with the positive &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; axis. In the below figure,
&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/cross-product-proof.png&quot; width=&quot;100%&quot; /&gt;
we see that this angle is given by &lt;script type=&quot;math/tex&quot;&gt;\tan^{-1}{y/x}&lt;/script&gt;. We also know that &lt;script type=&quot;math/tex&quot;&gt;\arctan&lt;/script&gt; is monotone and so since &lt;script type=&quot;math/tex&quot;&gt;\frac{y_2}{x_2} &gt; \frac{y_1}{x_1}&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;\theta_2 &gt; \theta_1&lt;/script&gt;. Therefore, &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; must be clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt;. Similarly, when the cross product is negative, we will see that &lt;script type=&quot;math/tex&quot;&gt;\frac{y_1}{x_1} &gt; \frac{y_2}{x_2}&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; must be anti-clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt;. (Ref (2)).&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;Checking whether a segment is straddling a line&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/geometry/segment-intersection/straddle-vectors.png&quot; width=&quot;100%&quot; /&gt;
Using the above idea, it becomes straight forward to determine whether a segment is straddling a line. Suppose we’re determining if segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_1p_2}&lt;/script&gt; is straddling the line containing &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We first find the result of the cross product &lt;script type=&quot;math/tex&quot;&gt;(p_1-p_3) \times (p_4-p_3)&lt;/script&gt;. This will tell us whether &lt;script type=&quot;math/tex&quot;&gt;\vec{p_1-p_3}&lt;/script&gt; is clockwise or anti-clockwise relative to  &lt;script type=&quot;math/tex&quot;&gt;\vec{p_4-p_3}&lt;/script&gt; (left figure). Next, we find &lt;script type=&quot;math/tex&quot;&gt;(p_2-p_3) \times (p_4-p_3)&lt;/script&gt; to determine if &lt;script type=&quot;math/tex&quot;&gt;\vec{p_2-p_3}&lt;/script&gt; is clockwise or anti-clockwise relative to &lt;script type=&quot;math/tex&quot;&gt;\vec{p_4-p_3}&lt;/script&gt; (right figure). Finally, we check if the products have different signs to rule out that &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_2&lt;/script&gt; are on different sides of the line.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Checking whether a point falls on a line segment&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we’re determining if point &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls on the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt;. We first need to determine if all three points &lt;script type=&quot;math/tex&quot;&gt;p_1, p_3&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p_4&lt;/script&gt; are colinear. To do so, we can check the cross product we’ve computed previously, namely, &lt;script type=&quot;math/tex&quot;&gt;(p_1-p_3) \times (p_4-p_3)&lt;/script&gt;. If this product is 0, then we know that the three points are colinear. 
&lt;br /&gt;&lt;br /&gt;
Next, we need to determine if the point &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls between the segment &lt;script type=&quot;math/tex&quot;&gt;\overline{p_3p_4}&lt;/script&gt; or on one of its end points. To do so, we need to check that the x-coordinate of &lt;script type=&quot;math/tex&quot;&gt;p_1&lt;/script&gt; falls in the range of &lt;script type=&quot;math/tex&quot;&gt;min(x_3,x_4), max(x_3,x_4)&lt;/script&gt; and the y-coordinate falls in the range &lt;script type=&quot;math/tex&quot;&gt;min(y_3,y_4),max(y_3,y_4)&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Implementation&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/strncat/algorithms-and-data-structures/blob/master/geometry/intersection-two-line-segments-clrs.cpp&quot;&gt;Full Implementation&lt;/a&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;CLRS Chapter 33
&lt;br /&gt;
&lt;a href=&quot;https://sites.math.rutgers.edu/~ajl213/CLRS/Ch33.pdf&quot;&gt;Cross Product Proof&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Suppose we have two line segments in two dimensions. Each line segment is determined by two given points. How can we determine if the two line segments intersect? Before answering this question, let’s review some concepts. What is a line segment? Given two points and . A line segment is the set of convex combinations of and . That is for any point on the line segment , we have $$ \begin{align*} x_{p_3} = \alpha x_{p_1} + (1-\alpha)x_{p_2} \\ y_{p_3} = \alpha y_{p_1} + (1-\alpha)y_{p_2} \end{align*} $$ where . and are the end points of the line segment. Straddling The algorithm CLRS presents is based on the idea of checking whether each line segment straddles the line containing the other line segment. In the above figure, consider the line segment and the line containing the segment . We say that straddles the line containing if and are on opposite sides of the line. Should this check be enough to guarantee the intersection of both segments? No. Consider the following figure, In this case, segment straddles the line but it does intersect the segment . We could fix this by also checking whether straddles the line containing . Should this be enough now to handle everything? Unfortunately, we are still missing a case. Consider the following, In this case, one of the end points is on the line and so we’re not exactly on opposite sides of the line. Therefore, we need to check whether or falls on the line segment . Pseudocode // line 1 = p1,p2 and line 2 = p3,p4 segment_intersection(p1,p2,p3,p4) { // first check whether each segment straddles the line // containing the other segment if (is_segment_straddling_line(p1,p2,p3,p4) &amp;amp;&amp;amp; is_segment_straddling_line(p3,p4,p1,p2)) { return true; } // otherwise check the boundary conditions // on_line_segment(px, py, pz) determines if px is // on the line segment pypz if (on_line_segment(p1, p3, p4) || on_line_segment(p2, p3, p4) || on_line_segment(p3, p1, p2) || on_line_segment(p4, p1, p2)) { return true; } return false; } The next questions would be how to check whether a line segment is straddling a line and how to check whether a point falls on a line segment. Both of these questions can be answered utilizing cross product. Cross Product Given two vectors and . If the cross product is positive, then we say that is clockwise from/relative to and we turn right at . Similarly, if the cross product is negative then we say that is anti-clockwise from/relative to and we turn left at . Proof (This is also exercise ) If the cross product is positive then we know that . $$ \begin{align*} x_1y_2 - x_2y_1 &amp;gt; 0 \\ x_1y_2 &amp;gt; x_2y_1 \\ \frac{y_2}{x_2} &amp;gt; \frac{y_1}{x_1} \end{align*} $$ Consider now the angle that both vectors make with the positive axis. In the below figure, we see that this angle is given by . We also know that is monotone and so since then we must have . Therefore, must be clockwise relative to . Similarly, when the cross product is negative, we will see that and so must be anti-clockwise relative to . (Ref (2)).</summary></entry><entry><title type="html">Groups</title><link href="http://localhost:4000/jekyll/update/2019/09/07/groups.html" rel="alternate" type="text/html" title="Groups" /><published>2019-09-07T07:01:36-07:00</published><updated>2019-09-07T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/07/groups</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/07/groups.html">&lt;!-------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abstract Algebra: An Introduction, 3rd Edition by Thomas W. Hungerford.&lt;/li&gt;
  &lt;li&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Definition&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A group is a nonempty set of elements with a binary operation that satisfies four properties&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;i&gt;Closure&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a, b \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * b \in G&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Associativity&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a, b, c \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * (b * c) = (a * b) * c&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Identity&lt;/i&gt;: There exists an identity element &lt;script type=&quot;math/tex&quot;&gt;e \in G&lt;/script&gt; such that for any &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * e = e * a = a&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Inverse&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, there exists an inverse element &lt;script type=&quot;math/tex&quot;&gt;a^{-1} \in G&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a * a^{-1} = a^{-1} * a = e&lt;/script&gt;.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Moreover, if the group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; satisfies commutativity so that for all &lt;script type=&quot;math/tex&quot;&gt;a, b \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * b = b * a&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; is an &lt;b&gt;abelian&lt;/b&gt; group. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Order of an Element&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Given a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and an element &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, the order of the element &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;|a|&lt;/script&gt;, is the smallest positive integer &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a^k = e&lt;/script&gt;. If there is no such element then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; has an infinite order.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Example:&lt;/i&gt; 
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Properties of Groups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Given a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, we must have the following&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has a unique identity element.&lt;/li&gt;
  &lt;li&gt;For every &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, there exists a unique inverse &lt;script type=&quot;math/tex&quot;&gt;a^{-1}&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a * a^{-1} = a^{-1} * a = e&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!-------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Subgroups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A subset &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; of a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a &lt;b&gt;subgroup&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is a group under &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;’s operation. We write it as &lt;script type=&quot;math/tex&quot;&gt;H \subseteq G&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;H \neq G&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is a &lt;b&gt;proper subgroup&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and we write &lt;script type=&quot;math/tex&quot;&gt;H \subset G&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Example:&lt;/i&gt; The set &lt;script type=&quot;math/tex&quot;&gt;L=\{1,-1,i,-i\}&lt;/script&gt; is a proper subgroup of &lt;script type=&quot;math/tex&quot;&gt;C^*&lt;/script&gt;, the multiplicative group of complex numbers.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Theorem:&lt;/i&gt; A nonempty subset &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; of a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a subgroup if &lt;br /&gt;
(i) for all &lt;script type=&quot;math/tex&quot;&gt;a, b \in H&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;ab \in H&lt;/script&gt;. &lt;br /&gt;
(ii) for all &lt;script type=&quot;math/tex&quot;&gt;a \in H&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a^{-1} \in H&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Proof: &lt;br /&gt;
The closure property is satisfied by (i). Since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a group then we know associativity holds for all elements including elements in &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt;. The inverse exists by (ii). For the identity element, since &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is not empty then we must have some element &lt;script type=&quot;math/tex&quot;&gt;a \in H&lt;/script&gt;. We also must have &lt;script type=&quot;math/tex&quot;&gt;a^{\prime} \in H&lt;/script&gt; by the inverse property. Therefore, we must have &lt;script type=&quot;math/tex&quot;&gt;aa^{-1} = e \in H&lt;/script&gt; by the closure property. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Subgroups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">References Abstract Algebra: An Introduction, 3rd Edition by Thomas W. Hungerford. Definition A group is a nonempty set of elements with a binary operation that satisfies four properties Closure: For all , we have . Associativity: For all , we have . Identity: There exists an identity element such that for any , we have . Inverse: For all , there exists an inverse element such that .</summary></entry><entry><title type="html">Expectation</title><link href="http://localhost:4000/jekyll/update/2019/09/06/expectation.html" rel="alternate" type="text/html" title="Expectation" /><published>2019-09-06T07:01:36-07:00</published><updated>2019-09-06T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/06/expectation</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/06/expectation.html">&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Expectation&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Recall that the expectation or expected value of a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is defined as:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the expected value is a weighted average of the value of the random variable (weighted by their probabilities). We also studied important properties of expectation&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Linearity of expectation:&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c
\end{align*}
$$
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a random variable, then for any real-valued function &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;,&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[g(X)] &amp;amp;= \sum_ig(x_i)p(x_i)
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Nth Moment&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Define the &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;th moment of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[X^n] &amp;amp;= \sum_{x:p(x)&amp;gt;0} x^np(x)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;From this, we see that the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the first moment of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Variance&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
While the expected value is really useful, we also want to study the spread of the values of random variables. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable with expected value &lt;script type=&quot;math/tex&quot;&gt;E[X]=\mu&lt;/script&gt; and define the variance of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) = E[(X - \mu)^2]
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Expanding this&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) &amp;amp;= E[(X - \mu)^2] \\
&amp;amp;= \sum_i (x_i - \mu)^2p(x_i) \\
&amp;amp;= \sum_i (x_i^2 - 2\mu x_i + \mu^2)p(x_i) \\
&amp;amp;= \sum_i x_i^2p(x_i) - 2\mu x_ip(x_i) + \mu^2p(x_i) \\
&amp;amp;= \sum_i x_i^2p(x_i) - 2\mu \sum_i x_ip(x_i) + \mu^2 \sum_ip(x_i) \\
&amp;amp;= E[X^2] - 2\mu^2 + \mu^2 \\
&amp;amp;= E[X^2] - (E[X])^2 \\
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ Expectation Recall that the expectation or expected value of a random variable is defined as: $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ In other words, the expected value is a weighted average of the value of the random variable (weighted by their probabilities). We also studied important properties of expectation Linearity of expectation: $$ \begin{align*} E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c \end{align*} $$ If is a random variable, then for any real-valued function , $$ \begin{align*} E[g(X)] &amp;amp;= \sum_ig(x_i)p(x_i) \end{align*} $$ Nth Moment Define the th moment of to be $$ \begin{align*} E[X^n] &amp;amp;= \sum_{x:p(x)&amp;gt;0} x^np(x) \end{align*} $$ From this, we see that the expected value of is the first moment of . Variance While the expected value is really useful, we also want to study the spread of the values of random variables. Let be a random variable with expected value and define the variance of to be $$ \begin{align*} Var(X) = E[(X - \mu)^2] \end{align*} $$ Expanding this $$ \begin{align*} Var(X) &amp;amp;= E[(X - \mu)^2] \\ &amp;amp;= \sum_i (x_i - \mu)^2p(x_i) \\ &amp;amp;= \sum_i (x_i^2 - 2\mu x_i + \mu^2)p(x_i) \\ &amp;amp;= \sum_i x_i^2p(x_i) - 2\mu x_ip(x_i) + \mu^2p(x_i) \\ &amp;amp;= \sum_i x_i^2p(x_i) - 2\mu \sum_i x_ip(x_i) + \mu^2 \sum_ip(x_i) \\ &amp;amp;= E[X^2] - 2\mu^2 + \mu^2 \\ &amp;amp;= E[X^2] - (E[X])^2 \\ \end{align*} $$</summary></entry><entry><title type="html">Counting Distinguishable and Indistinguishable Objects</title><link href="http://localhost:4000/jekyll/update/2019/09/05/counting-dist.html" rel="alternate" type="text/html" title="Counting Distinguishable and Indistinguishable Objects" /><published>2019-09-05T07:01:36-07:00</published><updated>2019-09-05T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/05/counting-dist</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/05/counting-dist.html">&lt;h4&gt;&lt;b&gt;(1) k distinguishable strings and n distinguishable buckets&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Label the strings &lt;script type=&quot;math/tex&quot;&gt;s_1, s_2,...,s_k&lt;/script&gt; and label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from. &lt;script type=&quot;math/tex&quot;&gt;s_2&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from and so. Therefore, the total number of choices is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n^k
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;(2) k distinguishable strings and n distinguishable buckets with at most 1 string in each bucket&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Assuming &lt;script type=&quot;math/tex&quot;&gt;k \leq n&lt;/script&gt; (otherwise it is impossible). Label the strings &lt;script type=&quot;math/tex&quot;&gt;s_1, s_2,...,s_k&lt;/script&gt; and label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from. &lt;script type=&quot;math/tex&quot;&gt;s_2&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; choices of buckets to choose from because it can’t go to the bucket that &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; chose. Similarly, &lt;script type=&quot;math/tex&quot;&gt;s_3&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; and so on. Therefore, the total number of choices is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n(n-1) ... (n-k+1) = \binom{n}{k} * k!
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;(3) k indistinguishable strings and n distinguishable buckets&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt; and line them up below:
&lt;img src=&quot;http://localhost:4000/assets/counting/0a.png&quot; alt=&quot;my photo&quot; /&gt;
The strings are indistinguishable. We want to distribute them among the buckets so for example we could have the following:
&lt;img src=&quot;http://localhost:4000/assets/counting/0b.png&quot; alt=&quot;my photo&quot; /&gt;
To simplify the problem, let’s pretend that they are distinguishable and instead of buckets we’ll use dividers to separate the strings into different buckets. This way the first set of strings are in bucket 1, the second set after the first divider are in bucket 2 and so on. We’ll use colors to distinguish them. We will only need &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; dividers to create &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; groups.
&lt;br /&gt;
&lt;br /&gt;
To visualize this, suppose &lt;script type=&quot;math/tex&quot;&gt;n=4&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;k=5&lt;/script&gt;. In the below figure, we have &lt;script type=&quot;math/tex&quot;&gt;\{s_1,s_2\}&lt;/script&gt; in the first bucket. &lt;script type=&quot;math/tex&quot;&gt;\{s_3\}&lt;/script&gt; in the second bucket. &lt;script type=&quot;math/tex&quot;&gt;\{s_4,s_5\}&lt;/script&gt; in the third bucket. The forth bucket is empty.
&lt;img src=&quot;http://localhost:4000/assets/counting/1.png&quot; alt=&quot;my photo&quot; /&gt;
How many possible permutions are there? We have &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; dividers and &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings so&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
(n+k-1)!
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Now, since strings are really indistinguishable, let’s remove the labels. We also don’t need the colors because we’re assuming the first set of strings goes to the first bucket, the second set goes to the second bucket and so on. So we’ll have something like this:
&lt;img src=&quot;http://localhost:4000/assets/counting/2.png&quot; alt=&quot;my photo&quot; /&gt;
To remove the unnecessary ordering, we divide by &lt;script type=&quot;math/tex&quot;&gt;k!&lt;/script&gt; and also divide by &lt;script type=&quot;math/tex&quot;&gt;(n-1)!&lt;/script&gt;. Therefore, the final answer is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\frac{(n+k-1)!}{k!(n-1)!} = \binom{n+k-1}{n-1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Note that solution can be applied to other interesting examples like finding the number of integer solutions to &lt;script type=&quot;math/tex&quot;&gt;x_1+x_2+...+x_k=n&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;(4) k indistinguishable strings and n distinguishable buckets with at most 1 string in each bucket&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;In case (2), we saw that the number of ways to put &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; distinguishable strings into &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; distinguishable buckets with at most 1 string in each bucket is &lt;script type=&quot;math/tex&quot;&gt;\binom{n}{k} * k!&lt;/script&gt;. In this case, the strings are indistinguishable so we don’t care about the order of strings and so we divide by &lt;script type=&quot;math/tex&quot;&gt;k!&lt;/script&gt;. The final answer therefore is simply&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\binom{n}{k}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">(1) k distinguishable strings and n distinguishable buckets Label the strings and label the buckets . has choices of buckets to choose from. has choices of buckets to choose from and so. Therefore, the total number of choices is $$ \begin{align*} n^k \end{align*} $$ (2) k distinguishable strings and n distinguishable buckets with at most 1 string in each bucket Assuming (otherwise it is impossible). Label the strings and label the buckets . has choices of buckets to choose from. has choices of buckets to choose from because it can’t go to the bucket that chose. Similarly, has and so on. Therefore, the total number of choices is $$ \begin{align*} n(n-1) ... (n-k+1) = \binom{n}{k} * k! \end{align*} $$ (3) k indistinguishable strings and n distinguishable buckets Label the buckets and line them up below: The strings are indistinguishable. We want to distribute them among the buckets so for example we could have the following: To simplify the problem, let’s pretend that they are distinguishable and instead of buckets we’ll use dividers to separate the strings into different buckets. This way the first set of strings are in bucket 1, the second set after the first divider are in bucket 2 and so on. We’ll use colors to distinguish them. We will only need dividers to create groups. To visualize this, suppose and . In the below figure, we have in the first bucket. in the second bucket. in the third bucket. The forth bucket is empty. How many possible permutions are there? We have dividers and strings so $$ \begin{align*} (n+k-1)! \end{align*} $$ Now, since strings are really indistinguishable, let’s remove the labels. We also don’t need the colors because we’re assuming the first set of strings goes to the first bucket, the second set goes to the second bucket and so on. So we’ll have something like this: To remove the unnecessary ordering, we divide by and also divide by . Therefore, the final answer is $$ \begin{align*} \frac{(n+k-1)!}{k!(n-1)!} = \binom{n+k-1}{n-1} \end{align*} $$ Note that solution can be applied to other interesting examples like finding the number of integer solutions to . (4) k indistinguishable strings and n distinguishable buckets with at most 1 string in each bucket In case (2), we saw that the number of ways to put distinguishable strings into distinguishable buckets with at most 1 string in each bucket is . In this case, the strings are indistinguishable so we don’t care about the order of strings and so we divide by . The final answer therefore is simply $$ \begin{align*} \binom{n}{k} \end{align*} $$ References Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/</summary></entry><entry><title type="html">Conditional Probability</title><link href="http://localhost:4000/jekyll/update/2019/08/29/conditional-probability.html" rel="alternate" type="text/html" title="Conditional Probability" /><published>2019-08-29T07:01:36-07:00</published><updated>2019-08-29T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/29/conditional-probability</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/29/conditional-probability.html">&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
(1) My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/&lt;br /&gt;
(2) First Course in Probability by Sheldon Ross.
&lt;br /&gt;
&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Conditional Probability&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/condprob/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Conditional probability is the probability that event &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; occurs given that event &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; has already occured written as &lt;script type=&quot;math/tex&quot;&gt;P(E|F)&lt;/script&gt;. In this case:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;b&gt;sample space&lt;/b&gt; consists of all possible outcomes consistent with &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; (events in &lt;script type=&quot;math/tex&quot;&gt;S \cap F&lt;/script&gt;).&lt;/li&gt;
  &lt;li&gt;The &lt;b&gt;event space&lt;/b&gt; consists of all possible outcomes in &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; that are consistent with &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; (events in &lt;script type=&quot;math/tex&quot;&gt;E \cap F&lt;/script&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefore, we have in general&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E|F) = \frac{p(E \cap F)}{p(F)} = \frac{p(EF)}{p(F)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And for equally likely outcomes:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E|F) = \frac{|EF|}{|F|} = \frac{|EF|/|S|}{|F|/|S|} = \frac{p(EF)}{p(F)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Chain Rule&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
From the conditional probability law, we can derive the chain rule!&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(EF) = P(E|F)P(F) = P(F|E)P(E)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And in general if we have multiple events:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E_1E_2...E_n) = P(E_1)P(E_2|E_1)...P(E_n|E_1E_2...E_{n-1})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
Suppose we have an urn with 8 red balls and 4 white balls. What is the probability of choosing two balls that are both red (without replacement). (Source: A First Course in Probability)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E_1&lt;/script&gt; to be the event that the first ball is red. &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E_2&lt;/script&gt; to be the event that the second ball is red. &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E_1E_2) = P(E_1)P(E_2|E_1) = \frac{8}{12}\frac{7}{11} = \frac{14}{33}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Law of Total Probability&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E) &amp;amp;= P(EF) + P(EF^c) \\
P(E) &amp;amp;= P(F)P(E|F) + P(F^c)P(E|F^c) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In general:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E) &amp;amp;= \sum_i^n P(F_i)P(E|F_i)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The law of total probability says that the probability of event &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; is now a weighted average of the conditional probability of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; given event &lt;script type=&quot;math/tex&quot;&gt;F_1&lt;/script&gt; plus the conditional probability of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; given event &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt; and so on. Note that these events &lt;script type=&quot;math/tex&quot;&gt;F_i&lt;/script&gt; must be mutually exclusive. Moreover, &lt;script type=&quot;math/tex&quot;&gt;\sum_iP(F_i) = 1&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
Suppose 25% of students are juniors. Suppose now that if a student is a junior then the probability of being a CS major is 30%, while if a student is not a junior then the probability of being a CS major is 20%. What is the probability of being a CS major? (Class Example)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;CS&lt;/script&gt; to be the event that a student is a CS major. &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;J&lt;/script&gt; to be the event that a student is a junior. &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(CS) &amp;amp;= P(CS | J)P(J) + P(CS | J^c)P(J^c) \\
&amp;amp;= 0.30*0.25 + 0.20*0.75 = 0.225
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Bayes' Theorem&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Common Form:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Expanded Form:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E|F)P(F) + P(E|F^c)P(F^c)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
A test is 98% effective at detecting HIV. The test has a false positive rate of 1%. 0.5% of the US population has HIV. What is the probability that you have HIV given that you tested positive? (class example)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; be that you test positive for HIV with the test&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; be that you actually have HIV. &lt;br /&gt;
We want to find &lt;script type=&quot;math/tex&quot;&gt;P(F|E)&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
First, the probability that the test is positive given that you actually have HIV is 0.98 (true positive). In terms of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;, this is &lt;script type=&quot;math/tex&quot;&gt;P(E|F)=0.98&lt;/script&gt;. Similarly, the probability that we get a false positive is 0.01. In terms of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;, this probability is &lt;script type=&quot;math/tex&quot;&gt;P(E|F^c)&lt;/script&gt;,&lt;/p&gt;

&lt;p&gt;We can now use Bayes’&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E|F)P(F) + P(E|F^c)P(F^c)} \\
&amp;amp;= \frac{(0.98)(0.005)}{(0.98)(0.005) + (0.01)(0.995)} = 0.330
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;The Monty Hall Problem&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have 3 doors. Behind one of the three doors a prize. We choose a door. The host then opens one of the remaining doors that reveals nothing. We are now given the chance to switch our door with the remaining door. Do we switch?
&lt;br /&gt;
&lt;br /&gt;
We want to compare &lt;script type=&quot;math/tex&quot;&gt;P(win)&lt;/script&gt; vs &lt;script type=&quot;math/tex&quot;&gt;P(win|switch)&lt;/script&gt;. We know that if stick with our door, &lt;script type=&quot;math/tex&quot;&gt;P(win)=1/3&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Suppose without the loss of generality that we picked door &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. What is the probability that we win given that we switched? Let’s consider what happens if we switch in each case. 
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;A, B&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; be the events that the prize is behind each door respectively. All three doors are equally likely and so each door has a probability of &lt;script type=&quot;math/tex&quot;&gt;1/3&lt;/script&gt;. Moreover, these events are mutually exlusive since the prize can be behind exactly one door. Also the probability of these events sum up to 1. 
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;:&lt;br /&gt;
In this case the host will open either door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. We will switch and lose. So, &lt;script type=&quot;math/tex&quot;&gt;P(win | \text {switch to B/C}) = 0&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;:&lt;br /&gt;
In this case the host will open door &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. We switch and we win! &lt;script type=&quot;math/tex&quot;&gt;P(win| \text {switch to C})=1&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;:&lt;br /&gt;
In this case the host will open door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. We switch and we win! &lt;script type=&quot;math/tex&quot;&gt;P(win| \text {switch to B})=1&lt;/script&gt;.
&lt;br /&gt;
Using the law of total probability:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(win|switch) &amp;amp;= p(win|\text{switch to A})*P(A) + P(win| \text{switch to B}) + P(win | \text{switch to C})P(C) \\
&amp;amp;= 0(1/3) + 1(1/3) + 1(1/3) = 2/3
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References (1) My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ (2) First Course in Probability by Sheldon Ross. Conditional Probability Conditional probability is the probability that event occurs given that event has already occured written as . In this case: The sample space consists of all possible outcomes consistent with (events in ). The event space consists of all possible outcomes in that are consistent with (events in ).</summary></entry><entry><title type="html">Karger’s Minimum Cut</title><link href="http://localhost:4000/jekyll/update/2019/08/28/min-cut.html" rel="alternate" type="text/html" title="Karger's Minimum Cut" /><published>2019-08-28T03:01:36-07:00</published><updated>2019-08-28T03:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/28/min-cut</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/28/min-cut.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/mincut/1.png&quot; width=&quot;100%&quot; /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be an undirected graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. A cut in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a partition of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; into two non-empty sets of vertices &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. The &lt;b&gt;size&lt;/b&gt; of the cut is the number of edges with one end point in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and another in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. A &lt;b&gt;global minimum cut&lt;/b&gt; is a cut of minimum size.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger's Algorithm&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Karger’s algorithm starts with picking an edge &lt;script type=&quot;math/tex&quot;&gt;(u,v)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; uniformly at random. It then &lt;b&gt;contracts&lt;/b&gt; this edge by creating a new node &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; that combines both &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. All the edges in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with an end point equal to either &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; now point to &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; instead. Also, any edge between &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is deleted. It repeatedly contracts randomly picked edges until we have two vertices in the graph. We then return the number of edges between the two vertices as the global minimum cut in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger's Algorithm Pseudocode&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;karger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Initially&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uniformly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sets&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Example&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we apply the contraction algorithm on the above graph. We start by picking an edge uniformly at random. Suppose we picked the edge &lt;script type=&quot;math/tex&quot;&gt;(d,e)&lt;/script&gt; below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/2.png&quot; width=&quot;100%&quot; /&gt;
We then delete &lt;script type=&quot;math/tex&quot;&gt;(d,e)&lt;/script&gt;. We create a new node &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;. We then point any edge that previously had an end point equal to &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; to point at &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/mincut/3.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/4.png&quot; width=&quot;100%&quot; /&gt;
We delete &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; and create node &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; and fix all the old edges pointing at &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; to point at &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/mincut/5.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(f,g)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/6.png&quot; width=&quot;100%&quot; /&gt;
We’ll repeat the same process by creating &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and fixing the edges below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/7.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(z,x)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/8.png&quot; width=&quot;100%&quot; /&gt;
We’ll again delete the edge, create a new node &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; and fix all the edges below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/9.png&quot; width=&quot;100%&quot; /&gt;
Finally, suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(y,c)&lt;/script&gt; and repeat the same steps. 
&lt;img src=&quot;http://localhost:4000/assets/mincut/10.png&quot; width=&quot;100%&quot; /&gt;
Since we only have 2 vertices then we’re done. We will return the number of edges between the two vertices which is 1 in this case. So the global minimum cut is of size 1 which is correct for this graph.
&lt;img src=&quot;http://localhost:4000/assets/mincut/11.png&quot; width=&quot;100%&quot; /&gt;
Suppose however that instead of picking &lt;script type=&quot;math/tex&quot;&gt;(y,c)&lt;/script&gt; to contract, we picked &lt;script type=&quot;math/tex&quot;&gt;(y,w)&lt;/script&gt;
&lt;img src=&quot;http://localhost:4000/assets/mincut/10a.png&quot; width=&quot;100%&quot; /&gt;
We will end up with a global minimum cut of size 2 instead which is not correct for this graph! This is why Krager’s algorithm is a Monte Carlo algorithm.
&lt;img src=&quot;http://localhost:4000/assets/mincut/11a.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Probability of Success&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we have a graph &lt;script type=&quot;math/tex&quot;&gt;G=(E,V)&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; nodes and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges. Suppose the cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt; is a global minimum cut is of size &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. Also let &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; to be the set of &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; edges in the cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt;. So &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; has the edges that have one end point in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and the other end point in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
The probability that the contraction algorithm succeeds is the probability that we don’t make any mistake in the &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; iterations of the algorithm. Suppose we let &lt;script type=&quot;math/tex&quot;&gt;S_i&lt;/script&gt; to be the event that we don’t make a mistake in step &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; or generally succeed in step &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. We want to calculate the following probability:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(success) = Pr(S_1 \cap S_2 \cap S_3 \cap ... \cap S_{n-2})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;These events are not independent! We can further expand this using the chain rule and instead calculate:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(success) = Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-2} | S_1 \cap S_2 \cap ... \cap S_{n-3})
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Success in the iteration 1:&lt;/b&gt;&lt;br /&gt;
Let’s look at how we can calculate each of these. What does it mean to not make a mistake in step 1? It means that we don’t pick an edge that connects a vertex from the set &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to a vertex from the set &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. Because if we did, then &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; will be merged together and we will not be able to return the global minimum cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt;. So we basically want to avoid picking edges from &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;. Therefore, the probability that we don’t make a mistake in step 1 is
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_1) = 1 - \frac{|F|}{|E|} = 1 - \frac{k}{|E|}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;What is &lt;script type=&quot;math/tex&quot;&gt;|E|&lt;/script&gt;? &lt;br /&gt;
We will use &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; to find an upper bound on &lt;script type=&quot;math/tex&quot;&gt;|E|&lt;/script&gt;. We know that the global minimum cut is of size &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;, therefore, we must have:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;For any node &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;degree(v) \geq k&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof: Suppose not, then there exists some node &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
degree(u) &lt; k %]]&gt;&lt;/script&gt;. Pick the minimum cut such that &lt;script type=&quot;math/tex&quot;&gt;A = \{u\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = V - \{u\}&lt;/script&gt;. The cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt; is a global minimum cut of size less than &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; which is a contradiction. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
Based on this, we can conclude that &lt;script type=&quot;math/tex&quot;&gt;|E| \geq \frac{1}{2}kn&lt;/script&gt;. (&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2}&lt;/script&gt; because &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is undirected).
&lt;br /&gt;
&lt;br /&gt;
So now we have:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_1) = 1 - \frac{|F|}{|E|} \geq 1 - \frac{2k}{kn} = 1 - \frac{2}{n}.
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Success in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;:&lt;/b&gt;&lt;br /&gt;
What about the other iterations? What is the probability that we don’t make a mistake in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; given that we haven’t made any mistake in all the previous interations? At iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;n-i&lt;/script&gt; nodes in the graph. Since we haven’t made any mistake yet, we still have &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; edges in &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; and each node is of degree at least &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; (same proof as before). Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_{i+1} | S_1 \cap S_2 \cap ... \cap S_i) \geq 1 - \frac{k}{1/2k(n-j)} = 1 - \frac{2}{n-j}.
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Now we can combine everything together:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\require{cancel}
\begin{align*}
Pr(success) &amp;amp;= Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-2} | S_1 \cap S_2 \cap ... \cap S_{n-3}) \\
&amp;amp;\geq \big(1 - \frac{2}{n}\big)\big(1 - \frac{2}{n-1}\big)...\big(1-\frac{2}{n-j}\big)...\big(1-\frac{2}{3}\big) \\
&amp;amp;= \big(\frac{n-2}{n}\big)\big(\frac{n-3}{n-1}\big)\big(\frac{n-4}{n-2}\big)...\big(\frac{3}{5}\big)\big(\frac{2}{4}\big)\big(\frac{1}{3}\big) \\
&amp;amp;= \big(\frac{\bcancel{n-2}}{n}\big)\big(\frac{\bcancel{n-3}}{n-1}\big)\big(\frac{\bcancel{n-4}}{\bcancel{n-2}}\big)...\big(\frac{\bcancel{3}}{\bcancel{5}}\big)\big(\frac{2}{\bcancel{4}}\big)\big(\frac{1}{\bcancel{3}}\big) \\
&amp;amp;= \frac{2}{n(n-1)}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Can we do better?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The probability of success, &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, we found so far is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p &amp;amp;\geq \frac{2}{n(n-1)} = \frac{1}{\binom{n}{2}}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Suppose we run &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; trials of Krager’s algorithm. We then take the minimum cut of all cuts found. These trials are independent. What is the probability of NOT getting the global minimum cut? It is the probability of failing in every trial. Let &lt;script type=&quot;math/tex&quot;&gt;F_i&lt;/script&gt; be the event that we failed to find the global minimum cut in iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(\text{Failure after } T \text{ trials}) &amp;amp;= Pr(F_1 \cap F_2 \cap ... \cap F_T) \\
&amp;amp;= Pr(F_1)Pr(F_2)...Pr(F_T) \text{  (by independence)}\\
&amp;amp;\leq \big(1-\frac{2}{n(n-1)} \big)^{T} \\
&amp;amp;= \big(1-\frac{1}{\binom{n}{2}} \big)^{T}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We also know that for any &lt;script type=&quot;math/tex&quot;&gt;x \geq 1&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\big (1-\frac{1}{x} \big)^x \leq \frac{1}{e}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Suppose we let &lt;script type=&quot;math/tex&quot;&gt;x = \frac{1}{p}&lt;/script&gt;, we see that&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
\big(1-\frac{1}{\binom{n}{2}} \big)^{\binom{n}{2}} \leq \frac{1}{e}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is exactly our expression above with &lt;script type=&quot;math/tex&quot;&gt;T = \binom{n}{2}&lt;/script&gt;. Furthermore, we can let &lt;script type=&quot;math/tex&quot;&gt;T = \ln(n)\binom{n}{2}&lt;/script&gt; to get&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
P(\text{Failure}) \leq \big(1-\frac{1}{\binom{n}{2}} \big)^{\ln(n)\binom{n}{2}} \leq \frac{1}{e}^{\ln(n)} = \frac{1}{n}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In general, if we want the probability of failure to be at most &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; then we need to set &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\ln(1/\delta)\frac{1}{p}&lt;/script&gt; in&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{Failure}) &amp;amp;\leq \big(1-p\big)^{T} \leq \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is because&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{Failure}) &amp;amp;\leq \big(1-p\big)^{\ln(1/\delta)\frac{1}{p}} \leq \frac{1}{e}^{\ln(1/\delta)} = \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Running Time&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; nodes and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges. In the naive implementation, we contract &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; edges until we reach a graph with 2 vertices. Every time we contract an edge, we need to create a new node and also correct all the edges connected to either end of the contracted edge. This could take &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. Therefore, the total running time is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. There are other faster implementations with union-find data structure that reduce the running time to &lt;script type=&quot;math/tex&quot;&gt;O(m * \alpha(n))&lt;/script&gt;. (TODO: More on this?)
&lt;br /&gt;
&lt;br /&gt;
Given that we can get a high success probability if we run Krager’s algorithm for &lt;script type=&quot;math/tex&quot;&gt;O(\log(n)n^2)&lt;/script&gt;. The total running time is therefore &lt;script type=&quot;math/tex&quot;&gt;O(n^4\log(n))&lt;/script&gt;!
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Can we do better than &lt;script type=&quot;math/tex&quot;&gt;O(n^4\log(n))&lt;/script&gt; and still maintain a high success probability? Krager and Stein published an improved result that’s much faster! 
&lt;br /&gt;
&lt;br /&gt;
Observe when running Krager’s algorithm is that the probability of picking the wrong edge (an edge from the edges crossing the cut, the set &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;) gets higher with every iteration. Therefore, we should really just run karger once in the first few iterations and then repeat Karger for the remaining nodes. 
&lt;br /&gt;
&lt;br /&gt;
This is what Karger-Stein’s algorithm is doing. We contract edges until we get &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. We then make copies of the graph and independently contract the edges again for each graph until we get to &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}/\sqrt{2}&lt;/script&gt;. We then return the minimum of both cuts. We repeat this process again until we reach 4 vertices and simply find the minimum cut by brute force. This is illustrated in the below graph:
&lt;img src=&quot;http://localhost:4000/assets/mincut/stein.png&quot; width=&quot;100%&quot; /&gt;
We also summarize it in the following pseudo-code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;brute&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Karger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cut1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cut2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minmum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein Running Time&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Karger-Stein is a recursive algorithm. At each level of the recursion, we perform Karger on &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; until we reach &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. Karger runs in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. Therefore, we have the following recurrence for the running time:&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
T(n) = 2T(n/\sqrt{2}) + O(n^2)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And therefore, the running time is &lt;script type=&quot;math/tex&quot;&gt;O(n^2\log(n))&lt;/script&gt; by the master theorem.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein Probability of Success&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Karger-Stein first contracts the graph from &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; vertices down to &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. Similar to the analysis we did earlier. The probability of success is the probability of not picking the wrong edges in any of the first &lt;script type=&quot;math/tex&quot;&gt;n-n/\sqrt{2}&lt;/script&gt; iterations. Therefore, combining all probabilities:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\require{cancel}
\begin{align*}
Pr(\text{success until } n/\sqrt{2}) &amp;amp;= Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-n\sqrt{2}} | S_1 \cap S_2 \cap ... \cap S_{n-n/\sqrt{2}}) \\
&amp;amp;\geq \big(1 - \frac{2}{n}\big)\big(1 - \frac{2}{n-1}\big)...\big(1-\frac{2}{n-j}\big)...\big(1-\frac{2}{n/\sqrt{2}+1}\big) \\
&amp;amp;= \big(\frac{n-2}{n}\big)\big(\frac{n-3}{n-1}\big)\big(\frac{n-4}{n-2}\big)...\big(\frac{n/\sqrt{2}}{n/\sqrt{2}+2}\big)\big(\frac{n/\sqrt{2}-1}{n/\sqrt{2}+1}\big) \\
&amp;amp;= \big(\frac{\bcancel{n-2}}{n}\big)\big(\frac{\bcancel{n-3}}{n-1}\big)\big(\frac{\bcancel{n-4}}{\bcancel{n-2}}\big)...\big(\frac{n/\sqrt{2}}{\bcancel{n/\sqrt{2}+2}}\big)\big(\frac{n/\sqrt{2}-1}{\bcancel{n/\sqrt{2}+1}}\big) \\
&amp;amp;= \frac{n/\sqrt{2}(n/\sqrt{2}-1)}{n(n-1)} \\
&amp;amp;= \frac{n(n-\sqrt{2})}{2n(n-1)} = \frac{n-\sqrt{2}}{2(n-1)} \approx \frac{1}{2}. \text{ (when n is large)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;If represent these probabilities with a binary tree then we know at each step we have a probability of &lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt; of picking the right path down to a leaf. Since we’re dividing by &lt;script type=&quot;math/tex&quot;&gt;\sqrt{2}&lt;/script&gt;, then we know that the depth of the tree is&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
\log_{\sqrt{2}}(n) = \frac{\log(n)}{\log(\sqrt{2})} = 2\log(n)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And the number of leaves is&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
2^{2\log(n)} = O(n^2)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;To find the overall probability of success, we need to find the probability of picking the right path from the root down to a leaf. Picking the right path means that at every step we pick the right edge. Suppose &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a vertex in this tree and let &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; be the height of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;p_d&lt;/script&gt; be the probability that there exists a path of surviving edges from &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; down to a leaf. Let &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; be the event that there exists a path of surviving edges in the left subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; be the event that there exists a path of surviving edges in the right subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We see that&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
p_d &amp;amp;= \frac{1}{2} * Pr(\text{there is at least one subtree with surviving edges}) \\
&amp;amp;= \frac{1}{2} * Pr(L \cup R) \\
&amp;amp;= \frac{1}{2} * (Pr(R) + Pr(L) - Pr(R \cap L)) \\
&amp;amp;= \frac{1}{2} * (Pr(R) + Pr(L) - Pr(R \cap L)) \\
&amp;amp;= \frac{1}{2} * (p_{d-1} + p_{d-1} - p_{d-1}^2) \\
&amp;amp;= p_{d-1} - \frac{1}{2}p_{d-1}^2 \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The claim is that &lt;script type=&quot;math/tex&quot;&gt;p_d \geq \frac{1}{d+1}&lt;/script&gt;. To see this, we need to prove this by induction by &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; for &lt;script type=&quot;math/tex&quot;&gt;d &gt; 0&lt;/script&gt;. 
&lt;br /&gt;
For the base case, the probability of finding a path of surviving edges when the height is 0 is 1. We also see that &lt;script type=&quot;math/tex&quot;&gt;p_0 \geq \frac{1}{0+1} = 1&lt;/script&gt; as we wanted to show.
&lt;br /&gt;
&lt;br /&gt;
For the inductive hypothesis, suppose it holds for &lt;script type=&quot;math/tex&quot;&gt;d-1&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;p_{d-1} \geq \frac{1}{d}&lt;/script&gt;. We will prove that it holds for &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;.&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
p_d &amp;amp;= p_{d-1} - \frac{1}{2}p_{d-1}^2 \\
&amp;amp;\geq \frac{1}{d} - \frac{1}{2}\frac{1}{d^2} \\
&amp;amp;\geq \frac{1}{d} - \frac{1}{d(d+1)} \quad \text{(} 1/d(d+1) \text{ is strictly greater than } 1/2d^2 \text { for } d \geq 1 \text{)} \\
&amp;amp;= \frac{1}{d+1}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Side Note: I don’t know how I would come up with replacing &lt;script type=&quot;math/tex&quot;&gt;1/d^2&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;1/d(d+1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Finally since the root of the tree has depth &lt;script type=&quot;math/tex&quot;&gt;2\log(n)&lt;/script&gt;, then we know that the probability of success is at least &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2\log(n)+1}&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein Improved Success Rate&lt;/b&gt;&lt;/h4&gt;

&lt;p&gt;But how many trials do we need in order to achieve the same success rate as Karger’s original algorithm (with repetition)? We know the probability of success is at least &lt;script type=&quot;math/tex&quot;&gt;p = \frac{1}{2\log(n)+1}&lt;/script&gt;. The probability of failing in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; trials (trials are independent) is the following if we set &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\ln(1/\delta)\frac{1}{p}&lt;/script&gt;&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{failure in }T \text{ trials}) &amp;amp;= (1 - p)^T \leq \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We arrived at this in the previous analysis of Karger’s algorithm. Therefore, we set &lt;script type=&quot;math/tex&quot;&gt;T = (2\log(n)+1)\ln(1/n)&lt;/script&gt; to get a probablity of failure to be at most &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{n}&lt;/script&gt;.
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;class notes from following:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs161/schedule.html&lt;/li&gt;
  &lt;li&gt;https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/11/Small11.pdf&lt;/li&gt;
  &lt;li&gt;http://web.stanford.edu/class/archive/cs/cs161/cs161.1172/CS161Lecture16.pdf&lt;/li&gt;
  &lt;li&gt;Algorithm Design (BEST BOOK)
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name></name></author><summary type="html">Let be an undirected graph with vertices and edges. A cut in is a partition of into two non-empty sets of vertices and . The size of the cut is the number of edges with one end point in and another in . A global minimum cut is a cut of minimum size. Karger's Algorithm Karger’s algorithm starts with picking an edge in uniformly at random. It then contracts this edge by creating a new node that combines both and . All the edges in with an end point equal to either and now point to instead. Also, any edge between and is deleted. It repeatedly contracts randomly picked edges until we have two vertices in the graph. We then return the number of edges between the two vertices as the global minimum cut in . Karger's Algorithm Pseudocode</summary></entry><entry><title type="html">Discrete Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html" rel="alternate" type="text/html" title="Discrete Random Variables" /><published>2019-08-25T07:01:36-07:00</published><updated>2019-08-25T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html">&lt;h4&gt;&lt;b&gt;Indicator/Bernoulli Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; for success and &lt;script type=&quot;math/tex&quot;&gt;1-p&lt;/script&gt; for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
X = \Big\{ \begin{array}{@{}lr@{}}
        1 \quad \text{If even A occurs } \\
        0 \quad \text{otherwise} \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1\}&lt;/script&gt;. Let’s look at the PMF of &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;. Remember that the PMF of a random variable is just the probability that this random variable takes on a value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;R_x&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}}
        p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\
        p(0) = 1 - P(A) \quad \text{if } x = 0 \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;What the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;? Recall that the expected value of a discrete random variable is defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = p(1)*1 + p(0)*0 = p(1) = P(A)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We also know the variance&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) = E[X^2] - (E[X])^2 = 1^2(p) + 0^2(1-p) - p^2 = p - p^2 = p(1-p)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Binomial Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;If we on the other hand have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; independent trials of Bernoulli random variables with a probability of success &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can use a binomial random variable to represent the number of successes in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. For example, if we are flipping a coin with probability of getting heads (success) equals to &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can define a binomial random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to represent the number of heads in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. 
&lt;br /&gt;
&lt;br /&gt;
Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt; and the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The expected value, variance and second moment of a binomial random variable:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= np \\
Var(X) &amp;amp;= np(1-p) \\
E[X^2] &amp;amp;= n^2p^2 - np^2 + np
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;&lt;br /&gt;
Suppose we flip a fair coin &lt;script type=&quot;math/tex&quot;&gt;4&lt;/script&gt; times. What is the probability of seeing exactly two heads.
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of heads. &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a binomial random variable with &lt;script type=&quot;math/tex&quot;&gt;n=4&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p=0.5&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(X=2) = \binom{4}{2}(0.5)^2(0.5)^2 = 0.375
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;&lt;br /&gt;
(Book Example). Suppose we have 12 jurors and in order to convict a defendant you need 8 jurors to vote guilty. Suppose the probability of making the right decision by a juror is &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. What is the probability of making a right decision?
&lt;br /&gt;
Suppose the defendant is guilty. This means that we need at least 8 jurors making the right the decision. Therefore, the probability is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;However if the defendant is innocent then we need at least 5 jurors making the right decision&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;If the defendant is guilty with probability &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt; then the probability becomes&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\alpha\sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i} + (1-\alpha)\sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Poisson Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Consider a duration of time where events occur at an average rate of &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of occurrences in a unit of time. We have &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt;. The PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Example 1: &lt;/b&gt;&lt;br /&gt;
Given a web server, suppose that the server load averages 2 hits per second. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of hits received in a second. What is &lt;script type=&quot;math/tex&quot;&gt;P(X=5)?&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Binomial and Poisson Random Variables&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;A Poisson random variable can also be used to approximate a binomial random variable if &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is very large and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is small so that &lt;script type=&quot;math/tex&quot;&gt;np&lt;/script&gt; is moderate. Let &lt;script type=&quot;math/tex&quot;&gt;\lambda = E[X] = np&lt;/script&gt; which is the average number of successes you see in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. Then we will have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\
&amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} \frac{(1-\lambda/n)^{n}}{(1-\lambda/n)^{k}} \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;When &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is very large, the term &lt;script type=&quot;math/tex&quot;&gt;n(n-1)...(n-k+1)/n^k&lt;/script&gt; is approximately 1. The term &lt;script type=&quot;math/tex&quot;&gt;(1-\lambda/n)^k&lt;/script&gt; is also approximately &lt;script type=&quot;math/tex&quot;&gt;1^k = 1&lt;/script&gt;. On the other hand we have &lt;script type=&quot;math/tex&quot;&gt;(1-\lambda/n)^{n} \approx e^{-\lambda}&lt;/script&gt;. So&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = k) &amp;amp;\approx \frac{\lambda^k}{k!}e^{-\lambda}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Expected Value and Variance of a Poisson Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Both the expected value and variance of a Poisson random variable is &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;. Intuitively, we know Poisson approximates a binomial random variable when &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is large and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is small with &lt;script type=&quot;math/tex&quot;&gt;\lambda = np&lt;/script&gt;. We also know that the expected value of a binomial random variable is &lt;script type=&quot;math/tex&quot;&gt;E[X] = np&lt;/script&gt;.  Therefore, the expected value of a Poisson random variable should be &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;. Similarly, to compute the variance, we know the binomial random variable variance is &lt;script type=&quot;math/tex&quot;&gt;np(1-p)&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;\lambda(1-p)&lt;/script&gt; when &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is very small is also &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;(Proof?)
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Geometric Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable for the number of trials until we see the first success. &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a geometric random variable with &lt;script type=&quot;math/tex&quot;&gt;PMF&lt;/script&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = (1-p)^{k-1}p
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; has the following expected value and variance&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= 1/p \\
Var(X) &amp;amp;= (1-p)/p^2
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The CDF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = P(X \leq k) &amp;amp;= \sum_{m=1}^k (1-p)^{m-1}p \\
&amp;amp;= p \sum_{m=0}^{k-1} (1-p)^{m} \\
&amp;amp;= p \frac{1-(1-p)^k}{1-(1-p)} \text{ (Recall }\sum_{i=0}^n x^i = \frac{1-x^{n+1}}{1-x}\text{)} \\
&amp;amp;= 1-(1-p)^k \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Another way to derive this is to let &lt;script type=&quot;math/tex&quot;&gt;C_i&lt;/script&gt; be the event where we succeed on the ith trial. We see that&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = P(X \leq k) &amp;amp;= 1 - P(X &amp;gt; k) \quad \text{ (first success happens after kth trial)}\\
&amp;amp;= 1 - P(C_1^c C_2^c ... C_k^c) \quad \text{ (none of 1..kth trial succeed)} \\
&amp;amp;= 1 - P(C_1^c)P(C_2^c) ... P(C_k^c) \quad \text{ (Independance)} \\
&amp;amp;= 1 - (1-p)^k 
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Negative Binomial Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the number of independent trials until the &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;th success.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \binom{k-1}{r-1}p^r(1-p)^{k-r}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; has the following expected value and variance&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= rp/(1-p) \\
Var(X) &amp;amp;= r(1-p)/p^2
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;References&lt;/h4&gt;
&lt;p&gt;My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/&lt;br /&gt;
First Course in Probability by Sheldon Ross.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Indicator/Bernoulli Random Variable If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability for success and for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following: $$ \begin{align*} X = \Big\{ \begin{array}{@{}lr@{}} 1 \quad \text{If even A occurs } \\ 0 \quad \text{otherwise} \\ \end{array} \end{align*} $$ Therefore, . Let’s look at the PMF of . Remember that the PMF of a random variable is just the probability that this random variable takes on a value in . Therefore, $$ \begin{align*} p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}} p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\ p(0) = 1 - P(A) \quad \text{if } x = 0 \\ \end{array} \end{align*} $$ What the expected value of ? Recall that the expected value of a discrete random variable is defined as $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ Therefore, $$ \begin{align*} E[X] = p(1)*1 + p(0)*0 = p(1) = P(A) \end{align*} $$ We also know the variance $$ \begin{align*} Var(X) = E[X^2] - (E[X])^2 = 1^2(p) + 0^2(1-p) - p^2 = p - p^2 = p(1-p) \end{align*} $$ Binomial Random Variable If we on the other hand have independent trials of Bernoulli random variables with a probability of success , then we can use a binomial random variable to represent the number of successes in trials. For example, if we are flipping a coin with probability of getting heads (success) equals to , then we can define a binomial random variable to represent the number of heads in trials. Therefore, and the PMF of is: $$ \begin{align*} p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k} \end{align*} $$ The expected value, variance and second moment of a binomial random variable: $$ \begin{align*} E[X] &amp;amp;= np \\ Var(X) &amp;amp;= np(1-p) \\ E[X^2] &amp;amp;= n^2p^2 - np^2 + np \end{align*} $$ Example 1 Suppose we flip a fair coin times. What is the probability of seeing exactly two heads. Let be the number of heads. is a binomial random variable with and . Therefore, $$ \begin{align*} p(X=2) = \binom{4}{2}(0.5)^2(0.5)^2 = 0.375 \end{align*} $$ Example 2 (Book Example). Suppose we have 12 jurors and in order to convict a defendant you need 8 jurors to vote guilty. Suppose the probability of making the right decision by a juror is . What is the probability of making a right decision? Suppose the defendant is guilty. This means that we need at least 8 jurors making the right the decision. Therefore, the probability is $$ \begin{align*} \sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i} \end{align*} $$ However if the defendant is innocent then we need at least 5 jurors making the right decision $$ \begin{align*} \sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i} \end{align*} $$ If the defendant is guilty with probability then the probability becomes $$ \begin{align*} \alpha\sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i} + (1-\alpha)\sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i} \end{align*} $$ Poisson Random Variable Consider a duration of time where events occur at an average rate of . Let be the number of occurrences in a unit of time. We have . The PMF of is: $$ \begin{align*} p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda} \end{align*} $$ Example 1: Given a web server, suppose that the server load averages 2 hits per second. Let be the number of hits received in a second. What is $$ \begin{align*} P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361 \end{align*} $$ Binomial and Poisson Random Variables A Poisson random variable can also be used to approximate a binomial random variable if is very large and is small so that is moderate. Let which is the average number of successes you see in trials. Then we will have $$ \begin{align*} P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\ &amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} \frac{(1-\lambda/n)^{n}}{(1-\lambda/n)^{k}} \\ \end{align*} $$ When is very large, the term is approximately 1. The term is also approximately . On the other hand we have . So $$ \begin{align*} P(X = k) &amp;amp;\approx \frac{\lambda^k}{k!}e^{-\lambda} \end{align*} $$ Expected Value and Variance of a Poisson Random Variable Both the expected value and variance of a Poisson random variable is . Intuitively, we know Poisson approximates a binomial random variable when is large and is small with . We also know that the expected value of a binomial random variable is . Therefore, the expected value of a Poisson random variable should be . Similarly, to compute the variance, we know the binomial random variable variance is and so when is very small is also .</summary></entry></feed>