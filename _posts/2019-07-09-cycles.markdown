---
layout: post
title:  "Cycles in Graphs"
date:   2019-07-09 12:01:36 -0700
categories: jekyll update
mathjax: true
---
<!--
<b>0 References</b><br>
?
<br>
<br>
<hr>
<br>
-->

<b>1 Introduction</b>
<br>
![my photo]({{ site.url }}/assets/cycle/1.png)

We are given a graph $$G = (V,E)$$ and we want to know if there exists a cycle in $$G$$. 

<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>2 Undirected Graphs</b>
<br>
<br>
This is extremely simple. We already keep track of nodes visited so far. If it happens during our search that we come across a visited node then we're done! there must exists a cycle otherwise, we won't ever re-visit any vertex in $$G$$. 
{% highlight c++ %}
bool bfs(int start, std::vector<std::vector<int>>& graph) {
    std::queue<int> q;
    q.push(start);
    std::vector<int> visited(graph.size(), false);
    visited[start] = true;
    while (!q.empty()) {
        int v = q.front();
        q.pop();
        for (int i = 0; i < graph[v].size(); i++) {
            int u = graph[v][i];
            if (visited[u] == false) {
                q.push(u);
                visited[u] = true;
            } else {
                // CYCLE
                return true;
            }
        }
    }
    return false;
}
{% endhighlight %}
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>3 Directed Graph</b>
<br>
<br>
In a typical DFS, we assign a start time to a node and then traverse all the nodes that it can reach and then at the very end when we have visited all the nodes possible, we mark it's end time. Let's traverse the above graph starting at node $$b$$. We will mark its start time. Say we visit $$c$$ next. We will also mark its start time and then visit $$d$$ and mark its start time. from $$d$$ we will visit $$e$$ and again mark its start time. From $$e$$ we will visit $$c$$. At this point, we know we've already seen $$c$$ and marked c's start time (it's not null). In a typical DFS, we would see that $$e$$ doesn't have any other unvisited neighbors and mark $$e$$'s finish time. We will end up with the below graph:
<br>
<br>
![my photo]({{ site.url }}/assets/cycle/3.png)



Let's go back to the moment when we marked $$e$$'s start time and we saw $$c$$. What does this mean for $$e$$ and $$c$$? Let's recall that the paranthesis theorem (CLRS) says that for any pair of nodes, in this case $$c$$ and $$e$$, one of three cases can happen:
- the intervals [c.start_time, c.finish_time] and [e.start_time, e.finish_time] are disjoint and neither $$c$$ or $$e$$ is a descendant of the other in the depth-first forest. This doesn't apply as the intervals are not disjoint.

- the interval [c.start_time, c.finish_time] is contained within the interval [e.start_time, e.finish_time] and $$c$$
is a descendant of $$e$$ in the depth-first tree. This doesn't apply either (above graph).

- the interval [e.start_time, e.finish_time] is contained within the interval [c.start_time, c.finish_time] and $$e$$ is a descendant of $$c$$ in the depth-first tree. Aha! this one applies!

Only the third case applies and we can conclude that $$e$$ must be a descendant of node $$c$$.  


let's use colors. All nodes will be colored black initially. When we visit a node for the first time, we will color it gray. When we're done visiting all the reachable nodes, we will mark it done by coloring it white.


![my photo]({{ site.url }}/assets/cycle/2.png)

{% highlight c++ %}
void dfs(graph& g, int v, int *color) {
    color[v] = gray;
    for (auto i = 0; i < g[v].size(); i++) {
        int u = g[v][i];
        if (color[u] == white) {
            dfs(g, u, color);
        } else if (color[u] == gray) {
            // CYCLE
        }
    }
    // we are done with the node for good
    color[v] = black;
}
{% endhighlight %}

<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>4 Proof</b>
<br>

<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>5 Implementations</b>
<br>
<br>
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/cycles
<br>
<br>


