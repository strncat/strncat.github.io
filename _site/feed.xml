<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-09-13T17:07:20-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Groups</title><link href="http://localhost:4000/jekyll/update/2019/09/07/groups.html" rel="alternate" type="text/html" title="Groups" /><published>2019-09-07T07:01:36-07:00</published><updated>2019-09-07T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/07/groups</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/07/groups.html">&lt;!-------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Abstract Algebra: An Introduction, 3rd Edition by Thomas W. Hungerford.&lt;/li&gt;
  &lt;li&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Definition&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A group is a nonempty set of elements with a binary operation that satisfies four properties&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;i&gt;Closure&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a, b \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * b \in G&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Associativity&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a, b, c \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * (b * c) = (a * b) * c&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Identity&lt;/i&gt;: There exists an identity element &lt;script type=&quot;math/tex&quot;&gt;e \in G&lt;/script&gt; such that for any &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * e = e * a = a&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;i&gt;Inverse&lt;/i&gt;: For all &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, there exists an inverse element &lt;script type=&quot;math/tex&quot;&gt;a^{-1} \in G&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a * a^{-1} = a^{-1} * a = e&lt;/script&gt;.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Moreover, if the group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; satisfies commutativity so that for all &lt;script type=&quot;math/tex&quot;&gt;a, b \in G&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a * b = b * a&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; is an &lt;b&gt;abelian&lt;/b&gt; group. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Order of an Element&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Given a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and an element &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, the order of the element &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;|a|&lt;/script&gt;, is the smallest positive integer &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a^k = e&lt;/script&gt;. If there is no such element then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; has an infinite order.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Example:&lt;/i&gt; 
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Properties of Groups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Given a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;, we must have the following&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; has a unique identity element.&lt;/li&gt;
  &lt;li&gt;For every &lt;script type=&quot;math/tex&quot;&gt;a \in G&lt;/script&gt;, there exists a unique inverse &lt;script type=&quot;math/tex&quot;&gt;a^{-1}&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a * a^{-1} = a^{-1} * a = e&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof&lt;/b&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;!-------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Subgroups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A subset &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; of a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a &lt;b&gt;subgroup&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is a group under &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;’s operation. We write it as &lt;script type=&quot;math/tex&quot;&gt;H \subseteq G&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;H \neq G&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is a &lt;b&gt;proper subgroup&lt;/b&gt; of &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; and we write &lt;script type=&quot;math/tex&quot;&gt;H \subset G&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Example:&lt;/i&gt; The set &lt;script type=&quot;math/tex&quot;&gt;L=\{1,-1,i,-i\}&lt;/script&gt; is a proper subgroup of &lt;script type=&quot;math/tex&quot;&gt;C^*&lt;/script&gt;, the multiplicative group of complex numbers.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Theorem:&lt;/i&gt; A nonempty subset &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; of a group &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a subgroup if &lt;br /&gt;
(i) for all &lt;script type=&quot;math/tex&quot;&gt;a, b \in H&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;ab \in H&lt;/script&gt;. &lt;br /&gt;
(ii) for all &lt;script type=&quot;math/tex&quot;&gt;a \in H&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a^{-1} \in H&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Proof: &lt;br /&gt;
The closure property is satisfied by (i). Since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a group then we know associativity holds for all elements including elements in &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt;. The inverse exists by (ii). For the identity element, since &lt;script type=&quot;math/tex&quot;&gt;H&lt;/script&gt; is not empty then we must have some element &lt;script type=&quot;math/tex&quot;&gt;a \in H&lt;/script&gt;. We also must have &lt;script type=&quot;math/tex&quot;&gt;a^{\prime} \in H&lt;/script&gt; by the inverse property. Therefore, we must have &lt;script type=&quot;math/tex&quot;&gt;aa^{-1} = e \in H&lt;/script&gt; by the closure property. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 10px 10px 7px 10px;&quot;&gt;
&lt;b&gt;Subgroups&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">References Abstract Algebra: An Introduction, 3rd Edition by Thomas W. Hungerford. Definition A group is a nonempty set of elements with a binary operation that satisfies four properties Closure: For all , we have . Associativity: For all , we have . Identity: There exists an identity element such that for any , we have . Inverse: For all , there exists an inverse element such that .</summary></entry><entry><title type="html">Expectation</title><link href="http://localhost:4000/jekyll/update/2019/09/06/expectation.html" rel="alternate" type="text/html" title="Expectation" /><published>2019-09-06T07:01:36-07:00</published><updated>2019-09-06T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/06/expectation</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/06/expectation.html">&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Expectation&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Recall that the expectation or expected value of a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is defined as:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the expected value is a weighted average of the value of the random variable (weighted by their probabilities). We also studied important properties of expectation&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Linearity of expectation:&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c
\end{align*}
$$
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a random variable, then for any real-valued function &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;,&lt;/li&gt;
&lt;/ul&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[g(X)] &amp;amp;= \sum_ig(x_i)p(x_i)
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Nth Moment&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Define the &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;th moment of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[X^n] &amp;amp;= \sum_{x:p(x)&amp;gt;0} x^np(x)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;From this, we see that the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the first moment of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;.
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#DAF5F4; padding: 20px 20px 7px 20px;&quot;&gt;
&lt;h3&gt;Variance&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
While the expected value is really useful, we also want to study the spread of the values of random variables. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable with expected value &lt;script type=&quot;math/tex&quot;&gt;E[X]=\mu&lt;/script&gt; and define the variance of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) = E[(X - \mu)^2]
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Expanding this&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) &amp;amp;= E[(X - \mu)^2] \\
&amp;amp;= \sum_i (x_i - \mu)^2p(x_i) \\
&amp;amp;= \sum_i (x_i^2 - 2\mu x_i + \mu^2)p(x_i) \\
&amp;amp;= \sum_i x_i^2p(x_i) - 2\mu x_ip(x_i) + \mu^2p(x_i) \\
&amp;amp;= \sum_i x_i^2p(x_i) - 2\mu \sum_i x_ip(x_i) + \mu^2 \sum_ip(x_i) \\
&amp;amp;= E[X^2] - 2\mu^2 + \mu^2 \\
&amp;amp;= E[X^2] - (E[X])^2 \\
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ Expectation Recall that the expectation or expected value of a random variable is defined as: $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ In other words, the expected value is a weighted average of the value of the random variable (weighted by their probabilities). We also studied important properties of expectation Linearity of expectation: $$ \begin{align*} E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c \end{align*} $$ If is a random variable, then for any real-valued function , $$ \begin{align*} E[g(X)] &amp;amp;= \sum_ig(x_i)p(x_i) \end{align*} $$ Nth Moment Define the th moment of to be $$ \begin{align*} E[X^n] &amp;amp;= \sum_{x:p(x)&amp;gt;0} x^np(x) \end{align*} $$ From this, we see that the expected value of is the first moment of . Variance While the expected value is really useful, we also want to study the spread of the values of random variables. Let be a random variable with expected value and define the variance of to be $$ \begin{align*} Var(X) = E[(X - \mu)^2] \end{align*} $$ Expanding this $$ \begin{align*} Var(X) &amp;amp;= E[(X - \mu)^2] \\ &amp;amp;= \sum_i (x_i - \mu)^2p(x_i) \\ &amp;amp;= \sum_i (x_i^2 - 2\mu x_i + \mu^2)p(x_i) \\ &amp;amp;= \sum_i x_i^2p(x_i) - 2\mu x_ip(x_i) + \mu^2p(x_i) \\ &amp;amp;= \sum_i x_i^2p(x_i) - 2\mu \sum_i x_ip(x_i) + \mu^2 \sum_ip(x_i) \\ &amp;amp;= E[X^2] - 2\mu^2 + \mu^2 \\ &amp;amp;= E[X^2] - (E[X])^2 \\ \end{align*} $$</summary></entry><entry><title type="html">Counting Distinguishable and Indistinguishable Objects</title><link href="http://localhost:4000/jekyll/update/2019/09/05/counting-dist.html" rel="alternate" type="text/html" title="Counting Distinguishable and Indistinguishable Objects" /><published>2019-09-05T07:01:36-07:00</published><updated>2019-09-05T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/09/05/counting-dist</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/09/05/counting-dist.html">&lt;h3&gt;References&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;b&gt;(1) k distinguishable strings and n distinguishable buckets&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Label the strings &lt;script type=&quot;math/tex&quot;&gt;s_1, s_2,...,s_k&lt;/script&gt; and label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from. &lt;script type=&quot;math/tex&quot;&gt;s_2&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from and so. Therefore, the total number of choices is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n^k
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;(2) k distinguishable strings and n distinguishable buckets with at most 1 string in each bucket&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Assuming &lt;script type=&quot;math/tex&quot;&gt;k \leq n&lt;/script&gt; (otherwise it is impossible). Label the strings &lt;script type=&quot;math/tex&quot;&gt;s_1, s_2,...,s_k&lt;/script&gt; and label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; choices of buckets to choose from. &lt;script type=&quot;math/tex&quot;&gt;s_2&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; choices of buckets to choose from because it can’t go to the bucket that &lt;script type=&quot;math/tex&quot;&gt;s_1&lt;/script&gt; chose. Similarly, &lt;script type=&quot;math/tex&quot;&gt;s_3&lt;/script&gt; has &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; and so on. Therefore, the total number of choices is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
n(n-1) ... (n-k+1) = \binom{n}{k} * k!
\end{align*}
$$
&lt;/div&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;(3) k indistinguishable strings and n distinguishable buckets&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Label the buckets &lt;script type=&quot;math/tex&quot;&gt;b_1, b_2,...,b_n&lt;/script&gt; and line them up below:
&lt;img src=&quot;http://localhost:4000/assets/counting/0a.png&quot; alt=&quot;my photo&quot; /&gt;
The strings are indistinguishable. We want to distribute them among the buckets so for example we could have the following:
&lt;img src=&quot;http://localhost:4000/assets/counting/0b.png&quot; alt=&quot;my photo&quot; /&gt;
To simplify the problem, let’s pretend that they are distinguishable and instead of buckets we’ll use dividers to separate the strings into different buckets. This way the first set of strings are in bucket 1, the second set after the first divider are in bucket 2 and so on. We’ll use colors to distinguish them. We will only need &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; dividers to create &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; groups.
&lt;br /&gt;
&lt;br /&gt;
To visualize this, suppose &lt;script type=&quot;math/tex&quot;&gt;n=4&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;k=5&lt;/script&gt;. In the below figure, we have &lt;script type=&quot;math/tex&quot;&gt;\{s_1,s_2\}&lt;/script&gt; in the first bucket. &lt;script type=&quot;math/tex&quot;&gt;\{s_3\}&lt;/script&gt; in the second bucket. &lt;script type=&quot;math/tex&quot;&gt;\{s_4,s_5\}&lt;/script&gt; in the third bucket. The forth bucket is empty.
&lt;img src=&quot;http://localhost:4000/assets/counting/1.png&quot; alt=&quot;my photo&quot; /&gt;
How many possible permutions are there? We have &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; dividers and &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings so&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
(n+k-1)!
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Now, since strings are really indistinguishable, let’s remove the labels. We also don’t need the colors because we’re assuming the first set of strings goes to the first bucket, the second set goes to the second bucket and so on. So we’ll have something like this:
&lt;img src=&quot;http://localhost:4000/assets/counting/2.png&quot; alt=&quot;my photo&quot; /&gt;
To remove the unnecessary ordering, we divide by &lt;script type=&quot;math/tex&quot;&gt;k!&lt;/script&gt; and also divide by &lt;script type=&quot;math/tex&quot;&gt;(n-1)!&lt;/script&gt;. Therefore, the final answer is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\frac{(n+k-1)!}{k!(n-1)!} = \binom{n+k-1}{n-1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Note that solution can be applied to other interesting examples like finding the number of integer solutions to &lt;script type=&quot;math/tex&quot;&gt;x_1+x_2+...+x_k=n&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;(4) k indistinguishable strings and n distinguishable buckets with at most 1 string in each bucket&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;In case (2), we saw that the number of ways to put &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; distinguishable strings into &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; distinguishable buckets with at most 1 string in each bucket is &lt;script type=&quot;math/tex&quot;&gt;\binom{n}{k} * k!&lt;/script&gt;. In this case, the strings are indistinguishable so we don’t care about the order of strings and so we divide by &lt;script type=&quot;math/tex&quot;&gt;k!&lt;/script&gt;. The final answer therefore is simply&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\binom{n}{k}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">References Personal study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ (1) k distinguishable strings and n distinguishable buckets Label the strings and label the buckets . has choices of buckets to choose from. has choices of buckets to choose from and so. Therefore, the total number of choices is $$ \begin{align*} n^k \end{align*} $$ (2) k distinguishable strings and n distinguishable buckets with at most 1 string in each bucket Assuming (otherwise it is impossible). Label the strings and label the buckets . has choices of buckets to choose from. has choices of buckets to choose from because it can’t go to the bucket that chose. Similarly, has and so on. Therefore, the total number of choices is $$ \begin{align*} n(n-1) ... (n-k+1) = \binom{n}{k} * k! \end{align*} $$ (3) k indistinguishable strings and n distinguishable buckets Label the buckets and line them up below: The strings are indistinguishable. We want to distribute them among the buckets so for example we could have the following: To simplify the problem, let’s pretend that they are distinguishable and instead of buckets we’ll use dividers to separate the strings into different buckets. This way the first set of strings are in bucket 1, the second set after the first divider are in bucket 2 and so on. We’ll use colors to distinguish them. We will only need dividers to create groups. To visualize this, suppose and . In the below figure, we have in the first bucket. in the second bucket. in the third bucket. The forth bucket is empty. How many possible permutions are there? We have dividers and strings so $$ \begin{align*} (n+k-1)! \end{align*} $$ Now, since strings are really indistinguishable, let’s remove the labels. We also don’t need the colors because we’re assuming the first set of strings goes to the first bucket, the second set goes to the second bucket and so on. So we’ll have something like this: To remove the unnecessary ordering, we divide by and also divide by . Therefore, the final answer is $$ \begin{align*} \frac{(n+k-1)!}{k!(n-1)!} = \binom{n+k-1}{n-1} \end{align*} $$ Note that solution can be applied to other interesting examples like finding the number of integer solutions to . (4) k indistinguishable strings and n distinguishable buckets with at most 1 string in each bucket In case (2), we saw that the number of ways to put distinguishable strings into distinguishable buckets with at most 1 string in each bucket is . In this case, the strings are indistinguishable so we don’t care about the order of strings and so we divide by . The final answer therefore is simply $$ \begin{align*} \binom{n}{k} \end{align*} $$</summary></entry><entry><title type="html">Conditional Probability</title><link href="http://localhost:4000/jekyll/update/2019/08/29/conditional-probability.html" rel="alternate" type="text/html" title="Conditional Probability" /><published>2019-08-29T07:01:36-07:00</published><updated>2019-08-29T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/29/conditional-probability</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/29/conditional-probability.html">&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
(1) My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/&lt;br /&gt;
(2) First Course in Probability by Sheldon Ross.
&lt;br /&gt;
&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Conditional Probability&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/condprob/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
Conditional probability is the probability that event &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; occurs given that event &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; has already occured written as &lt;script type=&quot;math/tex&quot;&gt;P(E|F)&lt;/script&gt;. In this case:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The &lt;b&gt;sample space&lt;/b&gt; consists of all possible outcomes consistent with &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; (events in &lt;script type=&quot;math/tex&quot;&gt;S \cap F&lt;/script&gt;).&lt;/li&gt;
  &lt;li&gt;The &lt;b&gt;event space&lt;/b&gt; consists of all possible outcomes in &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; that are consistent with &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; (events in &lt;script type=&quot;math/tex&quot;&gt;E \cap F&lt;/script&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefore, we have in general&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E|F) = \frac{p(E \cap F)}{p(F)} = \frac{p(EF)}{p(F)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And for equally likely outcomes:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E|F) = \frac{|EF|}{|F|} = \frac{|EF|/|S|}{|F|/|S|} = \frac{p(EF)}{p(F)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Chain Rule&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
From the conditional probability law, we can derive the chain rule!&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(EF) = P(E|F)P(F) = P(F|E)P(E)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And in general if we have multiple events:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E_1E_2...E_n) = P(E_1)P(E_2|E_1)...P(E_n|E_1E_2...E_{n-1})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
Suppose we have an urn with 8 red balls and 4 white balls. What is the probability of choosing two balls that are both red (without replacement). (Source: A First Course in Probability)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E_1&lt;/script&gt; to be the event that the first ball is red. &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E_2&lt;/script&gt; to be the event that the second ball is red. &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E_1E_2) = P(E_1)P(E_2|E_1) = \frac{8}{12}\frac{7}{11} = \frac{14}{33}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Law of Total Probability&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E) &amp;amp;= P(EF) + P(EF^c) \\
P(E) &amp;amp;= P(F)P(E|F) + P(F^c)P(E|F^c) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In general:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(E) &amp;amp;= \sum_i^n P(F_i)P(E|F_i)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The law of total probability says that the probability of event &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; is now a weighted average of the conditional probability of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; given event &lt;script type=&quot;math/tex&quot;&gt;F_1&lt;/script&gt; plus the conditional probability of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; given event &lt;script type=&quot;math/tex&quot;&gt;F_2&lt;/script&gt; and so on. Note that these events &lt;script type=&quot;math/tex&quot;&gt;F_i&lt;/script&gt; must be mutually exclusive. Moreover, &lt;script type=&quot;math/tex&quot;&gt;\sum_iP(F_i) = 1&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
Suppose 25% of students are juniors. Suppose now that if a student is a junior then the probability of being a CS major is 30%, while if a student is not a junior then the probability of being a CS major is 20%. What is the probability of being a CS major? (Class Example)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;CS&lt;/script&gt; to be the event that a student is a CS major. &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;J&lt;/script&gt; to be the event that a student is a junior. &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(CS) &amp;amp;= P(CS | J)P(J) + P(CS | J^c)P(J^c) \\
&amp;amp;= 0.30*0.25 + 0.20*0.75 = 0.225
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Bayes' Theorem&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Common Form:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Expanded Form:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E|F)P(F) + P(E|F^c)P(F^c)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example:&lt;/b&gt;
&lt;br /&gt;
A test is 98% effective at detecting HIV. The test has a false positive rate of 1%. 0.5% of the US population has HIV. What is the probability that you have HIV given that you tested positive? (class example)
&lt;br /&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; be that you test positive for HIV with the test&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; be that you actually have HIV. &lt;br /&gt;
We want to find &lt;script type=&quot;math/tex&quot;&gt;P(F|E)&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
First, the probability that the test is positive given that you actually have HIV is 0.98 (true positive). In terms of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;, this is &lt;script type=&quot;math/tex&quot;&gt;P(E|F)=0.98&lt;/script&gt;. Similarly, the probability that we get a false positive is 0.01. In terms of &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;, this probability is &lt;script type=&quot;math/tex&quot;&gt;P(E|F^c)&lt;/script&gt;,&lt;/p&gt;

&lt;p&gt;We can now use Bayes’&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(F|E) &amp;amp;= \frac{P(E|F)P(F)}{P(E|F)P(F) + P(E|F^c)P(F^c)} \\
&amp;amp;= \frac{(0.98)(0.005)}{(0.98)(0.005) + (0.01)(0.995)} = 0.330
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!----------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#E0E0F8; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;The Monty Hall Problem&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have 3 doors. Behind one of the three doors a prize. We choose a door. The host then opens one of the remaining doors that reveals nothing. We are now given the chance to switch our door with the remaining door. Do we switch?
&lt;br /&gt;
&lt;br /&gt;
We want to compare &lt;script type=&quot;math/tex&quot;&gt;P(win)&lt;/script&gt; vs &lt;script type=&quot;math/tex&quot;&gt;P(win|switch)&lt;/script&gt;. We know that if stick with our door, &lt;script type=&quot;math/tex&quot;&gt;P(win)=1/3&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Suppose without the loss of generality that we picked door &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. What is the probability that we win given that we switched? Let’s consider what happens if we switch in each case. 
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;A, B&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; be the events that the prize is behind each door respectively. All three doors are equally likely and so each door has a probability of &lt;script type=&quot;math/tex&quot;&gt;1/3&lt;/script&gt;. Moreover, these events are mutually exlusive since the prize can be behind exactly one door. Also the probability of these events sum up to 1. 
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;:&lt;br /&gt;
In this case the host will open either door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. We will switch and lose. So, &lt;script type=&quot;math/tex&quot;&gt;P(win | \text {switch to B/C}) = 0&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;:&lt;br /&gt;
In this case the host will open door &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. We switch and we win! &lt;script type=&quot;math/tex&quot;&gt;P(win| \text {switch to C})=1&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Prize behind door &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;:&lt;br /&gt;
In this case the host will open door &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. We switch and we win! &lt;script type=&quot;math/tex&quot;&gt;P(win| \text {switch to B})=1&lt;/script&gt;.
&lt;br /&gt;
Using the law of total probability:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(win|switch) &amp;amp;= p(win|\text{switch to A})*P(A) + P(win| \text{switch to B}) + P(win | \text{switch to C})P(C) \\
&amp;amp;= 0(1/3) + 1(1/3) + 1(1/3) = 2/3
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References (1) My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ (2) First Course in Probability by Sheldon Ross. Conditional Probability Conditional probability is the probability that event occurs given that event has already occured written as . In this case: The sample space consists of all possible outcomes consistent with (events in ). The event space consists of all possible outcomes in that are consistent with (events in ).</summary></entry><entry><title type="html">Karger’s Minimum Cut</title><link href="http://localhost:4000/jekyll/update/2019/08/28/min-cut.html" rel="alternate" type="text/html" title="Karger's Minimum Cut" /><published>2019-08-28T03:01:36-07:00</published><updated>2019-08-28T03:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/28/min-cut</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/28/min-cut.html">&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/mincut/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;class notes from following:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs161/schedule.html&lt;/li&gt;
  &lt;li&gt;https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/11/Small11.pdf&lt;/li&gt;
  &lt;li&gt;http://web.stanford.edu/class/archive/cs/cs161/cs161.1172/CS161Lecture16.pdf&lt;/li&gt;
  &lt;li&gt;Algorithm Design (BEST BOOK)
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;&lt;b&gt;Introduction&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be an undirected graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. A cut in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is a partition of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; into two non-empty sets of vertices &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. The &lt;b&gt;size&lt;/b&gt; of the cut is the number of edges with one end point in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and another in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. A &lt;b&gt;global minimum cut&lt;/b&gt; is a cut of minimum size.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger's Algorithm&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Karger’s algorithm starts with picking an edge &lt;script type=&quot;math/tex&quot;&gt;(u,v)&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; uniformly at random. It then &lt;b&gt;contracts&lt;/b&gt; this edge by creating a new node &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; that combines both &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. All the edges in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with an end point equal to either &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; now point to &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; instead. Also, any edge between &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is deleted. It repeatedly contracts randomly picked edges until we have two vertices in the graph. We then return the number of edges between the two vertices as the global minimum cut in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger's Algorithm Pseudocode&lt;/b&gt;&lt;/h4&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;karger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Initially&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;G&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;choose&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;an&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uniformly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;w&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;w&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;union&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sets&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Example&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we apply the contraction algorithm on the above graph. We start by picking an edge uniformly at random. Suppose we picked the edge &lt;script type=&quot;math/tex&quot;&gt;(d,e)&lt;/script&gt; below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/2.png&quot; width=&quot;100%&quot; /&gt;
We then delete &lt;script type=&quot;math/tex&quot;&gt;(d,e)&lt;/script&gt;. We create a new node &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;. We then point any edge that previously had an end point equal to &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; to point at &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/mincut/3.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/4.png&quot; width=&quot;100%&quot; /&gt;
We delete &lt;script type=&quot;math/tex&quot;&gt;(a,b)&lt;/script&gt; and create node &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; and fix all the old edges pointing at &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; to point at &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/mincut/5.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(f,g)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/6.png&quot; width=&quot;100%&quot; /&gt;
We’ll repeat the same process by creating &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and fixing the edges below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/7.png&quot; width=&quot;100%&quot; /&gt;
Suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(z,x)&lt;/script&gt; next.
&lt;img src=&quot;http://localhost:4000/assets/mincut/8.png&quot; width=&quot;100%&quot; /&gt;
We’ll again delete the edge, create a new node &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; and fix all the edges below:
&lt;img src=&quot;http://localhost:4000/assets/mincut/9.png&quot; width=&quot;100%&quot; /&gt;
Finally, suppose we pick &lt;script type=&quot;math/tex&quot;&gt;(y,c)&lt;/script&gt; and repeat the same steps. 
&lt;img src=&quot;http://localhost:4000/assets/mincut/10.png&quot; width=&quot;100%&quot; /&gt;
Since we only have 2 vertices then we’re done. We will return the number of edges between the two vertices which is 1 in this case. So the global minimum cut is of size 1 which is correct for this graph.
&lt;img src=&quot;http://localhost:4000/assets/mincut/11.png&quot; width=&quot;100%&quot; /&gt;
Suppose however that instead of picking &lt;script type=&quot;math/tex&quot;&gt;(y,c)&lt;/script&gt; to contract, we picked &lt;script type=&quot;math/tex&quot;&gt;(y,w)&lt;/script&gt;
&lt;img src=&quot;http://localhost:4000/assets/mincut/10a.png&quot; width=&quot;100%&quot; /&gt;
We will end up with a global minimum cut of size 2 instead which is not correct for this graph! This is why Krager’s algorithm is a Monte Carlo algorithm.
&lt;img src=&quot;http://localhost:4000/assets/mincut/11a.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Probability of Success&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we have a graph &lt;script type=&quot;math/tex&quot;&gt;G=(E,V)&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; nodes and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges. Suppose the cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt; is a global minimum cut is of size &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. Also let &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; to be the set of &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; edges in the cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt;. So &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; has the edges that have one end point in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and the other end point in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
The probability that the contraction algorithm succeeds is the probability that we don’t make any mistake in the &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; iterations of the algorithm. Suppose we let &lt;script type=&quot;math/tex&quot;&gt;S_i&lt;/script&gt; to be the event that we don’t make a mistake in step &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; or generally succeed in step &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. We want to calculate the following probability:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(success) = Pr(S_1 \cap S_2 \cap S_3 \cap ... \cap S_{n-2})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;These events are not independent! We can further expand this using the chain rule and instead calculate:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(success) = Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-2} | S_1 \cap S_2 \cap ... \cap S_{n-3})
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Success in the iteration 1:&lt;/b&gt;&lt;br /&gt;
Let’s look at how we can calculate each of these. What does it mean to not make a mistake in step 1? It means that we don’t pick an edge that connects a vertex from the set &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to a vertex from the set &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. Because if we did, then &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; will be merged together and we will not be able to return the global minimum cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt;. So we basically want to avoid picking edges from &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;. Therefore, the probability that we don’t make a mistake in step 1 is
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_1) = 1 - \frac{|F|}{|E|} = 1 - \frac{k}{|E|}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;What is &lt;script type=&quot;math/tex&quot;&gt;|E|&lt;/script&gt;? &lt;br /&gt;
We will use &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; to find an upper bound on &lt;script type=&quot;math/tex&quot;&gt;|E|&lt;/script&gt;. We know that the global minimum cut is of size &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;, therefore, we must have:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;For any node &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;degree(v) \geq k&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof: Suppose not, then there exists some node &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
degree(u) &lt; k %]]&gt;&lt;/script&gt;. Pick the minimum cut such that &lt;script type=&quot;math/tex&quot;&gt;A = \{u\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B = V - \{u\}&lt;/script&gt;. The cut &lt;script type=&quot;math/tex&quot;&gt;(A,B)&lt;/script&gt; is a global minimum cut of size less than &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; which is a contradiction. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
Based on this, we can conclude that &lt;script type=&quot;math/tex&quot;&gt;|E| \geq \frac{1}{2}kn&lt;/script&gt;. (&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2}&lt;/script&gt; because &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is undirected).
&lt;br /&gt;
&lt;br /&gt;
So now we have:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_1) = 1 - \frac{|F|}{|E|} \geq 1 - \frac{2k}{kn} = 1 - \frac{2}{n}.
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Success in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;:&lt;/b&gt;&lt;br /&gt;
What about the other iterations? What is the probability that we don’t make a mistake in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; given that we haven’t made any mistake in all the previous interations? At iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;n-i&lt;/script&gt; nodes in the graph. Since we haven’t made any mistake yet, we still have &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; edges in &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; and each node is of degree at least &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; (same proof as before). Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(S_{i+1} | S_1 \cap S_2 \cap ... \cap S_i) \geq 1 - \frac{k}{1/2k(n-j)} = 1 - \frac{2}{n-j}.
\end{align*}
$$
&lt;/div&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Now we can combine everything together:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\require{cancel}
\begin{align*}
Pr(success) &amp;amp;= Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-2} | S_1 \cap S_2 \cap ... \cap S_{n-3}) \\
&amp;amp;\geq \big(1 - \frac{2}{n}\big)\big(1 - \frac{2}{n-1}\big)...\big(1-\frac{2}{n-j}\big)...\big(1-\frac{2}{3}\big) \\
&amp;amp;= \big(\frac{n-2}{n}\big)\big(\frac{n-3}{n-1}\big)\big(\frac{n-4}{n-2}\big)...\big(\frac{3}{5}\big)\big(\frac{2}{4}\big)\big(\frac{1}{3}\big) \\
&amp;amp;= \big(\frac{\bcancel{n-2}}{n}\big)\big(\frac{\bcancel{n-3}}{n-1}\big)\big(\frac{\bcancel{n-4}}{\bcancel{n-2}}\big)...\big(\frac{\bcancel{3}}{\bcancel{5}}\big)\big(\frac{2}{\bcancel{4}}\big)\big(\frac{1}{\bcancel{3}}\big) \\
&amp;amp;= \frac{2}{n(n-1)}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Can we do better?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The probability of success, &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, we found so far is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p &amp;amp;\geq \frac{2}{n(n-1)} = \frac{1}{\binom{n}{2}}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Suppose we run &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; trials of Krager’s algorithm. We then take the minimum cut of all cuts found. These trials are independent. What is the probability of NOT getting the global minimum cut? It is the probability of failing in every trial. Let &lt;script type=&quot;math/tex&quot;&gt;F_i&lt;/script&gt; be the event that we failed to find the global minimum cut in iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Pr(\text{Failure after } T \text{ trials}) &amp;amp;= Pr(F_1 \cap F_2 \cap ... \cap F_T) \\
&amp;amp;= Pr(F_1)Pr(F_2)...Pr(F_T) \text{  (by independence)}\\
&amp;amp;\leq \big(1-\frac{2}{n(n-1)} \big)^{T} \\
&amp;amp;= \big(1-\frac{1}{\binom{n}{2}} \big)^{T}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We also know that for any &lt;script type=&quot;math/tex&quot;&gt;x \geq 1&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\big (1-\frac{1}{x} \big)^x \leq \frac{1}{e}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Suppose we let &lt;script type=&quot;math/tex&quot;&gt;x = \frac{1}{p}&lt;/script&gt;, we see that&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
\big(1-\frac{1}{\binom{n}{2}} \big)^{\binom{n}{2}} \leq \frac{1}{e}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is exactly our expression above with &lt;script type=&quot;math/tex&quot;&gt;T = \binom{n}{2}&lt;/script&gt;. Furthermore, we can let &lt;script type=&quot;math/tex&quot;&gt;T = \ln(n)\binom{n}{2}&lt;/script&gt; to get&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
P(\text{Failure}) \leq \big(1-\frac{1}{\binom{n}{2}} \big)^{\ln(n)\binom{n}{2}} \leq \frac{1}{e}^{\ln(n)} = \frac{1}{n}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In general, if we want the probability of failure to be at most &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; then we need to set &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\ln(1/\delta)\frac{1}{p}&lt;/script&gt; in&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{Failure}) &amp;amp;\leq \big(1-p\big)^{T} \leq \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This is because&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{Failure}) &amp;amp;\leq \big(1-p\big)^{\ln(1/\delta)\frac{1}{p}} \leq \frac{1}{e}^{\ln(1/\delta)} = \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Running Time&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; nodes and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges. In the naive implementation, we contract &lt;script type=&quot;math/tex&quot;&gt;n-2&lt;/script&gt; edges until we reach a graph with 2 vertices. Every time we contract an edge, we need to create a new node and also correct all the edges connected to either end of the contracted edge. This could take &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. Therefore, the total running time is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. There are other faster implementations with union-find data structure that reduce the running time to &lt;script type=&quot;math/tex&quot;&gt;O(m * \alpha(n))&lt;/script&gt;. (TODO: More on this?)
&lt;br /&gt;
&lt;br /&gt;
Given that we can get a high success probability if we run Krager’s algorithm for &lt;script type=&quot;math/tex&quot;&gt;O(\log(n)n^2)&lt;/script&gt;. The total running time is therefore &lt;script type=&quot;math/tex&quot;&gt;O(n^4\log(n))&lt;/script&gt;!
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Can we do better than &lt;script type=&quot;math/tex&quot;&gt;O(n^4\log(n))&lt;/script&gt; and still maintain a high success probability? Krager and Stein published an improved result that’s much faster! 
&lt;br /&gt;
&lt;br /&gt;
Observe when running Krager’s algorithm is that the probability of picking the wrong edge (an edge from the edges crossing the cut, the set &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;) gets higher with every iteration. Therefore, we should really just run karger once in the first few iterations and then repeat Karger for the remaining nodes. 
&lt;br /&gt;
&lt;br /&gt;
This is what Karger-Stein’s algorithm is doing. We contract edges until we get &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. We then make copies of the graph and independently contract the edges again for each graph until we get to &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}/\sqrt{2}&lt;/script&gt;. We then return the minimum of both cuts. We repeat this process again until we reach 4 vertices and simply find the minimum cut by brute force. This is illustrated in the below graph:
&lt;img src=&quot;http://localhost:4000/assets/mincut/stein.png&quot; width=&quot;100%&quot; /&gt;
We also summarize it in the following pseudo-code:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minimum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;brute&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;force&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Karger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Contract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;until&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqrt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Let&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;two&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cut1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cut2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;karger_stein&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;minmum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cut2&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein Running Time&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Karger-Stein is a recursive algorithm. At each level of the recursion, we perform Karger on &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; until we reach &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. Karger runs in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. Therefore, we have the following recurrence for the running time:&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
T(n) = 2T(n/\sqrt{2}) + O(n^2)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And therefore, the running time is &lt;script type=&quot;math/tex&quot;&gt;O(n^2\log(n))&lt;/script&gt; by the master theorem.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein Probability of Success&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Karger-Stein first contracts the graph from &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; vertices down to &lt;script type=&quot;math/tex&quot;&gt;n/\sqrt{2}&lt;/script&gt; vertices. Similar to the analysis we did earlier. The probability of success is the probability of not picking the wrong edges in any of the first &lt;script type=&quot;math/tex&quot;&gt;n-n/\sqrt{2}&lt;/script&gt; iterations. Therefore, combining all probabilities:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\require{cancel}
\begin{align*}
Pr(\text{success until } n/\sqrt{2}) &amp;amp;= Pr(S_1) * Pr(S_2 | S_1) * Pr(S_3 | S_1 \cap S_2) * ... * Pr(S_{n-n\sqrt{2}} | S_1 \cap S_2 \cap ... \cap S_{n-n/\sqrt{2}}) \\
&amp;amp;\geq \big(1 - \frac{2}{n}\big)\big(1 - \frac{2}{n-1}\big)...\big(1-\frac{2}{n-j}\big)...\big(1-\frac{2}{n/\sqrt{2}+1}\big) \\
&amp;amp;= \big(\frac{n-2}{n}\big)\big(\frac{n-3}{n-1}\big)\big(\frac{n-4}{n-2}\big)...\big(\frac{n/\sqrt{2}}{n/\sqrt{2}+2}\big)\big(\frac{n/\sqrt{2}-1}{n/\sqrt{2}+1}\big) \\
&amp;amp;= \big(\frac{\bcancel{n-2}}{n}\big)\big(\frac{\bcancel{n-3}}{n-1}\big)\big(\frac{\bcancel{n-4}}{\bcancel{n-2}}\big)...\big(\frac{n/\sqrt{2}}{\bcancel{n/\sqrt{2}+2}}\big)\big(\frac{n/\sqrt{2}-1}{\bcancel{n/\sqrt{2}+1}}\big) \\
&amp;amp;= \frac{n/\sqrt{2}(n/\sqrt{2}-1)}{n(n-1)} \\
&amp;amp;= \frac{n(n-\sqrt{2})}{2n(n-1)} = \frac{n-\sqrt{2}}{2(n-1)} \approx \frac{1}{2}. \text{ (when n is large)}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;If represent these probabilities with a binary tree then we know at each step we have a probability of &lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt; of picking the right path down to a leaf. Since we’re dividing by &lt;script type=&quot;math/tex&quot;&gt;\sqrt{2}&lt;/script&gt;, then we know that the depth of the tree is&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
\log_{\sqrt{2}}(n) = \frac{\log(n)}{\log(\sqrt{2})} = 2\log(n)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;And the number of leaves is&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
2^{2\log(n)} = O(n^2)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;To find the overall probability of success, we need to find the probability of picking the right path from the root down to a leaf. Picking the right path means that at every step we pick the right edge. Suppose &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a vertex in this tree and let &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; be the height of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;p_d&lt;/script&gt; be the probability that there exists a path of surviving edges from &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; down to a leaf. Let &lt;script type=&quot;math/tex&quot;&gt;L&lt;/script&gt; be the event that there exists a path of surviving edges in the left subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; be the event that there exists a path of surviving edges in the right subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We see that&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
p_d &amp;amp;= \frac{1}{2} * Pr(\text{there is at least one subtree with surviving edges}) \\
&amp;amp;= \frac{1}{2} * Pr(L \cup R) \\
&amp;amp;= \frac{1}{2} * (Pr(R) + Pr(L) - Pr(R \cap L)) \\
&amp;amp;= \frac{1}{2} * (Pr(R) + Pr(L) - Pr(R \cap L)) \\
&amp;amp;= \frac{1}{2} * (p_{d-1} + p_{d-1} - p_{d-1}^2) \\
&amp;amp;= p_{d-1} - \frac{1}{2}p_{d-1}^2 \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The claim is that &lt;script type=&quot;math/tex&quot;&gt;p_d \geq \frac{1}{d+1}&lt;/script&gt;. To see this, we need to prove this by induction by &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; for &lt;script type=&quot;math/tex&quot;&gt;d &gt; 0&lt;/script&gt;. 
&lt;br /&gt;
For the base case, the probability of finding a path of surviving edges when the height is 0 is 1. We also see that &lt;script type=&quot;math/tex&quot;&gt;p_0 \geq \frac{1}{0+1} = 1&lt;/script&gt; as we wanted to show.
&lt;br /&gt;
&lt;br /&gt;
For the inductive hypothesis, suppose it holds for &lt;script type=&quot;math/tex&quot;&gt;d-1&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;p_{d-1} \geq \frac{1}{d}&lt;/script&gt;. We will prove that it holds for &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;.&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
p_d &amp;amp;= p_{d-1} - \frac{1}{2}p_{d-1}^2 \\
&amp;amp;\geq \frac{1}{d} - \frac{1}{2}\frac{1}{d^2} \\
&amp;amp;\geq \frac{1}{d} - \frac{1}{d(d+1)} \quad \text{(} 1/d(d+1) \text{ is strictly greater than } 1/2d^2 \text { for } d \geq 1 \text{)} \\
&amp;amp;= \frac{1}{d+1}.
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Side Note: I don’t know how I would come up with replacing &lt;script type=&quot;math/tex&quot;&gt;1/d^2&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;1/d(d+1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
Finally since the root of the tree has depth &lt;script type=&quot;math/tex&quot;&gt;2\log(n)&lt;/script&gt;, then we know that the probability of success is at least &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2\log(n)+1}&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Karger - Stein Improved Success Rate&lt;/b&gt;&lt;/h4&gt;

&lt;p&gt;But how many trials do we need in order to achieve the same success rate as Karger’s original algorithm (with repetition)? We know the probability of success is at least &lt;script type=&quot;math/tex&quot;&gt;p = \frac{1}{2\log(n)+1}&lt;/script&gt;. The probability of failing in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; trials (trials are independent) is the following if we set &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\ln(1/\delta)\frac{1}{p}&lt;/script&gt;&lt;/p&gt;
&lt;div&gt;
$$
\begin{align*}
Pr(\text{failure in }T \text{ trials}) &amp;amp;= (1 - p)^T \leq \delta
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We arrived at this in the previous analysis of Karger’s algorithm. Therefore, we set &lt;script type=&quot;math/tex&quot;&gt;T = (2\log(n)+1)\ln(1/n)&lt;/script&gt; to get a probablity of failure to be at most &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{n}&lt;/script&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">References class notes from following: http://web.stanford.edu/class/cs161/schedule.html https://web.stanford.edu/class/archive/cs/cs161/cs161.1138/lectures/11/Small11.pdf http://web.stanford.edu/class/archive/cs/cs161/cs161.1172/CS161Lecture16.pdf Algorithm Design (BEST BOOK) Introduction Let be an undirected graph with vertices and edges. A cut in is a partition of into two non-empty sets of vertices and . The size of the cut is the number of edges with one end point in and another in . A global minimum cut is a cut of minimum size. Karger's Algorithm Karger’s algorithm starts with picking an edge in uniformly at random. It then contracts this edge by creating a new node that combines both and . All the edges in with an end point equal to either and now point to instead. Also, any edge between and is deleted. It repeatedly contracts randomly picked edges until we have two vertices in the graph. We then return the number of edges between the two vertices as the global minimum cut in . Karger's Algorithm Pseudocode</summary></entry><entry><title type="html">Discrete Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html" rel="alternate" type="text/html" title="Discrete Random Variables" /><published>2019-08-25T07:01:36-07:00</published><updated>2019-08-25T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/25/discrete-random-variables.html">&lt;h4&gt;References&lt;/h4&gt;
&lt;p&gt;My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/&lt;br /&gt;
First Course in Probability by Sheldon Ross.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Indicator/Bernoulli Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; for success and &lt;script type=&quot;math/tex&quot;&gt;1-p&lt;/script&gt; for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
X = \Big\{ \begin{array}{@{}lr@{}}
        1 \quad \text{If even A occurs } \\
        0 \quad \text{otherwise} \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1\}&lt;/script&gt;. Let’s look at the PMF of &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;. Remember that the PMF of a random variable is just the probability that this random variable takes on a value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;R_x&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}}
        p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\
        p(0) = 1 - P(A) \quad \text{if } x = 0 \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;What the expected value of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;? Recall that the expected value of a discrete random variable is defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = p(1)*1 + p(0)*0 = p(1) = P(A)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We also know the variance&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
Var(X) = E[X^2] - (E[X])^2 = 1^2(p) + 0^2(1-p) - p^2 = p - p^2 = p(1-p)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Binomial Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;If we on the other hand have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; independent trials of Bernoulli random variables with a probability of success &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can use a binomial random variable to represent the number of successes in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. For example, if we are flipping a coin with probability of getting heads (success) equals to &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;, then we can define a binomial random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to represent the number of heads in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. 
&lt;br /&gt;
&lt;br /&gt;
Therefore, &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt; and the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The expected value, variance and second moment of a binomial random variable:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= np \\
Var(X) &amp;amp;= np(1-p) \\
E[X^2] &amp;amp;= n^2p^2 - np^2 + np
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Example 1&lt;/b&gt;&lt;br /&gt;
Suppose we flip a fair coin &lt;script type=&quot;math/tex&quot;&gt;4&lt;/script&gt; times. What is the probability of seeing exactly two heads.
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of heads. &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a binomial random variable with &lt;script type=&quot;math/tex&quot;&gt;n=4&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p=0.5&lt;/script&gt;. Therefore,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(X=2) = \binom{4}{2}(0.5)^2(0.5)^2 = 0.375
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Example 2&lt;/b&gt;&lt;br /&gt;
(Book Example). Suppose we have 12 jurors and in order to convict a defendant you need 8 jurors to vote guilty. Suppose the probability of making the right decision by a juror is &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. What is the probability of making a right decision?
&lt;br /&gt;
Suppose the defendant is guilty. This means that we need at least 8 jurors making the right the decision. Therefore, the probability is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;However if the defendant is innocent then we need at least 5 jurors making the right decision&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;If the defendant is guilty with probability &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt; then the probability becomes&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\alpha\sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i} + (1-\alpha)\sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Poisson Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Consider a duration of time where events occur at an average rate of &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of occurrences in a unit of time. We have &lt;script type=&quot;math/tex&quot;&gt;R_X = \{0,1,...,n\}&lt;/script&gt;. The PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt; Example 1: &lt;/b&gt;&lt;br /&gt;
Given a web server, suppose that the server load averages 2 hits per second. Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be the number of hits received in a second. What is &lt;script type=&quot;math/tex&quot;&gt;P(X=5)?&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Binomial and Poisson Random Variables&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;A Poisson random variable can also be used to approximate a binomial random variable if &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is very large and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is small so that &lt;script type=&quot;math/tex&quot;&gt;np&lt;/script&gt; is moderate. Let &lt;script type=&quot;math/tex&quot;&gt;\lambda = E[X] = np&lt;/script&gt; which is the average number of successes you see in &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; trials. Then we will have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\
&amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\
&amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} \frac{(1-\lambda/n)^{n}}{(1-\lambda/n)^{k}} \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;When &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is very large, the term &lt;script type=&quot;math/tex&quot;&gt;n(n-1)...(n-k+1)/n^k&lt;/script&gt; is approximately 1. The term &lt;script type=&quot;math/tex&quot;&gt;(1-\lambda/n)^k&lt;/script&gt; is also approximately &lt;script type=&quot;math/tex&quot;&gt;1^k = 1&lt;/script&gt;. On the other hand we have &lt;script type=&quot;math/tex&quot;&gt;(1-\lambda/n)^{n} \approx e^{-\lambda}&lt;/script&gt;. So&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
P(X = k) &amp;amp;\approx \frac{\lambda^k}{k!}e^{-\lambda}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Expected Value and Variance of a Poisson Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Both the expected value and variance of a Poisson random variable is &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;. Intuitively, we know Poisson approximates a binomial random variable when &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is large and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is small with &lt;script type=&quot;math/tex&quot;&gt;\lambda = np&lt;/script&gt;. We also know that the expected value of a binomial random variable is &lt;script type=&quot;math/tex&quot;&gt;E[X] = np&lt;/script&gt;.  Therefore, the expected value of a Poisson random variable should be &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;. Similarly, to compute the variance, we know the binomial random variable variance is &lt;script type=&quot;math/tex&quot;&gt;np(1-p)&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;\lambda(1-p)&lt;/script&gt; when &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is very small is also &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;(Proof?)
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Geometric Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable for the number of trials until we see the first success. &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is a geometric random variable with &lt;script type=&quot;math/tex&quot;&gt;PMF&lt;/script&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = (1-p)^{k-1}p
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; has the following expected value and variance&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= 1/p \\
Var(X) &amp;amp;= (1-p)/p^2
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The CDF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = P(X \leq k) &amp;amp;= \sum_{m=1}^k (1-p)^{m-1}p \\
&amp;amp;= p \sum_{m=0}^{k-1} (1-p)^{m} \\
&amp;amp;= p \frac{1-(1-p)^k}{1-(1-p)} \text{ (Recall }\sum_{i=0}^n x^i = \frac{1-x^{n+1}}{1-x}\text{)} \\
&amp;amp;= 1-(1-p)^k \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Another way to derive this is to let &lt;script type=&quot;math/tex&quot;&gt;C_i&lt;/script&gt; be the event where we succeed on the ith trial. We see that&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = P(X \leq k) &amp;amp;= 1 - P(X &amp;gt; k) \quad \text{ (first success happens after kth trial)}\\
&amp;amp;= 1 - P(C_1^c C_2^c ... C_k^c) \quad \text{ (none of 1..kth trial succeed)} \\
&amp;amp;= 1 - P(C_1^c)P(C_2^c) ... P(C_k^c) \quad \text{ (Independance)} \\
&amp;amp;= 1 - (1-p)^k 
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Negative Binomial Random Variable&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is the number of independent trials until the &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;th success.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p(k) = P(X = k) = \binom{k-1}{r-1}p^r(1-p)^{k-r}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; has the following expected value and variance&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= rp/(1-p) \\
Var(X) &amp;amp;= r(1-p)/p^2
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/ First Course in Probability by Sheldon Ross. Indicator/Bernoulli Random Variable If we have an experiment that results in a boolean answer (yes/no) or (success/failure) with probability for success and for failure then we can use an indicator or a boolean random variable to represent its outcomes. We define the following: $$ \begin{align*} X = \Big\{ \begin{array}{@{}lr@{}} 1 \quad \text{If even A occurs } \\ 0 \quad \text{otherwise} \\ \end{array} \end{align*} $$ Therefore, . Let’s look at the PMF of . Remember that the PMF of a random variable is just the probability that this random variable takes on a value in . Therefore, $$ \begin{align*} p(x) = P(I = x) = \Big\{ \begin{array}{@{}lr@{}} p(1) = P(A) \quad \ \ \quad \text{If } x = 1 \\ p(0) = 1 - P(A) \quad \text{if } x = 0 \\ \end{array} \end{align*} $$ What the expected value of ? Recall that the expected value of a discrete random variable is defined as $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ Therefore, $$ \begin{align*} E[X] = p(1)*1 + p(0)*0 = p(1) = P(A) \end{align*} $$ We also know the variance $$ \begin{align*} Var(X) = E[X^2] - (E[X])^2 = 1^2(p) + 0^2(1-p) - p^2 = p - p^2 = p(1-p) \end{align*} $$ Binomial Random Variable If we on the other hand have independent trials of Bernoulli random variables with a probability of success , then we can use a binomial random variable to represent the number of successes in trials. For example, if we are flipping a coin with probability of getting heads (success) equals to , then we can define a binomial random variable to represent the number of heads in trials. Therefore, and the PMF of is: $$ \begin{align*} p(k) = P(X = k) = \binom{n}{k} p^k (1-p)^{n-k} \end{align*} $$ The expected value, variance and second moment of a binomial random variable: $$ \begin{align*} E[X] &amp;amp;= np \\ Var(X) &amp;amp;= np(1-p) \\ E[X^2] &amp;amp;= n^2p^2 - np^2 + np \end{align*} $$ Example 1 Suppose we flip a fair coin times. What is the probability of seeing exactly two heads. Let be the number of heads. is a binomial random variable with and . Therefore, $$ \begin{align*} p(X=2) = \binom{4}{2}(0.5)^2(0.5)^2 = 0.375 \end{align*} $$ Example 2 (Book Example). Suppose we have 12 jurors and in order to convict a defendant you need 8 jurors to vote guilty. Suppose the probability of making the right decision by a juror is . What is the probability of making a right decision? Suppose the defendant is guilty. This means that we need at least 8 jurors making the right the decision. Therefore, the probability is $$ \begin{align*} \sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i} \end{align*} $$ However if the defendant is innocent then we need at least 5 jurors making the right decision $$ \begin{align*} \sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i} \end{align*} $$ If the defendant is guilty with probability then the probability becomes $$ \begin{align*} \alpha\sum_{i=8}^{12}\binom{12}{i}p^i(1-p)^{12-i} + (1-\alpha)\sum_{i=5}^{12}\binom{12}{i}p^i(1-p)^{12-i} \end{align*} $$ Poisson Random Variable Consider a duration of time where events occur at an average rate of . Let be the number of occurrences in a unit of time. We have . The PMF of is: $$ \begin{align*} p(k) = P(X = k) = \frac{\lambda^k}{k!}e^{-\lambda} \end{align*} $$ Example 1: Given a web server, suppose that the server load averages 2 hits per second. Let be the number of hits received in a second. What is $$ \begin{align*} P(X = 5) = \frac{\lambda^5}{5!}e^{-2} \approx 0.0361 \end{align*} $$ Binomial and Poisson Random Variables A Poisson random variable can also be used to approximate a binomial random variable if is very large and is small so that is moderate. Let which is the average number of successes you see in trials. Then we will have $$ \begin{align*} P(X = k) &amp;amp;= \binom{n}{k}p^k(1-p)^{n-k} \\ &amp;amp;= \frac{n!}{k!(n-k)!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{k!}\frac{\lambda}{n}^k (1-\frac{\lambda}{n})^{n-k} \\ &amp;amp;= \frac{n(n-1)...(n-k+1)}{n^k}\frac{\lambda^k}{k!} \frac{(1-\lambda/n)^{n}}{(1-\lambda/n)^{k}} \\ \end{align*} $$ When is very large, the term is approximately 1. The term is also approximately . On the other hand we have . So $$ \begin{align*} P(X = k) &amp;amp;\approx \frac{\lambda^k}{k!}e^{-\lambda} \end{align*} $$ Expected Value and Variance of a Poisson Random Variable Both the expected value and variance of a Poisson random variable is . Intuitively, we know Poisson approximates a binomial random variable when is large and is small with . We also know that the expected value of a binomial random variable is . Therefore, the expected value of a Poisson random variable should be . Similarly, to compute the variance, we know the binomial random variable variance is and so when is very small is also .</summary></entry><entry><title type="html">Prime Numbers</title><link href="http://localhost:4000/jekyll/update/2019/08/23/prime-numbers.html" rel="alternate" type="text/html" title="Prime Numbers" /><published>2019-08-23T07:01:36-07:00</published><updated>2019-08-23T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/23/prime-numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/23/prime-numbers.html">&lt;p&gt;&lt;b&gt;References&lt;/b&gt;&lt;br /&gt;
These study notes are from the following sources: &lt;br /&gt;
(1) http://mathworld.wolfram.com/ &lt;br /&gt;
(2)
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Divisibility&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a,b \in Z&lt;/script&gt;. We say that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; divides &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;a \ | \ b&lt;/script&gt; if for some &lt;script type=&quot;math/tex&quot;&gt;c \in Z&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;b = ac&lt;/script&gt;. In this case, &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is a divisor of &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. If there is no such &lt;script type=&quot;math/tex&quot;&gt;c \in Z&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;b = ac&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; does not divide &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;a \nmid b&lt;/script&gt;.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Prime&lt;/b&gt;&lt;br /&gt;
An Integer &lt;script type=&quot;math/tex&quot;&gt;n &gt; 1&lt;/script&gt; is prime if the only positive divisors of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; are &lt;script type=&quot;math/tex&quot;&gt;1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. If &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is not prime then &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is composite.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Fundamental Theorem of Arithmetic:&lt;/b&gt;&lt;br /&gt; 
Every integer greater than 1 can be represented in exactly one way apart from rearrangement as a product of one or more primes.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Greatest Common Divisor&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a, b \in Z&lt;/script&gt;. Let&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
gcd(a,b) = \max \{ d \in Z : d \ |\  a \ \text{ and } \ d \ | \ b \}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; is the greatest common divisor of both &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;.
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Properties of the Greatest Common Divisor&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;a, b \in Z&lt;/script&gt;, we have&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
gcd(a,b) = gcd(a,b-a) = gcd(a,b+a)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Proof: Let &lt;script type=&quot;math/tex&quot;&gt;gcd(a,b) = d \in Z&lt;/script&gt;. By the defintion of &lt;script type=&quot;math/tex&quot;&gt;gcd&lt;/script&gt; we know that &lt;script type=&quot;math/tex&quot;&gt;d \ | \ a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;d \ | \ b&lt;/script&gt;. Therefore, for some &lt;script type=&quot;math/tex&quot;&gt;x, y \in Z&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;a = xd&lt;/script&gt; and, &lt;script type=&quot;math/tex&quot;&gt;b = yd&lt;/script&gt;. From this we have, &lt;script type=&quot;math/tex&quot;&gt;a - b = d(x - y)&lt;/script&gt;. Therefore, we know that &lt;script type=&quot;math/tex&quot;&gt;d = gcd(a,b) \ | \ a - b&lt;/script&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">References These study notes are from the following sources: (1) http://mathworld.wolfram.com/ (2) Divisibility Let . We say that divides or if for some , . In this case, is a divisor of . If there is no such such that then does not divide or . Prime An Integer is prime if the only positive divisors of are and . If is not prime then is composite. Fundamental Theorem of Arithmetic: Every integer greater than 1 can be represented in exactly one way apart from rearrangement as a product of one or more primes. Greatest Common Divisor Let . Let $$ \begin{align*} gcd(a,b) = \max \{ d \in Z : d \ |\ a \ \text{ and } \ d \ | \ b \} \end{align*} $$ is the greatest common divisor of both and . Properties of the Greatest Common Divisor Let , we have $$ \begin{align*} gcd(a,b) = gcd(a,b-a) = gcd(a,b+a) \end{align*} $$ Proof: Let . By the defintion of we know that and . Therefore, for some , we have and, . From this we have, . Therefore, we know that .</summary></entry><entry><title type="html">Binary Search Correctness Proof</title><link href="http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof.html" rel="alternate" type="text/html" title="Binary Search Correctness Proof" /><published>2019-08-19T07:01:36-07:00</published><updated>2019-08-19T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/08/19/binary-search-proof.html">&lt;!-----------------------------------------------------------------------------------&gt;
&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;These are my study notes from CLRS and ?
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Binary Search&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Given a sorted array &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; integers and a key, we want to return the index of the key in the array or -1 if the key doesn’t exist in the array. Binary search takes advantage of the property that the array is sorted and then iteratively finds which half of the list the key will be located in. After &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; iterations, we will either correctly return that index or return -1 if the key doesn’t exist.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;binary_search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not found&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Correctness Proof&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;This is just my attempt to prove that binary search algorithm implemented above is correct. To prove binary search is correct, we want to prove the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;At every iteration binary search is still searching the correct range in the array. This can be achieved with a loop invariant.&lt;/li&gt;
  &lt;li&gt;Binary search terminates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If we are able to prove these two then we can conclude that binary search is correct.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Preconditions and Postconditions&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;In addition to loop invariants, we also need to describe the preconditions of binary search. Preconditions are just assertions that must be true at the beginning of our function. In our case, &lt;b&gt;our precondition is that the array is sorted in an ascending order&lt;/b&gt;. If the array is not sorted, then we don’t guarantee anything about the outcome.
&lt;br /&gt;
&lt;br /&gt;
In addition to preconditions, we also need to describe our postconditions. Given that we met the preconditions, our loop invariant is correct and our algorithm terminates, our &lt;b&gt;post condition is that we return -1 if the key is not in the array or return the index of the key in the array&lt;/b&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Binary Search's Loop Invariant&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;As a reminder from CLRS, loop invariants have three parts that we need to prove:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The invariant is true before the first iteration of the loop. (Initialization)&lt;/li&gt;
  &lt;li&gt;If the invariant is true before iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;, then it is true before iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. (Maintenance)&lt;/li&gt;
  &lt;li&gt;When the loop terminates, the invariant gives us a property to help show that the algorithm is correct. (Termination)
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s define the following loop invariant: &lt;br /&gt;
At the start of each iteration of the while loop above the following is true: &lt;br /&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;1 \leq first \leq last \leq n&lt;/script&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If the key is in the array and so there is some &lt;script type=&quot;math/tex&quot;&gt;index&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;1 \leq index \leq n&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;first \leq index \leq last&lt;/script&gt;. This just means that we are correctly picking the right range to search at every iteration.
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;b&gt;Initialization:&lt;/b&gt;
&lt;br /&gt;
Before the first iteration we know that &lt;script type=&quot;math/tex&quot;&gt;first = 1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;last = n-1&lt;/script&gt; and so (1) is trivially true. Also, if the key is in &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; then it must be that &lt;script type=&quot;math/tex&quot;&gt;1 \leq index \leq n-1&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt;. Therefore, we are searching the correct range.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Maintenance:&lt;/b&gt;
&lt;br /&gt;
Suppose the invariant holds before iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and that if our key is in &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; then for some index where &lt;script type=&quot;math/tex&quot;&gt;a[index] = key&lt;/script&gt; we have &lt;script type=&quot;math/tex&quot;&gt;first \leq index \leq last&lt;/script&gt;. Let’s look at iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. We first calculate the mid point in the range &lt;script type=&quot;math/tex&quot;&gt;[first, last]&lt;/script&gt;. Based on this, we have three cases: 
&lt;br /&gt;
&lt;br /&gt;
(1) &lt;script type=&quot;math/tex&quot;&gt;a[m] == key&lt;/script&gt;. We therefore, return &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and we are done. 
&lt;br /&gt;
&lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm in this case searches the new range &lt;script type=&quot;math/tex&quot;&gt;[first, m-1]&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;first \leq index&lt;/script&gt; by the inductive hypothesis and so we only need to prove that &lt;script type=&quot;math/tex&quot;&gt;index \leq m-1&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt; and since the array is sorted then it must be that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
index &lt; m %]]&gt;&lt;/script&gt; is true otherwise &lt;script type=&quot;math/tex&quot;&gt;a[index]&lt;/script&gt; comes after &lt;script type=&quot;math/tex&quot;&gt;a[m]&lt;/script&gt; which indicates that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is not sorted.
&lt;br /&gt;
&lt;br /&gt;
(3) &lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm will then search the new range &lt;script type=&quot;math/tex&quot;&gt;[m+1, last]&lt;/script&gt;. We can use a similar argument to (2) to prove that &lt;script type=&quot;math/tex&quot;&gt;index \in [m+1, last]&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
From (1), (2), (3) we conclude that the invariant holds before iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Termination:&lt;/b&gt;
&lt;br /&gt;
Suppose we know we terminate (proof next), then by the loop invariant we know 
&lt;br /&gt;
&lt;br /&gt;
&lt;!-----------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Does Binary Search Terminate?&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Will we terminate? we need to prove that if the search range is &lt;script type=&quot;math/tex&quot;&gt;[first_i, last_i]&lt;/script&gt; in iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and the search range in iteration &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;[first_{i+1}, last_{i+1}]&lt;/script&gt; then it must be that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
last_{i+1} - first_{i+1} &lt; last_{i} - first_{i} %]]&gt;&lt;/script&gt;. To do so we can use a similar approach to the one we used to prove our maintenance step. We know there are three cases, in each case we can prove that the new range is shrinking.
&lt;br /&gt;
&lt;br /&gt;
Suppose &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; is the midpoint in &lt;script type=&quot;math/tex&quot;&gt;[first_i, last_i]&lt;/script&gt;. There are three cases:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;a[m] == key&lt;/script&gt;. We therefore, return &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and we are done (binary search terminates).&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm in this case searches the new range &lt;script type=&quot;math/tex&quot;&gt;[first_i, m-1]&lt;/script&gt;. We see here that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
m-1-first_i &lt; last_i-first_i %]]&gt;&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;a[m] &gt; key&lt;/script&gt;. Our algorithm will then search the new range &lt;script type=&quot;math/tex&quot;&gt;[m+1, last]&lt;/script&gt;. Similarly, we see here that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
last - m + 1 &lt; last_i - first_i %]]&gt;&lt;/script&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From the three cases we conclude that binary search must terminate.&lt;/p&gt;</content><author><name></name></author><summary type="html">References These are my study notes from CLRS and ? Binary Search Given a sorted array of integers and a key, we want to return the index of the key in the array or -1 if the key doesn’t exist in the array. Binary search takes advantage of the property that the array is sorted and then iteratively finds which half of the list the key will be located in. After iterations, we will either correctly return that index or return -1 if the key doesn’t exist. int binary_search(int *a, int key, int n) { int m, first = 0, last = n - 1; while (first &amp;lt;= last) { m = (first + (last - first / 2); if (key &amp;gt; a[m]) { first = m + 1; } else if (key &amp;lt; a[m]) { last = m - 1; } else if (key == a[m]) { return m; } } return -1; // not found } Correctness Proof This is just my attempt to prove that binary search algorithm implemented above is correct. To prove binary search is correct, we want to prove the following: At every iteration binary search is still searching the correct range in the array. This can be achieved with a loop invariant. Binary search terminates.</summary></entry><entry><title type="html">Closest Pair of Points</title><link href="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html" rel="alternate" type="text/html" title="Closest Pair of Points" /><published>2019-07-29T07:01:36-07:00</published><updated>2019-07-29T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/29/closest-pair</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/29/closest-pair.html">&lt;h4&gt;&lt;b&gt;References&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!!
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Problem&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;Suppose we are given a list of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; two dimensional points &lt;script type=&quot;math/tex&quot;&gt;\{\{x_1,y_1\},\{x_2,y_2\},...\{x_n,y_n\}\}&lt;/script&gt; and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; since we have &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; possible pairs. What else can we do?
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Divide and Conquer&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we arrive at the final result. As a starting point we will sort the points by their x-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We will also sort the points by their y-coordinate and let that array be &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;. We will be using &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; later in the algorithm.
&lt;img src=&quot;http://localhost:4000/assets/closest/1.png&quot; width=&quot;100%&quot; /&gt;
Given &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. We can start by applying the following divide and conquer idea. Repeatedly divide &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;http://localhost:4000/assets/closest/2.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;How do we combine the results to find the single true closest pair? we need to consider that the closest pair might have a point in the left half and a point in the right half. We call this pair a &lt;b&gt;split pair&lt;/b&gt;. So in the combine step we need to do two things, we find the split pair with the minimum distance. We then return the minimum pair of the three pairs we have, the left pair, the right pair and the split pair. The following pseudo-code implements this idea.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Px sorted by x-coordinate, Py by y-coordinate&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;less&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;than&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;three&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;points&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; 
       &lt;span class=&quot;c1&quot;&gt;// just use the naive algorithm &lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we will divide Px into two arrays left and right&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// median = Px[n/2-1]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_px_around_the_median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;median&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// We want to sort each of left_x and right_x by the y-coordinate.&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// discussed next&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sort_left_and_right_by_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we find the closest pair in each half&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;closest_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// delta_left and delta_right are the minimum distances in the left and right halfs&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	
    &lt;span class=&quot;c1&quot;&gt;// we'll discuss this soon!&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;delta_left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta_right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find_split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Px&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Py&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delta&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;split_pair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Running Time&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;We sorted the array upfront twice in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; time. We divide the input repeatedly in half until we reached the base case. We then combined the results by finding the split pair and returning the pair with the minimum distance. So we have a recurrence that looks like this:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 T(n) = aT(n/b) + n^c \\
 T(n) = 2T(n/2) + n^c
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;The &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; constant depends on the work we’re doing in each level. We first create the four arrays &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. This takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time. We then find the split pair. If we find the split pair in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;c = 2&lt;/script&gt; and by the master theorem, the total runtime is &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. This defeats the purpose since the naive solution runs in &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;. We also know that we initially sorted the array in &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; so the final runtime is at least &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;. So roughly we know that we need to find the split pair really fast in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; to have &lt;script type=&quot;math/tex&quot;&gt;c = 1&lt;/script&gt; and therefore, keeping our runtime at &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Sorting $P_x$ by the x-coordinate and the y-coordinate $O(n)$ time&lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;So we’re claiming that we’re sorting once only and then somehow we’re are repeatedly passing the two halfs of the &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; sorted by the x-coordinate and by the y-coordinate. How?! For sorting by the x-coordinate, we simply split &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; in half by calculating the median in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; time and then iterating over &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; to split the array into &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. That takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the current size of &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Now that we have both &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt;. We want to create two arrays &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;left_x&lt;/script&gt; but sorted by the y-coordinate. We also want &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;right_x&lt;/script&gt; sorted by the y-coordinate. How do we do this in just &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time? This is when we will use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt;! We will iterate over &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; and if we see an element with an x-coordinate below or equal to the median then this element belongs to &lt;script type=&quot;math/tex&quot;&gt;left_y&lt;/script&gt; otherwise it belongs to &lt;script type=&quot;math/tex&quot;&gt;right_y&lt;/script&gt;. Remember that &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; is just &lt;script type=&quot;math/tex&quot;&gt;P_x&lt;/script&gt; but sorted by the y-coordinate. We are also assuming for the sake of simplicity that the points are distinct. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;h4&gt;&lt;b&gt;Finding the split pair in $$O(n)$$ time &lt;/b&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/closest/3.png&quot; width=&quot;100%&quot; /&gt;
Let’s assume that the minimum pair is not a left pair or a right pair and it is a split pair. In the algorithm we described above, let the left minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; (shown above) and let the right minimum distance be &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; be the minimum of &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt;. Also let the right most point in the left array be &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. Now construct &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; to be an array with all the points that have x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x} + \delta&lt;/script&gt; sorted by their y-coordinate (we can use &lt;script type=&quot;math/tex&quot;&gt;P_y&lt;/script&gt; with a linear scan to insert any point that has an x-coordinate that fits our criteria). This linear scan costs &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time which is fine by us!
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;p=(x_1,y_1)&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q=(x_2,y_2)&lt;/script&gt; be the split pair points we’re trying to find where &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; is in the left half and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; is in the right half. We claim the following:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;At most 6 points are between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in M.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
So, assuming the above is correct (we’ll prove it formally), we now have a constant number of pairs to look at. Basically, for each point, we will look at 7 points and therefore, we only have &lt;script type=&quot;math/tex&quot;&gt;7n&lt;/script&gt; pairs and so we can find the split pair in only &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
But why why why the above is the correct? let’s look at the first claim.
&lt;br /&gt;&lt;br /&gt;
Proof:&lt;br /&gt;
We want to show that if the closest pair of points is a split pair then our algorithm will find it. Since our algorithm only searches &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, then we want to show that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;. So assuming that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are the closest pair, we then know that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
d(p,q) &lt; \delta %]]&gt;&lt;/script&gt;. From here we can expand the euclidean distance definition:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 \delta &amp;amp;&amp;gt; d(p,q) \\
  &amp;amp;= \sqrt{(y_2-y_1)^2 + (x_2-x_1)^2} \\
  &amp;amp;\geq \sqrt{\max\{(y_2-y_1)^2, (x_2-x_1)^2}\} \\
  &amp;amp;= \max\{(y_2-y_1), (x_2-x_1)\}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This says that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; in both their &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; coordinates!! So &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
|x_2-x_1| &lt; \delta %]]&gt;&lt;/script&gt;. We also know that &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are a split pair and so by definition we have &lt;script type=&quot;math/tex&quot;&gt;x_1 \leq \bar{x}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 &gt; \bar{x}&lt;/script&gt;. Therefore, we must have &lt;script type=&quot;math/tex&quot;&gt;x_1 \geq \bar{x} - \delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x_2 \leq \bar{x} + \delta&lt;/script&gt;. Finally, since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is defined to include all points such that the x-coordinate satisfies &lt;script type=&quot;math/tex&quot;&gt;\bar{x} - \delta \leq x \leq \bar{x} + \delta&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; are in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; and thererfore, we will find them. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
Let’s move to the second claim. why must we have 6 points only between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;?
&lt;br /&gt;
&lt;br /&gt;
Proof:
&lt;br /&gt;
Without the loss of generality, assume that &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; has the lower y-coordinate. We do know that both &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;’s x and y coordinates differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;’s x and y coordinates respectively. What do we know about the points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;?&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted by the y-coordinate, we do know that any point that comes between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; differ by less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;, this makes the y-coordinate of any of these points be in between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1 \leq y_2 + \delta&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;We know that any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must have an x-coordinate between &lt;script type=&quot;math/tex&quot;&gt;\bar{x}-\delta&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\bar{x}+\delta&lt;/script&gt; by our construction of &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using the above restrictions, any point between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; must be in one of the following boxes. (again, if you look at the x-axis, &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; only allow points within &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;\bar{x}&lt;/script&gt;. If you look vertically, the fact that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted makes the points between &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; have a y-coordinate between &lt;script type=&quot;math/tex&quot;&gt;y_2&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y_1&lt;/script&gt; and that gap is also less than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;!!).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/closest/4.png&quot; width=&quot;100%&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The next question is how many points do we have in each box?
&lt;br /&gt;&lt;br /&gt;
We claim that each box has only 1 point. Proof: Suppose it doesn’t and some box in the diagram above has 2 points. Let these points be &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;. This means than &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; are both a left pair or a right pair. Moreover, the distance between &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is at most &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\sqrt{(\delta/2)^2 + (\delta/2)^2} = \delta/\sqrt{2} &lt; \delta %]]&gt;&lt;/script&gt;. This is a contradiction, since by assumption we said both &lt;script type=&quot;math/tex&quot;&gt;\delta_l&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\delta_r&lt;/script&gt; are greater than &lt;script type=&quot;math/tex&quot;&gt;\delta&lt;/script&gt;. Therefore, we must have 1 point in each box and so there are only 6 points between &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;q&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; Wonderful!!&lt;/p&gt;</content><author><name></name></author><summary type="html">References These are my study notes from chapter 3 of Algorithms Illuminated: Part 1: The Basics. Buy this book!!! Problem Suppose we are given a list of two dimensional points and we want to find the closest pair of points in the list. By closest we mean they are the closest in terms of their euclidean distance. One naive approach would be to simply iterate over all possible pairs and find out the closest pair. This algorithm has a running time of since we have possible pairs. What else can we do? Divide and Conquer The brilliant algorithm we’re about to study is a divide and conquer algorithm, meaning that we will repeatedly divide the problem into a number of subproblems and then we will repeatedly combine the intermediate results until we arrive at the final result. As a starting point we will sort the points by their x-coordinate and let that array be . We will also sort the points by their y-coordinate and let that array be . We will be using later in the algorithm. Given . We can start by applying the following divide and conquer idea. Repeatedly divide into two halfs, left and right. Find the closest pair in the left half and the closest pair in the right half and then combine the results to output the single true closest pair.</summary></entry><entry><title type="html">Random Variables</title><link href="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html" rel="alternate" type="text/html" title="Random Variables" /><published>2019-07-26T07:01:36-07:00</published><updated>2019-07-26T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/26/random-variables</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/26/random-variables.html">&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;References&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188// &lt;br /&gt;
Specifically: http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/lectures/06_random_variables.pdf
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;What is a Random Variable?&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A random variable is a real-valued function defined on a sample space. Why define a random variable? sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some groups of the outcomes or more formally some &lt;b&gt;function of the outcome&lt;/b&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 1:&lt;/b&gt;
&lt;br /&gt; 
Suppose we’re interested in &lt;i&gt;counting&lt;/i&gt; the number of heads in &lt;script type=&quot;math/tex&quot;&gt;5&lt;/script&gt; trials of flipping a coin. We can define a random variable &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to represent the number of heads in 5 trials. Using &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;, we can now refer to the probability of seeing two heads in 5 trials as &lt;script type=&quot;math/tex&quot;&gt;P(Y=2)&lt;/script&gt;. This is much simpler that listing the exact outcomes that we’re interested in. (&lt;script type=&quot;math/tex&quot;&gt;\{H,H,T,T,T\},\{H,T,H,T,T\},...\}&lt;/script&gt;).
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 2:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice and we’re interested in the sum of the two dice. We define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 as &lt;script type=&quot;math/tex&quot;&gt;P(X=7)&lt;/script&gt;. This is much simpler that saying that we want the probability of seeing any of these outcomes: &lt;script type=&quot;math/tex&quot;&gt;(3,4),(4,3),(2,5),(5,2),(1,6),(6,1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Discrete Random Variables&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
If our random variable takes on countable values &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, x_3,...,x_n&lt;/script&gt;, we call it a discrete random variable. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Probability Mass Function&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; that takes on a discrete values in &lt;script type=&quot;math/tex&quot;&gt;R_X = \{k_1, k_2,...,k_n\}&lt;/script&gt;. Define the probability mass function &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; to be the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; takes on a particular value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;. In other words, the PMF is defined as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
p_X(k) = P(X = k)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Furthermore, the PMF of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; satisfies&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{i=1}^{\infty} p_X(k_i) = 1
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This also means that for any value &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; that is not in &lt;script type=&quot;math/tex&quot;&gt;R_X&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;p_X(k) = 0&lt;/script&gt;,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 P(X=k) = \Big\{ \begin{array}{@{}lr@{}}
        p_X(k) \quad \text{ for } k \in R_X \\
        0 \quad \quad \quad \text{ otherwise} \\
        \end{array}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;We can also refer to &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; as just &lt;script type=&quot;math/tex&quot;&gt;p(k)&lt;/script&gt; if the random variable is clear from the context. 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 2:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll the two dice again from example 2. Define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be to the sum of the two dice. We know &lt;script type=&quot;math/tex&quot;&gt;R_X = \{2,3,4,5,6,7,8,9,10,11,12\}&lt;/script&gt;. Below is a graph of the &lt;script type=&quot;math/tex&quot;&gt;PMF&lt;/script&gt; of &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;p_X(k)&lt;/script&gt; for all values in &lt;script type=&quot;math/tex&quot;&gt;R_X&lt;/script&gt;.
&lt;img src=&quot;http://localhost:4000/assets/random/pmf.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Cumulative Distribution Function&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we’re interested in the probability that a random variables, &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;, is less than or equal to a particular value, &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. One way to do this is to sum all the probabilities for all the values that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; can take up to &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt;. An easier way to do this is to use the cumulative distribution function (CDF) that gives the probability that &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is less than or equal to a particular value, specifically&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = F(k) = P(X \leq k), \quad \text{ where } -\infty &amp;lt; k &amp;lt; \infty
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;For a discrete random variable, this will be just the sum of all variables&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
F_X(k) = F(k) = \sum_{\text{ all } i \leq k} p(i)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Expectation&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
The expectation or expected value of a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; is defined as:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the expected value is a weighted average of the value of the random variable (values weighted by their probabilities).
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 4:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice again from example 2 and 3. Define a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be to the sum of the two dice. We can use our PMF from the previous section to compute the expected value as&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X] &amp;amp;= 2*P(X=2) + 3*P(X=3) + 4*P(X=4) + 5 * P(X=5) * 6*P(X=6) + 7*P(X=7) \\
\\ &amp;amp;+ 8*P(X=8) + 9*P(X=9) + 10*P(X=10) + 11*P(X=11) * 12*P(X=12) \\
E[X] &amp;amp;= 2*\frac{1}{36} + 3*\frac{2}{36} + 4*\frac{3}{36} + 5*\frac{4}{36} + 6*\frac{5}{36} + 7*\frac{6}{36} + 8*\frac{5}{36} + 9*\frac{4}{36} + 10*\frac{3}{36} \\
&amp;amp;+ 11*\frac{2}{36} + 12*\frac{1}{36} = 7
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Expectation of a function of a random variable&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Suppose we have a random variable &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; and we have a function &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; is real-valued function. Suppose we want to calculate the expected value of &lt;script type=&quot;math/tex&quot;&gt;g(X)&lt;/script&gt;. Define&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[g(X)] = E[Y] &amp;amp;= \sum_j y_jp(y_j) \\
&amp;amp;= \sum_i g(x_i) p(x_i) \\
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;PROOF?
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example 5:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll a die and define &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; to be the value on the die. Define a new random variable &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;X^2&lt;/script&gt;. What is &lt;script type=&quot;math/tex&quot;&gt;E[Y]&lt;/script&gt;?&lt;br /&gt;
&lt;br /&gt;
Using the above, &lt;script type=&quot;math/tex&quot;&gt;E[Y] = E[X^2] = \sum_i (k_i^2)p(k_i) = 1/6*(1+4+9+16+25+36) \approx 15.167&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Linearity of expectation&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Expectation of the sum of two random variables is the sum of expectation of the two random variables.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
 E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;b&gt;Example 6:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll a die and let &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; be a random variable representing the outcome of the roll. Suppose also that you will win a number of dollars equals to &lt;script type=&quot;math/tex&quot;&gt;3X+5&lt;/script&gt;. What is the expected value of your winnings? We can let &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; be a random variable representing our winnings. Now we have&lt;/p&gt;

&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Y] = E[6X^2+5] &amp;amp;= \sum_i (3x_i + 5)p(x_i) \\
&amp;amp;= \frac{1}{6} \sum_{i=1}^6 3x_i+5 \\
&amp;amp;= \frac{1}{6} (8+11+14+17+20+23) = 15.5
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;However using the linearity of expectation, we know that &lt;script type=&quot;math/tex&quot;&gt;E[X]=3.5&lt;/script&gt;. Therefore we could do the following:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Y] = E[3X+5] &amp;amp;= 3E[X]+5  \\
&amp;amp;= 3(3.5) + 5 = 15.5
\end{align*}
$$
&lt;/div&gt;

&lt;p&gt;&lt;b&gt;Example 7:&lt;/b&gt;
&lt;br /&gt; 
Suppose we roll two dice again and we’re interested in the expectation of the sum of two dice. We calculated this value previously in example 4 using the PMF. Let’s use the second property of expectation. Let &lt;script type=&quot;math/tex&quot;&gt;X_1&lt;/script&gt; be a random variable representing the value of the first die and &lt;script type=&quot;math/tex&quot;&gt;X_2&lt;/script&gt; be a random variable representing the sum value of the second die. Let the sum of the two dice be &lt;script type=&quot;math/tex&quot;&gt;X_1 + X_2&lt;/script&gt;.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[X_1 + X_2] = E[X_1] + E[X_2] = 7
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Example 8: St. Petersburg Paradox&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
A fair coin comes up heads with &lt;script type=&quot;math/tex&quot;&gt;p = 0.5&lt;/script&gt;. We flip the coin until we see the first tails. We will then win &lt;script type=&quot;math/tex&quot;&gt;2^n&lt;/script&gt; dollars where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the number of heads seen before the first tail. How much would you pay to play?
&lt;br /&gt;
&lt;br /&gt;
Let’s define the following random variables: &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; be the number of “heads” before the the first “tails”.&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; be a random variable representing our winnings. &lt;script type=&quot;math/tex&quot;&gt;W = 2^Y&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
What is the probability of seeing &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; heads before seeing the first tail on the &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt;th trial? &lt;script type=&quot;math/tex&quot;&gt;P(Y = i) = (1/2) * (1/2) * ... = (1/2)^{i+1}&lt;/script&gt;. This is because  we stop at the &lt;script type=&quot;math/tex&quot;&gt;i+1&lt;/script&gt; flip which is a tail. Each outcome has a probability equals to &lt;script type=&quot;math/tex&quot;&gt;1/2&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
What is the expected value of our winnings?&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[W] = E[2^Y] &amp;amp;= \sum_i 2^i P(Y=i) =  \sum_i 2^i p(i) \\
&amp;amp;= (\frac{1}{2})^1 2^0 + (\frac{1}{2})^2 2^1 +  (\frac{1}{2})^3 2^2 + ... \\
&amp;amp;= \sum_i^{\infty} (\frac{1}{2})^{i+1} 2^i = \infty
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;div style=&quot;background-color:#FFFDD0; padding: 7px 7px 7px 20px;&quot;&gt;
&lt;b&gt;Example 9: Roulette&lt;/b&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Consider an even money bet (betting “Red” in Roulette). &lt;script type=&quot;math/tex&quot;&gt;p=18/38&lt;/script&gt; you win &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; dollars, otherwise &lt;script type=&quot;math/tex&quot;&gt;1-p&lt;/script&gt; you lose &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; dollars. Consider the following strategy:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Let &lt;script type=&quot;math/tex&quot;&gt;Y=1&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Bet &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt;.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If win then stop.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;Else let &lt;script type=&quot;math/tex&quot;&gt;Y=2Y&lt;/script&gt; go to step 2.&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What is the expected value of our winning? &lt;br /&gt;
Define &lt;script type=&quot;math/tex&quot;&gt;Z&lt;/script&gt; to be our winnings until we stop. &lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
E[Z] &amp;amp;= p*1 + (1-p)p*(2-1) + (1-p)^2p*(4-2-1) + ... \\
&amp;amp;= \sum_{i=0}^{\infty} p(1-p)^i(2^i - \sum_{j=0}^{i-1}2^j) \\
&amp;amp;= p\sum_{i=0}^{\infty} (1-p)^i = p\frac{1}{1-(1-p)} = 1
\end{align*}
$$
&lt;/div&gt;</content><author><name></name></author><summary type="html">References My study notes from CS109 http://web.stanford.edu/class/archive/cs/cs109/cs109.1188// Specifically: http://web.stanford.edu/class/archive/cs/cs109/cs109.1188/lectures/06_random_variables.pdf What is a Random Variable? A random variable is a real-valued function defined on a sample space. Why define a random variable? sometimes instead of being interested in the individual outcomes of an experiment, we are interested in some groups of the outcomes or more formally some function of the outcome. Example 1: Suppose we’re interested in counting the number of heads in trials of flipping a coin. We can define a random variable to represent the number of heads in 5 trials. Using , we can now refer to the probability of seeing two heads in 5 trials as . This is much simpler that listing the exact outcomes that we’re interested in. (). Example 2: Suppose we roll two dice and we’re interested in the sum of the two dice. We define a random variable to be the sum of two dice (function of outcomes). We can now refer to the probability that the sum of the dice is 7 as . This is much simpler that saying that we want the probability of seeing any of these outcomes: . Discrete Random Variables If our random variable takes on countable values , we call it a discrete random variable. Probability Mass Function Suppose we have a random variable that takes on a discrete values in . Define the probability mass function to be the probability that takes on a particular value . In other words, the PMF is defined as $$ \begin{align*} p_X(k) = P(X = k) \end{align*} $$ Furthermore, the PMF of satisfies $$ \begin{align*} \sum_{i=1}^{\infty} p_X(k_i) = 1 \end{align*} $$ This also means that for any value that is not in , we have , $$ \begin{align*} P(X=k) = \Big\{ \begin{array}{@{}lr@{}} p_X(k) \quad \text{ for } k \in R_X \\ 0 \quad \quad \quad \text{ otherwise} \\ \end{array} \end{align*} $$ We can also refer to as just if the random variable is clear from the context. Example 2: Suppose we roll the two dice again from example 2. Define a random variable to be to the sum of the two dice. We know . Below is a graph of the of , for all values in . Cumulative Distribution Function Suppose we’re interested in the probability that a random variables, , is less than or equal to a particular value, . One way to do this is to sum all the probabilities for all the values that can take up to . An easier way to do this is to use the cumulative distribution function (CDF) that gives the probability that is less than or equal to a particular value, specifically $$ \begin{align*} F_X(k) = F(k) = P(X \leq k), \quad \text{ where } -\infty &amp;lt; k &amp;lt; \infty \end{align*} $$ For a discrete random variable, this will be just the sum of all variables $$ \begin{align*} F_X(k) = F(k) = \sum_{\text{ all } i \leq k} p(i) \end{align*} $$ Expectation The expectation or expected value of a random variable is defined as: $$ \begin{align*} E[X] = \sum_{k:p(k)&amp;gt;0} p(k)*k \end{align*} $$ In other words, the expected value is a weighted average of the value of the random variable (values weighted by their probabilities). Example 4: Suppose we roll two dice again from example 2 and 3. Define a random variable to be to the sum of the two dice. We can use our PMF from the previous section to compute the expected value as $$ \begin{align*} E[X] &amp;amp;= 2*P(X=2) + 3*P(X=3) + 4*P(X=4) + 5 * P(X=5) * 6*P(X=6) + 7*P(X=7) \\ \\ &amp;amp;+ 8*P(X=8) + 9*P(X=9) + 10*P(X=10) + 11*P(X=11) * 12*P(X=12) \\ E[X] &amp;amp;= 2*\frac{1}{36} + 3*\frac{2}{36} + 4*\frac{3}{36} + 5*\frac{4}{36} + 6*\frac{5}{36} + 7*\frac{6}{36} + 8*\frac{5}{36} + 9*\frac{4}{36} + 10*\frac{3}{36} \\ &amp;amp;+ 11*\frac{2}{36} + 12*\frac{1}{36} = 7 \end{align*} $$ Expectation of a function of a random variable Suppose we have a random variable and we have a function where is real-valued function. Suppose we want to calculate the expected value of . Define $$ \begin{align*} E[g(X)] = E[Y] &amp;amp;= \sum_j y_jp(y_j) \\ &amp;amp;= \sum_i g(x_i) p(x_i) \\ \end{align*} $$ PROOF? Example 5: Suppose we roll a die and define to be the value on the die. Define a new random variable to be . What is ? Using the above, Linearity of expectation Expectation of the sum of two random variables is the sum of expectation of the two random variables. $$ \begin{align*} E[aX + bY + c] &amp;amp;= aE[X] + bE[Y] + c \end{align*} $$ Example 6: Suppose we roll a die and let be a random variable representing the outcome of the roll. Suppose also that you will win a number of dollars equals to . What is the expected value of your winnings? We can let be a random variable representing our winnings. Now we have</summary></entry></feed>