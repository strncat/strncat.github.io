<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-25T08:06:52-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">nemo’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Lecture 01: Groups and Symmetries</title><link href="http://localhost:4000/jekyll/update/2025/01/24/math417-02-rotations-in-space.html" rel="alternate" type="text/html" title="Lecture 01: Groups and Symmetries" /><published>2025-01-24T00:01:36-08:00</published><updated>2025-01-24T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/24/math417-02-rotations-in-space</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/24/math417-02-rotations-in-space.html"><![CDATA[<h4><b>Introduction</b></h4>
<p>Abstract Algebra lets us examine structures which allow for algebraic manipulations of the types we’ve used in high school. As an example, we have Fields. It’s a set with operations addition, subtraction, multiplication and division that satisfy a few rules. An example of a field is the field of real numbers \(\mathbf{R}\) or the field of complex numbers \(\mathbf{C}\). We also have the field of rational numbers \(\mathbf{Q}\). Or \(\mathbf{Z}_p\) which is a finite field of integers modulo some prime \(p\). It is finite with \(p\) elements.
<br />
<br />
Another example of important structures are Rings. Here we have the operations addition, subtraction and multiplication. The first example of a ring is \(\mathbf{Z}\). Another example of a ring is a polynomial ring in one variable over \(\mathbf{R}\), \(\mathbf{R}[x]\). The set of all square matrices. \(M_{n \times n}(\mathbf{R})\) is also another example. This example is non-commutative.<br />
<br />
<br />
Another structure is a Group. It is a set with one operation usually called “multiplication”. One example is the set of real numbers with just addition. Another example is \((\mathbf{R}^{x})\) (the set of real numbers with zero removed, \(\mathbf{R} - \{0\}\) along with multiplication. \(GL(n,\mathbf{R})\), the set of invertible matrices with multiplication is another example of a Group. This is an example of a non-abelian or non-commutative group.
<br />
<br />
One additional structure that comes up is a Monoid. These are sets with one operation but you don’t have to have inverses like Groups. So \(\mathbf{R}\) with multiplication is not a group because it includes zero and zero doesn’t have an inverse but this set is a Monoid. 
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Groups and Symmetries</b></h4>

<p>From the book, a symmetry is an undetectable motion. An object is symmetric if it has symmetries. Take an equilateral triangle.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-1.png" width="40%" class="center" /></p>

<p>What are the symmetries of this triangle? We want to rotate the triangle in such a way that we won’t tell if it was rotated. For example, if we rotate this triangle by \(120\) degrees counter clockwise, then we’ll get a triangle in the same exact orientation. We label this rotation with \(r_1\). Note here that the labels on the vertices are used to illustrate that we indeed have rotated the triangle. They are a visual aid.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-2.png" width="70%" class="center" /></p>

<p>We can also rotate this triangle \(120\) degrees clockwise to get the following \(r_2\) rotation.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-3.png" width="70%" class="center" /></p>

<p>Are there more rotations? Yes, consider the rotation around the axis that goes through the vertex \(A\) by 180 degrees so essentially it’s a flip around that axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-4.png" width="70%" class="center" /></p>

<p>Similarly, we can do a flip around the axis that goes through the vertex \(B\) and a flip around the axis that goes through the vertex \(C\).</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-5.png" width="40%" class="center" /></p>

<p>So now we have \(5\) symmetries total. Is that all? No, We have one more symmetry representing the identity symmetry \(e\) that does nothing. So the set of symmetries are then</p>
<div>
$$
\begin{align*}
G = \{e, r_1, r_2, a, b, c\}
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Can We Compose Symmetries?</b></h4>

<p>Can we compose symmetries? Yes, in fact we’ll equip the group above with the operation compose. This means that for any \(x, y \in G\), \(xy\) means that we need to apply the rotation \(y\) first and then apply the rotation \(x\). Since we have \(6\) elements in \(G\), then we have \(36\) ways of composing these elements. 
<br />
<br />
For example composing \(r_1\) with \(r_1\) again results in the rotation \(r_2\) so \(r_1r_1 = r_2\).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-6.png" width="70%" class="center" /></p>
<p>And if we compose \(r_1\) with \(r_2\), then we’ll get the identity rotation so \(r_1r_2 = e\).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-7.png" width="70%" class="center" /></p>
<p>In fact since \(r_1r_1 = r_2\) and \(r_1r_2 = e\), we’ll change the notation to a much simpler notation. Let \(r_1 = r\). Then, \(r_2 = r_1r_1 = rr = r^2\). So now we can fill these in a table as follows
<br />
<!------------------------------------------------------------------------></p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(\)</td>
   <td>\(\)</td>	
   <td>\(\)</td>
   <td>\(\)</td>
   <td>\(\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
</table>
</div>
<p><br />
So far so good. What about composing the flips around the axes? For example composing \(a\) with \(b\). What would that do? For starters, note that each flip is a \(180\) degrees flip. So if you compose ANY two flips, we’ll be back to the same face we started with. This means that any two flips will be equivalent to \(e, r\) or \(r^2\). For example, if we apply \(a\) and then apply \(b\), we’ll get</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-8.png" width="90%" class="center" /></p>

<p>Note here that when did the second flip, we still rotated through the \(b\) access which now goes through vertex \(C\) instead. Physically the axis will still be in the same position. So we see above doing two flips \(a\), then around \(b\) is equivalent to applying two rotations so \(ba = r^2\). 
<br />
<br />
What about two flips of the same type? What happens if you apply \(a\) and then again flip it around that same access? We’ll get the identity rotation since we just go back to the same exact orientation. Applying this same logic on the rest of flips, we can fill that forth quadrant of the table which are all about compositions of flips.
<br />
<br />
<!------------------------------------------------------------------------></p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(\)</td>
   <td>\(\)</td>	
   <td>\(r^2\)</td>
   <td>\(e\)</td>
   <td>\(r\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
  </tr>
</table>
</div>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Second and Third Quadrants</b></h4>
<p>What about applying a rotation \(r\) followed by a flip \(a\)? What is \(ar\)? We apply a rotation so we move \(120\) degrees anti-clockwise and then we do an \(a\) flip which is now going to be through the \(C\) vertex. The triangle will now be faced down which is equivalent to applying a single flip. Comparing the vertices in the original triangle and the outcome, we see that \(B\) is fixed while \(A\) and \(C\) have switched. This means that this is a flip around the \(b\) access.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-9.png" width="90%" class="center" /></p>

<!------------------------------------------------------------------------>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(c\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
	<td>\(a\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(c\)</td>
   <td>\(a\)</td>	
   <td>\(r^2\)</td>
   <td>\(e\)</td>
   <td>\(r\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
  </tr>
</table>
</div>
<p>We notice that each row has each rotation appearing exactly once and it’s the same for each column. Notice also that composition is not commutative above. So \(ar \neq ra\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Matrix Representation of Symmetries</b></h4>
<p>We can actually represent these symmetries by matrices. For example, the following matrix will represent a \(120\) degrees rotation around the \(z-\) axis</p>
<div>
$$
\begin{align*}
r(x,y,z) &amp;= 
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; - \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; + \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p>or we can do the \(a\) flip so a \(180\) degree flip around the \(x\)-axis.</p>
<div>
$$
\begin{align*}
a(x,y,z) &amp;= 
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 0
\end{pmatrix}
\end{align*}
$$
</div>
<p>What about something more complex? like \(ra\) which is equal to \(c\) using the multiplication table above. This will be</p>
<div>
$$
\begin{align*}
c(x,y,z) &amp;= ra(x,y,z) 
\\
&amp;= 
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; - \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; + \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 0
\end{pmatrix}
\\
&amp;=
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; - \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Symmetries of the Rectangle</b></h4>
<p>How many symmetries does the rectangle have?</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect.png" width="30%" class="center" /></p>

<p>We can have a rotation \(r_1\) around the \(y-\)axis as follows</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect-r1.png" width="75%" class="center" /></p>

<p>We can also have a rotation \(r_2\) around the \(x-\)axis</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect-r2.png" width="75%" class="center" /></p>

<p>Finally, we have one more rotation \(r_3\) around the \(z-\)axis. (the axis coming off the screen toward us from the centroid of the face.)</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect-r3.png" width="75%" class="center" /></p>

<p>So we have four rotations which make the following group</p>
<div>
$$
\begin{align*}
G = \{e, r_1, r_2, r_3\}
\end{align*}
$$
</div>
<p>One thing to notice here that for any rotation in \(G\), if you apply it twice, you’ll get the identity rotation. So each rotation has an order \(2\). The multiplication table for the symmetries of the rectangle is as follows</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r_1\)</td>
	<td>\(r_2\)</td>
	<td>\(r_3\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r_1\)</td>
	<td>\(r_2\)</td>
	<td>\(r_3\)</td>
  </tr>
  <tr>
    <td>\(r_1\)</td>
    <td>\(r_1\)</td>
    <td>\(r_2\)</td>
	<td>\(r_3\)</td>
	<td>\(e\)</td>
  </tr>
  <tr>
    <td>\(r_2\)</td>
    <td>\(r_2\)</td>
    <td>\(r_3\)</td>
	<td>\(e\)</td>
	<td>\(r_1\)</td>
  </tr>
  <tr>
    <td>\(r_3\)</td>
    <td>\(r_3\)</td>
    <td>\(e\)</td>
	<td>\(r_1\)</td>
	<td>\(r_2\)</td>
  </tr>
</table>
</div>
<p><br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Symmetries of the Square</b></h4>
<p>What about the symmetries of the square? There are eight of them. First we consider the axis coming through the centroid of the face toward us. There are three rotations around this axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-r.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-r2.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-r3.png" width="55%" class="center" /></p>

<p>Next, we can consider the \(x-\)axis or the axis coming through the center of the edges. We can do a \(180\) degrees rotation around this access (a flip). Call this one \(a\).</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-a.png" width="55%" class="center" /></p>

<p>Similarly, we can do one around the \(y-\)axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-b.png" width="55%" class="center" /></p>

<p>And then two more through the diagonals of the square.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-c.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-d.png" width="55%" class="center" /></p>

<div>
$$
\begin{align*}
G = \{e, r, r^2, r^3, a, b, c, d\}
\end{align*}
$$
</div>
<p><br />
<br />
<br />
<br />
<br />
<br /></p>

<div class="mintheaderdiv">
Definition 1.11.1
</div>
<div class="mintbodydiv">
<ol type="a">
	<li>Under addition, \(R\) is an abelian group.</li>
	<li>Multiplication is associaive.</li>
	<li>Multiplication distributes over addition. \(a(b+c) = ab + ac\), and \((b+c)a = ba + ca\) for all \(a,b,c \in R\).</li>
</ol>
</div>
<p><br />
<br />
<!------------------------------------------------------------------------></p>
<div class="peachheaderdiv">
Proposition 2.5.3
</div>
<div class="peachbodydiv">
<ol type="a">
	<li>\(a \in bH\).</li>
	<li>\(b \in aH\).</li>
	<li>\(aH = bH\).</li>
	<li>\(b^{-1}a \in H\).</li>
	<li>\(a^{-1}b \in H\).</li>
</ol>
</div>
<!------------------------------------------------------------------------>
<p><br />
<b>Proof</b>
<br />
<br />
<br />
For \((d)\) ….
<br />
<br />
<br />
<!------------------------------------------------------------------------></p>
<div class="yellowheaderdiv">
Theorem 2.5.6 (Lagrange's Theorem)
</div>
<div class="yellowbodydiv">
k
</div>
<!------------------------------------------------------------------------>
<p><br /></p>

<p><br />
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>MATH417 by Charles Rezk</li>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Introduction Abstract Algebra lets us examine structures which allow for algebraic manipulations of the types we’ve used in high school. As an example, we have Fields. It’s a set with operations addition, subtraction, multiplication and division that satisfy a few rules. An example of a field is the field of real numbers \(\mathbf{R}\) or the field of complex numbers \(\mathbf{C}\). We also have the field of rational numbers \(\mathbf{Q}\). Or \(\mathbf{Z}_p\) which is a finite field of integers modulo some prime \(p\). It is finite with \(p\) elements. Another example of important structures are Rings. Here we have the operations addition, subtraction and multiplication. The first example of a ring is \(\mathbf{Z}\). Another example of a ring is a polynomial ring in one variable over \(\mathbf{R}\), \(\mathbf{R}[x]\). The set of all square matrices. \(M_{n \times n}(\mathbf{R})\) is also another example. This example is non-commutative. Another structure is a Group. It is a set with one operation usually called “multiplication”. One example is the set of real numbers with just addition. Another example is \((\mathbf{R}^{x})\) (the set of real numbers with zero removed, \(\mathbf{R} - \{0\}\) along with multiplication. \(GL(n,\mathbf{R})\), the set of invertible matrices with multiplication is another example of a Group. This is an example of a non-abelian or non-commutative group. One additional structure that comes up is a Monoid. These are sets with one operation but you don’t have to have inverses like Groups. So \(\mathbf{R}\) with multiplication is not a group because it includes zero and zero doesn’t have an inverse but this set is a Monoid. Groups and Symmetries]]></summary></entry><entry><title type="html">Lecture 01: Groups and Symmetries</title><link href="http://localhost:4000/jekyll/update/2025/01/24/math417-01-groups-and-symmetries.html" rel="alternate" type="text/html" title="Lecture 01: Groups and Symmetries" /><published>2025-01-24T00:01:36-08:00</published><updated>2025-01-24T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/24/math417-01-groups-and-symmetries</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/24/math417-01-groups-and-symmetries.html"><![CDATA[<h4><b>Introduction</b></h4>
<p>Abstract Algebra lets us examine structures which allow for algebraic manipulations of the types we’ve used in high school. As an example, we have Fields. It’s a set with operations addition, subtraction, multiplication and division that satisfy a few rules. An example of a field is the field of real numbers \(\mathbf{R}\) or the field of complex numbers \(\mathbf{C}\). We also have the field of rational numbers \(\mathbf{Q}\). Or \(\mathbf{Z}_p\) which is a finite field of integers modulo some prime \(p\). It is finite with \(p\) elements.
<br />
<br />
Another example of important structures are Rings. Here we have the operations addition, subtraction and multiplication. The first example of a ring is \(\mathbf{Z}\). Another example of a ring is a polynomial ring in one variable over \(\mathbf{R}\), \(\mathbf{R}[x]\). The set of all square matrices. \(M_{n \times n}(\mathbf{R})\) is also another example. This example is non-commutative.<br />
<br />
<br />
Another structure is a Group. It is a set with one operation usually called “multiplication”. One example is the set of real numbers with just addition. Another example is \((\mathbf{R}^{x})\) (the set of real numbers with zero removed, \(\mathbf{R} - \{0\}\) along with multiplication. \(GL(n,\mathbf{R})\), the set of invertible matrices with multiplication is another example of a Group. This is an example of a non-abelian or non-commutative group.
<br />
<br />
One additional structure that comes up is a Monoid. These are sets with one operation but you don’t have to have inverses like Groups. So \(\mathbf{R}\) with multiplication is not a group because it includes zero and zero doesn’t have an inverse but this set is a Monoid. 
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Groups and Symmetries</b></h4>

<p>From the book, a symmetry is an undetectable motion. An object is symmetric if it has symmetries. Take an equilateral triangle.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-1.png" width="40%" class="center" /></p>

<p>What are the symmetries of this triangle? We want to rotate the triangle in such a way that we won’t tell if it was rotated. For example, if we rotate this triangle by \(120\) degrees counter clockwise, then we’ll get a triangle in the same exact orientation. We label this rotation with \(r_1\). Note here that the labels on the vertices are used to illustrate that we indeed have rotated the triangle. They are a visual aid.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-2.png" width="70%" class="center" /></p>

<p>We can also rotate this triangle \(120\) degrees clockwise to get the following \(r_2\) rotation.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-3.png" width="70%" class="center" /></p>

<p>Are there more rotations? Yes, consider the rotation around the axis that goes through the vertex \(A\) by 180 degrees so essentially it’s a flip around that axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-4.png" width="70%" class="center" /></p>

<p>Similarly, we can do a flip around the axis that goes through the vertex \(B\) and a flip around the axis that goes through the vertex \(C\).</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-5.png" width="40%" class="center" /></p>

<p>So now we have \(5\) symmetries total. Is that all? No, We have one more symmetry representing the identity symmetry \(e\) that does nothing. So the set of symmetries are then</p>
<div>
$$
\begin{align*}
G = \{e, r_1, r_2, a, b, c\}
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Can We Compose Symmetries?</b></h4>

<p>Can we compose symmetries? Yes, in fact we’ll equip the group above with the operation compose. This means that for any \(x, y \in G\), \(xy\) means that we need to apply the rotation \(y\) first and then apply the rotation \(x\). Since we have \(6\) elements in \(G\), then we have \(36\) ways of composing these elements. 
<br />
<br />
For example composing \(r_1\) with \(r_1\) again results in the rotation \(r_2\) so \(r_1r_1 = r_2\).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-6.png" width="70%" class="center" /></p>
<p>And if we compose \(r_1\) with \(r_2\), then we’ll get the identity rotation so \(r_1r_2 = e\).</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-7.png" width="70%" class="center" /></p>
<p>In fact since \(r_1r_1 = r_2\) and \(r_1r_2 = e\), we’ll change the notation to a much simpler notation. Let \(r_1 = r\). Then, \(r_2 = r_1r_1 = rr = r^2\). So now we can fill these in a table as follows
<br />
<!------------------------------------------------------------------------></p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(\)</td>
   <td>\(\)</td>	
   <td>\(\)</td>
   <td>\(\)</td>
   <td>\(\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
</table>
</div>
<p><br />
So far so good. What about composing the flips around the axes? For example composing \(a\) with \(b\). What would that do? For starters, note that each flip is a \(180\) degrees flip. So if you compose ANY two flips, we’ll be back to the same face we started with. This means that any two flips will be equivalent to \(e, r\) or \(r^2\). For example, if we apply \(a\) and then apply \(b\), we’ll get</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-8.png" width="90%" class="center" /></p>

<p>Note here that when did the second flip, we still rotated through the \(b\) access which now goes through vertex \(C\) instead. Physically the axis will still be in the same position. So we see above doing two flips \(a\), then around \(b\) is equivalent to applying two rotations so \(ba = r^2\). 
<br />
<br />
What about two flips of the same type? What happens if you apply \(a\) and then again flip it around that same access? We’ll get the identity rotation since we just go back to the same exact orientation. Applying this same logic on the rest of flips, we can fill that forth quadrant of the table which are all about compositions of flips.
<br />
<br />
<!------------------------------------------------------------------------></p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(\)</td>
   <td>\(\)</td>	
   <td>\(r^2\)</td>
   <td>\(e\)</td>
   <td>\(r\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(\)</td>
	<td>\(\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
  </tr>
</table>
</div>
<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Second and Third Quadrants</b></h4>
<p>What about applying a rotation \(r\) followed by a flip \(a\)? What is \(ar\)? We apply a rotation so we move \(120\) degrees anti-clockwise and then we do an \(a\) flip which is now going to be through the \(C\) vertex. The triangle will now be faced down which is equivalent to applying a single flip. Comparing the vertices in the original triangle and the outcome, we see that \(B\) is fixed while \(A\) and \(C\) have switched. This means that this is a flip around the \(b\) access.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-9.png" width="90%" class="center" /></p>

<!------------------------------------------------------------------------>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
  </tr>
  <tr>
    <td>\(r\)</td>
    <td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(c\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
  </tr>
  <tr>
    <td>\(r^2\)</td>
    <td>\(r^2\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
	<td>\(a\)</td>
  </tr>
  <tr>
    <td>\(a\)</td>
    <td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(c\)</td>
	<td>\(e\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
  </tr>
 <tr>
   <td>\(b\)</td>
   <td>\(b\)</td>
   <td>\(c\)</td>
   <td>\(a\)</td>	
   <td>\(r^2\)</td>
   <td>\(e\)</td>
   <td>\(r\)</td>
 </tr>
  <tr>
    <td>\(c\)</td>
    <td>\(c\)</td>
	<td>\(a\)</td>
	<td>\(b\)</td>
	<td>\(r\)</td>
	<td>\(r^2\)</td>
	<td>\(e\)</td>
  </tr>
</table>
</div>
<p>We notice that each row has each rotation appearing exactly once and it’s the same for each column. Notice also that composition is not commutative above. So \(ar \neq ra\).
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Matrix Representation of Symmetries</b></h4>
<p>We can actually represent these symmetries by matrices. For example, the following matrix will represent a \(120\) degrees rotation around the \(z-\) axis</p>
<div>
$$
\begin{align*}
r(x,y,z) &amp;= 
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; - \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; + \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p>or we can do the \(a\) flip so a \(180\) degree flip around the \(x\)-axis.</p>
<div>
$$
\begin{align*}
a(x,y,z) &amp;= 
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 0
\end{pmatrix}
\end{align*}
$$
</div>
<p>What about something more complex? like \(ra\) which is equal to \(c\) using the multiplication table above. This will be</p>
<div>
$$
\begin{align*}
c(x,y,z) &amp;= ra(x,y,z) 
\\
&amp;= 
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; - \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; + \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\begin{pmatrix}
1 &amp; 0 &amp; 0 \\
0 &amp; 1 &amp; 0 \\
0 &amp; -1 &amp; 0
\end{pmatrix}
\\
&amp;=
\begin{pmatrix}
\cos\frac{2\pi}{3} &amp; \sin\frac{2\pi}{3} &amp; 0 \\
\sin\frac{2\pi}{3} &amp; - \cos\frac{2\pi}{3} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{pmatrix}
\end{align*}
$$
</div>
<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Symmetries of the Rectangle</b></h4>
<p>How many symmetries does the rectangle have?</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect.png" width="30%" class="center" /></p>

<p>We can have a rotation \(r_1\) around the \(y-\)axis as follows</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect-r1.png" width="75%" class="center" /></p>

<p>We can also have a rotation \(r_2\) around the \(x-\)axis</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect-r2.png" width="75%" class="center" /></p>

<p>Finally, we have one more rotation \(r_3\) around the \(z-\)axis. (the axis coming off the screen toward us from the centroid of the face.)</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-rect-r3.png" width="75%" class="center" /></p>

<p>So we have four rotations which make the following group</p>
<div>
$$
\begin{align*}
G = \{e, r_1, r_2, r_3\}
\end{align*}
$$
</div>
<p>One thing to notice here that for any rotation in \(G\), if you apply it twice, you’ll get the identity rotation. So each rotation has an order \(2\). The multiplication table for the symmetries of the rectangle is as follows</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td></td>
    <td>\(e\)</td>
    <td>\(r_1\)</td>
	<td>\(r_2\)</td>
	<td>\(r_3\)</td>
  </tr>
  <tr>
    <td>\(e\)</td>
    <td>\(e\)</td>
    <td>\(r_1\)</td>
	<td>\(r_2\)</td>
	<td>\(r_3\)</td>
  </tr>
  <tr>
    <td>\(r_1\)</td>
    <td>\(r_1\)</td>
    <td>\(r_2\)</td>
	<td>\(r_3\)</td>
	<td>\(e\)</td>
  </tr>
  <tr>
    <td>\(r_2\)</td>
    <td>\(r_2\)</td>
    <td>\(r_3\)</td>
	<td>\(e\)</td>
	<td>\(r_1\)</td>
  </tr>
  <tr>
    <td>\(r_3\)</td>
    <td>\(r_3\)</td>
    <td>\(e\)</td>
	<td>\(r_1\)</td>
	<td>\(r_2\)</td>
  </tr>
</table>
</div>
<p><br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>Symmetries of the Square</b></h4>
<p>What about the symmetries of the square? There are eight of them. First we consider the axis coming through the centroid of the face toward us. There are three rotations around this axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-r.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-r2.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-r3.png" width="55%" class="center" /></p>

<p>Next, we can consider the \(x-\)axis or the axis coming through the center of the edges. We can do a \(180\) degrees rotation around this access (a flip). Call this one \(a\).</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-a.png" width="55%" class="center" /></p>

<p>Similarly, we can do one around the \(y-\)axis.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-b.png" width="55%" class="center" /></p>

<p>And then two more through the diagonals of the square.</p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-c.png" width="55%" class="center" /></p>

<p style="text-align:center;"><img src="http://localhost:4000/assets/math/abstract-algebra/01-square-d.png" width="55%" class="center" /></p>

<div>
$$
\begin{align*}
G = \{e, r, r^2, r^3, a, b, c, d\}
\end{align*}
$$
</div>
<p><br />
What about the cube? How many symmetries does it have? it has 24 symmetries!
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li>MATH417 by Charles Rezk</li>
<li><a href="https://homepage.divms.uiowa.edu/~goodman/algebrabook.dir/algebrabook.html">Algebra: Abstract and Concrete by Frederick M. Goodman</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Introduction Abstract Algebra lets us examine structures which allow for algebraic manipulations of the types we’ve used in high school. As an example, we have Fields. It’s a set with operations addition, subtraction, multiplication and division that satisfy a few rules. An example of a field is the field of real numbers \(\mathbf{R}\) or the field of complex numbers \(\mathbf{C}\). We also have the field of rational numbers \(\mathbf{Q}\). Or \(\mathbf{Z}_p\) which is a finite field of integers modulo some prime \(p\). It is finite with \(p\) elements. Another example of important structures are Rings. Here we have the operations addition, subtraction and multiplication. The first example of a ring is \(\mathbf{Z}\). Another example of a ring is a polynomial ring in one variable over \(\mathbf{R}\), \(\mathbf{R}[x]\). The set of all square matrices. \(M_{n \times n}(\mathbf{R})\) is also another example. This example is non-commutative. Another structure is a Group. It is a set with one operation usually called “multiplication”. One example is the set of real numbers with just addition. Another example is \((\mathbf{R}^{x})\) (the set of real numbers with zero removed, \(\mathbf{R} - \{0\}\) along with multiplication. \(GL(n,\mathbf{R})\), the set of invertible matrices with multiplication is another example of a Group. This is an example of a non-abelian or non-commutative group. One additional structure that comes up is a Monoid. These are sets with one operation but you don’t have to have inverses like Groups. So \(\mathbf{R}\) with multiplication is not a group because it includes zero and zero doesn’t have an inverse but this set is a Monoid. Groups and Symmetries]]></summary></entry><entry><title type="html">Project Euler: 69 Totient Maximum</title><link href="http://localhost:4000/jekyll/update/2025/01/23/project-euler-69-totient-maximum.html" rel="alternate" type="text/html" title="Project Euler: 69 Totient Maximum" /><published>2025-01-23T00:01:36-08:00</published><updated>2025-01-23T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/23/project-euler-69-totient-maximum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/23/project-euler-69-totient-maximum.html"><![CDATA[<p>I wrote about Euler’s Totient function in <a href="https://strncat.github.io/jekyll/update/2025/01/22/euler-totient.html">here</a>, but to recap, given an integer \(n\), the Totient function \(\phi(n)\) is the number of positive integers not exceeding \(n\) and are relatively prime to \(n\). The goal of this problem is to find  \(n\) such that \(\frac{n}{\phi(n)}\) is maximized.
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>To start, we should definitely make use of the existing formula to compute the Totient function. Given an integer \(n\) and the distinct prime divisors of \(n\),  \(\{p_1,p_2...,p_k\}\), we can compute the Totient function as follows</p>
<div>
	$$
	\begin{align*}
	 \phi(n) = n \prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big).
	\end{align*}
	$$
</div>
<p>Since we’re interested in computing specifically \(\frac{n}{\phi(n)}\) so we get a simplified expression as follows</p>
<div>
	$$
	\begin{align*}
	 \frac{n}{\phi(n)} &amp;= \frac{n}{n\prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big)} \\
	                   &amp;= \frac{1}{\big( 1 - \frac{1}{p_1} \big) \big( 1 - \frac{1}{p_2} \big) ... \big( 1 - \frac{1}{p_k} \big)} \\
					   &amp;= \frac{1}{\big( \frac{p_1 - 1}{p_1} \big) \big( \frac{p_2 - 1}{p_2} \big) ... \big( \frac{p_k - 1}{p_k} \big)}  \\
					   &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1)  }
	\end{align*}
	$$
</div>
<p>Before we can implement the function, we need to generate these distinct prime factors. We implemented this before in <a href="https://strncat.github.io/jekyll/update/2024/12/24/project-euler-03-largest-prime-factor.html">Problem 3</a>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">prime_factorization</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">factors</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// prime factor 2</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">factors</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// all the other prime factors</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">factors</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">n</span> <span class="o">/=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// n is prime itself</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">factors</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
Once we have these distinct factors, we can just run this for all integers \(n \leq 1000000\) as follows:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">double</span> <span class="n">max</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1000000</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">factors</span><span class="p">;</span>
        <span class="n">prime_factorization</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">factors</span><span class="p">);</span>
        <span class="kt">double</span> <span class="n">tot</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">//printf("%d: ", i);</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">e</span> <span class="o">=</span> <span class="n">factors</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">factors</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">e</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//printf("%d, ", *e);</span>
            <span class="n">tot</span> <span class="o">*=</span> <span class="o">*</span><span class="n">e</span> <span class="o">/</span> <span class="p">(</span><span class="o">*</span><span class="n">e</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tot</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">tot</span><span class="p">;</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//printf("tot = %f \n", tot);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"max n = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span></code></pre></figure>

<p>I added one small optimization which didn’t do much and feels unnecessary to skip prime numbers since based on the formula, the solution will never be a prime number.
<br />
<br />
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0069-totient-maximum">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>More Advanced Solution?</b></h4>
<p>while the brute force solution is great (good to practice writing all of these methods), you can see above that the formula</p>
<div>
	$$
	\begin{align*}
	 \frac{n}{\phi(n)} &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1)  }
	\end{align*}
	$$
</div>
<p>is maximized when we have the most distinct prime numbers. So instead we can generate all prime numbers with sieve and then multiply them until we hit the limit \(1,000,000\).
<br />
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=69">Project Euler - 69</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I wrote about Euler’s Totient function in here, but to recap, given an integer \(n\), the Totient function \(\phi(n)\) is the number of positive integers not exceeding \(n\) and are relatively prime to \(n\). The goal of this problem is to find \(n\) such that \(\frac{n}{\phi(n)}\) is maximized. Solution To start, we should definitely make use of the existing formula to compute the Totient function. Given an integer \(n\) and the distinct prime divisors of \(n\), \(\{p_1,p_2...,p_k\}\), we can compute the Totient function as follows $$ \begin{align*} \phi(n) = n \prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big). \end{align*} $$ Since we’re interested in computing specifically \(\frac{n}{\phi(n)}\) so we get a simplified expression as follows $$ \begin{align*} \frac{n}{\phi(n)} &amp;= \frac{n}{n\prod_{i=1}^{k} \big( 1 - \frac{1}{p_i} \big)} \\ &amp;= \frac{1}{\big( 1 - \frac{1}{p_1} \big) \big( 1 - \frac{1}{p_2} \big) ... \big( 1 - \frac{1}{p_k} \big)} \\ &amp;= \frac{1}{\big( \frac{p_1 - 1}{p_1} \big) \big( \frac{p_2 - 1}{p_2} \big) ... \big( \frac{p_k - 1}{p_k} \big)} \\ &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1) } \end{align*} $$ Before we can implement the function, we need to generate these distinct prime factors. We implemented this before in Problem 3. void prime_factorization(int n, std::set&lt;int&gt;&amp; factors) { // prime factor 2 while (n % 2 == 0) { n /= 2; factors.insert(2); } // all the other prime factors int limit = sqrt(n); for (int i = 3; i &lt;= limit; i += 2) { while (n % i == 0) { factors.insert(i); n /= i; } } // n is prime itself if (n &gt; 2) { factors.insert(n); } } Once we have these distinct factors, we can just run this for all integers \(n \leq 1000000\) as follows: double max = 0.0; int n = 0; for (int i = 1000000; i &gt; 0; i--) { if (!prime[i]) { std::set&lt;int&gt; factors; prime_factorization(i, factors); double tot = 1; //printf("%d: ", i); for (auto e = factors.begin(); e != factors.end(); e++) { //printf("%d, ", *e); tot *= *e / (*e - 1.0); } if (tot &gt; max) { max = tot; n = i; } //printf("tot = %f \n", tot); } } printf("max n = %d\n", n); I added one small optimization which didn’t do much and feels unnecessary to skip prime numbers since based on the formula, the solution will never be a prime number. The entire code is here. More Advanced Solution? while the brute force solution is great (good to practice writing all of these methods), you can see above that the formula $$ \begin{align*} \frac{n}{\phi(n)} &amp;= \frac{p_1 p_2 ... p_k}{ (p_1 - 1) (p_2 - 1) ... (p_k - 1) } \end{align*} $$ is maximized when we have the most distinct prime numbers. So instead we can generate all prime numbers with sieve and then multiply them until we hit the limit \(1,000,000\). References Project Euler - 69]]></summary></entry><entry><title type="html">Euler’s Totient Function</title><link href="http://localhost:4000/jekyll/update/2025/01/22/euler-totient.html" rel="alternate" type="text/html" title="Euler’s Totient Function" /><published>2025-01-22T00:01:36-08:00</published><updated>2025-01-22T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/22/euler-totient</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/22/euler-totient.html"><![CDATA[<div class="mintheaderdiv">
Definition
</div>
<div class="mintbodydiv">
Given an integer \(n\). Euler's totient function is a function that counts the positive integers up to \(n\) that are relatively prime to \(n\). It is denoted with \(\phi(n)\).
</div>
<p><br />
Alternatively, it is the the number of integers \(k\) in the range \(1 \leq k \leq n\) for which \(gcd(n,k)=1\). 
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>Take \(n = 9\). The numbers \(1,2,4,5,7\) and \(8\) are relatively prime to \(9\) while \(3,6\) and \(9\) are not. Therefore \(\phi(9) = 6\). 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Computing Euler Totient's Function</b></h4>
<p>One formula that computes Euler’s Totient’s function is the following</p>
<div>
$$
\begin{align*}
\phi(n) = n \prod_{p|n} \big( 1 - \frac{1}{p} \big).
\end{align*}
$$
</div>
<p>where \(p\) is a distinct prime factor of \(n\). For example, for \(9\),</p>
<div>
$$
\begin{align*}
\phi(9) &amp;= 9 \big( 1 - \frac{1}{3} \big) \\
        &amp;= 9 \big( \frac{2}{3} \big) = 6.
\end{align*}
$$
</div>
<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Multiplicative Function</b></h4>
<p>Euler’s Totient’s function is a multiplicative function. This means that if \(m\) and \(n\) are relatively prime, then \(\phi(mn) = \phi(m)(n)\) which makes sense since they won’t share any prime divisors. 
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Wikipedia</a></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Definition Given an integer \(n\). Euler's totient function is a function that counts the positive integers up to \(n\) that are relatively prime to \(n\). It is denoted with \(\phi(n)\). Alternatively, it is the the number of integers \(k\) in the range \(1 \leq k \leq n\) for which \(gcd(n,k)=1\). Example Take \(n = 9\). The numbers \(1,2,4,5,7\) and \(8\) are relatively prime to \(9\) while \(3,6\) and \(9\) are not. Therefore \(\phi(9) = 6\). Computing Euler Totient's Function One formula that computes Euler’s Totient’s function is the following $$ \begin{align*} \phi(n) = n \prod_{p|n} \big( 1 - \frac{1}{p} \big). \end{align*} $$ where \(p\) is a distinct prime factor of \(n\). For example, for \(9\), $$ \begin{align*} \phi(9) &amp;= 9 \big( 1 - \frac{1}{3} \big) \\ &amp;= 9 \big( \frac{2}{3} \big) = 6. \end{align*} $$ Multiplicative Function Euler’s Totient’s function is a multiplicative function. This means that if \(m\) and \(n\) are relatively prime, then \(\phi(mn) = \phi(m)(n)\) which makes sense since they won’t share any prime divisors. References Wikipedia]]></summary></entry><entry><title type="html">Project Euler: 33 Digit Cancelling Fractions</title><link href="http://localhost:4000/jekyll/update/2025/01/21/project-euler-33-digit-canceling-fractions.html" rel="alternate" type="text/html" title="Project Euler: 33 Digit Cancelling Fractions" /><published>2025-01-21T00:01:36-08:00</published><updated>2025-01-21T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/21/project-euler-33-digit-canceling-fractions</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/21/project-euler-33-digit-canceling-fractions.html"><![CDATA[<p>The goal of this problem is to find the exact 4 fractions such that</p>
<ul>
	<li>The fraction is less than one in value.</li>
	<li>It contains two digits in the numerator and two digits in the denominator.</li>
	<li>The numerator and denominator have a digit in common.</li>
	<li>If you remove the common digit from both the numerator and the denominator, you'll get a fraction equal to what you get when you simplify the fraction in a proper way. For example, \(49 / 98\) has \(9\) as a common digit. If we remove it, then we'll get \(4/8\) which is the actual value that you would get if you properly divide both the numerator and the denominator by \(49\).</li>
	<li>We should not count trivial examples. For example \(30/50 = 3/5\) is a trivial example.</li>
</ul>
<p>With just the first three conditions, the search space contains at most 1377 fractions. You can use the loop below to see them!
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">den</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">den</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">den</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">den</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">d1</span> <span class="o">||</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">||</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">d1</span> <span class="o">||</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">d2</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d / %d with digits %d%d / %d%d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">den</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">d1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"count = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>Since we have at most \(1377\) cases, then we can easily check all of them. We will ignore trivial cases. For the non-trivial cases like \(49/98\), we will extract the \(4\) digits and save them in different variables. The numerator digits are \(n_1 = 9\) and \(n_2 = 4\). The denominator digits are \(d_1 = 8\) and \(d_2 = 8\). To check if \(\frac{49}{98}\) is equal to \(\frac{4}{8}\), we can check if</p>
<div>
	$$
	\begin{align*}
	 49 \times 8 &amp;= 98 * 4 \\
	 numerator \times d_1 &amp;= denominator \times n_2 
	\end{align*}
	$$
</div>
<p>After we collect all the fractions, we can divide by the greatest common divisor. This is captured in the following code.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">numerator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">denominator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">den</span> <span class="o">=</span> <span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">den</span> <span class="o">&lt;=</span> <span class="mi">99</span><span class="p">;</span> <span class="n">den</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">num</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">den</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">d2</span> <span class="o">=</span> <span class="n">den</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="c1">//</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n2</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">||</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">d1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// even if it works, this is a trivial example</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">==</span> <span class="n">d2</span> <span class="o">||</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">d1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// example is 49/98. this will simplify to 4/8</span>
            <span class="c1">// now we want to check if 49/98 == 4/8 which is the same as checking if 49*8 == 98*4</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">den</span> <span class="o">*</span> <span class="n">n2</span> <span class="o">==</span> <span class="n">num</span> <span class="o">*</span> <span class="n">d1</span> <span class="o">||</span> <span class="n">den</span> <span class="o">*</span> <span class="n">n1</span> <span class="o">==</span> <span class="n">num</span> <span class="o">*</span> <span class="n">d2</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// printf("%d / %d\n", num, den);</span>
                <span class="n">numerator</span> <span class="o">*=</span> <span class="n">num</span><span class="p">;</span>
                <span class="n">denominator</span> <span class="o">*=</span> <span class="n">den</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="n">gcd</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">gcd</span><span class="p">(</span><span class="n">numerator</span><span class="p">,</span><span class="n">denominator</span><span class="p">);</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"denominator = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">denominator</span><span class="o">/</span><span class="n">gcd</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0033-digit-canceling-fractions.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=33">Project Euler - 33</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The goal of this problem is to find the exact 4 fractions such that The fraction is less than one in value. It contains two digits in the numerator and two digits in the denominator. The numerator and denominator have a digit in common. If you remove the common digit from both the numerator and the denominator, you'll get a fraction equal to what you get when you simplify the fraction in a proper way. For example, \(49 / 98\) has \(9\) as a common digit. If we remove it, then we'll get \(4/8\) which is the actual value that you would get if you properly divide both the numerator and the denominator by \(49\). We should not count trivial examples. For example \(30/50 = 3/5\) is a trivial example. With just the first three conditions, the search space contains at most 1377 fractions. You can use the loop below to see them! int count = 0; for (int num = 10; num &lt;= 99; num++) { for (int den = num+1; den &lt;= 99; den++) { int n1 = num % 10; int n2 = num / 10; int d1 = den % 10; int d2 = den / 10; if (n1 == d1 || n1 == d2 || n2 == d1 || n2 == d2) { count++; printf("%d / %d with digits %d%d / %d%d \n", num, den, n2, n1, d2, d1); } } } printf("count = %d\n", count); Solution Since we have at most \(1377\) cases, then we can easily check all of them. We will ignore trivial cases. For the non-trivial cases like \(49/98\), we will extract the \(4\) digits and save them in different variables. The numerator digits are \(n_1 = 9\) and \(n_2 = 4\). The denominator digits are \(d_1 = 8\) and \(d_2 = 8\). To check if \(\frac{49}{98}\) is equal to \(\frac{4}{8}\), we can check if $$ \begin{align*} 49 \times 8 &amp;= 98 * 4 \\ numerator \times d_1 &amp;= denominator \times n_2 \end{align*} $$ After we collect all the fractions, we can divide by the greatest common divisor. This is captured in the following code. int numerator = 1; int denominator = 1; for (int num = 10; num &lt;= 99; num++) { for (int den = num+1; den &lt;= 99; den++) { int n1 = num % 10; int n2 = num / 10; int d1 = den % 10; int d2 = den / 10; // if (n2 == d2 || n1 == d1) { continue; // even if it works, this is a trivial example } if (n1 == d2 || n2 == d1) { // example is 49/98. this will simplify to 4/8 // now we want to check if 49/98 == 4/8 which is the same as checking if 49*8 == 98*4 if (den * n2 == num * d1 || den * n1 == num * d2) { // printf("%d / %d\n", num, den); numerator *= num; denominator *= den; } } } } int gcd = std::gcd(numerator,denominator); printf("denominator = %d\n", denominator/gcd); The entire code is here. References Project Euler - 33]]></summary></entry><entry><title type="html">Project Euler: 02 Even Fibonacci Numbers</title><link href="http://localhost:4000/jekyll/update/2025/01/20/project-euler-02-even-fibonacci-numbers.html" rel="alternate" type="text/html" title="Project Euler: 02 Even Fibonacci Numbers" /><published>2025-01-20T00:01:36-08:00</published><updated>2025-01-20T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/20/project-euler-02-even-fibonacci%20numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/20/project-euler-02-even-fibonacci-numbers.html"><![CDATA[<p>The first few terms of the fibonacci sequence are</p>
<div>
	$$
	\begin{align*}
	1,2,3,5,8,13,21,34,55,89,...
	\end{align*}
	$$
</div>
<p>The goal of this problem is finding the sum of the even-valued terms where the maximum term that we need to consider is at most 4 million.
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>One thing to note immediately is that we’re going to exceed 4 million just with the 35th term! So the simplest solution that just implements the fibonacci recurrence (below) will work.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define N 35 // the 35th term exceeds 4 million
</span><span class="c1">// all fibonacci's terms</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">all</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">void</span> <span class="nf">fibonacci_all</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">all</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">all</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">all</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">35</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">fibonacci_all</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// add only if it's even</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">all</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sum = %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span> <span class="c1">// works!</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0002-even-fibonacci-numbers.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=2">Project Euler - 02</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The first few terms of the fibonacci sequence are $$ \begin{align*} 1,2,3,5,8,13,21,34,55,89,... \end{align*} $$ The goal of this problem is finding the sum of the even-valued terms where the maximum term that we need to consider is at most 4 million. Solution One thing to note immediately is that we’re going to exceed 4 million just with the 35th term! So the simplest solution that just implements the fibonacci recurrence (below) will work. #define N 35 // the 35th term exceeds 4 million // all fibonacci's terms unsigned long long all[N] = {0}; void fibonacci_all() { all[0] = 0; all[1] = 1; all[2] = 1; for (int i = 3; i &lt; 35; i++) { all[i] = all[i-1] + all[i-2]; } } int main(int argc, const char * argv[]) { fibonacci_all(); unsigned long long sum = 0; for (int i = 0; i &lt; N; i++) { if (all[i] % 2 == 0) { // add only if it's even sum += all[i]; } } printf("sum = %llu\n", sum); // works! return 0; } The entire code is here. References Project Euler - 02]]></summary></entry><entry><title type="html">Project Euler: 50 Consecutive Prime Sum</title><link href="http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum.html" rel="alternate" type="text/html" title="Project Euler: 50 Consecutive Prime Sum" /><published>2025-01-19T00:01:36-08:00</published><updated>2025-01-19T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum.html"><![CDATA[<p>The prime \(41\), can be written as the sum of six consecutive primes \(2 + 3 + 5 + 7 + 11 + 13\). The goal of this problem is to find the prime below one-million that can be written as the sum of the most consecutive primes. 
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>It took me a few attempts to get this one right. The first few recurrences that I was trying to build didn’t go anywhere and one of them was this two dimensional table that included every sum of the primes between any pair of prime numbers \(i\) and \(j\). But that was too much. After a few more attempts on paper, I noticed one critical pattern that led to a reasonable solution. To see this, write down the first few consecutive sums below</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>Prime</td>
    <td>\(2\)</td>
    <td>\(3\)</td>
    <td>\(5\)</td>
	<td>\(7\)</td>
	<td>\(11\)</td>
	<td>\(13\)</td>
	<td>\(17\)</td>
	<td>\(...\)</td>
  </tr>
  <tr>
    <td>Sum</td>
    <td>\(2\)</td>
    <td>\(5\)</td>
    <td>\(10\)</td>
	<td>\(17\)</td>
	<td>\(28\)</td>
	<td>\(41\)</td>
	<td>\(58\)</td>
	<td>\(...\)</td>
  </tr>
</table>
</div>
<p>Now notice that if we wanted to find the sum of primes between \(3\) and \(11\) not including \(3\), then we can use the table above to see that it is</p>
<div>
	$$
	\begin{align*}
	 sum(11) - sum(3) &amp;= 28 - 5 = 23
	\end{align*}
	$$
</div>
<p>which is exactly the sum of primes \(5 + 7 + 11\). So for any two primes \(i\) and \(j\), the sum of the primes between them (while including \(j\) and not \(i\)) is</p>
<div>
	$$
	\begin{align*}
	 sum(j) - sum(i)
	\end{align*}
	$$
</div>
<p>This idea is crucial. Because all we have to do now is try all prime pairs below 1 million and we’ll get an \(O(n^2)\) algorithm instead of an exponential one. All we need to do is to pre-compute that table with all the sums and then write a double loop to find the prime that can be written as the sum of the most consecutive primes.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">cons_sum</span> <span class="o">=</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">-</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">second</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">cons_sum</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cons_sum</span><span class="p">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
But checking every pair below one million is a lot. Does prime_numbers above need to have all the prime numbers below 1 million? No! Another critical hint to this problem that I completely missed is that the prime we’re trying to find has to be below a million. In fact, the sum of the first \(546\) primes will already exceed a million! Therefore, we can limit the search to a much smaller range of prime numbers.
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prime_numbers</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">consecutive_sums</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">prime_sums</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// fake prime</span>
    <span class="n">consecutive_sums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span>  <span class="mi">546</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c1">// we don't need more than that!</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
Finally, the method to precompute the prime_numbers array is the usual sieve method that we’ve used over and over again before. Adding it below for completion.
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">prime</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>The entire code is <a href="https://github.com/strncat/project-euler/blob/main/0050-consecutive-prime-sum.cpp">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=50">Project Euler - 50</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The prime \(41\), can be written as the sum of six consecutive primes \(2 + 3 + 5 + 7 + 11 + 13\). The goal of this problem is to find the prime below one-million that can be written as the sum of the most consecutive primes. Solution It took me a few attempts to get this one right. The first few recurrences that I was trying to build didn’t go anywhere and one of them was this two dimensional table that included every sum of the primes between any pair of prime numbers \(i\) and \(j\). But that was too much. After a few more attempts on paper, I noticed one critical pattern that led to a reasonable solution. To see this, write down the first few consecutive sums below Prime \(2\) \(3\) \(5\) \(7\) \(11\) \(13\) \(17\) \(...\) Sum \(2\) \(5\) \(10\) \(17\) \(28\) \(41\) \(58\) \(...\) Now notice that if we wanted to find the sum of primes between \(3\) and \(11\) not including \(3\), then we can use the table above to see that it is $$ \begin{align*} sum(11) - sum(3) &amp;= 28 - 5 = 23 \end{align*} $$ which is exactly the sum of primes \(5 + 7 + 11\). So for any two primes \(i\) and \(j\), the sum of the primes between them (while including \(j\) and not \(i\)) is $$ \begin{align*} sum(j) - sum(i) \end{align*} $$ This idea is crucial. Because all we have to do now is try all prime pairs below 1 million and we’ll get an \(O(n^2)\) algorithm instead of an exponential one. All we need to do is to pre-compute that table with all the sums and then write a double loop to find the prime that can be written as the sum of the most consecutive primes. int p = 0; int max = 0; for (int i = prime_numbers.size() - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; i; j++) { int first = prime_numbers[i]; int second = prime_numbers[j]; int cons_sum = consecutive_sums[first] - consecutive_sums[second]; if (prime[cons_sum] &amp;&amp; max &lt; abs(i - j)) { p = cons_sum; max = abs(i - j); } } } printf("%d\n", p); But checking every pair below one million is a lot. Does prime_numbers above need to have all the prime numbers below 1 million? No! Another critical hint to this problem that I completely missed is that the prime we’re trying to find has to be below a million. In fact, the sum of the first \(546\) primes will already exceed a million! Therefore, we can limit the search to a much smaller range of prime numbers. std::vector&lt;int&gt; prime_numbers; std::unordered_map&lt;int,int&gt; consecutive_sums; void prime_sums() { int sum = 0; prime_numbers.push_back(0); // fake prime consecutive_sums[0] = 0; for (int i = 0; i &lt; N; i++) { if (prime[i]) { sum += i; prime_numbers.push_back(i); consecutive_sums[i] = sum; if (prime_numbers.size() &gt; 546) { break; // we don't need more than that! } } } } Finally, the method to precompute the prime_numbers array is the usual sieve method that we’ve used over and over again before. Adding it below for completion. int prime[N]; void sieve() { // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { prime[i] = 1; } prime[0] = prime[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (prime[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { prime[i] = 0; } } } } The entire code is here. References Project Euler - 50]]></summary></entry><entry><title type="html">Project Euler: 42 Coded Triangle Numbers</title><link href="http://localhost:4000/jekyll/update/2025/01/18/project-euler-42-coded-triangle-numbers.html" rel="alternate" type="text/html" title="Project Euler: 42 Coded Triangle Numbers" /><published>2025-01-18T00:01:36-08:00</published><updated>2025-01-18T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/18/project-euler-42-coded-triangle-numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/18/project-euler-42-coded-triangle-numbers.html"><![CDATA[<p>In this problem, we are introduced to the sequence of triangle numbers where the nth term of the sequence is given by</p>
<div>
	$$
	\begin{align*}
	 t_n = \frac{1}{2}n(n+1).
	\end{align*}
	$$
</div>
<p>The first 10 triangle numbers are therefore</p>
<div>
	$$
	\begin{align*}
	 1,3,6,10,15,21,28,36,45,55,...
	\end{align*}
	$$
</div>
<p>We are given a list of words in a file. A word’s alphabetical score is calculated by summing each letter’s alphabetical position. So for example, SKY’s alphabetical score is \(19+11+25 = 55\). This is also the 10th term in the triangle sequence above. So SKY is a triangle word. The goal of this problem is to find the number of triangle words in the file.
<br />
<br />
Similar to <a href="">Problem 22</a>, the first thing we want to do is read the file we’re given and add the words in an array. We can do this with
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">freopen</span><span class="p">(</span><span class="s">"0022_names.txt"</span> <span class="p">,</span> <span class="s">"r"</span> <span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// read the entire string</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="nf">ss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">token</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">','</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">word</span> <span class="o">=</span> <span class="n">token</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">token</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">words</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
And while we parse, we want to know the maximum length of a word in the file. We want this in order to pre-compute enough terms from the triangle sequence. For example, if the maximum word length is 10, then the score of this word is at most \(26 * 10 = 260\) (assuming it’s just a bunch of ZZZ’s). So we want to pre-compute 260 terms from the sequence. We can then build a table of triangle sequence terms as follows
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">triangle</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">is_valid_term</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">triangle_sequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">triangle</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">term</span><span class="p">;</span> <span class="c1">// so triangle[10] = 55</span>
        <span class="n">is_valid_term</span><span class="p">[</span><span class="n">triangle</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// is_triangle[55] is a term in the sequence</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
<br />
Finally, we want to use that table to determine how many words in the file are triangle words.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="sc">'A'</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_valid_term</span><span class="p">[</span><span class="n">score</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"triangle terms count = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=42">Project Euler - 42</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this problem, we are introduced to the sequence of triangle numbers where the nth term of the sequence is given by $$ \begin{align*} t_n = \frac{1}{2}n(n+1). \end{align*} $$ The first 10 triangle numbers are therefore $$ \begin{align*} 1,3,6,10,15,21,28,36,45,55,... \end{align*} $$ We are given a list of words in a file. A word’s alphabetical score is calculated by summing each letter’s alphabetical position. So for example, SKY’s alphabetical score is \(19+11+25 = 55\). This is also the 10th term in the triangle sequence above. So SKY is a triangle word. The goal of this problem is to find the number of triangle words in the file. Similar to Problem 22, the first thing we want to do is read the file we’re given and add the words in an array. We can do this with freopen("0022_names.txt" , "r" , stdin); std::string str; std::cin &gt;&gt; str; // read the entire string std::vector&lt;std::string&gt; words; std::stringstream ss(str); std::string token; char delimiter = ','; int max_length = 0; while (std::getline(ss, token, delimiter)) { std::string word = token.substr(1, token.size() - 2); words.push_back(word); if (word.length() &gt; max_length) { max_length = word.length(); } } And while we parse, we want to know the maximum length of a word in the file. We want this in order to pre-compute enough terms from the triangle sequence. For example, if the maximum word length is 10, then the score of this word is at most \(26 * 10 = 260\) (assuming it’s just a bunch of ZZZ’s). So we want to pre-compute 260 terms from the sequence. We can then build a table of triangle sequence terms as follows int triangle[N]; std::unordered_map&lt;int,int&gt; is_valid_term; void triangle_sequence(int max) { for (int n = 1; n &lt;= max; n++) { int term = (n * (n+1)) / 2; triangle[n] = term; // so triangle[10] = 55 is_valid_term[triangle[n]] = 1; // is_triangle[55] is a term in the sequence } } Finally, we want to use that table to determine how many words in the file are triangle words. int count = 0; for (int i = 0; i &lt; words.size(); i++) { int score = 0; for (int j = 0; j &lt; words[i].size(); j++) { score += words[i][j]-'A'+1; } if (is_valid_term[score]) { count++; } } printf("triangle terms count = %d\n", count); References Project Euler - 42]]></summary></entry><entry><title type="html">Project Euler: 39 Integer Right Triangles</title><link href="http://localhost:4000/jekyll/update/2025/01/17/project-euler-39-integer-right-triangles.html" rel="alternate" type="text/html" title="Project Euler: 39 Integer Right Triangles" /><published>2025-01-17T00:01:36-08:00</published><updated>2025-01-17T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/17/project-euler-39-integer-right-triangles</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/17/project-euler-39-integer-right-triangles.html"><![CDATA[<p>In this problem, we are given a right triangle with sides \(a, b\) and \(c\). We are also given the perimeter of this triangle \(p\). Given only this, there are multiple solutions to what the side lengths \(\{a,b,c\}\) could be. For example for \(p = 120\), there are exactly three solutions \(\{20,48,52\},\{24,45,51\},\{30,40,50\}\). The goal of this problem is finding \(p\) such that we have the maximum number of solutions.
<br />
<br />
Solution: One fact that we know is that the sum of any two sides in a triangle must be greater than the length of the third side. So for any side, its length can at most be \(\frac{p}{2} - 1\). So when we’re searching for solutions, we can immediately limit the search to that range for any side. Additionally, this is a right triangle, so pick \(c\) to be the hypotenuse. So overall, we have the following equations</p>
<div>
	$$
	\begin{align*}
	 p &amp;= a + b + c \\
	 c^2 &amp;= a^2 + b^2
	\end{align*}
	$$
</div>
<p>So we’re given \(p\) and suppose we choose \(a\) to be a value between \(1\) and \(\frac{p}{2}-1\), then the above becomes two equations in unknowns and we can solve to find both \(b\) and \(c\) as follows. Write the first equation in terms of \(b\):</p>
<div>
	$$
	\begin{align*}
     p &amp;= a + b + c \\
	 p - a &amp;= b + c \\
	 b &amp;= (p - a) - c
	\end{align*}
	$$
</div>
<p>We can now plug in this into the second equation:</p>
<div>
	$$
	\begin{align*}
     c^2 &amp;= a^2 + b^2 \\
     c^2 &amp;= a^2 + ((p - a) - c)^2 \\
     c^2 &amp;= a^2 + (p - a)^2 -2(p-a)c + c^2 \\
     2(p-a)c &amp;= a^2 + (p - a)^2 \\
	 c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)}
	\end{align*}
	$$
</div>
<p>Once caveat here is that we want to only accept if \(c\) is an integer. To test this, we can multiply \(c\) by \(2(p-a)\) and check if it’s equal to \(a^2 + (p - a)^2\). 
<br />
<br />
For a concrete example, suppose that \(p = 120\) and suppose we picked \(a\) to be 20. Then</p>
<div>
	$$
	\begin{align*}
	 b &amp;= (p - a) - c \\
	 &amp; = 100 - c
	\end{align*}
	$$
</div>
<p>Now we can plug it back in to see that</p>
<div>
	$$
	\begin{align*}
	 c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)} \\
	 &amp;= \frac{400 + (100)^2}{2(100)} \\
	 &amp;= \frac{10400}{200} = 52
	\end{align*}
	$$
</div>
<p>Therefore, \(b = p - a - c = 120 - 20 - 52 = 48\). This can be captured in
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pa</span><span class="p">);</span>
    <span class="c1">// we want to know if this fraction is an integer (aa + papa) / 2*pa</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">!=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// c is not a solution since the fraction is not an integer</span>
        <span class="k">continue</span><span class="p">;</span> <span class="c1">// choose another a</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Solution = %d, %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
But this doesn’t quite work yet because it will count \(\{30,40,50\}\) and \(\{40,30,50\}\) as two different solutions. To solve this, we can half the limit above.
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max_p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pa</span><span class="p">);</span>
        <span class="c1">// we want to know if this fraction is an integer (aa + papa) / 2*pa</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">!=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// c is not a solution since the fraction isn't an integer</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// choose another a</span>
        <span class="p">}</span>
        <span class="c1">//int b = p - a - c; // we don't even need to calculate this (only if we want to print)</span>
        <span class="c1">//printf("Solution %d, %d, %d\n", a, b, c);</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
        <span class="n">max_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"max = %d, max_p = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">max_p</span><span class="p">);</span></code></pre></figure>

<p>Running this takes 0.000241 seconds on my M1 mac.
<!------------------------------------------------------------------------------------>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=39">Project Euler - 39</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this problem, we are given a right triangle with sides \(a, b\) and \(c\). We are also given the perimeter of this triangle \(p\). Given only this, there are multiple solutions to what the side lengths \(\{a,b,c\}\) could be. For example for \(p = 120\), there are exactly three solutions \(\{20,48,52\},\{24,45,51\},\{30,40,50\}\). The goal of this problem is finding \(p\) such that we have the maximum number of solutions. Solution: One fact that we know is that the sum of any two sides in a triangle must be greater than the length of the third side. So for any side, its length can at most be \(\frac{p}{2} - 1\). So when we’re searching for solutions, we can immediately limit the search to that range for any side. Additionally, this is a right triangle, so pick \(c\) to be the hypotenuse. So overall, we have the following equations $$ \begin{align*} p &amp;= a + b + c \\ c^2 &amp;= a^2 + b^2 \end{align*} $$ So we’re given \(p\) and suppose we choose \(a\) to be a value between \(1\) and \(\frac{p}{2}-1\), then the above becomes two equations in unknowns and we can solve to find both \(b\) and \(c\) as follows. Write the first equation in terms of \(b\): $$ \begin{align*} p &amp;= a + b + c \\ p - a &amp;= b + c \\ b &amp;= (p - a) - c \end{align*} $$ We can now plug in this into the second equation: $$ \begin{align*} c^2 &amp;= a^2 + b^2 \\ c^2 &amp;= a^2 + ((p - a) - c)^2 \\ c^2 &amp;= a^2 + (p - a)^2 -2(p-a)c + c^2 \\ 2(p-a)c &amp;= a^2 + (p - a)^2 \\ c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)} \end{align*} $$ Once caveat here is that we want to only accept if \(c\) is an integer. To test this, we can multiply \(c\) by \(2(p-a)\) and check if it’s equal to \(a^2 + (p - a)^2\). For a concrete example, suppose that \(p = 120\) and suppose we picked \(a\) to be 20. Then $$ \begin{align*} b &amp;= (p - a) - c \\ &amp; = 100 - c \end{align*} $$ Now we can plug it back in to see that $$ \begin{align*} c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)} \\ &amp;= \frac{400 + (100)^2}{2(100)} \\ &amp;= \frac{10400}{200} = 52 \end{align*} $$ Therefore, \(b = p - a - c = 120 - 20 - 52 = 48\). This can be captured in int limit = p/2 - 1; for (int a = 1; a &lt; limit; a++) { int pa = p - a; int c = (a*a + pa*pa) / (2*pa); // we want to know if this fraction is an integer (aa + papa) / 2*pa if (c * 2 * pa != a*a + pa*pa) { // c is not a solution since the fraction is not an integer continue; // choose another a } int b = p - a - c; printf("Solution = %d, %d, %d\n", a, b, c); count++; } But this doesn’t quite work yet because it will count \(\{30,40,50\}\) and \(\{40,30,50\}\) as two different solutions. To solve this, we can half the limit above. int max = 0; int max_p = 0; for (int p = 1; p &lt;= 1000; p++) { int count = 0; int limit = p/2; for (int a = 1; a &lt;= limit/2; a++) { int pa = p - a; int c = (a*a + pa*pa) / (2*pa); // we want to know if this fraction is an integer (aa + papa) / 2*pa if (c * 2 * pa != a*a + pa*pa) { // c is not a solution since the fraction isn't an integer continue; // choose another a } //int b = p - a - c; // we don't even need to calculate this (only if we want to print) //printf("Solution %d, %d, %d\n", a, b, c); count++; } if (count &gt; max) { max = count; max_p = p; } } printf("max = %d, max_p = %d\n", max, max_p); Running this takes 0.000241 seconds on my M1 mac. References Project Euler - 39]]></summary></entry><entry><title type="html">Project Euler: 37 Truncatable Primes</title><link href="http://localhost:4000/jekyll/update/2025/01/16/project-euler-37-truncatable-primes.html" rel="alternate" type="text/html" title="Project Euler: 37 Truncatable Primes" /><published>2025-01-16T00:01:36-08:00</published><updated>2025-01-16T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/16/project-euler-37-truncatable-primes</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/16/project-euler-37-truncatable-primes.html"><![CDATA[<p>A prime is truncatable if it’s possible to continuously remove digits from either left to right or right to left and have it still be prime. For example, consider 3797. If we remove the digits from left to right, then we’ll get</p>
<div>
	$$
	\begin{align*}
	 3797 \rightarrow 797 \rightarrow 97 \rightarrow 7.
	\end{align*}
	$$
</div>
<p>All of these numbers are prime. Similarly if we remove the digits from right to left, then</p>
<div>
	$$
	\begin{align*}
	 3797 \rightarrow 379 \rightarrow 37 \rightarrow 3.
	\end{align*}
	$$
</div>
<p>are all prime as well. As in all of the previous problems involving primes, we’ll reuse the sieve algorithm function to generate prime numbers up to 1 million as a start. We’re given a big hint that says there are only 11 primes with this property. Therefore, we can start with the upper limit 1 million and see how many trucatable primes we can get.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">prime</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prime_numbers</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>What about implementing truncatable itself? We can easily remove one digit at a time from right to left by constantly dividing by 10</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">is_truncatable_left</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for example for 3797, we want to check 379 -&gt; 37 -&gt; 3</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>For the left to right direction, consider \(3797\). One way to do this is to subtract \(3000\) from \(3797\) to get \(797\) which is what we want. In the next iteration, we can subtract \(700\) to get \(97\) and so on. To get \(3000\), notice that it’s the most significant digit multiplied by \(10^{d-1}\) where \(d\) is the number of digits in \(3797\). To get the most significant digit itself, we can divide \(3797\) by \(1000\) which is again \(10^{d-1}\). There could be other ways to do this but that’s the way I thought of which worked for this problem.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">is_truncatable_right</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 797 -&gt; 97 -&gt; 7</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//example: suppose p = 3797</span>
        <span class="kt">int</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">);</span> <span class="c1">// divisor = 10^3 = 1000</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="k">break</span><span class="p">;}</span>
        <span class="kt">int</span> <span class="n">most_sig</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="n">divisor</span><span class="p">;</span> <span class="c1">// 3797/1000 = 3</span>
        <span class="kt">int</span> <span class="n">new_p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">divisor</span> <span class="o">*</span> <span class="n">most_sig</span><span class="p">;</span> <span class="c1">// r = 3797 - 3*1000 = 797</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">new_p</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">new_p</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>One last observation I saw is that for a prime to be truncatable, the last digit must be either 3 or 7. For example consider \(3675\). While \(5\) is prime, \(75\) and \(72\) are definitely not. Putting all of these methods together, we have
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">is_truncatable</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// we must end with 3 or 7 only</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="c1">// (1) check the left to right direction</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_truncatable_left</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// (2) now the other direction</span>
    <span class="c1">// 797 -&gt; 97 -&gt; 7</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_truncatable_right</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>Finally, we can just call the above method for all prime numbers under 1 million which turns out to be enough because it did find all of the 11 truncatable numbers!</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="n">sieve</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// we start from 4 because 2, 3, 5 and 7 are not truncatable by definition</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_truncatable</span><span class="p">(</span><span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d is truncatable</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=37">Project Euler - 37</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[A prime is truncatable if it’s possible to continuously remove digits from either left to right or right to left and have it still be prime. For example, consider 3797. If we remove the digits from left to right, then we’ll get $$ \begin{align*} 3797 \rightarrow 797 \rightarrow 97 \rightarrow 7. \end{align*} $$ All of these numbers are prime. Similarly if we remove the digits from right to left, then $$ \begin{align*} 3797 \rightarrow 379 \rightarrow 37 \rightarrow 3. \end{align*} $$ are all prime as well. As in all of the previous problems involving primes, we’ll reuse the sieve algorithm function to generate prime numbers up to 1 million as a start. We’re given a big hint that says there are only 11 primes with this property. Therefore, we can start with the upper limit 1 million and see how many trucatable primes we can get. int prime[N]; std::vector&lt;int&gt; prime_numbers; void sieve() { // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { prime[i] = 1; } prime[0] = prime[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (prime[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { prime[i] = 0; } } } for (int i = 0; i &lt; N; i++) { if (prime[i]) { prime_numbers.push_back(i); } } } What about implementing truncatable itself? We can easily remove one digit at a time from right to left by constantly dividing by 10 bool is_truncatable_left(int p, int d) { // for example for 3797, we want to check 379 -&gt; 37 -&gt; 3 int m = p; while (m &gt; 0) { if (!prime[m]) { return false; } m /= 10; } return true; } For the left to right direction, consider \(3797\). One way to do this is to subtract \(3000\) from \(3797\) to get \(797\) which is what we want. In the next iteration, we can subtract \(700\) to get \(97\) and so on. To get \(3000\), notice that it’s the most significant digit multiplied by \(10^{d-1}\) where \(d\) is the number of digits in \(3797\). To get the most significant digit itself, we can divide \(3797\) by \(1000\) which is again \(10^{d-1}\). There could be other ways to do this but that’s the way I thought of which worked for this problem. bool is_truncatable_right(int p, int d) { // 797 -&gt; 97 -&gt; 7 int i = 0; while (p &gt; 0) { //example: suppose p = 3797 int divisor = pow(10, d-1-i); // divisor = 10^3 = 1000 if (divisor &lt;= 1) {break;} int most_sig = p/divisor; // 3797/1000 = 3 int new_p = p - divisor * most_sig; // r = 3797 - 3*1000 = 797 if (!prime[new_p]) { return false; } p = new_p; i++; } return true; } One last observation I saw is that for a prime to be truncatable, the last digit must be either 3 or 7. For example consider \(3675\). While \(5\) is prime, \(75\) and \(72\) are definitely not. Putting all of these methods together, we have bool is_truncatable(int p) { // we must end with 3 or 7 only if (p % 10 != 3 &amp;&amp; p % 10 != 7) { return false; } int d = floor(log10(p)) + 1; // (1) check the left to right direction if (!is_truncatable_left(p, d)) { return false; } // (2) now the other direction // 797 -&gt; 97 -&gt; 7 if (!is_truncatable_right(p, d)) { return false; } return true; } Finally, we can just call the above method for all prime numbers under 1 million which turns out to be enough because it did find all of the 11 truncatable numbers! sieve(); int sum = 0; // we start from 4 because 2, 3, 5 and 7 are not truncatable by definition for (int i = 4; i &lt; prime_numbers.size(); i++) { if (is_truncatable(prime_numbers[i])) { printf("%d is truncatable\n", prime_numbers[i]); sum += prime_numbers[i]; } } printf("sum = %d\n", sum); References Project Euler - 37]]></summary></entry></feed>