<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-19T21:06:01-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">nemo’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Project Euler: 50 Consecutive Prime Sum</title><link href="http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum.html" rel="alternate" type="text/html" title="Project Euler: 50 Consecutive Prime Sum" /><published>2025-01-19T00:01:36-08:00</published><updated>2025-01-19T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/19/project-euler-50-consecutive-prime-sum.html"><![CDATA[<p>The prime $41$, can be written as the sum of six consecutive primes \(2 + 3 + 5 + 7 + 11 + 13\). The goal of this problem is to find which prime below one-million, can be written as the sum of the most consecutive primes. 
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Solution</b></h4>
<p>It took me a few attempts to get this one right. The first few recurrences that I was trying to build didn’t go anywhere and one of them was this two dimensional table that included every sum of the range of primes between any pair of prime numbers \(i\) and \(j\). After a few pages written, I noticed one critical idea that led to a reasonable solution. To see this, write down the first few consecutive sums below</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>Prime</td>
    <td>\(2\)</td>
    <td>\(3\)</td>
    <td>\(5\)</td>
	<td>\(7\)</td>
	<td>\(11\)</td>
	<td>\(13\)</td>
	<td>\(17\)</td>
	<td>\(...\)</td>
  </tr>
  <tr>
    <td>Sum</td>
    <td>\(2\)</td>
    <td>\(5\)</td>
    <td>\(10\)</td>
	<td>\(17\)</td>
	<td>\(28\)</td>
	<td>\(41\)</td>
	<td>\(58\)</td>
	<td>\(...\)</td>
  </tr>
</table>
</div>
<p>Now notice that if we wanted to find the sum of primes between \(3\) and \(11\) not including \(3\), then we can use the table above to see that it is</p>
<div>
	$$
	\begin{align*}
	 sum(11) - sum(3) &amp;= 28 - 5 = 23
	\end{align*}
	$$
</div>
<p>which is exactly the sum of primes \(5 + 7 + 11\). So for any two primes \(i\) and \(j\), the sum of the primes between them and including \(j\) is</p>
<div>
	$$
	\begin{align*}
	 sum(j) - sum(i)
	\end{align*}
	$$
</div>
<p>This idea is crucial. Because all we have to do now is try all the pairs below 1 million and we’ll get an \(O(n^2)\) algorithm instead of an exponential one! All we need to do is to pre-compute that table with all the sums and then write a double loop to find the prime that can be written as the sum of the most consecutive primes.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">first</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">second</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">cons_sum</span> <span class="o">=</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">first</span><span class="p">]</span> <span class="o">-</span> <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">second</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">cons_sum</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">max</span> <span class="o">&lt;</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">cons_sum</span><span class="p">;</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
Another critical aspect to this problem is that there is another hint that I completely missed. The prime we’re trying to find has to be below a million but do we have to search for all the primes below a million? No! In fact, the sum of the first \(546\) primes will already exceed a million!! Therefore, we can limit the search to a much smaller range. Just find the first \(546\) primes and then search for the best prime with the previous code.
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">prime_sums</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// fake prime</span>
    <span class="n">consecutive_sums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
            <span class="n">prime_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
            <span class="n">index</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span>  <span class="mi">546</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c1">// we don't need more than that!</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
<br />
Finally, we want to use that table to determine how many words in the file are triangle words.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">prime_sums</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// fake prime</span>
    <span class="n">consecutive_sums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
            <span class="n">consecutive_sums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
            <span class="n">prime_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
            <span class="n">index</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span>  <span class="mi">546</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span> <span class="c1">// we don't need more than that!</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=50">Project Euler - 50</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The prime $41$, can be written as the sum of six consecutive primes \(2 + 3 + 5 + 7 + 11 + 13\). The goal of this problem is to find which prime below one-million, can be written as the sum of the most consecutive primes. Solution It took me a few attempts to get this one right. The first few recurrences that I was trying to build didn’t go anywhere and one of them was this two dimensional table that included every sum of the range of primes between any pair of prime numbers \(i\) and \(j\). After a few pages written, I noticed one critical idea that led to a reasonable solution. To see this, write down the first few consecutive sums below Prime \(2\) \(3\) \(5\) \(7\) \(11\) \(13\) \(17\) \(...\) Sum \(2\) \(5\) \(10\) \(17\) \(28\) \(41\) \(58\) \(...\) Now notice that if we wanted to find the sum of primes between \(3\) and \(11\) not including \(3\), then we can use the table above to see that it is $$ \begin{align*} sum(11) - sum(3) &amp;= 28 - 5 = 23 \end{align*} $$ which is exactly the sum of primes \(5 + 7 + 11\). So for any two primes \(i\) and \(j\), the sum of the primes between them and including \(j\) is $$ \begin{align*} sum(j) - sum(i) \end{align*} $$ This idea is crucial. Because all we have to do now is try all the pairs below 1 million and we’ll get an \(O(n^2)\) algorithm instead of an exponential one! All we need to do is to pre-compute that table with all the sums and then write a double loop to find the prime that can be written as the sum of the most consecutive primes. int p = 0; int max = 0; for (int i = prime_numbers.size() - 1; i &gt;= 0; i--) { for (int j = 0; j &lt; i; j++) { int first = prime_numbers[i]; int second = prime_numbers[j]; int cons_sum = consecutive_sums[first] - consecutive_sums[second]; if (prime[cons_sum] &amp;&amp; max &lt; abs(i - j)) { p = cons_sum; max = abs(i - j); } } } printf("%d\n", p); Another critical aspect to this problem is that there is another hint that I completely missed. The prime we’re trying to find has to be below a million but do we have to search for all the primes below a million? No! In fact, the sum of the first \(546\) primes will already exceed a million!! Therefore, we can limit the search to a much smaller range. Just find the first \(546\) primes and then search for the best prime with the previous code. void prime_sums() { int sum = 0; int index = 0; prime_numbers.push_back(0); // fake prime consecutive_sums[0] = 0; for (int i = 0; i &lt; N; i++) { if (prime[i]) { sum += i; prime_numbers.push_back(i); consecutive_sums[i] = sum; prime_indices[i] = index; index++; if (index &gt; 546) { break; // we don't need more than that! } } } } Finally, we want to use that table to determine how many words in the file are triangle words. void prime_sums() { int sum = 0; int index = 0; prime_numbers.push_back(0); // fake prime consecutive_sums[0] = 0; for (int i = 0; i &lt; N; i++) { if (prime[i]) { sum += i; prime_numbers.push_back(i); consecutive_sums[i] = sum; prime_indices[i] = index; index++; if (index &gt; 546) { break; // we don't need more than that! } } } } References Project Euler - 50]]></summary></entry><entry><title type="html">Project Euler: 42 Coded Triangle Numbers</title><link href="http://localhost:4000/jekyll/update/2025/01/18/project-euler-42-coded-triangle-numbers.html" rel="alternate" type="text/html" title="Project Euler: 42 Coded Triangle Numbers" /><published>2025-01-18T00:01:36-08:00</published><updated>2025-01-18T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/18/project-euler-42-coded-triangle-numbers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/18/project-euler-42-coded-triangle-numbers.html"><![CDATA[<p>In this problem, we are introduced to the sequence of triangle numbers where the nth term of the sequence is given by</p>
<div>
	$$
	\begin{align*}
	 t_n = \frac{1}{2}n(n+1).
	\end{align*}
	$$
</div>
<p>The first 10 triangle numbers are therefore</p>
<div>
	$$
	\begin{align*}
	 1,3,6,10,15,21,28,36,45,55,...
	\end{align*}
	$$
</div>
<p>We are given a list of words in a file. A word’s alphabetical score is calculated by summing each letter’s alphabetical position. So for example, SKY’s alphabetical score is \(19+11+25 = 55\). This is also the 10th term in the triangle sequence above. So SKY is a triangle word. The goal of this problem is to find the number of triangle words in the file.
<br />
<br />
Similar to <a href="">Problem 22</a>, the first thing we want to do is read the file we’re given and add the words in an array. We can do this with
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">freopen</span><span class="p">(</span><span class="s">"0022_names.txt"</span> <span class="p">,</span> <span class="s">"r"</span> <span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">str</span><span class="p">;</span> <span class="c1">// read the entire string</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="nf">ss</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">token</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">delimiter</span> <span class="o">=</span> <span class="sc">','</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max_length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">word</span> <span class="o">=</span> <span class="n">token</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">token</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">words</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_length</span> <span class="o">=</span> <span class="n">word</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
And while we parse, we want to know the maximum length of a word in the file. We want this in order to pre-compute enough terms from the triangle sequence. For example, if the maximum word length is 10, then the score of this word is at most \(26 * 10 = 260\) (assuming it’s just a bunch of ZZZ’s). So we want to pre-compute 260 terms from the sequence. We can then build a table of triangle sequence terms as follows
<!------------------------------------------------------------------------------------>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">triangle</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">is_valid_term</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">triangle_sequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">term</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">triangle</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">term</span><span class="p">;</span> <span class="c1">// so triangle[10] = 55</span>
        <span class="n">is_valid_term</span><span class="p">[</span><span class="n">triangle</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// is_triangle[55] is a term in the sequence</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------>
<br />
Finally, we want to use that table to determine how many words in the file are triangle words.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="n">words</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="sc">'A'</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_valid_term</span><span class="p">[</span><span class="n">score</span><span class="p">])</span> <span class="p">{</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"triangle terms count = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=42">Project Euler - 42</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this problem, we are introduced to the sequence of triangle numbers where the nth term of the sequence is given by $$ \begin{align*} t_n = \frac{1}{2}n(n+1). \end{align*} $$ The first 10 triangle numbers are therefore $$ \begin{align*} 1,3,6,10,15,21,28,36,45,55,... \end{align*} $$ We are given a list of words in a file. A word’s alphabetical score is calculated by summing each letter’s alphabetical position. So for example, SKY’s alphabetical score is \(19+11+25 = 55\). This is also the 10th term in the triangle sequence above. So SKY is a triangle word. The goal of this problem is to find the number of triangle words in the file. Similar to Problem 22, the first thing we want to do is read the file we’re given and add the words in an array. We can do this with freopen("0022_names.txt" , "r" , stdin); std::string str; std::cin &gt;&gt; str; // read the entire string std::vector&lt;std::string&gt; words; std::stringstream ss(str); std::string token; char delimiter = ','; int max_length = 0; while (std::getline(ss, token, delimiter)) { std::string word = token.substr(1, token.size() - 2); words.push_back(word); if (word.length() &gt; max_length) { max_length = word.length(); } } And while we parse, we want to know the maximum length of a word in the file. We want this in order to pre-compute enough terms from the triangle sequence. For example, if the maximum word length is 10, then the score of this word is at most \(26 * 10 = 260\) (assuming it’s just a bunch of ZZZ’s). So we want to pre-compute 260 terms from the sequence. We can then build a table of triangle sequence terms as follows int triangle[N]; std::unordered_map&lt;int,int&gt; is_valid_term; void triangle_sequence(int max) { for (int n = 1; n &lt;= max; n++) { int term = (n * (n+1)) / 2; triangle[n] = term; // so triangle[10] = 55 is_valid_term[triangle[n]] = 1; // is_triangle[55] is a term in the sequence } } Finally, we want to use that table to determine how many words in the file are triangle words. int count = 0; for (int i = 0; i &lt; words.size(); i++) { int score = 0; for (int j = 0; j &lt; words[i].size(); j++) { score += words[i][j]-'A'+1; } if (is_valid_term[score]) { count++; } } printf("triangle terms count = %d\n", count); References Project Euler - 42]]></summary></entry><entry><title type="html">Project Euler: 39 Integer Right Triangles</title><link href="http://localhost:4000/jekyll/update/2025/01/17/project-euler-39-integer-right-triangles.html" rel="alternate" type="text/html" title="Project Euler: 39 Integer Right Triangles" /><published>2025-01-17T00:01:36-08:00</published><updated>2025-01-17T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/17/project-euler-39-integer-right-triangles</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/17/project-euler-39-integer-right-triangles.html"><![CDATA[<p>In this problem, we are given a right triangle with sides \(a, b\) and \(c\). We are also given the perimeter of this triangle \(p\). Given only this, there are multiple solutions to what the side lengths \(\{a,b,c\}\) could be. For example for \(p = 120\), there are exactly three solutions \(\{20,48,52\},\{24,45,51\},\{30,40,50\}\). The goal of this problem is finding \(p\) such that we have the maximum number of solutions.
<br />
<br />
Solution: One fact that we know is that the sum of any two sides in a triangle must be greater than the length of the third side. So for any side, its length can at most be \(\frac{p}{2} - 1\). So when we’re searching for solutions, we can immediately limit the search to that range for any side. Additionally, this is a right triangle, so pick \(c\) to be the hypotenuse. So overall, we have the following equations</p>
<div>
	$$
	\begin{align*}
	 p &amp;= a + b + c \\
	 c^2 &amp;= a^2 + b^2
	\end{align*}
	$$
</div>
<p>So we’re given \(p\) and suppose we choose \(a\) to be a value between \(1\) and \(\frac{p}{2}-1\), then the above becomes two equations in unknowns and we can solve to find both \(b\) and \(c\) as follows. Write the first equation in terms of \(b\):</p>
<div>
	$$
	\begin{align*}
     p &amp;= a + b + c \\
	 p - a &amp;= b + c \\
	 b &amp;= (p - a) - c
	\end{align*}
	$$
</div>
<p>We can now plug in this into the second equation:</p>
<div>
	$$
	\begin{align*}
     c^2 &amp;= a^2 + b^2 \\
     c^2 &amp;= a^2 + ((p - a) - c)^2 \\
     c^2 &amp;= a^2 + (p - a)^2 -2(p-a)c + c^2 \\
     2(p-a)c &amp;= a^2 + (p - a)^2 \\
	 c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)}
	\end{align*}
	$$
</div>
<p>Once caveat here is that we want to only accept if \(c\) is an integer. To test this, we can multiply \(c\) by \(2(p-a)\) and check if it’s equal to \(a^2 + (p - a)^2\). 
<br />
<br />
For a concrete example, suppose that \(p = 120\) and suppose we picked \(a\) to be 20. Then</p>
<div>
	$$
	\begin{align*}
	 b &amp;= (p - a) - c \\
	 &amp; = 100 - c
	\end{align*}
	$$
</div>
<p>Now we can plug it back in to see that</p>
<div>
	$$
	\begin{align*}
	 c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)} \\
	 &amp;= \frac{400 + (100)^2}{2(100)} \\
	 &amp;= \frac{10400}{200} = 52
	\end{align*}
	$$
</div>
<p>Therefore, \(b = p - a - c = 120 - 20 - 52 = 48\). This can be captured in
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pa</span><span class="p">);</span>
    <span class="c1">// we want to know if this fraction is an integer (aa + papa) / 2*pa</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">!=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// c is not a solution since the fraction is not an integer</span>
        <span class="k">continue</span><span class="p">;</span> <span class="c1">// choose another a</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">a</span> <span class="o">-</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Solution = %d, %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
But this doesn’t quite work yet because it will count \(\{30,40,50\}\) and \(\{40,30,50\}\) as two different solutions. To solve this, we can half the limit above.
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">max_p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">pa</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">a</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">pa</span><span class="p">);</span>
        <span class="c1">// we want to know if this fraction is an integer (aa + papa) / 2*pa</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pa</span> <span class="o">!=</span> <span class="n">a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">pa</span><span class="o">*</span><span class="n">pa</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// c is not a solution since the fraction isn't an integer</span>
            <span class="k">continue</span><span class="p">;</span> <span class="c1">// choose another a</span>
        <span class="p">}</span>
        <span class="c1">//int b = p - a - c; // we don't even need to calculate this (only if we want to print)</span>
        <span class="c1">//printf("Solution %d, %d, %d\n", a, b, c);</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
        <span class="n">max_p</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"max = %d, max_p = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">max_p</span><span class="p">);</span></code></pre></figure>

<p>Running this takes 0.000241 seconds on my M1 mac.
<!------------------------------------------------------------------------------------>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=39">Project Euler - 39</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this problem, we are given a right triangle with sides \(a, b\) and \(c\). We are also given the perimeter of this triangle \(p\). Given only this, there are multiple solutions to what the side lengths \(\{a,b,c\}\) could be. For example for \(p = 120\), there are exactly three solutions \(\{20,48,52\},\{24,45,51\},\{30,40,50\}\). The goal of this problem is finding \(p\) such that we have the maximum number of solutions. Solution: One fact that we know is that the sum of any two sides in a triangle must be greater than the length of the third side. So for any side, its length can at most be \(\frac{p}{2} - 1\). So when we’re searching for solutions, we can immediately limit the search to that range for any side. Additionally, this is a right triangle, so pick \(c\) to be the hypotenuse. So overall, we have the following equations $$ \begin{align*} p &amp;= a + b + c \\ c^2 &amp;= a^2 + b^2 \end{align*} $$ So we’re given \(p\) and suppose we choose \(a\) to be a value between \(1\) and \(\frac{p}{2}-1\), then the above becomes two equations in unknowns and we can solve to find both \(b\) and \(c\) as follows. Write the first equation in terms of \(b\): $$ \begin{align*} p &amp;= a + b + c \\ p - a &amp;= b + c \\ b &amp;= (p - a) - c \end{align*} $$ We can now plug in this into the second equation: $$ \begin{align*} c^2 &amp;= a^2 + b^2 \\ c^2 &amp;= a^2 + ((p - a) - c)^2 \\ c^2 &amp;= a^2 + (p - a)^2 -2(p-a)c + c^2 \\ 2(p-a)c &amp;= a^2 + (p - a)^2 \\ c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)} \end{align*} $$ Once caveat here is that we want to only accept if \(c\) is an integer. To test this, we can multiply \(c\) by \(2(p-a)\) and check if it’s equal to \(a^2 + (p - a)^2\). For a concrete example, suppose that \(p = 120\) and suppose we picked \(a\) to be 20. Then $$ \begin{align*} b &amp;= (p - a) - c \\ &amp; = 100 - c \end{align*} $$ Now we can plug it back in to see that $$ \begin{align*} c &amp;= \frac{a^2 + (p - a)^2}{2(p-a)} \\ &amp;= \frac{400 + (100)^2}{2(100)} \\ &amp;= \frac{10400}{200} = 52 \end{align*} $$ Therefore, \(b = p - a - c = 120 - 20 - 52 = 48\). This can be captured in int limit = p/2 - 1; for (int a = 1; a &lt; limit; a++) { int pa = p - a; int c = (a*a + pa*pa) / (2*pa); // we want to know if this fraction is an integer (aa + papa) / 2*pa if (c * 2 * pa != a*a + pa*pa) { // c is not a solution since the fraction is not an integer continue; // choose another a } int b = p - a - c; printf("Solution = %d, %d, %d\n", a, b, c); count++; } But this doesn’t quite work yet because it will count \(\{30,40,50\}\) and \(\{40,30,50\}\) as two different solutions. To solve this, we can half the limit above. int max = 0; int max_p = 0; for (int p = 1; p &lt;= 1000; p++) { int count = 0; int limit = p/2; for (int a = 1; a &lt;= limit/2; a++) { int pa = p - a; int c = (a*a + pa*pa) / (2*pa); // we want to know if this fraction is an integer (aa + papa) / 2*pa if (c * 2 * pa != a*a + pa*pa) { // c is not a solution since the fraction isn't an integer continue; // choose another a } //int b = p - a - c; // we don't even need to calculate this (only if we want to print) //printf("Solution %d, %d, %d\n", a, b, c); count++; } if (count &gt; max) { max = count; max_p = p; } } printf("max = %d, max_p = %d\n", max, max_p); Running this takes 0.000241 seconds on my M1 mac. References Project Euler - 39]]></summary></entry><entry><title type="html">Project Euler: 37 Truncatable Primes</title><link href="http://localhost:4000/jekyll/update/2025/01/16/project-euler-37-truncatable-primes.html" rel="alternate" type="text/html" title="Project Euler: 37 Truncatable Primes" /><published>2025-01-16T00:01:36-08:00</published><updated>2025-01-16T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/16/project-euler-37-truncatable-primes</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/16/project-euler-37-truncatable-primes.html"><![CDATA[<p>A prime is truncatable if it’s possible to continuously remove digits from either left to right or right to left and have it still be prime. For example, consider 3797. If we remove the digits from left to right, then we’ll get</p>
<div>
	$$
	\begin{align*}
	 3797 \rightarrow 797 \rightarrow 97 \rightarrow 7.
	\end{align*}
	$$
</div>
<p>All of these numbers are prime. Similarly if we remove the digits from right to left, then</p>
<div>
	$$
	\begin{align*}
	 3797 \rightarrow 379 \rightarrow 37 \rightarrow 3.
	\end{align*}
	$$
</div>
<p>are all prime as well. As in all of the previous problems involving primes, we’ll reuse the sieve algorithm function to generate prime numbers up to 1 million as a start. We’re given a big hint that says there are only 11 primes with this property. Therefore, we can start with the upper limit 1 million and see how many trucatable primes we can get.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">prime</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prime_numbers</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>What about implementing truncatable itself? We can easily remove one digit at a time from right to left by constantly dividing by 10</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">is_truncatable_left</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for example for 3797, we want to check 379 -&gt; 37 -&gt; 3</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">m</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">m</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>For the left to right direction, consider \(3797\). One way to do this is to subtract \(3000\) from \(3797\) to get \(797\) which is what we want. In the next iteration, we can subtract \(700\) to get \(97\) and so on. To get \(3000\), notice that it’s the most significant digit multiplied by \(10^{d-1}\) where \(d\) is the number of digits in \(3797\). To get the most significant digit itself, we can divide \(3797\) by \(1000\) which is again \(10^{d-1}\). There could be other ways to do this but that’s the way I thought of which worked for this problem.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">is_truncatable_right</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 797 -&gt; 97 -&gt; 7</span>
    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//example: suppose p = 3797</span>
        <span class="kt">int</span> <span class="n">divisor</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">d</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">);</span> <span class="c1">// divisor = 10^3 = 1000</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">divisor</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span><span class="k">break</span><span class="p">;}</span>
        <span class="kt">int</span> <span class="n">most_sig</span> <span class="o">=</span> <span class="n">p</span><span class="o">/</span><span class="n">divisor</span><span class="p">;</span> <span class="c1">// 3797/1000 = 3</span>
        <span class="kt">int</span> <span class="n">new_p</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">divisor</span> <span class="o">*</span> <span class="n">most_sig</span><span class="p">;</span> <span class="c1">// r = 3797 - 3*1000 = 797</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">new_p</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">new_p</span><span class="p">;</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>One last observation I saw is that for a prime to be truncatable, the last digit must be either 3 or 7. For example consider \(3675\). While \(5\) is prime, \(75\) and \(72\) are definitely not. Putting all of these methods together, we have
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">is_truncatable</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// we must end with 3 or 7 only</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">%</span> <span class="mi">10</span> <span class="o">!=</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">log10</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="c1">// (1) check the left to right direction</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_truncatable_left</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// (2) now the other direction</span>
    <span class="c1">// 797 -&gt; 97 -&gt; 7</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_truncatable_right</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>Finally, we can just call the above method for all prime numbers under 1 million which turns out to be enough because it did find all of the 11 truncatable numbers!</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="n">sieve</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// we start from 4 because 2, 3, 5 and 7 are not truncatable by definition</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_truncatable</span><span class="p">(</span><span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d is truncatable</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=37">Project Euler - 37</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[A prime is truncatable if it’s possible to continuously remove digits from either left to right or right to left and have it still be prime. For example, consider 3797. If we remove the digits from left to right, then we’ll get $$ \begin{align*} 3797 \rightarrow 797 \rightarrow 97 \rightarrow 7. \end{align*} $$ All of these numbers are prime. Similarly if we remove the digits from right to left, then $$ \begin{align*} 3797 \rightarrow 379 \rightarrow 37 \rightarrow 3. \end{align*} $$ are all prime as well. As in all of the previous problems involving primes, we’ll reuse the sieve algorithm function to generate prime numbers up to 1 million as a start. We’re given a big hint that says there are only 11 primes with this property. Therefore, we can start with the upper limit 1 million and see how many trucatable primes we can get. int prime[N]; std::vector&lt;int&gt; prime_numbers; void sieve() { // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { prime[i] = 1; } prime[0] = prime[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (prime[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { prime[i] = 0; } } } for (int i = 0; i &lt; N; i++) { if (prime[i]) { prime_numbers.push_back(i); } } } What about implementing truncatable itself? We can easily remove one digit at a time from right to left by constantly dividing by 10 bool is_truncatable_left(int p, int d) { // for example for 3797, we want to check 379 -&gt; 37 -&gt; 3 int m = p; while (m &gt; 0) { if (!prime[m]) { return false; } m /= 10; } return true; } For the left to right direction, consider \(3797\). One way to do this is to subtract \(3000\) from \(3797\) to get \(797\) which is what we want. In the next iteration, we can subtract \(700\) to get \(97\) and so on. To get \(3000\), notice that it’s the most significant digit multiplied by \(10^{d-1}\) where \(d\) is the number of digits in \(3797\). To get the most significant digit itself, we can divide \(3797\) by \(1000\) which is again \(10^{d-1}\). There could be other ways to do this but that’s the way I thought of which worked for this problem. bool is_truncatable_right(int p, int d) { // 797 -&gt; 97 -&gt; 7 int i = 0; while (p &gt; 0) { //example: suppose p = 3797 int divisor = pow(10, d-1-i); // divisor = 10^3 = 1000 if (divisor &lt;= 1) {break;} int most_sig = p/divisor; // 3797/1000 = 3 int new_p = p - divisor * most_sig; // r = 3797 - 3*1000 = 797 if (!prime[new_p]) { return false; } p = new_p; i++; } return true; } One last observation I saw is that for a prime to be truncatable, the last digit must be either 3 or 7. For example consider \(3675\). While \(5\) is prime, \(75\) and \(72\) are definitely not. Putting all of these methods together, we have bool is_truncatable(int p) { // we must end with 3 or 7 only if (p % 10 != 3 &amp;&amp; p % 10 != 7) { return false; } int d = floor(log10(p)) + 1; // (1) check the left to right direction if (!is_truncatable_left(p, d)) { return false; } // (2) now the other direction // 797 -&gt; 97 -&gt; 7 if (!is_truncatable_right(p, d)) { return false; } return true; } Finally, we can just call the above method for all prime numbers under 1 million which turns out to be enough because it did find all of the 11 truncatable numbers! sieve(); int sum = 0; // we start from 4 because 2, 3, 5 and 7 are not truncatable by definition for (int i = 4; i &lt; prime_numbers.size(); i++) { if (is_truncatable(prime_numbers[i])) { printf("%d is truncatable\n", prime_numbers[i]); sum += prime_numbers[i]; } } printf("sum = %d\n", sum); References Project Euler - 37]]></summary></entry><entry><title type="html">Project Euler: 35 Circular Primes</title><link href="http://localhost:4000/jekyll/update/2025/01/15/project-euler-35-circular-primes.html" rel="alternate" type="text/html" title="Project Euler: 35 Circular Primes" /><published>2025-01-15T00:01:36-08:00</published><updated>2025-01-15T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/15/project-euler-35-circular-primes</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/15/project-euler-35-circular-primes.html"><![CDATA[<p>A prime is circular if all rotations of the digits are prime. For example, the rotations of 197 are 197, 971 and 719. All of the rotations are prime numbers so 197 is a circular prime. In this problem, we want to find the number of circular primes below 1 million. To start, we need a method to check if a number is prime. We can re-use the sieve method we did for problem 7 and generate all prime numbers under 1 million.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">prime</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prime_numbers</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>The next thing we want to do is to generate all possible rotations of a given a number. To do so, consider the number \(p=197\). The umber of digits in 197 is \(n = 3\) so we have a total of 3 rotations (197, 719, 971). to generate these, iterate 3 times where in each iteration, extract and remove the last digit and then multiply it by \(10^{n-1}\) and add it back again to \(p\). In this example, the last digit is 7. We will then add \(7 \times (10^{n-1}) = 7 \times 100 = 700\) to \(19\) to get \(719\).
<br />
<br />
Another example is 1793. We will extract 3 and remove it by dividing by 10 to get 179. We then will add \(3 \times 1000 = 3000\) to \(179\) to get \(3179\) which is the next rotation of \(1793\). In the next iteration, we will again extract \(9\) and add \(9000\) to \(317\) to generate the next rotation \(9317\). At any point of time during these iterations, if a rotation happens to be non-prime, then we exit and return false in
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">count_digits</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">d</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">is_circular</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// we want to rotate the digits n times where n is the number of digits</span>
    <span class="c1">// so 197 -&gt; 719 -&gt; 971</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">count_digits</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span> <span class="c1">// save the last digit d</span>
        <span class="n">p</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// git rid of d in p</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">d</span><span class="o">*</span><span class="n">m</span><span class="p">;</span> <span class="c1">// add the last digit*m to p</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// not a circular number</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>Finally, we can call this method to check again the primes we generated earlier. I did try using an optimization where I save the rotations in a map in order to avoid generating them again but that didn’t save much time and made the code look more complicated so I removed it. The entire naive solution rain in 0.0094 seconds time on my M1 mac.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">sieve</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// There are 4 primes &lt; 10</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// prime_numbers[4] = 11</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_circular</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"total count = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=35">Project Euler - 35</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[A prime is circular if all rotations of the digits are prime. For example, the rotations of 197 are 197, 971 and 719. All of the rotations are prime numbers so 197 is a circular prime. In this problem, we want to find the number of circular primes below 1 million. To start, we need a method to check if a number is prime. We can re-use the sieve method we did for problem 7 and generate all prime numbers under 1 million. int prime[N]; std::vector&lt;int&gt; prime_numbers; void sieve() { // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { prime[i] = 1; } prime[0] = prime[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (prime[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { prime[i] = 0; } } } for (int i = 0; i &lt; N; i++) { if (prime[i]) { prime_numbers.push_back(i); } } } The next thing we want to do is to generate all possible rotations of a given a number. To do so, consider the number \(p=197\). The umber of digits in 197 is \(n = 3\) so we have a total of 3 rotations (197, 719, 971). to generate these, iterate 3 times where in each iteration, extract and remove the last digit and then multiply it by \(10^{n-1}\) and add it back again to \(p\). In this example, the last digit is 7. We will then add \(7 \times (10^{n-1}) = 7 \times 100 = 700\) to \(19\) to get \(719\). Another example is 1793. We will extract 3 and remove it by dividing by 10 to get 179. We then will add \(3 \times 1000 = 3000\) to \(179\) to get \(3179\) which is the next rotation of \(1793\). In the next iteration, we will again extract \(9\) and add \(9000\) to \(317\) to generate the next rotation \(9317\). At any point of time during these iterations, if a rotation happens to be non-prime, then we exit and return false in int count_digits(int n) { int d = 0; while (n &gt; 0) { n /= 10; d++; } return d; } bool is_circular(int p) { // we want to rotate the digits n times where n is the number of digits // so 197 -&gt; 719 -&gt; 971 int n = count_digits(p); int m = pow(10, n-1); for (int i = 0; i &lt; n; i++) { int d = p%10; // save the last digit d p /= 10; // git rid of d in p p += d*m; // add the last digit*m to p if (!prime[p]) { return false; // not a circular number } } return true; } Finally, we can call this method to check again the primes we generated earlier. I did try using an optimization where I save the rotations in a map in order to avoid generating them again but that didn’t save much time and made the code look more complicated so I removed it. The entire naive solution rain in 0.0094 seconds time on my M1 mac. sieve(); int count = 4; // There are 4 primes &lt; 10 for (int i = 4; i &lt; prime_numbers.size(); i++) { // prime_numbers[4] = 11 int p = prime_numbers[i]; if (is_circular(p)) { count++; } } printf("total count = %d\n", count); References Project Euler - 35]]></summary></entry><entry><title type="html">Project Euler: 34 Digit Factorials</title><link href="http://localhost:4000/jekyll/update/2025/01/14/project-euler-34-digit-factorials.html" rel="alternate" type="text/html" title="Project Euler: 34 Digit Factorials" /><published>2025-01-14T00:01:36-08:00</published><updated>2025-01-14T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/14/project-euler-34-digit-factorials</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/14/project-euler-34-digit-factorials.html"><![CDATA[<p>In this one, we want the sum of all numbers such that each number’s digit factorials add up to the number itself. For example</p>
<div>
	$$
	\begin{align*}
	 145 = 1! + 4! + 5!
	\end{align*}
	$$
</div>
<p>We are told not to include the trivial cases \(1! = 1\) and \(2! = 2\) since they are not sums. We are also not given any upper bound. As a guess, we can observe that \(9! * 10 = 3628800\). So a number consisting of 10 digits will at most be 3628800. I tried this upper limit and it was fine. One thing we want to do is to pre-calculate the factorials for all digits a head of time in</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">calc_factorial</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The rest is all simple</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">calc_factorial</span><span class="p">();</span>
    <span class="c1">// 9! * 10 = 3628800</span>
    <span class="c1">// 0! + 0! + 0! + 1! + 1! = 2</span>
    <span class="kt">int</span> <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3628800</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">num</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">d</span><span class="p">];</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=34">Project Euler - 34</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this one, we want the sum of all numbers such that each number’s digit factorials add up to the number itself. For example $$ \begin{align*} 145 = 1! + 4! + 5! \end{align*} $$ We are told not to include the trivial cases \(1! = 1\) and \(2! = 2\) since they are not sums. We are also not given any upper bound. As a guess, we can observe that \(9! * 10 = 3628800\). So a number consisting of 10 digits will at most be 3628800. I tried this upper limit and it was fine. One thing we want to do is to pre-calculate the factorials for all digits a head of time in int f[10]; void calc_factorial() { f[0] = 1; f[1] = 1; for (int i = 2; i &lt; 10; i++) { f[i] = i * f[i-1]; } } The rest is all simple int main(int argc, const char * argv[]) { calc_factorial(); // 9! * 10 = 3628800 // 0! + 0! + 0! + 1! + 1! = 2 int total_sum = 0; for (long long n = 3; n &lt;= 3628800; n++) { long long sum = 0; long long num = n; while (num &gt; 0 &amp;&amp; sum &lt;= n) { int d = num%10; int p = f[d]; sum += p; num /= 10; } if (sum == n) { total_sum += sum; } } printf("%d\n", total_sum); return 0; } References Project Euler - 34]]></summary></entry><entry><title type="html">Project Euler: 30 Digit Fifth Powers</title><link href="http://localhost:4000/jekyll/update/2025/01/13/project-euler-30-digit-fifth-powers.html" rel="alternate" type="text/html" title="Project Euler: 30 Digit Fifth Powers" /><published>2025-01-13T00:01:36-08:00</published><updated>2025-01-13T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/13/project-euler-30-digit-fifth-powers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/13/project-euler-30-digit-fifth-powers.html"><![CDATA[<p>This was not bad! the minimum number that can be written as a sum of its 5th digits powers is</p>
<div>
	$$
	\begin{align*}
	 2 = 0^5 + 0^5 + 0^5 + 1^5 + 1^5.
	\end{align*}
	$$
</div>
<p>while the maximum number that can be written as a sum of its 5th digits powers is</p>
<div>
	$$
	\begin{align*}
	 295245 = 9^5 + 9^5 + 9^5 + 9^5 + 9^5.
	\end{align*}
	$$
</div>
<p>So let’s check all the numbers in this range</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 5*9^5 = 295,245</span>
<span class="c1">// 0^5 + 0^5 + 0^5 + 1^5 + 1^5 = 2</span>
<span class="kt">int</span> <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">295245</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">num</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=30">Project Euler - 30</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This was not bad! the minimum number that can be written as a sum of its 5th digits powers is $$ \begin{align*} 2 = 0^5 + 0^5 + 0^5 + 1^5 + 1^5. \end{align*} $$ while the maximum number that can be written as a sum of its 5th digits powers is $$ \begin{align*} 295245 = 9^5 + 9^5 + 9^5 + 9^5 + 9^5. \end{align*} $$ So let’s check all the numbers in this range // 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 5*9^5 = 295,245 // 0^5 + 0^5 + 0^5 + 1^5 + 1^5 = 2 int total_sum = 0; for (int n = 2; n &lt;= 295245; n++) { long sum = 0; int num = n; while (num &gt; 0 &amp;&amp; sum &lt;= n) { int d = num%10; int p = pow(d, 5); sum += p; num /= 10; } if (sum == n) { total_sum += sum; } } printf("%d\n", total_sum); References Project Euler - 30]]></summary></entry><entry><title type="html">Project Euler: 28 Number Spiral Diagonals</title><link href="http://localhost:4000/jekyll/update/2025/01/12/project-euler-28-number-spiral-diagonals.html" rel="alternate" type="text/html" title="Project Euler: 28 Number Spiral Diagonals" /><published>2025-01-12T00:01:36-08:00</published><updated>2025-01-12T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/12/project-euler-28-number-spiral-diagonals</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/12/project-euler-28-number-spiral-diagonals.html"><![CDATA[<p>My first solution was just to sum the numbers across the diagonals after breaking them into 4 parts.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/1.png" width="90%" class="center" /></p>
<p>We can come up with a formula for the yellow cells for example by observing that the difference between the cells follow a pattern.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/2.png" width="80%" class="center" /></p>
<p>You can see above that the difference between the cells keeps increasing by 8 each time we move up. Similarly, we can find that the other 3 parts follow a similar pattern. For example, we can see that the difference between the cells below also increases by 8. The only difference between the green cells and the yellow cells is that the initial difference here is 9 while it was 7 for the yellow cells.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/3.png" width="80%" class="center" /></p>
<p>Similarly, the difference between the blue cells also increase by 8 but the initial difference is 3 here.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/4.png" width="80%" class="center" /></p>
<p>So we can come up with the following function that takes the initial cell value and the initial difference and then returns the total sum. Since the grid is \(1001 \times 10001\), then each quadrant will contain 500 cells.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">sum_quadrant</span><span class="p">(</span><span class="kt">int</span> <span class="n">cell</span><span class="p">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">500</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">cell</span><span class="p">;</span> <span class="c1">// add the cell value</span>
        <span class="n">cell</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span> <span class="c1">// cell value will increase by the diff</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="n">add</span><span class="p">;</span> <span class="c1">// the diff will increase by 8 each iteration</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
We now can use the above method to print the total.
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">long</span> <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span> <span class="c1">// Top Left Diagonal</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// Top Right Diagonal</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// Bottom Right Diagonal</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> <span class="c1">// Bottom Left Diagonal</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Closed Formula</b></h4>
<p>Of course my naive solution was too basic and it seems that there is a closed formula for this … I have yet to do it! [TODO]
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=27">Project Euler - 27</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[My first solution was just to sum the numbers across the diagonals after breaking them into 4 parts. We can come up with a formula for the yellow cells for example by observing that the difference between the cells follow a pattern. You can see above that the difference between the cells keeps increasing by 8 each time we move up. Similarly, we can find that the other 3 parts follow a similar pattern. For example, we can see that the difference between the cells below also increases by 8. The only difference between the green cells and the yellow cells is that the initial difference here is 9 while it was 7 for the yellow cells. Similarly, the difference between the blue cells also increase by 8 but the initial difference is 3 here. So we can come up with the following function that takes the initial cell value and the initial difference and then returns the total sum. Since the grid is \(1001 \times 10001\), then each quadrant will contain 500 cells. int sum_quadrant(int cell, int diff) { int add = 8, sum = 0; for (int i = 1; i &lt;= 500; i++) { sum += cell; // add the cell value cell += diff; // cell value will increase by the diff diff += add; // the diff will increase by 8 each iteration } return sum; } We now can use the above method to print the total. long total_sum = 0; total_sum += sum_quadrant(7, 14); // Top Left Diagonal total_sum += sum_quadrant(9, 16); // Top Right Diagonal total_sum += sum_quadrant(3, 10); // Bottom Right Diagonal total_sum += sum_quadrant(5, 12); // Bottom Left Diagonal printf("%ld\n", total_sum + 1); Closed Formula Of course my naive solution was too basic and it seems that there is a closed formula for this … I have yet to do it! [TODO] References Project Euler - 27]]></summary></entry><entry><title type="html">Project Euler: 27 Quadratic Primes</title><link href="http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes.html" rel="alternate" type="text/html" title="Project Euler: 27 Quadratic Primes" /><published>2025-01-11T00:01:36-08:00</published><updated>2025-01-11T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes.html"><![CDATA[<p>I was so scared when I read the problem description! so I was shocked when I just got this on the first try. Admittedly, my solution is just the naive solution but it was fast enough. Basically we want to know \(a\) and \(b\) that will make the equation \(f(n) = n^2 + an + b\) produce the longest sequence of prime numbers. To do so, we need a fast way to check whether a number is prime. For that we can just borrow the sieve algorithm we implemented for problem 7.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
After this, it is pretty straight forward. Just check all possible the values for \(a\) and \(b\). Both variables will range from -999 to 999.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">sieve</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// f(n) = n^2 + an + b</span>
        <span class="c1">// f(0) = b is the initial value</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">fn</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">n</span><span class="o">++</span><span class="p">;</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
            <span class="n">max_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">max_b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"a = %d, b = %d, a*b = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max_a</span><span class="p">,</span> <span class="n">max_b</span><span class="p">,</span> <span class="n">max_a</span> <span class="o">*</span> <span class="n">max_b</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=27">Project Euler - 27</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I was so scared when I read the problem description! so I was shocked when I just got this on the first try. Admittedly, my solution is just the naive solution but it was fast enough. Basically we want to know \(a\) and \(b\) that will make the equation \(f(n) = n^2 + an + b\) produce the longest sequence of prime numbers. To do so, we need a fast way to check whether a number is prime. For that we can just borrow the sieve algorithm we implemented for problem 7. void sieve() { int s[N]; // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { primes[i] = 1; } s[0] = s[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (primes[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { primes[i] = 0; } } } } After this, it is pretty straight forward. Just check all possible the values for \(a\) and \(b\). Both variables will range from -999 to 999. sieve(); int max_count = 0, max_a = 0, max_b = 0; for (int a = -999; a &lt; 1000; a++) { for (int b = -999; b &lt; 1000; b++) { // f(n) = n^2 + an + b // f(0) = b is the initial value int n = 0; int fn = b; int count = 0; while (primes[fn]) { count++; n++; fn = n*n + a*n + b; } if (count &gt; max_count) { max_count = count; max_a = a; max_b = b; } } } printf("a = %d, b = %d, a*b = %d\n", max_a, max_b, max_a * max_b); References Project Euler - 27]]></summary></entry><entry><title type="html">Project Euler: 7 10001st Prime</title><link href="http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime.html" rel="alternate" type="text/html" title="Project Euler: 7 10001st Prime" /><published>2025-01-10T00:01:36-08:00</published><updated>2025-01-10T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime.html"><![CDATA[<p>This is just Sieve’s algorithm to find all primes until we reach the 10001st prime. I don’t know know if there is a faster algorithm to do this.
In Sieve’s algorithm, we mark all numbers up to our limit \(N\) as potential primes. Then starting at 2, we mark all multiples of 2 as non prime. When we’re done, we move to the next potenial prime and repeat the same process.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define N 1000000
</span><span class="kt">int</span> <span class="n">primes</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">primes</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// the 10001st prime is primes[10000]</span>
<span class="p">}</span></code></pre></figure>

<p><br />
This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm).
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=7">Project Euler - 07</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This is just Sieve’s algorithm to find all primes until we reach the 10001st prime. I don’t know know if there is a faster algorithm to do this. In Sieve’s algorithm, we mark all numbers up to our limit \(N\) as potential primes. Then starting at 2, we mark all multiples of 2 as non prime. When we’re done, we move to the next potenial prime and repeat the same process. #define N 1000000 int primes[N]; void sieve() { int s[N]; // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { s[i] = 1; } s[0] = s[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (s[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { s[i] = 0; } } } int index = 0; for (int i = 0; i &lt; N; i++) { if (s[i] == 1) { primes[index++] = i; } } // the 10001st prime is primes[10000] } This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm). References Project Euler - 07]]></summary></entry></feed>