I"èf<p><img src="http://localhost:4000/assets/trees/binary-search-trees/binary-search-tree.png" width="100%" />
A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The <b>binary-search-tree property</b> states that given a node \(x\) in the tree, every node in the left subtree has a key less than \(x\)â€™s key and every node in the right subtree has a key greater than \(x\)â€™s key.
<br />
<!------------------------------------------------------------------------------------></p>
<h3>Motivation</h3>
<p>But why invent another data structure? Letâ€™s take a look at sorted arrays. We can search a sorted array for keys in just \(O(\log(n))\) time with binary search. However, inserting and deleting elements takes \(O(n)\) time. Similarly, while inserting elements in a linked list takes only \(O(1)\) time, searching a linked list takes \(O(n)\) time in the worst case. Can we do better with binary search trees? yes!
<br /><br />
The binary search tree property is really great at allowing us to insert/search and delete in just \(O(h)\) time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be \(O(\log(n))\) where is \(n\) is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h3>In Order Walk</h3>
<p>Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. 
<!----------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">in_order_walk</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">in_order_walk</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">print</span> <span class="n">key</span>
    <span class="nf">in_order_walk</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<!---------------------->
<p>Proving that it takes \(O(n)\) time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof)
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h3>Search</h3>
<p>Similar to the in-order walk, we can simply perform a search by using the following
<!----------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">tree</span><span class="o">*</span> <span class="nf">search</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h3>Minimum, Maximum, Predecessor and Successor</h3>
<p>Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node \(x\), we have two cases:</p>
<ul>
  <li>If \(x\) has a right subtree, then the most left element (tree minimum) of the right subtree is the successor.</li>
  <li>If \(x\) doesnâ€™t have a right subtree, then the next element would be the first ancestor such that \(x\) is a left child of it. 
<!----------------------></li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">tree</span><span class="o">*</span> <span class="nf">successor</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span>  <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">tree_minimum</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// otherwise, find the closest parent where t is a left child</span>
    <span class="n">tree</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
 <!------------------------------------------------------------------------------------></p>
<h3>Insert</h3>
<p>Inserting a node into a binary search tree is pretty simple. We need to follow the following steps:</p>
<ul>
  <li>Create a new node and assign both the left and right pointers to NULL.</li>
  <li>Similar to search, descend in the tree with pointer \(current\) based on the key value, while keeping a trailing pointer \(p\) to its parent. Once we hit NULL, we know that the \(p\) will be the parent of our node.
The figure below illustrates the process:
<img src="http://localhost:4000/assets/trees/binary-search-trees/insert.png" width="100%" />
<!----------------------></li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">tree</span> <span class="o">**</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// create a new node x</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">x</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// x is now the root!</span>
        <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
 <span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h3>Delete</h3>
<p>Before discussing delete, weâ€™ll present a helper function that we will use in deleting a node in a binary search three. <i>transplant</i> replaces a subtree rooted at \(x\) with another subtree rooted at \(v\), illustrated below, 
<img src="http://localhost:4000/assets/trees/binary-search-trees/transplant.png" width="100%" /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// replace subtree u with subtree v</span>
<span class="kt">void</span> <span class="nf">transplant</span><span class="p">(</span><span class="n">tree</span> <span class="o">**</span><span class="n">t</span><span class="p">,</span> <span class="n">tree</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">tree</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is the root </span>
        <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is a left child</span>
        <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// fix v's parent pointer</span>
        <span class="n">v</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span>
    <span class="p">}</span>
 <span class="p">}</span></code></pre></figure>

<p>Now, suppose weâ€™re about to delete node \(x\) and that are given a pointer to it
We have four different cases that we need to handle:</p>
<ul>
  <li>
    <p>\(x\) has no children. We then can simply delete that node and return. This case could be handled implicitly in the next case. 
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-1.png" width="100%" /></p>
  </li>
  <li>
    <p>\(x\) has only one child. We then just transplant its child at \(x\)â€™s parent and remove \(x\).
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-2.png" width="100%" /></p>
  </li>
</ul>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// one child case</span>
<span class="c1">// delete node x if x has only one child</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// no left child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1">// replace x with its right child</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is a left child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1">// replace x with its left child</span>
<span class="p">}</span>
<span class="c1">// we're good to remove x's memory using "free" or "delete" or whatever we need</span></code></pre></figure>

<ul>
  <li>\(x\) has two children. The idea here is that the successor of \(x\) will take \(x\)â€™s place to maintain the binary search tree property and then we can just delete \(x\). We do know that the successor is the most left child (minimum node) in \(x\)â€™s right subtree. Let \(s\) be the successor of \(x\). It is also important to note that \(s\) canâ€™t have left children since it is the most left node by definition. We now break deleting \(x\) into two sub-cases:</li>
</ul>

<p>(1) \(s\) is the right child of \(x\).  In this case, we transplant \(s\) at \(x\)â€™s parent. We also move \(x\)â€™s left subtree to be \(s\)â€™s left subtree. We then we remove \(x\). 
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-3.png" width="100%" /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// two children first sub-case (s is a right child of x)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s is x's immediate right child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// replace x with s</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> <span class="c1">// s's left subtree = x's left subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
<span class="p">}</span></code></pre></figure>

<p><br />
(2) \(s\) is in the left subtree of \(x\)â€™s right child. In this case, itâ€™s a little more complicated. We first want to replace \(s\) (21 in the example) with its right subtree (25 in the example) (remember \(s\) canâ€™t have a left subtree). We then assign \(x\)â€™s right subtree to be \(s\)â€™s right subtree. So now the subtree 29 is the right child of 21. Finally just like in the earlier case, simply replace \(x\) with its right subtree. In this example, it means to replace 19 with 21!
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-4.png" width="100%" /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// two children second sub-case (s is not right child of x)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s is not x's immediate right child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">right</span><span class="p">);</span> <span class="c1">// replace s with its right subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span> <span class="c1">// s's right subtree = x's right subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
<span class="p">}</span>
<span class="c1">// repeat steps from above to replace x with its right child (s)</span>
<span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// replace x with s</span>
<span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> <span class="c1">// s's left subtree is now x's left subtree</span>
<span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span></code></pre></figure>

<p><br />
Finally putting everything together in one place:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">delete</span><span class="p">(</span><span class="n">tree</span> <span class="o">**</span><span class="n">t</span><span class="p">,</span> <span class="n">tree</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// one child case</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// no left child</span>
        <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1">// replace x with its right child</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is a left child</span>
        <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1">// replace x with its left child</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// two children second sub-case (s is not right child of x)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s is not x's immediate right child</span>
        <span class="n">transplant</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">right</span><span class="p">);</span> <span class="c1">// replace s with its right subtree</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span> <span class="c1">// s's right subtree = x's right subtree</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
    <span class="p">}</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// replace x with s</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> <span class="c1">// s's left subtree is now x's left subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h3>Implementation</h3>
<p><a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/binary-search-tree.cpp">Source Code</a>
<!------------------------------------------------------------------------------------></p>
<h3>References</h3>
<p>CLRS</p>

:ET