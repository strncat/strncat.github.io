<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-04-02T16:50:03-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strcat’s notebook</title><subtitle>Hello.</subtitle><entry><title type="html">Prim’s Minimum Spanning Tree</title><link href="http://localhost:4000/jekyll/update/2019/04/02/prim.html" rel="alternate" type="text/html" title="Prim's Minimum Spanning Tree" /><published>2019-04-02T12:01:36-07:00</published><updated>2019-04-02T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/04/02/prim</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/04/02/prim.html">&lt;svg width=&quot;800&quot; height=&quot;250&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;294.5&quot; cy=&quot;68.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;289.5&quot; y=&quot;74.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;498.5&quot; cy=&quot;68.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;494.5&quot; y=&quot;74.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;664.5&quot; cy=&quot;147.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;659.5&quot; y=&quot;153.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;d&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;498.5&quot; cy=&quot;218.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;494.5&quot; y=&quot;224.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;e&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;294.5&quot; cy=&quot;218.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;291.5&quot; y=&quot;224.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;f&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;137.5&quot; cy=&quot;159.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;133.5&quot; y=&quot;165.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;324.5,68.5 468.5,68.5&quot; /&gt;
	&lt;text x=&quot;391.5&quot; y=&quot;89.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;4&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;525.589,81.392 637.411,134.608&quot; /&gt;
	&lt;text x=&quot;586.5&quot; y=&quot;98.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;7&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;636.917,159.298 526.083,206.702&quot; /&gt;
	&lt;text x=&quot;566.5&quot; y=&quot;173.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;468.5,218.5 324.5,218.5&quot; /&gt;
	&lt;text x=&quot;391.5&quot; y=&quot;209.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;6&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;318.67,200.728 474.33,86.272&quot; /&gt;
	&lt;text x=&quot;401.5&quot; y=&quot;164.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;5&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;163.455,144.456 268.545,83.544&quot; /&gt;
	&lt;text x=&quot;220.5&quot; y=&quot;135.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;165.583,170.053 266.417,207.947&quot; /&gt;
	&lt;text x=&quot;201.5&quot; y=&quot;210.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;498.5,188.5 498.5,98.5&quot; /&gt;
	&lt;text x=&quot;503.5&quot; y=&quot;149.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;3&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;294.5,188.5 294.5,98.5&quot; /&gt;
	&lt;text x=&quot;299.5&quot; y=&quot;149.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
&lt;/svg&gt;
&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be undirected, weighted graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. A minimum spanning tree is a tree that connects all the vertices in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; of minimal cost. Prim greedily finds the minimum spanning tree by growing a tree. what start from a vertex and then we pick the cheapest edge out of that vertex. We keep adding cheap edges such that we don’t create a cycle until we cover all the vertices in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;. Even though we will only analyze the efficient implementation of Prim, it is very useful to look at the naive implementation because it is more intuitive.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.1 Algorithm (slow naive version)&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;We&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lightest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coming&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;out&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cheapest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edge&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;so&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;that&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.2 Algorithm (fast, used for the remaining of these notes)&lt;/b&gt;
&lt;br /&gt;
This smart implementation is basically Dijkstra! The only difference is the update condition. In Dijkstra, we take into account the whole path cost while in Prim we only care about the edge weight itself!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreached&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infinity&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreached&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unreached&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// The is the only difference between Prim and Dijkstra&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Mark&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reached&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// This edge is safe to add and won't rule out success, proof below!&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;&lt;br /&gt;
In the above example, the minimum spanning tree is the following tree:&lt;/p&gt;
&lt;svg width=&quot;800&quot; height=&quot;250&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;294.5&quot; cy=&quot;68.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;289.5&quot; y=&quot;74.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;498.5&quot; cy=&quot;68.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;494.5&quot; y=&quot;74.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;664.5&quot; cy=&quot;147.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;659.5&quot; y=&quot;153.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;d&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;498.5&quot; cy=&quot;218.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;494.5&quot; y=&quot;224.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;e&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;294.5&quot; cy=&quot;218.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;291.5&quot; y=&quot;224.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;f&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;137.5&quot; cy=&quot;159.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;133.5&quot; y=&quot;165.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;324.5,68.5 468.5,68.5&quot; /&gt;
	&lt;text x=&quot;391.5&quot; y=&quot;89.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;4&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;636.917,159.298 526.083,206.702&quot; /&gt;
	&lt;text x=&quot;566.5&quot; y=&quot;173.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;163.455,144.456 268.545,83.544&quot; /&gt;
	&lt;text x=&quot;220.5&quot; y=&quot;135.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;498.5,188.5 498.5,98.5&quot; /&gt;
	&lt;text x=&quot;503.5&quot; y=&quot;149.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;3&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;294.5,188.5 294.5,98.5&quot; /&gt;
	&lt;text x=&quot;299.5&quot; y=&quot;149.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
&lt;/svg&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
Why does this algorithm find a minimum spanning tree? Before we can answer that, let’s define some terms and prove some lemma that will be useful in the main proof. Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be the graph below and let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be the set of yellow edges in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/cut.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A &lt;b&gt;cut&lt;/b&gt; is a partition of the vertices into two non-empty parts. the red line (cut) partitions &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;\{a,b,f,e\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\{c,d\}&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;A cut &lt;b&gt;respects&lt;/b&gt; &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; if no edges in &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; cross the cut. None of the yellow edges cross the red cut.&lt;/li&gt;
  &lt;li&gt;An edge crossing the cut is called &lt;b&gt;light&lt;/b&gt; if it has the smallest weight of any edge crossing the cut. In this case, &lt;script type=&quot;math/tex&quot;&gt;\{e,d\}&lt;/script&gt; is a light edge.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Lemma: Let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be a set of edges and consider a cut that respects &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Suppose there is an MST containing &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; be a light edge. Then there is an MST containing &lt;script type=&quot;math/tex&quot;&gt;S \cup \{u,v\}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; Let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be a set of edges and and consider a cut that respects &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; be an MST containing &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; be a light edge. There are two cases. &lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; is in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;, then we’re done. &lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; is not in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;. By the definition of MST, adding &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; will create a cycle in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;. Since the sets resulting from the cut must be non-empty. This means that we must have an edge that crosses the cut in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;. Let that edge be &lt;script type=&quot;math/tex&quot;&gt;\{x,y\}&lt;/script&gt;. Consider replacing &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;\{x,y\}&lt;/script&gt; to produce the new tree &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; is still an MST since we deleted &lt;script type=&quot;math/tex&quot;&gt;\{x,y\}&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt; has also a cost of at most the cost of &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; since {u,v} is a light edge. Therefore, &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt; is an MST which includes both &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; which is what we wanted to show. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Theorem: Prim will correctly find a minimum spanning tree&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
&lt;b&gt;Inductive Hypothesis: &lt;/b&gt;After adding the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th edge, there exists an MST with the edges added so far.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case: &lt;/b&gt; After adding the 0’th edge, there exists an MST with the edges added so far.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Inductive Step:&lt;/b&gt; Suppose the inductive hypothesis holds for &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be the set containing the edges added so far and so there is an MST extending them by the inductive hypothesis. Consider the cut &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;V-S&lt;/script&gt;. This cut respects &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Prim adds the lightest edge crossing this cut. By the Lemma above that edge is safe to add. Therefore, there is still an MST extending the new set of edges.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Conclusion:&lt;/b&gt; After adding the &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt;‘st edge, there exists an MST with the edges added so far. At this point we have reached all vertices and the &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; edges we have is an MST.&lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Running Time:&lt;/b&gt; &lt;br /&gt;
The analysis is exactly like Dijkstra!. What are we doing in this algorithm? For each vertex in the unreached list, we &lt;br /&gt;
(1) find the minimum vertex. &lt;br /&gt;
(2) remove that vertex. &lt;br /&gt;
(3) update all neighbors with lower key values if possible.&lt;br /&gt;
&lt;br /&gt;
Therefore we see that if we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
TotalTime &amp;amp;= \sum_{u \in V} \big\{ T(findMin) + \big(\sum_{v \in u.neighbors} T(updateKey)\big) + T(removeMin) \big\} \\
&amp;amp;= n(T(findMin) + T(removeMin)) + m(T(updateKey))

\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Now it is clear that it really depends on how we implement the list that holds the not-sure nodes. Let’s consider different data structures&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Arrays
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n(2n) + m) = O(n^2 + m) = O(n^2)&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Red Black Tree
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n) + m\log(n)) = O((n+m)\log(n))&lt;/script&gt;. &lt;br /&gt;
Notice here, if the graph is dense, meaning that &lt;script type=&quot;math/tex&quot;&gt;m=O(n^2)&lt;/script&gt;, then this is worse than arrays! if it’s sparse, then it’s better.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fibonacci Heaps
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;, amortized time.&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;, amortized time.&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;, amortized time.&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n) + m)&lt;/script&gt;, amortized time. &lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Detailed Implementation:&lt;/b&gt; &lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/minimum-spanning-trees/prim&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html&lt;/p&gt;</content><author><name></name></author><summary type="html">b c d e f a 4 7 2 6 5 1 2 3 1 1 Introduction Let be undirected, weighted graph with vertices and edges. A minimum spanning tree is a tree that connects all the vertices in of minimal cost. Prim greedily finds the minimum spanning tree by growing a tree. what start from a vertex and then we pick the cheapest edge out of that vertex. We keep adding cheap edges such that we don’t create a cycle until we cover all the vertices in . Even though we will only analyze the efficient implementation of Prim, it is very useful to look at the naive implementation because it is more intuitive.</summary></entry><entry><title type="html">Kosaraju’s SCC Algorithm</title><link href="http://localhost:4000/jekyll/update/2019/04/01/kosaraju.html" rel="alternate" type="text/html" title="Kosaraju's SCC Algorithm" /><published>2019-04-01T12:01:36-07:00</published><updated>2019-04-01T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/04/01/kosaraju</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/04/01/kosaraju.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be a graph with &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is strongly connected if for all &lt;script type=&quot;math/tex&quot;&gt;u,v&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;:&lt;br /&gt;
(1) There is a path from &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;.&lt;br /&gt;
(2) There is a path from &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;.&lt;br /&gt;
We can decompose a graph into strongly connected components. To find these strongly connected components, we describe in this page Kosaraju’s algorithm.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Algorithm&lt;/b&gt;&lt;br /&gt;
It is a magical algorithm!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;keep&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tracking&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finishing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Reverse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;G&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Run&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;again&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reverse&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;finishing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;The&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SCCs&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;different&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;trees&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DFS&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;forest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;
&lt;svg width=&quot;800&quot; height=&quot;250&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;441.5&quot; cy=&quot;51.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;417.5&quot; y=&quot;57.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a(0,9)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;360.5&quot; cy=&quot;179.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;327.5&quot; y=&quot;185.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c(10,11)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;82.5&quot; cy=&quot;139.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;58.5&quot; y=&quot;145.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;d(3,4)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;209.5&quot; cy=&quot;139.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;185.5&quot; y=&quot;145.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;e(2,5)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;236.5&quot; cy=&quot;51.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;214.5&quot; y=&quot;57.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;f(1,6)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;501.5&quot; cy=&quot;145.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;477.5&quot; y=&quot;151.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b(7,8)&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.5,51.5 411.5,51.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;411.5,51.5 403.5,46.5 403.5,56.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.5,51.5 411.5,51.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;411.5,51.5 403.5,46.5 403.5,56.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;411.5,51.5 266.5,51.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.5,51.5 274.5,56.5 274.5,46.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;485.359,120.212 457.641,76.788&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;457.641,76.788 457.731,86.221 466.16,80.841&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;227.7,80.18 218.3,110.82&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;218.3,110.82 225.426,104.638 215.866,101.705&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;413.45,62.14 237.55,128.86&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;237.55,128.86 246.803,130.698 243.257,121.348&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;179.5,139.5 112.5,139.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;112.5,139.5 120.5,144.5 120.5,134.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;112.5,139.5 179.5,139.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;179.5,139.5 171.5,134.5 171.5,144.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;376.542,154.149 425.458,76.851&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;425.458,76.851 416.955,80.937 425.405,86.284&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;331.5,171.818 238.5,147.182&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;238.5,147.182 244.953,154.064 247.513,144.397&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;264.774,61.529 473.226,135.471&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;473.226,135.471 467.358,128.084 464.015,137.509&quot; /&gt;
&lt;/svg&gt;
&lt;p&gt;In the above graph, we run a first pass of DFS while keeping tracking of the finishing times of vertices. Here, we see that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; has the largest finishing time. We next reverse the edges in the graph and perform another DFS from the node with the largest finishing time.&lt;/p&gt;
&lt;svg width=&quot;800&quot; height=&quot;250&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;441.5&quot; cy=&quot;51.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;417.5&quot; y=&quot;57.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a(0,8)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;360.5&quot; cy=&quot;179.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;327.5&quot; y=&quot;185.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c(11,12)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;82.5&quot; cy=&quot;139.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;58.5&quot; y=&quot;145.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;d(3,4)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;209.5&quot; cy=&quot;139.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;185.5&quot; y=&quot;145.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;e(2,5)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;236.5&quot; cy=&quot;51.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;214.5&quot; y=&quot;57.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;f(1,7)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;501.5&quot; cy=&quot;145.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;477.5&quot; y=&quot;151.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b(2,6)&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.5,51.5 411.5,51.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;411.5,51.5 403.5,46.5 403.5,56.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.5,51.5 411.5,51.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;411.5,51.5 403.5,46.5 403.5,56.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;411.5,51.5 266.5,51.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.5,51.5 274.5,56.5 274.5,46.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;485.359,120.212 457.641,76.788&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;457.641,76.788 457.731,86.221 466.16,80.841&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;227.7,80.18 218.3,110.82&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;218.3,110.82 225.426,104.638 215.866,101.705&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;413.45,62.14 237.55,128.86&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;237.55,128.86 246.803,130.698 243.257,121.348&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;179.5,139.5 112.5,139.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;112.5,139.5 120.5,144.5 120.5,134.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;112.5,139.5 179.5,139.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;179.5,139.5 171.5,134.5 171.5,144.5&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;376.542,154.149 425.458,76.851&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;425.458,76.851 416.955,80.937 425.405,86.284&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;331.5,171.818 238.5,147.182&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;238.5,147.182 244.953,154.064 247.513,144.397&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;264.774,61.529 473.226,135.471&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;473.226,135.471 467.358,128.084 464.015,137.509&quot; /&gt;
&lt;/svg&gt;
&lt;p&gt;Notice in the second DFS, we visit &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; first and there are no nodes reachable from &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, so &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is a strongly connected component. We next visit &lt;script type=&quot;math/tex&quot;&gt;\{a,b,c\}&lt;/script&gt; and that’s our second strongly connected component. We finally visit &lt;script type=&quot;math/tex&quot;&gt;\{d,e\}&lt;/script&gt; and that’s our third and final strongly connected component as expected.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
Why does this algorithm find the SCCs? To show how, we’ll first prove two important lemmas that we’ll use in proving that the algorithm is correct.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Lemma 1: The SCC graph is a DAG&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; Suppose that the SCC graph is not a DAG and let &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; be two components where there is an edge from &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; and an edge from &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; be a vertex in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and let &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; be a vertex in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. By the connected component definition, we know there is a path between &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and every vertex in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. Similarly, there is a path between &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and any vertex in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. Since there is an edge from &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; then there is a path from &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; to any vertex in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; and Similarly, there is a path between &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and any vertex in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. Therefore, the vertices in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; must be in the same strongly connected component. This is a contradiction, since we assumed &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; two strongly connected components. Therefore, the SCC graph must be a DAG. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Lemma 2: In the SCC DAG, if there is an edge from component &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to component &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;A.finish &gt; B.finish&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; There are two cases: &lt;br /&gt;
Case 1: We reached &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; before &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; in our first DFS: &lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; have the largest finish time in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; have the largest finish time in &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; be the first node discovered in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; then we will reach &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and discover &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; then at some point we will reach &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; and discover &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;. This means that &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;. By the parentheses theorem, this means that &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; has a larger finish time. Since &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; has the largest finish time in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;x.finish &gt; z.finish&lt;/script&gt; and since &lt;script type=&quot;math/tex&quot;&gt;.z.finish &gt; y.finish&lt;/script&gt; then we have &lt;script type=&quot;math/tex&quot;&gt;A.finish &gt; B.finish&lt;/script&gt;, as required.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
Case 2: We reached &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; before &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; in our first DFS: &lt;br /&gt;
Since we assumed that there is an edge from &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; then by Lemma 1, we don’t have an edge from &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.Therefore, we will explore &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; completely first and then &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; will be explored later after we restart the DFS, this means that &lt;script type=&quot;math/tex&quot;&gt;A.finish &gt; B.finish&lt;/script&gt;, as we wanted to show. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Corollary 1: In the SCC DAG, if there is an edge from component &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; to component &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; in the reversed graph, then &lt;script type=&quot;math/tex&quot;&gt;A.finish &gt; B.finish&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We can now combine the previous results to prove the following theorem:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Theorem: The algorithm we saw before will correctly identify strongly connected components&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
&lt;b&gt;Inductive Hypothesis: &lt;/b&gt; The first &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; trees found in the second (reversed) DFS
forest are the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; SCCs with the largest finish times. Moreover, what’s left unvisited after these &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; trees have been explored is a DAG on the un-found SCCs.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case:&lt;/b&gt; It is vacuously true that the first 0 trees found in the reversed DFS forest are the 0 SCCs with the largest finish times. Moreover, what’s left unvisited after 0 trees have been explored is a DAG on all the SCCs by Lemma 1.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Inductive Step:&lt;/b&gt; Assume by induction that the first &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; trees are the last-finishing SCCs, and the remaining SCCs form a DAG. 
&lt;br /&gt;
Now, consider the &lt;script type=&quot;math/tex&quot;&gt;t+1&lt;/script&gt;st tree produced and let &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; be the root of the tree. Let &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; be in SCC &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;. We know that &lt;script type=&quot;math/tex&quot;&gt;A.finish &gt; B.finish&lt;/script&gt; for the remaining SCCs &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt;. This is because we chose &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in the second DFS to have the largest finish time. 
&lt;br /&gt;
Also since &lt;script type=&quot;math/tex&quot;&gt;A.finish &gt; B.finish&lt;/script&gt;, then there are no edges going from &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;B&lt;/script&gt; because suppose there was an edge to some component &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;C.finish &gt; A.finish&lt;/script&gt; by Corollary 1 which is a contradiction since &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; has the largest finish time. 
&lt;br /&gt;
Therefore, we will only discover vertices in &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; in the second DFS started from &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. So the &lt;script type=&quot;math/tex&quot;&gt;t+1&lt;/script&gt;st tree is the SCC with the (t+1)st biggest finish time. Also the remaining SCCs still form a DAG, since removing a vertex won’t create a cycle.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Conclusion:&lt;/b&gt; The second (reversed) DFS forest contains all the SCCs as its trees. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Running Time:&lt;/b&gt; 
What are we doing in this algorithm algorithm? Two passes of DFS that we know run in &lt;script type=&quot;math/tex&quot;&gt;O(n+m)&lt;/script&gt;. Therefore the running time is astonishingly &lt;script type=&quot;math/tex&quot;&gt;O(n+m)&lt;/script&gt;. 
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Detailed Implementation:&lt;/b&gt; 
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/connected-components/strongly-connected-components-directed-kosaraju&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction Let be a graph with vertices and edges. is strongly connected if for all in : (1) There is a path from to . (2) There is a path from to . We can decompose a graph into strongly connected components. To find these strongly connected components, we describe in this page Kosaraju’s algorithm. 2 Algorithm It is a magical algorithm! - Run DFS to create a DFS forest and keep tracking of finishing times. - Reverse all the edges in G. - Run DFS again in the reverse graph from the node with the largest finishing time. - The SCCs are the different trees in the second DFS forest. 3 Example a(0,9) c(10,11) d(3,4) e(2,5) f(1,6) b(7,8) In the above graph, we run a first pass of DFS while keeping tracking of the finishing times of vertices. Here, we see that has the largest finishing time. We next reverse the edges in the graph and perform another DFS from the node with the largest finishing time. a(0,8) c(11,12) d(3,4) e(2,5) f(1,7) b(2,6) Notice in the second DFS, we visit first and there are no nodes reachable from , so is a strongly connected component. We next visit and that’s our second strongly connected component. We finally visit and that’s our third and final strongly connected component as expected. 4 Proof of Correctness Why does this algorithm find the SCCs? To show how, we’ll first prove two important lemmas that we’ll use in proving that the algorithm is correct.</summary></entry><entry><title type="html">Dijkstra</title><link href="http://localhost:4000/jekyll/update/2019/03/31/dijkstra.html" rel="alternate" type="text/html" title="Dijkstra" /><published>2019-03-31T12:01:36-07:00</published><updated>2019-03-31T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/31/dijkstra</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/31/dijkstra.html">&lt;svg width=&quot;700&quot; height=&quot;300&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;286.5&quot; cy=&quot;93.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;282.5&quot; y=&quot;99.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;164.5&quot; cy=&quot;234.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;160.5&quot; y=&quot;240.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;s&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;505.5&quot; cy=&quot;93.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;500.5&quot; y=&quot;99.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;388.5&quot; cy=&quot;234.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;384.5&quot; y=&quot;240.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;622.5&quot; cy=&quot;234.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;619.5&quot; y=&quot;240.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;t&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;184.13,211.813 266.87,116.187&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;266.87,116.187 257.855,118.965 265.417,125.508&quot; /&gt;
	&lt;text x=&quot;230.5&quot; y=&quot;184.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;304.084,117.807 370.916,210.193&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;370.916,210.193 370.279,200.781 362.176,206.642&quot; /&gt;
	&lt;text x=&quot;343.5&quot; y=&quot;156.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;194.5,234.5 358.5,234.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;358.5,234.5 350.5,229.5 350.5,239.5&quot; /&gt;
	&lt;text x=&quot;271.5&quot; y=&quot;255.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;316.5,93.5 475.5,93.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;475.5,93.5 467.5,88.5 467.5,98.5&quot; /&gt;
	&lt;text x=&quot;391.5&quot; y=&quot;114.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;524.657,116.587 603.343,211.413&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;603.343,211.413 602.082,202.064 594.386,208.45&quot; /&gt;
	&lt;text x=&quot;548.5&quot; y=&quot;184.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;418.5,234.5 592.5,234.5&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;592.5,234.5 584.5,229.5 584.5,239.5&quot; /&gt;
	&lt;text x=&quot;500.5&quot; y=&quot;255.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;6&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;407.657,211.413 486.343,116.587&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;486.343,116.587 477.386,119.55 485.082,125.936&quot; /&gt;
	&lt;text x=&quot;452.5&quot; y=&quot;184.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;4&lt;/text&gt;
&lt;/svg&gt;

&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Dijkstra solves the shortest weighted path problem in a weighted graph with non-negative edge weights. If we want to find the shortest path between nodes &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; in the above graph then the shortest path is &lt;script type=&quot;math/tex&quot;&gt;s \rightarrow a \rightarrow b \rightarrow t&lt;/script&gt;.
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Algorithm&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vertices&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;infinity&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;pick&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallest&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;estimate&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;each&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// It is cheaper to reach v from u than the current path&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;Mark&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// at this point we know that d[u] = distance(s,v) (proof below)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;
&lt;br /&gt;
In the above graph, we maintain a set of not-sure nodes &lt;script type=&quot;math/tex&quot;&gt;\{s, a, b, c, t\}&lt;/script&gt;. We then assign &lt;script type=&quot;math/tex&quot;&gt;d[v] = \infty&lt;/script&gt; for all nodes. For the source node, we update its estimate to zero. &lt;script type=&quot;math/tex&quot;&gt;d[s] = 0&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
&lt;i&gt;Iteration 0&lt;/i&gt;&lt;br /&gt;
We extract the minimum not-sure not &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. We we now update each neighbor according to the algorithm. After updating each neightbor we get the following the values. Also, after updating all neighbors, we mark &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; as sure.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Iteration&lt;/th&gt;
      &lt;th&gt;s&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;c&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0 (extract &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Iteration 1&lt;/i&gt;&lt;br /&gt;
We extract the minimum again from the not-sure nodes. This time we extract &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;. We update all the neighbors and at the end of this iteration, we mark &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; as sure.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Iteration&lt;/th&gt;
      &lt;th&gt;s&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;c&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0 (extract &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 (extract &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Final iteration&lt;/i&gt;&lt;br /&gt;
We continue with the same process. We extract the node &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and update its neighbors. We then mark it as sure, meaning that the distance from node &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to node &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is 2 and will not change again. We next extract &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; and update the neighbors again. We then mark &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; as sure. We finally extract &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; which has no out-going edges. At the end of the algorithm, we see that we generated all the shortest paths from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to all the other nodes in the graph.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Iteration&lt;/th&gt;
      &lt;th&gt;s&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;c&lt;/th&gt;
      &lt;th&gt;t&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0 (extract &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1 (extract &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2 (extract &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3 (extract &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4 (extract &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;)&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Extracting the path&lt;/b&gt;&lt;br /&gt;
To reconstruct the actuall path take, we just maintain a pointer to the parent node. We simply keep an additional array &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; and modify the update step as follows:
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;there&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;are&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sure&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// we maintain a parent link&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
Why does Dijkstra work? We need to prove two important claims in order to prove that Dijkstra is correct.
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim 1: For all &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt;. That is, &lt;script type=&quot;math/tex&quot;&gt;d[v]&lt;/script&gt; will never be an underestimate for any node &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
&lt;b&gt;Inducive Hypothesis:&lt;/b&gt; After &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; iterations, &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case:&lt;/b&gt; After 0 iterations, the algorithms sets &lt;script type=&quot;math/tex&quot;&gt;d[s]= 0 = d(s,s)&lt;/script&gt; and sets &lt;script type=&quot;math/tex&quot;&gt;d[v]&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;v \neq s&lt;/script&gt; and therefore we have &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt;, as required.&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Inductive Step:&lt;/b&gt; Assume that after &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; iterations, &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. We will prove the inequality holds after &lt;script type=&quot;math/tex&quot;&gt;t+1&lt;/script&gt; iterations. At iteration &lt;script type=&quot;math/tex&quot;&gt;t+1&lt;/script&gt;, we pick the minimum not-sure node &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and then update all neighbors &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; such that:
&lt;script type=&quot;math/tex&quot;&gt;d[v] = min(d[v], d[u]+w(u,v))&lt;/script&gt;. To see that &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt;, notice that: &lt;br /&gt;
(1) &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; by the inductive hypothesis. &lt;br /&gt;
(2) &lt;script type=&quot;math/tex&quot;&gt;d[u] + w(u,v) \geq d(s,v)&lt;/script&gt;. This is because we know that &lt;script type=&quot;math/tex&quot;&gt;d(s,v) \leq d(s,u) + d(u,v)&lt;/script&gt; and we also know that &lt;script type=&quot;math/tex&quot;&gt;d[u] \geq d(s,u)&lt;/script&gt; by the inductive hypothesis. Therefore, &lt;script type=&quot;math/tex&quot;&gt;d(s,v) \leq d[u] + d(u,v)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Conclusion:&lt;/b&gt; 
After the algorithm terminates, we have &lt;script type=&quot;math/tex&quot;&gt;d[v] \geq d(s,v)&lt;/script&gt; for all $v$ in $V$, as required. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim 2: When a vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is marked sure, &lt;script type=&quot;math/tex&quot;&gt;d[u] = d(s,u)&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
&lt;b&gt;Inducive Hypothesis:&lt;/b&gt; When the t’th vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is marked as sure, &lt;script type=&quot;math/tex&quot;&gt;d[v] = d(s,v)&lt;/script&gt;. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case:&lt;/b&gt; When the first vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is marked sure, we know that &lt;script type=&quot;math/tex&quot;&gt;d[s]=0=d(s,s)&lt;/script&gt;, as required. &lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Inductive Step:&lt;/b&gt; Suppose we’re about to mark vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; as sure, and assume every vertex already marked as sure has &lt;script type=&quot;math/tex&quot;&gt;d[v]=d(s,v)&lt;/script&gt;. We will show that &lt;script type=&quot;math/tex&quot;&gt;d[u]=d(s,u)&lt;/script&gt;. Consider a shortest path from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;.&lt;/p&gt;

&lt;svg width=&quot;800&quot; height=&quot;200&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;101.5&quot; cy=&quot;106.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;97.5&quot; y=&quot;112.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;s&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;366.5&quot; cy=&quot;122.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;362.5&quot; y=&quot;128.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;z&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;235.5&quot; cy=&quot;65.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;516.5&quot; cy=&quot;65.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;510.5&quot; y=&quot;71.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;z'&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;645.5&quot; cy=&quot;106.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;640.5&quot; y=&quot;112.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;u&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;130.187,97.723 206.813,74.277&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;206.813,74.277 197.7,71.837 200.626,81.399&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;394.544,111.843 488.456,76.157&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;488.456,76.157 479.202,74.324 482.754,83.672&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;263.009,77.469 338.991,110.531&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;338.991,110.531 333.65,102.754 329.661,111.923&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;545.091,74.587 616.909,97.413&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;616.909,97.413 610.8,90.225 607.771,99.755&quot; /&gt;
&lt;/svg&gt;
&lt;p&gt;We want to prove that &lt;script type=&quot;math/tex&quot;&gt;d[u]=d(s,u)&lt;/script&gt;. Suppose toward a contradiction that our claim is not true and that &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; has the wrong estimate. Also suppose that node &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; is the last node with a correct estimate before node &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and that vertex &lt;script type=&quot;math/tex&quot;&gt;z'&lt;/script&gt; is the vertex after &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; in the shortest path above. We can see that &lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ d[z] = d(s,z) \leq d(s,u) \leq d[u] $$ &lt;br /&gt;
&lt;/div&gt;
&lt;p&gt;This is because we assumed &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; has a correct estimate and we also know that &lt;script type=&quot;math/tex&quot;&gt;d(s,z) \leq d(s,u)&lt;/script&gt; because first, sub-paths of shortest paths are shortest paths (can be proved by contradiction). Second, the distance from &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is non-negative because all edges have non-negative weights and therefore &lt;script type=&quot;math/tex&quot;&gt;d(s,z) \leq d(s,u)&lt;/script&gt;. The last part &lt;script type=&quot;math/tex&quot;&gt;d(s,u) \leq d[u]&lt;/script&gt; follows from claim 1!
&lt;br /&gt;
&lt;br /&gt;
So now, we have &lt;script type=&quot;math/tex&quot;&gt;d[z] \leq d[u]&lt;/script&gt;. There are two cases: &lt;br /&gt;
Case 1: If &lt;script type=&quot;math/tex&quot;&gt;d[z] = d[u]&lt;/script&gt;. In this case, since we assumed &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; has a correct estimate then &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; must have a correct estimate and we’re done! &lt;br /&gt;
Case 2: If &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
d[z] &lt; d[u] %]]&gt;&lt;/script&gt;. In this case, since &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; was the smallest not-sure node, then &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; must be sure. Otherwise we would have picked &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; as the smallest not-sure node. Since &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; is sure then we must have updated &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;’s neighbors. In particular, we know that &lt;script type=&quot;math/tex&quot;&gt;z'&lt;/script&gt; comes after &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; so,&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
d[z'] &amp;amp;\leq d[z] + w(z,z') \\
&amp;amp;= d(s,z) + w(z,z') \ \ \text{This is because } z \text{ is a sure node so by IH } d[z] = d(s,z) \\ 
&amp;amp;= d(s,z') \ \ \text{ Subpaths of shortest paths are shortest paths} \\
&amp;amp;\leq d[z'] \ \ \text{ By claim 1}
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;This means that &lt;script type=&quot;math/tex&quot;&gt;z'&lt;/script&gt; has a correct estimate. This is a contradiction because we assumed that &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; is the last node with a good estimate and therefore, &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; must have the correct estimate, as required.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Conclusion:&lt;/b&gt; 
After the last node is marked sure, we have &lt;script type=&quot;math/tex&quot;&gt;d[v] = d(s,v)&lt;/script&gt; for all $v$ in $V$, as we wanted to show. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time:&lt;/b&gt; 
What are we doing in this algorithm? For each vertex in the not-sure list, we &lt;br /&gt;
(1) find the minimum vertex. &lt;br /&gt;
(2) remove that vertex. &lt;br /&gt;
(3) update all neighbors with lower estimates if possible.&lt;br /&gt;
&lt;br /&gt;
Therefore we see that if we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
TotalTime &amp;amp;= \sum_{u \in V} \big\{ T(findMin) + \big(\sum_{v \in u.neighbors} T(updateKey)\big) + T(removeMin) \big\} \\
&amp;amp;= n(T(findMin) + T(removeMin)) + m(T(updateKey))

\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;Now it is clear that it really depends on how we implement the list that holds the not-sure nodes. Let’s consider different data structures&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Arrays
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n(2n) + m) = O(n^2 + m) = O(n^2)&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Red Black Tree
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n) + m\log(n)) = O((n+m)\log(n))&lt;/script&gt;. &lt;br /&gt;
Notice here, if the graph is dense, meaning that &lt;script type=&quot;math/tex&quot;&gt;m=O(n^2)&lt;/script&gt;, then this is worse than arrays! if it’s sparse, then it’s better.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Fibonacci Heaps
    &lt;ul&gt;
      &lt;li&gt;findMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;, amortized time.&lt;/li&gt;
      &lt;li&gt;RemoveMin will run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;, amortized time.&lt;/li&gt;
      &lt;li&gt;UpdateKey will run in &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;, amortized time.&lt;br /&gt;
Therefore, the total time will be &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n) + m)&lt;/script&gt;, amortized time. &lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Negative weight edges:&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;8 Detailed Implementation:&lt;/b&gt; 
https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/dijkstra/dijkstra.cpp&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html&lt;/p&gt;</content><author><name></name></author><summary type="html">a s b c t 2 1 1 2 1 6 4</summary></entry><entry><title type="html">10154 - Weights and Measures</title><link href="http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures.html" rel="alternate" type="text/html" title="10154 - Weights and Measures" /><published>2019-03-29T12:01:36-07:00</published><updated>2019-03-29T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry><entry><title type="html">10069 - Distinct Subsequences</title><link href="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html" rel="alternate" type="text/html" title="10069 - Distinct Subsequences" /><published>2019-03-27T12:01:36-07:00</published><updated>2019-03-27T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html">&lt;p&gt;&lt;b&gt;Solution&lt;/b&gt;
&lt;br /&gt;
To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”.
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
 c[p] = \sum_i\left\{\begin{array}{@{}lr@{}}
        \sum_{j &amp;lt; i}c[p_0...p_{i-1}] &amp;amp; \text{if }x_i = p_i\\
        0                       &amp;amp; \text{otherwise} 
        \end{array}\right\}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Why does this work?&lt;/b&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be a string and let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be the string we want to count the occurences of in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; be the length of &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. Assume that we know the optimal count of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and suppose toward a contradiction that the count of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n}&lt;/script&gt; is not optimal. Since there are more ocurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt;, then naturally this means that there are more ocurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n}&lt;/script&gt;. This is a contradiction because we assumed that the number of occurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt; is optimal. Therefore our solution must be optimal.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Implementation Details&lt;/b&gt;
&lt;br /&gt;
Base Case: Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be a string and let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be the string that we are looking for. We initialize an array &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; to store 1 if we see &lt;script type=&quot;math/tex&quot;&gt;p[0]&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; otherwise, we store 0.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;From this point, we iterate through &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; starting at index &lt;script type=&quot;math/tex&quot;&gt;i=1&lt;/script&gt; and apply the above recurrence. At each step we need row “i-1” to produce row “i”. Instead of maintaining two arrays or a two dimensional array, we simply maintain a sum variable to keep track of the sum of the previous row and also reset the cells as we go. 
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// starting matching p[i] at i&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;bignum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;i=0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">Solution To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”. $$ c[p] = \sum_i\left\{\begin{array}{@{}lr@{}} \sum_{j &amp;lt; i}c[p_0...p_{i-1}] &amp;amp; \text{if }x_i = p_i\\ 0 &amp;amp; \text{otherwise} \end{array}\right\} $$ Why does this work? Let be a string and let be the string we want to count the occurences of in . Let be the length of . Assume that we know the optimal count of in and suppose toward a contradiction that the count of is not optimal. Since there are more ocurrences of , then naturally this means that there are more ocurrences of . This is a contradiction because we assumed that the number of occurrences of is optimal. Therefore our solution must be optimal. Implementation Details Base Case: Let be a string and let be the string that we are looking for. We initialize an array to store 1 if we see in otherwise, we store 0.</summary></entry><entry><title type="html">10003 - Cutting Sticks</title><link href="http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks.html" rel="alternate" type="text/html" title="10003 - Cutting Sticks" /><published>2019-03-25T12:01:36-07:00</published><updated>2019-03-25T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry></feed>