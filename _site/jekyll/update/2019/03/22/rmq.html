<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>The RMQ Problem | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="The RMQ Problem" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hello" />
<meta property="og:description" content="Hello" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/03/22/rmq.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/03/22/rmq.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-03-22T07:01:36-07:00" />
<script type="application/ld+json">
{"description":"Hello","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/03/22/rmq.html","headline":"The RMQ Problem","dateModified":"2019-03-22T07:01:36-07:00","datePublished":"2019-03-22T07:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/03/22/rmq.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">The RMQ Problem</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-03-22T07:01:36-07:00" itemprop="datePublished">Mar 22, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="http://localhost:4000/assets/rmq-array.png" alt="my photo" /></p>

<p><b> 0 References </b><br /></p>
<ol>
  <li>CS166 Lecture Slides http://web.stanford.edu/class/cs166/lectures/00/Small00.pdf</li>
  <li>Fischer, Johannes and Heun, Volker. Theoretical and Practical Improvements on the RMQ-Problem, with Applications to LCA and LCE
<br />
<br />
<!------------------------------------------------------------------------------------></li>
</ol>
<hr />

<p><br />
<b>1 Introduction</b><br />
Given an array <script type="math/tex">A</script> and two indices <script type="math/tex">i \leq j</script> that are not known in advance. The RMQ problem solves the problem of finding the minimum element in the range <script type="math/tex">A[i],A[i+1],...,A[j-1],A[j]</script>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>2 Definitions</b><br />
Let <script type="math/tex">\langle p(n), q(n)\rangle</script> be the complexity of an algorithm with preprocessing time <script type="math/tex">p(n)</script> and query time <script type="math/tex">q(n)</script>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>3.1 Algorithm 1: Do nothing! <script type="math/tex">\langle p(n), q(n)\rangle = \langle O(1), O(n)\rangle</script></b>
<br />
The simplest approach is to not do any kind of preprocessing on the input and just compute the minimum for each query. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>3.2 Algorithm 2: Compute all ranges <script type="math/tex">\langle p(n), q(n)\rangle = \langle O(n^3), O(1)\rangle</script></b>
<br />
We compute the minimum element for all possible ranges. There are <script type="math/tex">O(n^2)</script> possible ranges. We need $O(n)$ time to compute the minimum in each range so the total time preprocessing time is <script type="math/tex">p(n) = O(n^3)</script>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>3.3 Algorithm 3: Compute all ranges with DP <script type="math/tex">\langle p(n), q(n)\rangle = \langle O(n^2), O(1)\rangle</script></b>
<br />
We can use dynamic programming to compute all the ranges. Given that we know the minimum <script type="math/tex">m</script> to a range <script type="math/tex">A[i,...j]</script>, the solution to the range <script type="math/tex">A[i,...j+1]</script> is just <script type="math/tex">min(m, A[j+1])</script>.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="kt">int</span> <span class="n">dp</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">=</span><span class="p">{...}</span>
    <span class="c1">// given the minimum to range dp[i,j-1], </span>
	<span class="c1">// the minimum to range [i,j+1] = min(dp[i,j-1],a[j])</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// for range i..j</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Therefore, <script type="math/tex">p(n) = O(n^2)</script>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>3.4 Algorithm 4: Block Decomposition, <script type="math/tex">\langle p(n), q(n)\rangle = \langle O(n), O(\sqrt{n})\rangle</script></b><br /></p>

<p><img src="http://localhost:4000/assets/rmq-block.png" alt="my photo" /></p>

<p><i>Approach:</i><br />
We can split the input into <script type="math/tex">O(n/b)</script> blocks of block size <script type="math/tex">b</script> and compute the minumum in each block.<br /></p>

<p><i>Preprocessing Time:</i><br />
We need to find the minimum for each block. Time to find the minimum for all blocks is <script type="math/tex">p(n) = n/b*b = O(n)</script>. <br /></p>

<p><i>Query Time:</i><br />
Given indices <script type="math/tex">i</script> and <script type="math/tex">j</script>.<br />
(1) We find the minimum for the internal blocks between <script type="math/tex">i</script> and <script type="math/tex">j</script> in time <script type="math/tex">O(n/b)</script>.<br />
(2) We need to look at possibly all the elements in the two outer blocks. This can be done in time <script type="math/tex">O(2b)=O(b)</script>.<br /></p>

<p>Therefore, <script type="math/tex">q(n) = O(b + (n/b))</script>:</p>

<p><i>What is the optimal block size?</i><br />
We can take the derivative of <script type="math/tex">b + n/b</script> to find the value that minimizes <script type="math/tex">b</script>. This value is <script type="math/tex">b = \sqrt{n}</script>. Therefore, the query time is <script type="math/tex">q(n) = O(b + (n/b)) = O(\sqrt{n} + (n/\sqrt{n})) = O(\sqrt{n})</script></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++">    <span class="c1">// given that we computed each block's minimum</span>
    <span class="c1">// given indices i and j, we can do something like this</span>
    <span class="kt">int</span> <span class="n">block_i</span> <span class="o">=</span> <span class="n">i</span><span class="o">/</span><span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">block_j</span> <span class="o">=</span> <span class="n">j</span><span class="o">/</span><span class="n">b</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>

    <span class="c1">// search internal blocks</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">block_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">block_j</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">block</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// search elements in the outer blocks</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">block_i</span><span class="o">*</span><span class="n">b</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">block_i</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">k</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">block_j</span><span class="o">*</span><span class="n">b</span><span class="p">);</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">block_j</span><span class="o">*</span><span class="n">b</span><span class="o">+</span><span class="n">b</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">m</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d  "</span><span class="p">,</span> <span class="n">min</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>3.5 Algorithm 5: Sparse Tables, <script type="math/tex">\langle p(n), q(n)\rangle = \langle O(n\log(n)), O(1)\rangle</script></b><br /></p>

<p><img src="http://localhost:4000/assets/rmq-sparse-main.png" alt="my photo" /></p>

<p>Going back to the dynamic programmnig solution. Instead of computing all ranges, we can instead compute a specific set of ranges. How? For each index, we compute the minimum for the ranges
<br /></p>
<div center=""> 
$$
\begin{align*}
\{i,i+2^0\}, \{i,i+2^1\}, \{i,i+2^2\}, ..., \{i,i+2^k\}
\end{align*}
$$
</div>
<p>So for the array above we will have the following minimums: 
<br /></p>

<p><img src="http://localhost:4000/assets/rmq-sparse.png" alt="my photo" /></p>

<p>Each Entry, <script type="math/tex">M[i,j]</script> represents the minimum for the range <script type="math/tex">\{i,i+2^j\}</script>. Since we’re computing <script type="math/tex">n\log(n)</script> ranges, therefore, this table has size <script type="math/tex">O(nlogn)</script>. We can further use dynamic programmnig to fill this table out. 
<br />
<br />
<i>Dyanmic Programming</i>
<br />
Notice that any region can be divided into two regions. The intuition is that since we’re computing the minimum for ranges that are powers of 2, then any region of size <script type="math/tex">2^k</script> can be divided into two regions of size <script type="math/tex">2^{k-1}</script> which we compute first. In the example below, we want to find the minimum for the gray range that starts at <script type="math/tex">i</script> and of size <script type="math/tex">2^j</script>. To do so, we divide the range into the blue and yellow regions, each of size <script type="math/tex">2^{j-1}</script>. The blue region is just <script type="math/tex">M[i,j-1]</script> and the yellow region is just <script type="math/tex">M[i+2^{j-1},j-1]</script>
<br />
<img src="http://localhost:4000/assets/rmq-sparse-range.png" alt="my photo" />
<br />
Therefore, the recursive formula to compute <script type="math/tex">M[i,j]</script> is:</p>
<div center="">
$$
 M[i,j] = \left\{\begin{array}{@{}lr@{}}
        M[i,j-1] &amp; \text{if }M[i,j-1] \leq M[i+2^{j-1},j-1]\\
        M[i+2^{j-1}, j-1]                       &amp; \text{otherwise} 
        \end{array}\right\}
$$
</div>

<p>We can use something similar to this to compute the values based on the recurrence above</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">preprocess_sparse</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">LOGMAX</span><span class="p">])</span> <span class="p">{</span> <span class="c1">// O(nlog(n))</span>
    <span class="c1">// 2^0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">lg</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>

    <span class="c1">// for each power of 2</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">lg</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// fill each row</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">))][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br /></p>

<p><i>Preprocessing Time:</i><br />
Notice that for each index, we’re computing <script type="math/tex">\log{n}</script> ranges. Therefore, the total preprocessing time <script type="math/tex">p(n) = O(n\log(n))</script>.</p>

<p><i>Query Time:</i><br /></p>

<p><img src="http://localhost:4000/assets/rmq-sparse-query.png" alt="my photo" />
<br />
Given indices <script type="math/tex">i</script> and <script type="math/tex">j</script>:<br />
(1) We know the number of elements in the range <script type="math/tex">\{i,j\}</script> is <script type="math/tex">j-i+1</script>. We can then find the largest block of size <script type="math/tex">2^k</script> that fits in that range. We can simply take the log of <script type="math/tex">j - i + 1</script> to get <script type="math/tex">k</script>. This is done in <script type="math/tex">O(1)</script> time. <br />
<br />
(2) We can now divide the range into two possibly overlapping regions, <script type="math/tex">\{i, i+2^k-1\}</script> which is <script type="math/tex">M[i][k]</script> and <script type="math/tex">\{j-2^k+1, j\}</script> which is <script type="math/tex">M[j-2^k+1][k]</script>. We can return the minimum of the two ranges. The total time is therefore <script type="math/tex">O(1)</script>.
<br />
This code just tests all possible ranges:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">test_sparse</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">M</span><span class="p">[</span><span class="n">MAX</span><span class="p">][</span><span class="n">LOGMAX</span><span class="p">];</span>
    <span class="n">preprocess_sparse</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>

    <span class="c1">// query time</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// given indices i and j</span>
            <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">log2</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\t</span><span class="s">"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="n">M</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">k</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">k</span><span class="p">]));</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br /></p>

<!------------------------------------------------------------------------------------>
<hr />

<p><br />
<b>6 Detailed Implementation:</b> <br />
https://github.com/strncat/algorithms-and-data-structures/blob/master/rmq/rmq.cpp</p>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br /></p>


  </div><a class="u-url" href="/jekyll/update/2019/03/22/rmq.html" hidden></a>
</article>

		
	 
    	 
		 
		 
      </div>
	  
	  
	  
	 
    </main>
	
	
	 

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
