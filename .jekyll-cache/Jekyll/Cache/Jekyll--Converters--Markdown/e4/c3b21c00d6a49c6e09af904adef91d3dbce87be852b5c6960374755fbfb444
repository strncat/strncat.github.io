I"µB<!------------------------------------------------------------------------------------>
<h4><b>Convexity</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/conv-0.png" width="100%" class="center" /></p>
<p>A set of points $S$ is convex if for any two points $a \in S$ and $b \in S$, then the line segment connecting these two points is also in $S$ ($\overline{ab} \subseteq S$). A convex polygon is a polygon that is the boundary of a convex set. The left figure is a convex polygon while the right figure is not per our definition.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Convex Hull</b></h4>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/conv-1.png" width="70%" class="center" /></p>
<p>The convex hull of a set $S={p_1,p_2,‚Ä¶,p_n}$ is the set that contains all the combinations of the points in the $S$,</p>
<div>
$$
\begin{align*}
conv(S) = \{ \sum_{i=1}^{n} \lambda_i p_i | \sum_{i=1}^{n} \lambda_i = 1 \text{ and } \lambda_i \geq 0 \text{ for all $i$} \}
\end{align*}
$$
</div>
<p>We can also define the convex hull of $S$ to be the smallest convex set that contains all the points in $S$ which also implies the definition that the convex hull of $S$ is the intersection of all convex sets containing $S$.</p>
<div>
$$
\begin{align*}
conv(S) = \text{ Intersection of all convex sets containing $S$ }
\end{align*}
$$
</div>
<p>In the figure above for example, the yellow, green and pink sets are all convex sets that contain $S$ but the smallest one is the pink one which is also the intersection of all three. Why does this definition matter? there are infinitely many convex sets that will contain all the points in $S$. It turns out that this definition also works for a special kind of convex sets, called half-planes.</p>
<div>
$$
\begin{align*}
conv(S) = \text{ Intersection of all "half planes" containing $S$ }
\end{align*}
$$
</div>
<p>This result is helpful in (TODO: revisit this part of the lecture)
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Finding the Convex Hull</b></h4>
<p>Finding the convex hull is a classic computatioal geometry problem and many algorithms have been developed to solve it. Next, we discuss one of the simplest algorithms that is used to find the convex hull of a set of points.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Jarvis's March (Gift Wrapping Algorithm)</b></h4>
<p>Jarvis‚Äôs March is similar to Selection Sort. In each iteration of Selection Sort, we pick the smallest element in the array and then move it to the front. Once we‚Äôre done, we‚Äôll have a sorted array. In Jarvis‚Äôs algorithm, we find the next vertex in the hull by selecting the vertex that is the right most vertex from the current hull vertex in each iteration.
<br />
<br />
Initially, we will pick the a vertex that we know will be in the hull. We can pick the left most vertex or the bottom most vertex or any vertex where all the points will be on one side (half plane). Let‚Äôs pick the left most vertex and let it be $p_0$. See below.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-1.png" width="60%" class="center" /></p>
<p>Next, we will iterate over all the remaining points and pick the right most vertex to be the next vertex in the convex hull.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2.png" width="60%" class="center" /></p>
<p>How do we determine the right most vertex relative to $p_0$? Previously we derived an expression to find out whether a point $r$ is on the left or right of the line that goes through two given points $p$ and $q$ (see the post: Orientation of Three Points). We can wrap the expression in a function: (we also used this in triangulating polygons. See Triangulation (Finding a Diagonal).</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// determines if r is on the left of the line pq</span>
<span class="kt">int</span> <span class="nf">direction</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="p">(</span><span class="n">q_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">r_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">r_x</span><span class="o">-</span><span class="n">p_x</span><span class="p">)(</span><span class="n">q_y</span><span class="o">-</span><span class="n">p_y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// anti-clockwise</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="c1">// clockwise</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// collinear</span>
<span class="p">}</span></code></pre></figure>

<p>But which three points will we compare in the above figure (step 2)? We then will maintain two variables. One tracks the current ‚Äúbest‚Äù or ‚Äúright most‚Äù vetex call it $candidate$ (green shaded vertex below) and a variable to track the remaining vertices that we‚Äôre testing. For each remaining vertex $i$. We will call $direction(p_0, candidate, i)$ meaning is vertex $i$ on the left or right of the line that goes through $\overline{p_0, candidate}$. If the test returns -1, then know that $i$ is the new right vertex and so we assign $candidate = i$. The candidate here is the green shaded vertex.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2b.png" width="80%" class="center" /></p>
<p>We will use this test for the all vertices until we arrive at the right most vertex.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="n">the</span> <span class="n">remaining</span> <span class="nf">vertices</span> <span class="p">(</span><span class="n">not</span> <span class="n">in</span> <span class="n">the</span> <span class="n">hull</span> <span class="n">yet</span><span class="p">)</span><span class="o">:</span>
    <span class="c1">// if point i is further right than the current candidate, then we'll pick it</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">orientation</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="n">hull_point</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">hull_candidate</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hull_candidate</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-2a.png" width="65%" class="center" /></p>
<p>We repeat this again process again but this time we will find the vertex that is right most relative to $p_1$</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-3.png" width="65%" class="center" /></p>
<p>When do we terminate? we terminate when the next right most vertex is the first vertex that we started with!</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/geometry/convex-hull/step-4.png" width="65%" class="center" /></p>
<p><br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Implementation</b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">knapsack_01</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">item</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">bag</span><span class="p">,</span> <span class="kt">int</span> <span class="n">W</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">K</span><span class="p">[</span><span class="mi">100</span><span class="p">][</span><span class="mi">100</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="c1">// base case k[0][j] = 0, K[i][0] = 0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">w</span> <span class="o">&lt;=</span> <span class="n">W</span><span class="p">;</span> <span class="n">w</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each weight w</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each item i:</span>
            <span class="c1">// case 1: item i is not in the optimal solution</span>
            <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="c1">// case 2: item i is in the optimal solution</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">K</span><span class="p">[</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span> <span class="o">+</span> <span class="n">K</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// print items</span>
    <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">res</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">cur_w</span> <span class="o">=</span> <span class="n">W</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cur_v</span> <span class="o">=</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">res</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cur_v</span> <span class="o">!=</span> <span class="n">K</span><span class="p">[</span><span class="n">cur_w</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">"%d %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">,</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>
            <span class="n">cur_v</span> <span class="o">-=</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">v</span><span class="p">;</span>
            <span class="n">cur_w</span> <span class="o">-=</span> <span class="n">bag</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">w</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Optimal value = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()]);</span>
    <span class="k">return</span> <span class="n">K</span><span class="p">[</span><span class="n">W</span><span class="p">][</span><span class="n">bag</span><span class="p">.</span><span class="n">size</span><span class="p">()];</span>
<span class="p">}</span></code></pre></figure>
:ET