I"a'<p><img src="http://localhost:4000/assets/graphs/cycle/1.png" alt="my photo" />
We are given a graph \(G = (V,E)\) and we want to know if there exists a cycle in \(G\). 
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Undirected Graphs&lt;/h3&gt;
This is extremely simple. We already keep track of nodes visited so far. If it happens during our search that we come across a visited node then we're done! there must exists a cycle otherwise, we won't ever re-visit any vertex in $$G$$. 

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">bool</span> <span class="nf">bfs</span><span class="p">(</span><span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">graph</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>
    <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">visited</span><span class="p">(</span><span class="n">graph</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
                <span class="n">visited</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="c1">// CYCLE</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<br />
<!----------------------------------------------------------------------------------->
<h4><b>Directed Graphs&lt;/h3&gt;
Suppose we apply the earlier idea used in undirected graphs. We traverse the nodes and if we see a node we've seen before, we conclude that we found a cycle. Let's take the graph above and start a DFS pass from the node $$a$$ below:

![my photo](http://localhost:4000/assets/graphs/cycle/2.png)

From $$a$$ we visit $$c$$. Node $$c$$ doesn't have neighbors so we mark its finish time and then we go back to $$a$$. We next visit $$b$$ and mark its start time. From $$b$$, we see $$c$$ again! is this a cycle? NO. The idea fails here.
<br />
<br />
In directed graph we instead have three types of nodes. 
- A node that hasn't been discovered yet (we didn't mark its start time yet). Node $$e$$ is one example above. Let's color this node black.
- A node that has been discovered (we marked its start time) but it hasn't been processed yet (we didn't mark its finish time). Let's color this node gray.
- A node that has been processed. We marked its start time and its finish time. Let's color this node white.
<br />
<br />
When will a directed cycle happen? when we re-discover a gray node! below is a continuation of the traversal that started from node $$a$$. We discover nodes $$b, e, f$$ and $$d$$. From $$d$$ we re-discover $$e$$ but $$e$$ has already been discovered because it's gray! This means we have a cycle. 
![my photo](http://localhost:4000/assets/graphs/cycle/3.png)

<!--
Let's go back to the moment when we marked $$e$$'s start time and we saw $$c$$. What does this mean for $$e$$ and $$c$$? Let's recall that the paranthesis theorem (CLRS) says that for any pair of nodes, in this case $$c$$ and $$e$$, one of three cases can happen:
- the intervals [c.start_time, c.finish_time] and [e.start_time, e.finish_time] are disjoint and neither $$c$$ or $$e$$ is a descendant of the other in the depth-first forest. This doesn't apply as the intervals are not disjoint.

- the interval [c.start_time, c.finish_time] is contained within the interval [e.start_time, e.finish_time] and $$c$$
is a descendant of $$e$$ in the depth-first tree. This doesn't apply either (above graph).

- the interval [e.start_time, e.finish_time] is contained within the interval [c.start_time, c.finish_time] and $$e$$ is a descendant of $$c$$ in the depth-first tree. Aha! this one applies!
-->

The following code implements this idea which is just a small modification to a typical depth search first traversal.


<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">,</span> <span class="kt">int</span> <span class="n">v</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">gray</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">white</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">dfs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">color</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">color</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="n">gray</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// CYCLE</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// we are done with the node for good</span>
    <span class="n">color</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">black</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<br />
<!----------------------------------------------------------------------------------->
<h4><b>Correctness Proof&lt;/h3&gt;
TODO
<br />
<br />
<!----------------------------------------------------------------------------------->
<h4><b>Implementation&lt;/h3&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/cycles
<br />
<br />
<!----------------------------------------------------------------------------------->
<h4><b>References&lt;/h3&gt;
CLRS
<br />
<br />

</b></h4></b></h4></b></h4></b></h4></b></h4>
:ET