I"ÖJ<svg width="700" height="300" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="286.5" cy="93.5" rx="30" ry="30" />
	<text x="282.5" y="99.5" font-family="Times New Roman" font-size="20">a</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="164.5" cy="234.5" rx="30" ry="30" />
	<text x="160.5" y="240.5" font-family="Times New Roman" font-size="20">s</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="505.5" cy="93.5" rx="30" ry="30" />
	<text x="500.5" y="99.5" font-family="Times New Roman" font-size="20">b</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="388.5" cy="234.5" rx="30" ry="30" />
	<text x="384.5" y="240.5" font-family="Times New Roman" font-size="20">c</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="622.5" cy="234.5" rx="30" ry="30" />
	<text x="619.5" y="240.5" font-family="Times New Roman" font-size="20">t</text>
	<polygon stroke="black" stroke-width="1" points="184.13,211.813 266.87,116.187" />
	<polygon fill="black" stroke-width="1" points="266.87,116.187 257.855,118.965 265.417,125.508" />
	<text x="230.5" y="184.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="304.084,117.807 370.916,210.193" />
	<polygon fill="black" stroke-width="1" points="370.916,210.193 370.279,200.781 362.176,206.642" />
	<text x="343.5" y="156.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="194.5,234.5 358.5,234.5" />
	<polygon fill="black" stroke-width="1" points="358.5,234.5 350.5,229.5 350.5,239.5" />
	<text x="271.5" y="255.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="316.5,93.5 475.5,93.5" />
	<polygon fill="black" stroke-width="1" points="475.5,93.5 467.5,88.5 467.5,98.5" />
	<text x="391.5" y="114.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="524.657,116.587 603.343,211.413" />
	<polygon fill="black" stroke-width="1" points="603.343,211.413 602.082,202.064 594.386,208.45" />
	<text x="548.5" y="184.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="418.5,234.5 592.5,234.5" />
	<polygon fill="black" stroke-width="1" points="592.5,234.5 584.5,229.5 584.5,239.5" />
	<text x="500.5" y="255.5" font-family="Times New Roman" font-size="20">6</text>
	<polygon stroke="black" stroke-width="1" points="407.657,211.413 486.343,116.587" />
	<polygon fill="black" stroke-width="1" points="486.343,116.587 477.386,119.55 485.082,125.936" />
	<text x="452.5" y="184.5" font-family="Times New Roman" font-size="20">4</text>
</svg>
<p>Given a graph $G=(E,V)$ and a source node $s$. Dijkstra finds the shortest weighted path from $s$ to every other node in the graph. The graph however needs to only have non-negative edge weights. In the above graph the shortest path between nodes $s$ and $t$ is $s \rightarrow a \rightarrow b \rightarrow t$. Dikstra is extremely fast. It can run in amortized time $O(n\log(n) + m)$ if we implement Dijkstra with a fiponacci heap. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>How does Dijkstra work? Using the above example, we maintain a set of <i>not-sure</i> nodes ${a, b, c, t, s}$. We let $d[v]$ be the current distance from $s$ to $v$. Initially we let $d[v] = \infty$ for any node in <i>not-sure</i> and $d[s] = 0$ for the source node only.
<br />
<br />
In the first iteration of Dijkstra, we extract the node with the minimum distance in the <i>not-sure</i> list. This node is $s$. We then update the distance of each neighbor based on the following,</p>
<div center="">
$$
\begin{align*}
d[u] &amp;= min(d[u], d[u]+weight(s,u))
\end{align*}
$$
</div>
<p>After updating each neightbor, we mark $s$ as sure. We should see the following values after this iteration.</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>s</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract $s$)</td>
      <td>0</td>
      <td>2</td>
      <td>$\infty$</td>
      <td>1</td>
      <td>$\infty$</td>
    </tr>
  </tbody>
</table>

<p><i>Iteration 1</i><br />
We extract the node with the minimum distance again from the not-sure list. This time we extract $c$. We update all the neighbors and at the end of this iteration, we mark $c$ as sure.</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>s</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract $s$)</td>
      <td>0</td>
      <td>2</td>
      <td>$\infty$</td>
      <td>1</td>
      <td>$\infty$</td>
    </tr>
    <tr>
      <td>1 (extract $c$)</td>
      <td>0</td>
      <td>2</td>
      <td>5</td>
      <td>1</td>
      <td>7</td>
    </tr>
  </tbody>
</table>

<p><i>Final iteration</i><br />
We continue the same process. We extract the node \(a\) and update its neighbors. We then mark it as sure, meaning that the distance from node \(s\) to node \(a\) is 2 and will not change again. We next extract \(b\) and update the neighbors again. We then mark \(b\) as sure. We finally extract \(t\) which has no out-going edges. At the end of the algorithm, we see that we generated all the shortest paths from $s$ to all the other nodes in the graph.</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>s</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>t</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract \(s\))</td>
      <td>0</td>
      <td>2</td>
      <td>\(\infty\)</td>
      <td>1</td>
      <td>\(\infty\)</td>
    </tr>
    <tr>
      <td>1 (extract \(c\))</td>
      <td>0</td>
      <td>2</td>
      <td>5</td>
      <td>1</td>
      <td>7</td>
    </tr>
    <tr>
      <td>2 (extract \(a\))</td>
      <td>0</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
      <td>7</td>
    </tr>
    <tr>
      <td>3 (extract \(b\))</td>
      <td>0</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
      <td>5</td>
    </tr>
    <tr>
      <td>4 (extract \(t\))</td>
      <td>0</td>
      <td>2</td>
      <td>4</td>
      <td>1</td>
      <td>5</td>
    </tr>
  </tbody>
</table>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Pseudocode</b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Set</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">to</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span>
<span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">infinity</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">V</span>
<span class="n">d</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">there</span> <span class="n">are</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span> <span class="n">nodes</span> <span class="p">{</span>
	<span class="n">pick</span> <span class="n">the</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span> <span class="n">node</span> <span class="n">u</span> <span class="n">with</span> <span class="n">the</span> <span class="n">smallest</span> <span class="n">estimate</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">].</span>
	<span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="n">v</span> <span class="n">of</span> <span class="n">u</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// It is cheaper to reach v from u than the current path</span>
			<span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">Mark</span> <span class="n">u</span> <span class="n">as</span> <span class="n">sure</span>
	<span class="c1">// at this point we know that d[u] = distance(s,v) (proof below)</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<h4><b>Extracting the path</b></h4>
<p>To reconstruct the actuall path take, we just maintain a pointer to the parent node. We simply keep an additional array \(p\) and modify the update step as follows:
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">V</span>
<span class="k">while</span> <span class="n">there</span> <span class="n">are</span> <span class="n">not</span><span class="o">-</span><span class="n">sure</span> <span class="n">nodes</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
		<span class="c1">// we maintain a parent link</span>
		<span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/dijkstra/dijkstra.cpp">Full Implementation on Github</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Proof of Correctness</b></h4>
<p>Why does Dijkstra work? We need to prove two important claims in order to prove that Dijkstra is correct.
<br /></p>

<table>
  <tbody>
    <tr>
      <td>Claim 1: For all \(v\), \(d[v] \geq d(s,v)\). That is, \(d[v]\) will never be an underestimate for any node \(v\).</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> <br />
<b>Inducive Hypothesis:</b> After \(t\) iterations, \(d[v] \geq d(s,v)\) for all \(v\). <br /></p>

<p><b>Base Case:</b> After 0 iterations, the algorithms sets \(d[s]= 0 = d(s,s)\) and sets \(d[v]\) to \(\infty\) for all \(v \neq s\) and therefore we have \(d[v] \geq d(s,v)\), as required.<br /></p>

<p><b>Inductive Step:</b> Assume that after \(t\) iterations, \(d[v] \geq d(s,v)\) for all \(v\). We will prove the inequality holds after \(t+1\) iterations. At iteration \(t+1\), we pick the minimum not-sure node \(u\) and then update all neighbors \(v\) such that:
\(d[v] = min(d[v], d[u]+w(u,v))\). To see that \(d[v] \geq d(s,v)\), notice that: <br />
(1) \(d[v] \geq d(s,v)\) by the inductive hypothesis. <br />
(2) \(d[u] + w(u,v) \geq d(s,v)\). This is because we know that \(d(s,v) \leq d(s,u) + d(u,v)\) and we also know that \(d[u] \geq d(s,u)\) by the inductive hypothesis. Therefore, \(d(s,v) \leq d[u] + d(u,v)\).</p>

<p><b>Conclusion:</b> 
After the algorithm terminates, we have \(d[v] \geq d(s,v)\) for all $v$ in $V$, as required. \(\blacksquare\)
<br /></p>

<table>
  <tbody>
    <tr>
      <td>Claim 2: When a vertex \(u\) is marked sure, \(d[u] = d(s,u)\)</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> <br />
<b>Inducive Hypothesis:</b> When the tâth vertex \(v\) is marked as sure, \(d[v] = d(s,v)\). <br /></p>

<p><b>Base Case:</b> When the first vertex \(s\) is marked sure, we know that \(d[s]=0=d(s,s)\), as required. <br /></p>

<p><b>Inductive Step:</b> Suppose weâre about to mark vertex \(u\) as sure, and assume every vertex already marked as sure has \(d[v]=d(s,v)\). We will show that \(d[u]=d(s,u)\). Consider a shortest path from \(s\) to \(u\).</p>

<svg width="800" height="200" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="101.5" cy="106.5" rx="30" ry="30" />
	<text x="97.5" y="112.5" font-family="Times New Roman" font-size="20">s</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="366.5" cy="122.5" rx="30" ry="30" />
	<text x="362.5" y="128.5" font-family="Times New Roman" font-size="20">z</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="235.5" cy="65.5" rx="30" ry="30" />
	<ellipse stroke="black" stroke-width="1" fill="none" cx="516.5" cy="65.5" rx="30" ry="30" />
	<text x="510.5" y="71.5" font-family="Times New Roman" font-size="20">z'</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="645.5" cy="106.5" rx="30" ry="30" />
	<text x="640.5" y="112.5" font-family="Times New Roman" font-size="20">u</text>
	<polygon stroke="black" stroke-width="1" points="130.187,97.723 206.813,74.277" />
	<polygon fill="black" stroke-width="1" points="206.813,74.277 197.7,71.837 200.626,81.399" />
	<polygon stroke="black" stroke-width="1" points="394.544,111.843 488.456,76.157" />
	<polygon fill="black" stroke-width="1" points="488.456,76.157 479.202,74.324 482.754,83.672" />
	<polygon stroke="black" stroke-width="1" points="263.009,77.469 338.991,110.531" />
	<polygon fill="black" stroke-width="1" points="338.991,110.531 333.65,102.754 329.661,111.923" />
	<polygon stroke="black" stroke-width="1" points="545.091,74.587 616.909,97.413" />
	<polygon fill="black" stroke-width="1" points="616.909,97.413 610.8,90.225 607.771,99.755" />
</svg>
<p>We want to prove that \(d[u]=d(s,u)\). Suppose toward a contradiction that our claim is not true and that \(u\) has the wrong estimate. Also suppose that node \(z\) is the last node with a correct estimate before node \(u\) and that vertex \(z'\) is the vertex after \(z\) in the shortest path above. We can see that <br /></p>
<div center="">
$$ d[z] = d(s,z) \leq d(s,u) \leq d[u] $$ <br />
</div>
<p>This is because we assumed \(z\) has a correct estimate and we also know that \(d(s,z) \leq d(s,u)\) because first, sub-paths of shortest paths are shortest paths (can be proved by contradiction). Second, the distance from \(z\) to \(u\) is non-negative because all edges have non-negative weights and therefore \(d(s,z) \leq d(s,u)\). The last part \(d(s,u) \leq d[u]\) follows from claim 1!
<br />
<br />
So now, we have \(d[z] \leq d[u]\). There are two cases: <br />
Case 1: If \(d[z] = d[u]\). In this case, since we assumed \(z\) has a correct estimate then \(u\) must have a correct estimate and weâre done! <br />
Case 2: If \(d[z] &lt; d[u]\). In this case, since \(u\) was the smallest not-sure node, then \(z\) must be sure. Otherwise we would have picked \(z\) as the smallest not-sure node. Since \(z\) is sure then we must have updated \(z\)âs neighbors. In particular, we know that \(z'\) comes after \(z\) so,</p>
<div center="">
$$
\begin{align*}
d[z'] &amp;\leq d[z] + w(z,z') \\
&amp;= d(s,z) + w(z,z') \ \ \text{This is because } z \text{ is a sure node so by IH } d[z] = d(s,z) \\ 
&amp;= d(s,z') \ \ \text{ Subpaths of shortest paths are shortest paths} \\
&amp;\leq d[z'] \ \ \text{ By claim 1}
\end{align*}
$$
</div>
<p>This means that \(z'\) has a correct estimate. This is a contradiction because we assumed that \(z\) is the last node with a good estimate and therefore, \(u\) must have the correct estimate, as required.</p>

<p><b>Conclusion:</b> 
After the last node is marked sure, we have \(d[v] = d(s,v)\) for all $v$ in $V$, as we wanted to show. \(\blacksquare\)
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Running Time</b></h4>
<p>What are we doing in this algorithm? For each vertex in the not-sure list, we <br />
(1) find the minimum vertex. <br />
(2) remove that vertex. <br />
(3) update all neighbors with lower estimates if possible.<br />
<br />
Therefore we see that if we have \(n\) vertices and \(m\) edges:</p>
<div center="">
$$
\begin{align*}
TotalTime &amp;= \sum_{u \in V} \big\{ T(findMin) + \big(\sum_{v \in u.neighbors} T(updateKey)\big) + T(removeMin) \big\} \\
&amp;= n(T(findMin) + T(removeMin)) + m(T(updateKey))

\end{align*}
$$
</div>
<p>Now it is clear that it really depends on how we implement the list that holds the not-sure nodes. Letâs consider different data structures</p>
<ul>
  <li>Arrays
    <ul>
      <li>findMin will run in \(O(n)\)</li>
      <li>RemoveMin will run in \(O(n)\)</li>
      <li>UpdateKey will run in \(O(1)\)<br />
Therefore, the total time will be \(O(n(2n) + m) = O(n^2 + m) = O(n^2)\)</li>
    </ul>
  </li>
  <li>Red Black Tree
    <ul>
      <li>findMin will run in \(O(\log(n))\)</li>
      <li>RemoveMin will run in \(O(\log(n))\)</li>
      <li>UpdateKey will run in \(O(\log(n))\)<br />
Therefore, the total time will be \(O(n\log(n) + m\log(n)) = O((n+m)\log(n))\). <br />
Notice here, if the graph is dense, meaning that \(m=O(n^2)\), then this is worse than arrays! if itâs sparse, then itâs better.</li>
    </ul>
  </li>
  <li>Fibonacci Heaps
    <ul>
      <li>findMin will run in \(O(1)\), amortized time.</li>
      <li>RemoveMin will run in \(O(\log(n))\), amortized time.</li>
      <li>UpdateKey will run in \(O(1)\), amortized time.<br />
Therefore, the total time will be \(O(n\log(n) + m)\), amortized time.
<br />
<br />
<!------------------------------------------------------------------------------------></li>
    </ul>
  </li>
</ul>
<h4><b>Handling Negative Weights</b></h4>
<p>TODO!!
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="http://web.stanford.edu/class/cs161/schedule.html">CS161 Stanford</a>
<br />
<br /></p>

:ET