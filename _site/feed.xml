<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-01T16:37:34-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>Hello.</subtitle><entry><title type="html">Greedy: Maximum Activity Selection</title><link href="http://localhost:4000/jekyll/update/2019/07/01/activity-selection.html" rel="alternate" type="text/html" title="Greedy: Maximum Activity Selection" /><published>2019-07-01T07:01:36-07:00</published><updated>2019-07-01T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/01/activity-selection</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/01/activity-selection.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
Problems with greedy solutions might have the simplest solutions however they are really hard to reason about and therefore, greedy algorithms are generally taught toward the end of an algorithms class. One the of classic problems with greedy solutions is the activity selection problem. In this problem we are given a list of activities, each with a start time &lt;script type=&quot;math/tex&quot;&gt;t_i&lt;/script&gt; and a finish time &lt;script type=&quot;math/tex&quot;&gt;f_i&lt;/script&gt; and we would like to pick activities such that the total number of activities is maximized with the constraint that no two activities can overlap.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Greedy Solution&lt;/b&gt;&lt;br /&gt;
As we said earlier, typically greedy solutions are super straight forward and easy. For the activities selection problem, one approach that works is to simply select the activities with the earliest finish time.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;&lt;br /&gt;
Suppose we have the following activities:
&lt;img src=&quot;http://localhost:4000/assets/activities.png&quot; alt=&quot;my photo&quot; /&gt;
Based on our solution, we will pick &lt;script type=&quot;math/tex&quot;&gt;A1&lt;/script&gt; first. We will skip &lt;script type=&quot;math/tex&quot;&gt;A2&lt;/script&gt; since it violates the condition of not having overlapped activities. We will then go on to pick &lt;script type=&quot;math/tex&quot;&gt;A3&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;A5&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;A6&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Algorithm&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// re-do it again&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;select_maximum_activities&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;custom_sort_by_finish_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;act&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;act&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finish_time&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;act&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
		&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;picked&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
This is the most interesting part of any greedy algorithm! why does it work? To prove the correctness of greedy algorithms, we want to prove that as we select activities, we are &lt;b&gt; not ruling out &lt;/b&gt; the optimal solution. So each decision we make, doesn’t affect the our ability of reaching out an optimal solution, which means that at the end we must have an optimal solution.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Now, this should sound very familiar, we have a base case where we start with an empty set of activities and then we want to prove that each selection we make doesn’t rule out an optimal solution. What proof method should we use? of course, Induction.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Proof By Induction:&lt;/b&gt;&lt;br /&gt;
&lt;b&gt;Inductive Hypothesis: &lt;/b&gt; After adding the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th activity, there is an optimal solution that extends our current solution.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case:&lt;/b&gt; When we add the zero’th activity, there exists an optimal solution that extends the current solution which contains no activities yet.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Inductive Step:&lt;/b&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; be a natural number and suppose we’re about to add the &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;‘th activity and that our inductive hypothesis holds for &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt;, meaning that we didn’t rule out an optimal solution yet and that there is some optimal solution &lt;script type=&quot;math/tex&quot;&gt;T^*&lt;/script&gt; that extends the &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt; choices we’ve made so far. We’re about to select our &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;‘th activity. 
&lt;br /&gt;&lt;br /&gt;
Our greedy algorithm picks the next activity with the earliest finish time such that it doesn’t overlap with any of the &lt;script type=&quot;math/tex&quot;&gt;k-1&lt;/script&gt; activities we’ve selected so far. Let our selection be &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; for some natural number &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt;. There are two cases &lt;br /&gt;&lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; is in the optimal solution so &lt;script type=&quot;math/tex&quot;&gt;a_j \in T^*&lt;/script&gt;. yay, we didn’t rule out the optimal solution and we’re done! &lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; is not in the optimal solution so &lt;script type=&quot;math/tex&quot;&gt;a_j \not\in T^*&lt;/script&gt;. In this case, some other activity was selected instead of &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt;. Let that activity be &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt;. Let’s consider swapping &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt; to create a new set of activities, &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
We claim that &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; is allowed and optimal. First, we know that &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; has a smaller finish than &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt; because our greedy algorithm selects the activity with the earliest finish time. Therefore, &lt;script type=&quot;math/tex&quot;&gt;a_j&lt;/script&gt; doesn’t conflict with anything chosen after &lt;script type=&quot;math/tex&quot;&gt;a_k&lt;/script&gt;. From this we see that &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; also has the same number of activities as &lt;script type=&quot;math/tex&quot;&gt;T^*&lt;/script&gt; and therefore, we can conclude that &lt;script type=&quot;math/tex&quot;&gt;T^*&lt;/script&gt; is optimal.&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Conclusion:&lt;/b&gt;
After adding the last activity, we will have an optimal solution that extends our current choices. Our current choices or solution is the only solution that extends the current solution and therefore, our current solution is optimal. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time:&lt;/b&gt; &lt;br /&gt;
If we need to sorted then it will be &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt;. If it’s sorted then we’re only doing a linear scan of activities and therefore, the running time is &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Detailed Implementation:&lt;/b&gt; &lt;br /&gt;
-
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction Problems with greedy solutions might have the simplest solutions however they are really hard to reason about and therefore, greedy algorithms are generally taught toward the end of an algorithms class. One the of classic problems with greedy solutions is the activity selection problem. In this problem we are given a list of activities, each with a start time and a finish time and we would like to pick activities such that the total number of activities is maximized with the constraint that no two activities can overlap. 2 Greedy Solution As we said earlier, typically greedy solutions are super straight forward and easy. For the activities selection problem, one approach that works is to simply select the activities with the earliest finish time. 3 Example Suppose we have the following activities: Based on our solution, we will pick first. We will skip since it violates the condition of not having overlapped activities. We will then go on to pick , and . 4 Algorithm // re-do it again std::vector&amp;lt;activity&amp;gt; select_maximum_activities(std::vector&amp;lt;activity&amp;gt; a) { std::sort(a.begin(), a.end(), custom_sort_by_finish_time); std::vector&amp;lt;activity&amp;gt; picked; for act in a { if act.start_time &amp;gt;= last picked activity.finish_time { picked.push_back(act); } } return picked } 5 Proof of Correctness This is the most interesting part of any greedy algorithm! why does it work? To prove the correctness of greedy algorithms, we want to prove that as we select activities, we are not ruling out the optimal solution. So each decision we make, doesn’t affect the our ability of reaching out an optimal solution, which means that at the end we must have an optimal solution.</summary></entry><entry><title type="html">Knapsack</title><link href="http://localhost:4000/jekyll/update/2019/07/01/knapsack.html" rel="alternate" type="text/html" title="Knapsack" /><published>2019-07-01T07:01:36-07:00</published><updated>2019-07-01T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/07/01/knapsack</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/07/01/knapsack.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
The Knapsack problem is a classic example of problems that have greedy solutions. Greedy solutions are hard because it is really hard to prove that they actually work. In Knapsack, we’re given a knapsack of size &lt;script type=&quot;math/tex&quot;&gt;W&lt;/script&gt; and a list of items &lt;script type=&quot;math/tex&quot;&gt;x_i&lt;/script&gt; that each have a weight &lt;script type=&quot;math/tex&quot;&gt;w_i&lt;/script&gt; and a value &lt;script type=&quot;math/tex&quot;&gt;v_i&lt;/script&gt;. There are many variations of the Knapsack Problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack. There is also the unbounded knaspack where you have multiple/unbounded copies of each item.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;b&gt;2 Example&lt;/b&gt;&lt;br /&gt;
Suppose we have an ubounded number of tacos, each of weight 3 and value 10. We also have burritos each of weight 6 and value 14. Suppose now that we have &lt;script type=&quot;math/tex&quot;&gt;W=18&lt;/script&gt;. One simple greedy strategy is to pack as many items as possible of the best value/weight ratio. Based on this, we’ll pick 3 burritos of value &lt;script type=&quot;math/tex&quot;&gt;3*14=42&lt;/script&gt;. But this strategy doesn’t work because if you instead pack 2 burritos and 2 tacos, you’ll get the maximum value of &lt;script type=&quot;math/tex&quot;&gt;2*14+2*10=48&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.1 Algorithm (slow naive version)&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;non&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decreasing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorted&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;we&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;can&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;without&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;creating&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cycle&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2.2 Algorithm (fast, used for the remaining of these notes)&lt;/b&gt;
&lt;br /&gt;
The reason why this implementation is the standard kruskal implemenation is because we use a special data structure to maintain the forests kruskal is maintaining in the algorithm. The data structure is union-find which supports the following operations&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;makeSet(u): creates a set &lt;script type=&quot;math/tex&quot;&gt;\{u\}&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;find(u): returns the set that &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is in.&lt;/li&gt;
  &lt;li&gt;union(u,v): merge the set that &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is in with the set that &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is in.&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;edges&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;non&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decreasing&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;makeSet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;find&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;union&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MST&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;We initialize the following forests &lt;script type=&quot;math/tex&quot;&gt;\{a\}, \{b\}, \{c\}, \{d\}, \{e\}, \{f\}&lt;/script&gt;. We also sort the edges by non-decreasing weight and proceed to merge our forests. Assume the sorted order is the following: &lt;script type=&quot;math/tex&quot;&gt;\{a,b\}, \{b,f\}, \{a,f\}, \{e,d\}, \{c,e\}, \{b,c\}, \{c,f\}, \{f,e\}, \{c,d\}&lt;/script&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;i&gt;Iteration 0&lt;/i&gt;&lt;br /&gt;
The first edge to consider is either &lt;script type=&quot;math/tex&quot;&gt;\{a,b\}&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; are not in the same set, we add the edge to the MST and combine both &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Iteration 1&lt;/i&gt;&lt;br /&gt;
We next consider  &lt;script type=&quot;math/tex&quot;&gt;\{b,f\}&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; are not in the same set, we add the edge to the MST and combine both &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt;. So now we have the following forests: &lt;script type=&quot;math/tex&quot;&gt;\{a, b, f\}, \{c\}, \{d\}, \{e\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;i&gt;Iteration 2&lt;/i&gt;&lt;br /&gt;
We next consider  &lt;script type=&quot;math/tex&quot;&gt;\{a,f\}&lt;/script&gt;. Since &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; are in the same set, we don’t combine the nodes and don’t add the edge to the MST.&lt;/p&gt;

&lt;p&gt;At the end of the algorithm, the minimum spanning tree is the following tree:&lt;/p&gt;
&lt;svg width=&quot;800&quot; height=&quot;250&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;294.5&quot; cy=&quot;68.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;289.5&quot; y=&quot;74.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;498.5&quot; cy=&quot;68.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;494.5&quot; y=&quot;74.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;664.5&quot; cy=&quot;147.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;659.5&quot; y=&quot;153.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;d&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;498.5&quot; cy=&quot;218.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;494.5&quot; y=&quot;224.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;e&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;294.5&quot; cy=&quot;218.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;291.5&quot; y=&quot;224.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;f&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;137.5&quot; cy=&quot;159.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;133.5&quot; y=&quot;165.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;324.5,68.5 468.5,68.5&quot; /&gt;
	&lt;text x=&quot;391.5&quot; y=&quot;89.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;4&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;636.917,159.298 526.083,206.702&quot; /&gt;
	&lt;text x=&quot;566.5&quot; y=&quot;173.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;2&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;163.455,144.456 268.545,83.544&quot; /&gt;
	&lt;text x=&quot;220.5&quot; y=&quot;135.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;498.5,188.5 498.5,98.5&quot; /&gt;
	&lt;text x=&quot;503.5&quot; y=&quot;149.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;3&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;294.5,188.5 294.5,98.5&quot; /&gt;
	&lt;text x=&quot;299.5&quot; y=&quot;149.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;1&lt;/text&gt;
&lt;/svg&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
This first section is exaclty copied from Prim’s so I should probably just link it, instead of copy/pasting. agh
&lt;br /&gt;&lt;br /&gt;
Why does this algorithm find a minimum spanning tree? Before we can answer that, let’s define some terms and prove some lemma that will be useful in the main proof. Let &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; be the graph below and let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be the set of yellow edges in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/cut.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A &lt;b&gt;cut&lt;/b&gt; is a partition of the vertices into two non-empty parts. the red line (cut) partitions &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;\{a,b,f,e\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\{c,d\}&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;A cut &lt;b&gt;respects&lt;/b&gt; &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; if no edges in &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; cross the cut. None of the yellow edges cross the red cut.&lt;/li&gt;
  &lt;li&gt;An edge crossing the cut is called &lt;b&gt;light&lt;/b&gt; if it has the smallest weight of any edge crossing the cut. In this case, &lt;script type=&quot;math/tex&quot;&gt;\{e,d\}&lt;/script&gt; is a light edge.&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Lemma: Let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be a set of edges and consider a cut that respects &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Suppose there is an MST containing &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; be a light edge. Then there is an MST containing &lt;script type=&quot;math/tex&quot;&gt;S \cup \{u,v\}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; Let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be a set of edges and and consider a cut that respects &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; be an MST containing &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; be a light edge. There are two cases. &lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; is in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;, then we’re done. &lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; is not in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;. By the definition of MST, adding &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; will create a cycle in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;. Since the sets resulting from the cut must be non-empty. This means that we must have an edge that crosses the cut in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;. Let that edge be &lt;script type=&quot;math/tex&quot;&gt;\{x,y\}&lt;/script&gt;. Consider replacing &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; with &lt;script type=&quot;math/tex&quot;&gt;\{x,y\}&lt;/script&gt; to produce the new tree &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; is still an MST since we deleted &lt;script type=&quot;math/tex&quot;&gt;\{x,y\}&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt; has also a cost of at most the cost of &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; since {u,v} is a light edge. Therefore, &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt; is an MST which includes both &lt;script type=&quot;math/tex&quot;&gt;\{u,v\}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; which is what we wanted to show. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Theorem: Kruskal will correctly find a minimum spanning tree&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt; &lt;br /&gt;
&lt;b&gt;Inductive Hypothesis: &lt;/b&gt;After adding the &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;‘th edge, there exists an MST with the edges added so far.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;b&gt;Base Case: &lt;/b&gt; After adding the 0’th edge, there exists an MST with the edges added so far.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Inductive Step:&lt;/b&gt; Suppose the inductive hypothesis holds for &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; be the set containing the edges added so far and so there is an MST extending them by the inductive hypothesis. Kruskal adds the next edge that combines some trees &lt;script type=&quot;math/tex&quot;&gt;T_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;T_2&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. Consider the cut &lt;script type=&quot;math/tex&quot;&gt;T_1&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;V-T_1&lt;/script&gt;. This cut respects &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt;. By the Lemma above, that edge is safe to add. Therefore, there is still an MST extending the new set of edges.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Conclusion:&lt;/b&gt; After adding the &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt;‘st edge, there exists an MST with the edges added so far. At this point we have reached all vertices and the &lt;script type=&quot;math/tex&quot;&gt;n-1&lt;/script&gt; edges we have is an MST.&lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Running Time:&lt;/b&gt; &lt;br /&gt;
Assume we have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; edges. First of all, sorting the edges will take time &lt;script type=&quot;math/tex&quot;&gt;O(m\log(m)) = m\log(n^2) = O(m\log(n))&lt;/script&gt;. If radixSort can be utilized then we can do this step in time &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt;. 
&lt;br /&gt;&lt;br /&gt;
We then have &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; calls to makeSet, &lt;script type=&quot;math/tex&quot;&gt;2m&lt;/script&gt; calls to find and &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; calls to union. These operations run in amortized time &lt;script type=&quot;math/tex&quot;&gt;O(\alpha(n))&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;\alpha(n)&lt;/script&gt; is the inverse Ackerman function and &lt;script type=&quot;math/tex&quot;&gt;\alpha(n) \leq 4&lt;/script&gt; provided that &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is smaller than the number of atoms in the universe.
&lt;br /&gt;&lt;br /&gt;
Therefore, the total time is just &lt;script type=&quot;math/tex&quot;&gt;O(m\log(n))&lt;/script&gt; which is similar to Prim if we use a Red Black Tree and closer to &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; if we use radixSort.&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Detailed Implementation:&lt;/b&gt; &lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/minimum-spanning-trees/kruskal&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction The Knapsack problem is a classic example of problems that have greedy solutions. Greedy solutions are hard because it is really hard to prove that they actually work. In Knapsack, we’re given a knapsack of size and a list of items that each have a weight and a value . There are many variations of the Knapsack Problem. 0/1 Knapsack puts a limit of at most 1 copy of each item that you can pack. There is also the unbounded knaspack where you have multiple/unbounded copies of each item. 2 Example Suppose we have an ubounded number of tacos, each of weight 3 and value 10. We also have burritos each of weight 6 and value 14. Suppose now that we have . One simple greedy strategy is to pack as many items as possible of the best value/weight ratio. Based on this, we’ll pick 3 burritos of value . But this strategy doesn’t work because if you instead pack 2 burritos and 2 tacos, you’ll get the maximum value of . 2.1 Algorithm (slow naive version) E = Sort the edges by non-decreasing weight. MST = {} for e in sorted E { if we can add e to MST without creating a cycle { add e to MST } } return MST 2.2 Algorithm (fast, used for the remaining of these notes) The reason why this implementation is the standard kruskal implemenation is because we use a special data structure to maintain the forests kruskal is maintaining in the algorithm. The data structure is union-find which supports the following operations makeSet(u): creates a set find(u): returns the set that is in. union(u,v): merge the set that is in with the set that is in.</summary></entry><entry><title type="html">Longest Increasing Subsequence</title><link href="http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html" rel="alternate" type="text/html" title="Longest Increasing Subsequence" /><published>2019-06-25T12:01:36-07:00</published><updated>2019-06-25T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/06/25/longest-increasing-subsequence.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;A = [a_0, a_1, a_2,...,a_n]&lt;/script&gt; be an array containing &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; real numbers. A longest increasing subsequence of A is a sequence &lt;script type=&quot;math/tex&quot;&gt;0 \leq i_0 \leq i_1 \leq ... \leq i_k \leq n&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;A[i_i] \leq A[i_2] \leq ... \leq A[i_k]&lt;/script&gt; so that &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is of maximum value.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;2 Example&lt;/b&gt;
&lt;br /&gt;
Suppose &lt;script type=&quot;math/tex&quot;&gt;A = [3, 8, 1, 2, 7, 9, 6, 4, 5]&lt;/script&gt; then a longest increasing subsequence could be &lt;script type=&quot;math/tex&quot;&gt;[1, 2, 4, 5]&lt;/script&gt;. Note that it is not unique.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;3 The Brute Force Solution&lt;/b&gt;
&lt;br /&gt;
We can check every possible subsequence. For each element of &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;, we either select that element or not. Therefore, the total number of possible subsequences is &lt;script type=&quot;math/tex&quot;&gt;2^n&lt;/script&gt;. As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is &lt;script type=&quot;math/tex&quot;&gt;O(2^n)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;4 Dynamic Programming and the Optimal Substructure&lt;/b&gt;
&lt;br /&gt;
To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS).&lt;br /&gt;
&lt;br /&gt;
It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let &lt;script type=&quot;math/tex&quot;&gt;D[i]&lt;/script&gt; be the length of the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;, then we will find that&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
D[i] = 1 + \max({D[k] : k &amp;lt; i \text{ and } A[k] &amp;lt; A[i]})
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; can be found by looking at all &lt;script type=&quot;math/tex&quot;&gt;D[k]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i %]]&gt;&lt;/script&gt; (meaning that &lt;script type=&quot;math/tex&quot;&gt;A[k]&lt;/script&gt; comes before &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;) and &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; A[k]&lt;/script&gt; (meaning that &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; can extend the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[k]&lt;/script&gt;). We then take the maximum value of &lt;script type=&quot;math/tex&quot;&gt;D[k]&lt;/script&gt;, 
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Proof:&lt;/b&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; be a natural number and let &lt;script type=&quot;math/tex&quot;&gt;D[i]&lt;/script&gt; be the length of the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Consider the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i + 1]&lt;/script&gt;. We have two cases:
&lt;br /&gt;
&lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is the smallest element in &lt;script type=&quot;math/tex&quot;&gt;A[0...i+1]&lt;/script&gt;. Therefore, the length of the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is 1.
&lt;br /&gt;
&lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is not the smallest element in &lt;script type=&quot;math/tex&quot;&gt;A[0...i+1]&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; be a natural number where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i+1 %]]&gt;&lt;/script&gt;. This means that we can use &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; to extend the subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[k]&lt;/script&gt; if &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[k] &lt; A[i + 1] %]]&gt;&lt;/script&gt;. Since we are searching for the longest increasing subsequence then we take the maximum value for all possible &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i + 1 %]]&gt;&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;D[i+1]&lt;/script&gt; is the maximum value plus 1 as defined above.
&lt;br /&gt;
&lt;br /&gt;
We claim that &lt;script type=&quot;math/tex&quot;&gt;D[i+1]&lt;/script&gt; is the length of longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt;. Suppose it wasn’t and that the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;m &gt; D[i+1]&lt;/script&gt;. By our definition, we know that &lt;script type=&quot;math/tex&quot;&gt;D[i+1] = D[k] + 1&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;D[k]&lt;/script&gt; is the longest increasing subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k &lt; i+1 %]]&gt;&lt;/script&gt;. This means that &lt;script type=&quot;math/tex&quot;&gt;m &gt; D[k]+1&lt;/script&gt; but this is not possible since we’re only adding &lt;script type=&quot;math/tex&quot;&gt;A[i+1]&lt;/script&gt; to the subsequence. Therefore, &lt;script type=&quot;math/tex&quot;&gt;D[i+1]&lt;/script&gt; is optimal.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;3 The &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt; Implementation&lt;/b&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;longest_increasing_subsequence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// maximum subsequence ending at a[i] is initially 1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// parent array&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// for element a[i], check all the previous subsequences where i &amp;lt; j&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// and see if a[i] can extend any of them&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// I can extend the subsequence&lt;/span&gt;
	            &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	            &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// used for reconstructing the subsequence&lt;/span&gt;
	        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// maximum subsequence so far&lt;/span&gt;
	        &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
	    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Running Time:&lt;/b&gt; 
&lt;br /&gt;
We’re doing two simple loops to fill arrays &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. Therefore, our runtime is just &lt;script type=&quot;math/tex&quot;&gt;O(n^2)&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Example:&lt;/b&gt; 
&lt;br /&gt;
Initially we start with arrays &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;:
Consider again &lt;script type=&quot;math/tex&quot;&gt;A = [3, 8, 1, 2, 7, 9, 6, 4, 5]&lt;/script&gt;. We initialize &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;D = [1, 1, 1, 1, 1, 1, 1, 1, 1]&lt;/script&gt; representing the initial length of the subsequence ending at each possible &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Iteration &lt;script type=&quot;math/tex&quot;&gt;i = 1&lt;/script&gt;. We look at &lt;script type=&quot;math/tex&quot;&gt;A[1] = 8&lt;/script&gt;. We have &lt;script type=&quot;math/tex&quot;&gt;D[1]=1&lt;/script&gt; and so the subsequence is just &lt;script type=&quot;math/tex&quot;&gt;\{8\}&lt;/script&gt;. Can 8 extend any previous subsequences? We look at &lt;script type=&quot;math/tex&quot;&gt;j = 0&lt;/script&gt; and in that case, we see that &lt;script type=&quot;math/tex&quot;&gt;A[1] &gt; A[0]&lt;/script&gt;, meaning that that the subsequence can now include 3 and become &lt;script type=&quot;math/tex&quot;&gt;\{3, 8\}&lt;/script&gt;. And so now we have:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
Iteration &lt;script type=&quot;math/tex&quot;&gt;i = 2&lt;/script&gt;. We look at &lt;script type=&quot;math/tex&quot;&gt;A[2] = 1&lt;/script&gt;. We have &lt;script type=&quot;math/tex&quot;&gt;D[2]=1&lt;/script&gt; and so the subsequence is just &lt;script type=&quot;math/tex&quot;&gt;\{1\}&lt;/script&gt;. Can 4 extend any previous subsequences? We need to look at &lt;script type=&quot;math/tex&quot;&gt;j = 0&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;j = 1&lt;/script&gt;. It turns out that 1 will not be able to extend either subsequence.&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
We continue doing so until we reach the end and we have:&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$
$$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$
&lt;/div&gt;
&lt;p&gt;This means that the longest subsequence ends at element 9 or 5. We can then &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; to construct the subsequence. One possible construction will generate: &lt;script type=&quot;math/tex&quot;&gt;[1, 2, 7, 9]&lt;/script&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 The O(nlg(n)) Solution with Binary Search:&lt;/b&gt; 
&lt;br /&gt;
The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes!
&lt;br /&gt;&lt;br /&gt;
Previously, we said that &lt;script type=&quot;math/tex&quot;&gt;D[i]&lt;/script&gt; is the length of the longest subsequence ending at &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Now we will consider a completely different substructure. Let &lt;script type=&quot;math/tex&quot;&gt;M[i]&lt;/script&gt; to be the smallest element that ends a subsequence of length &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. For simplicity we will initially let &lt;script type=&quot;math/tex&quot;&gt;M[0]&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;-\infty&lt;/script&gt; and everything else to be &lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;. 
&lt;br /&gt;&lt;br /&gt;
Let’s take the same example where &lt;script type=&quot;math/tex&quot;&gt;A = [3, 8, 1, 2, 7, 9, 6, 4, 5]&lt;/script&gt;. In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is &lt;script type=&quot;math/tex&quot;&gt;[-\infty, 1, 2, 4, 5, \infty, \infty, \infty, \infty]&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;, that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; must be sorted because this will help us later on. To prove that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted, we will prove that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is a strictly increasing array and that for any &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;, we have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
M[k] &lt; M[k+1] %]]&gt;&lt;/script&gt;. (We will ignore the placeholder &lt;script type=&quot;math/tex&quot;&gt;\infty&lt;/script&gt;’s otherwise the proof would not work)
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim: M is a strictly increasing array&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;b&gt;Proof:&lt;/b&gt;&lt;br /&gt;
Suppose it is not and that there exists some &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; where either &lt;script type=&quot;math/tex&quot;&gt;M[j] = M[j+1]&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;M[j] &gt; M[j+1]&lt;/script&gt;. We will prove neither case is possible.
&lt;br /&gt;&lt;br /&gt;
First, suppose that &lt;script type=&quot;math/tex&quot;&gt;M[j] = M[j+1]&lt;/script&gt; then this means that we have two strictly increasing subsequences that end in &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt;. Let the first subsequence be &lt;script type=&quot;math/tex&quot;&gt;\{a_1, a_2,...a_n,M[j]\}&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; and let the second subsequence be &lt;script type=&quot;math/tex&quot;&gt;\{b_1,b_2,..,b_m,M[j]\}&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;j+1&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;m = n + 1&lt;/script&gt;. Since this is a strictly increasing subsequence, we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b_m &lt; M[j] %]]&gt;&lt;/script&gt;. This is a contradiction because by assumption we know that &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; is the smallest element that ends a subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; but we just showed that there exists a subsequence, namely, &lt;script type=&quot;math/tex&quot;&gt;\{b_1,b_2,..,b_m\}&lt;/script&gt;, of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that ends with a smaller element, &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b_m &lt; M[j] %]]&gt;&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Next, suppose that &lt;script type=&quot;math/tex&quot;&gt;M[j] &gt; M[j+1]&lt;/script&gt;. This is a contradiction for the same reasons above. Let &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; be the subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that ends with &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; and if we let &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; the subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j+1&lt;/script&gt; that ends with M[j+1]. Since subsequences are strictly increasing then we can extract all the elements from &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; except for &lt;script type=&quot;math/tex&quot;&gt;M[j+1]&lt;/script&gt;. This new sequence ends with an element strictly less than &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; and therefore, we arrive at the same contradiction and conclude that it is not possible.
&lt;br /&gt;&lt;br /&gt;
Therefore, we can conclude that we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
M[k] &lt; M[k+1] %]]&gt;&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; as we wanted to show.
&lt;!-- --&gt;
&lt;br /&gt;&lt;br /&gt;
&lt;b&gt;Algorithm:&lt;/b&gt;&lt;br /&gt;
Let’s traverse &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; from left to right. For the base case, we consider &lt;script type=&quot;math/tex&quot;&gt;i = 0&lt;/script&gt; and at this point we know that &lt;script type=&quot;math/tex&quot;&gt;A[0] &gt; -\infty&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;M[1] = A[0]&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Now let’s consider iteration &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Also, let &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; be the length of the longest subsequence reached so far, meaning that &lt;script type=&quot;math/tex&quot;&gt;M[k] \neq \infty&lt;/script&gt; and for any &lt;script type=&quot;math/tex&quot;&gt;j &gt; k&lt;/script&gt; we have &lt;script type=&quot;math/tex&quot;&gt;M[j] = \infty&lt;/script&gt;. Let’s consider two cases:
&lt;br /&gt;&lt;br /&gt;
Case 1: &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[k]&lt;/script&gt;. In this case, we see that it is possible to extend the subsequence ending with element &lt;script type=&quot;math/tex&quot;&gt;M[k]&lt;/script&gt; because &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; is greater, yay! Now we can set &lt;script type=&quot;math/tex&quot;&gt;M[k+1] = A[i]&lt;/script&gt; and we are done. (But why? don’t we need to check previous subsequences in &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt;? No. Proof: We established previously that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted and so if &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[k]&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[j]&lt;/script&gt; for &lt;script type=&quot;math/tex&quot;&gt;j \leq k&lt;/script&gt;. This means that &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; is not a possible candidate for replacing any of the previous elements because &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; holds ONLY the minimum possible elements that end each subsequence.)
&lt;br /&gt;&lt;br /&gt;
Case 2: &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[i] &lt; M[k] %]]&gt;&lt;/script&gt;. This one is tricky. In this case &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; can’t extend the current subsequence of length &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; but it can potentially be a better candidate for ending some subsequence of length &lt;script type=&quot;math/tex&quot;&gt;1,...,k&lt;/script&gt;. Recall that &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted and is a strictly increasing array. Let &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; be natural number where &lt;script type=&quot;math/tex&quot;&gt;j \leq k&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; is the smallest element such that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[i] &lt; M[j] %]]&gt;&lt;/script&gt;. (Note that it might be that &lt;script type=&quot;math/tex&quot;&gt;j = k&lt;/script&gt;). By our construction, this means that &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[j-1]&lt;/script&gt;. (Note that it might be that j-1 = 0). This means that we can take the subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j-1&lt;/script&gt; ending with &lt;script type=&quot;math/tex&quot;&gt;M[j-1]&lt;/script&gt; and extend it with &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;, making a new subsequence of length &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; that has a smaller ending value than the one ending with &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt;! (we’re basically replacing the subsequence ending with M[j] with the new subsequence consisting of what we have already in &lt;script type=&quot;math/tex&quot;&gt;M[j-1]&lt;/script&gt; plus &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;). How do we find such an index &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
M[j-1] &lt; A[i] &lt; M[j] %]]&gt;&lt;/script&gt;? This is where binary search comes in! since &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is sorted, we can find this position in just &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt;.
&lt;br /&gt;&lt;br /&gt;
Could we replace the end of any other subsequence? No. Even though &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
A[i] &lt; M[j] %]]&gt;&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;j..k&lt;/script&gt;, only &lt;script type=&quot;math/tex&quot;&gt;M[j]&lt;/script&gt; can be replaced because &lt;script type=&quot;math/tex&quot;&gt;A[i] &gt; M[j-1]&lt;/script&gt;. Any subsequence of length greater than &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; already has more elements than just &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; so &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; could not end these subsequences. (more formal?)
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;3 The &lt;script type=&quot;math/tex&quot;&gt;O(n\log(n))&lt;/script&gt; Implementation&lt;/b&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;longest_increasing_subsequence_fast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// O(nlogn)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;INF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// keeps track of the length of the longest &lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// increasing subsequence found so far&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// in each iteration either a[i] &amp;gt; a[k] meaning we can &lt;/span&gt;
		&lt;span class=&quot;c1&quot;&gt;// extend the subsequence&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// or a[i] &amp;lt; a[k] meaning we can update one of the previous &lt;/span&gt;
			&lt;span class=&quot;c1&quot;&gt;// subsequences to a better subsequence ending &lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// just a binary search&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Full Implementation: &lt;/b&gt;&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/blob/master/dynamic-programming/longest-increasing-subsequence.cpp&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;References: &lt;/b&gt;&lt;br /&gt;
These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html and CLRS.&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction Let be an array containing real numbers. A longest increasing subsequence of A is a sequence such that so that is of maximum value. 2 Example Suppose then a longest increasing subsequence could be . Note that it is not unique. 3 The Brute Force Solution We can check every possible subsequence. For each element of , we either select that element or not. Therefore, the total number of possible subsequences is . As we generate the subsequences, we can keep track of the longest subsequence encountered so far and therefore, our run time is . 4 Dynamic Programming and the Optimal Substructure To use dynamic programming, we first need to find an optimal substructure. An optimal substructure means that an optimal solution to the problem will contain within it optimal solutions to subproblems (Ref: CLRS). It turns out that we have a beautiful optimal substructure to the longest increasing subsequence problem. If we let be the length of the longest increasing subsequence ending at , then we will find that $$ \begin{align*} D[i] = 1 + \max({D[k] : k &amp;lt; i \text{ and } A[k] &amp;lt; A[i]}) \end{align*} $$ In other words, the longest increasing subsequence ending at can be found by looking at all where (meaning that comes before ) and (meaning that can extend the subsequence ending at ). We then take the maximum value of , Proof: Let be a natural number and let be the length of the longest increasing subsequence ending at . Consider the subsequence ending at . We have two cases: Case 1: is the smallest element in . Therefore, the length of the subsequence ending at is 1. Case 2: is not the smallest element in . Let be a natural number where . This means that we can use to extend the subsequence ending at if . Since we are searching for the longest increasing subsequence then we take the maximum value for all possible and so is the maximum value plus 1 as defined above. We claim that is the length of longest increasing subsequence ending at . Suppose it wasn’t and that the longest increasing subsequence ending at is and so . By our definition, we know that where is the longest increasing subsequence ending at . This means that but this is not possible since we’re only adding to the subsequence. Therefore, is optimal. 3 The Implementation int longest_increasing_subsequence(int *a, int n) { int D[n], p[n], max = 0; // maximum subsequence ending at a[i] is initially 1 for (int i = 0; i &amp;lt; n; i++) { D[i] = 1; p[i] = -1; // parent array } // for element a[i], check all the previous subsequences where i &amp;lt; j // and see if a[i] can extend any of them for (int i = 1; i &amp;lt; n; i++) { for (int j = 0; j &amp;lt; i; j++) { if (A[i] &amp;gt; A[j] &amp;amp;&amp;amp; D[i] &amp;lt; D[j] + 1) { // I can extend the subsequence D[i] = D[j] + 1; p[i] = j; // used for reconstructing the subsequence } } if (D[i] &amp;gt; max) { // maximum subsequence so far max = D[i]; } } return max; } 5 Running Time: We’re doing two simple loops to fill arrays and . Therefore, our runtime is just 6 Example: Initially we start with arrays and : Consider again . We initialize to be representing the initial length of the subsequence ending at each possible . Iteration . We look at . We have and so the subsequence is just . Can 8 extend any previous subsequences? We look at and in that case, we see that , meaning that that the subsequence can now include 3 and become . And so now we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ Iteration . We look at . We have and so the subsequence is just . Can 4 extend any previous subsequences? We need to look at and . It turns out that 1 will not be able to extend either subsequence. $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 1, 1, 1, 1, 1, 1]$$ We continue doing so until we reach the end and we have: $$A = [3, 8, 1, 2, 7, 9, 6, 4, 5]$$ $$D = [1, 2, 1, 2, 3, 4, 3, 3, 4]$$ This means that the longest subsequence ends at element 9 or 5. We can then to construct the subsequence. One possible construction will generate: 5 The O(nlg(n)) Solution with Binary Search: The O(n^2) dynamic programming solution we’ve developed is great but can we do better? The answer is fortunately yes! Previously, we said that is the length of the longest subsequence ending at . Now we will consider a completely different substructure. Let to be the smallest element that ends a subsequence of length . For simplicity we will initially let to be and everything else to be . Let’s take the same example where . In this case, the smallest number that ends a subsequence of length 1 is 1. Also the smallest number that ends a subsequence of length 3 is 4 and so on. We will eventually have is . Before proceeding with the algorithm and why it works. Let’s prove that based on our construction of , that must be sorted because this will help us later on. To prove that is sorted, we will prove that is a strictly increasing array and that for any , we have . (We will ignore the placeholder ’s otherwise the proof would not work)</summary></entry><entry><title type="html">Breadth First Search</title><link href="http://localhost:4000/jekyll/update/2019/06/20/bfs.html" rel="alternate" type="text/html" title="Breadth First Search" /><published>2019-06-20T12:01:36-07:00</published><updated>2019-06-20T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/06/20/bfs</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/06/20/bfs.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Dijkstra solves the single source shortest weighted path problem in a weighted graph with non-negative edge weights. But what if we have multiple sources and we want to find the shortest distance to ANY of the sources? We can also use Dijkstra!
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;b&gt;2 Example&lt;/b&gt;
&lt;br /&gt;
Say we have the following grid and want to find the distance from any cell to a cell that has “1”.&lt;/p&gt;
&lt;table&gt;
	&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;We can just run Dijkstra with the modification that we have many sources initially in the queue with distance 0.
After running the modified Dijkstra, we’ll get the following array of distances!&lt;/p&gt;
&lt;table&gt;
	&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;0&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;b&gt;3 Algorithm&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;multibfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Initialize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;priorty&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sources&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Initialize&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;INF&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;all&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nodes&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// pop a node from the queue&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// for each neighbor, in the above example (4 directions top, bottom, right, left)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;every&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// in c++ we don't have a decrease key but there is a workaround! check the full implementation&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decrease_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;distance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; 
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// distances now have the short distances&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Full Implementation:&lt;/b&gt; 
https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/multiple-source-bfs.cpp&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction Dijkstra solves the single source shortest weighted path problem in a weighted graph with non-negative edge weights. But what if we have multiple sources and we want to find the shortest distance to ANY of the sources? We can also use Dijkstra! 2 Example Say we have the following grid and want to find the distance from any cell to a cell that has “1”. 0001 0011 0110 We can just run Dijkstra with the modification that we have many sources initially in the queue with distance 0. After running the modified Dijkstra, we’ll get the following array of distances! 3210 2101 1001 3 Algorithm void multibfs() { Initialize a priorty queue q and all the sources Initialize a distance array with INF for all nodes while (q is not empty) { node u = q.top() // pop a node from the queue // for each neighbor, in the above example (4 directions top, bottom, right, left) for every neighbor v of u { if (distance[v] &amp;gt; distance[u] + 1) { distance[v] = distance[u] + 1; // in c++ we don't have a decrease key but there is a workaround! check the full implementation q.decrease_key(distance[v], v); } } } // distances now have the short distances } 4 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/multiple-source-bfs.cpp</summary></entry><entry><title type="html">Input Handling Examples</title><link href="http://localhost:4000/jekyll/update/2019/06/18/input-handling.html" rel="alternate" type="text/html" title="Input Handling Examples" /><published>2019-06-18T12:01:36-07:00</published><updated>2019-06-18T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/06/18/input-handling</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/06/18/input-handling.html">&lt;p&gt;&lt;b&gt;1 Unbounded Tests&lt;/b&gt;&lt;br /&gt;
We have a bunch of tests but we don’t know the number of tests. This is an example:&lt;br /&gt;&lt;/p&gt;
&lt;table&gt;
	&lt;td&gt;
5 &lt;br /&gt;
E 0.01 *A &lt;br /&gt;
... &lt;br /&gt;
10 &lt;br /&gt;
S 2.23 Q* &lt;br /&gt;
A 9.76 CKM &lt;br /&gt;
...
&lt;/td&gt;
&lt;/table&gt;

&lt;p&gt;Each test case starts with the number of lines in the test case. Each line contains three values and so we use std::istringstream to extract the values. The following works although not pretty.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// for each test case, we read the number of lines in the test case&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;planet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// this is my hack to know we're done and there are no more lines&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
	
	&lt;span class=&quot;c1&quot;&gt;// take this line now and process it the way you want&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// in this specific case, we know we have three values&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istringstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;planet&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;neighbors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Reading 3D Grid Data&lt;/b&gt;&lt;br /&gt;
This is from problem “532 - Dungeon Master”. Here we know when to terminate. We also know the number of rows, colums and the height (number of levels). There is also an extra new line between each board.&lt;/p&gt;

&lt;table&gt;
&lt;td&gt;
2 4 5 &lt;br /&gt;
SXXXX &lt;br /&gt;
X@@@X &lt;br /&gt;
X@@XX &lt;br /&gt;
@@@X@&lt;br /&gt;
&lt;br /&gt;
@@@@@ &lt;br /&gt;
@@@@@ &lt;br /&gt;
@@X@@ &lt;br /&gt;
@@XXX &lt;br /&gt;
&lt;br /&gt;
1 3 3 &lt;br /&gt;
S@@&lt;br /&gt;
@E@ &lt;br /&gt;
@@@ &lt;br /&gt;
&lt;br /&gt;
0 0 0
&lt;/td&gt;
&lt;/table&gt;

&lt;p&gt;And this is the code I’ve used.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;start_j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d %d %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// each level&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// each board&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// a line here is @@XX@&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;C&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// put each char in its cell&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'S'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// record the start position&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start_k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start_i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;start_j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stdin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// get the nasty extra line between levels&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Strings with variable number of ints&lt;/b&gt;&lt;br /&gt;
Consider a number of lines where each line consists of a variable number of ints. We can use std::istringstream and use a while loop to read as many ints as possible from that line. Code below shows this:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;scanf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;istringstream&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;line&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// do something with num&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;Other examples:&lt;/b&gt; 
https://github.com/strncat/competitive-programming&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Unbounded Tests We have a bunch of tests but we don’t know the number of tests. This is an example: 5 E 0.01 *A ... 10 S 2.23 Q* A 9.76 CKM ...</summary></entry><entry><title type="html">A Manual of Data Structures for Competitive Programming</title><link href="http://localhost:4000/jekyll/update/2019/06/17/data-structures.html" rel="alternate" type="text/html" title="A Manual of Data Structures for Competitive Programming" /><published>2019-06-17T12:01:36-07:00</published><updated>2019-06-17T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/06/17/data-structures</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/06/17/data-structures.html">&lt;p&gt;&lt;b&gt;1 You want to hash 2D grid positions&lt;/b&gt;&lt;br /&gt;
Maybe you want to model positions as std pairs (x, y). Now you want to hash them but map requires your own custom hash function. Whatever, we can make one. Here is an example.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// figuring out the total cells in the path&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unary_function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// silly hash function but it works for grids!&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unordered_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;equal_to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;position&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// so now I can run bfs and do something like parents[next] = current&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 You want to hash 3D grid positions&lt;/b&gt;&lt;br /&gt;
This is the same as above but for a 3D grid! we use std tuples this time:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tuple&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unary_function&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unordered_map&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;equal_to&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tuple_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;tuple_map&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 &lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;9 References:&lt;/b&gt; 
-&lt;/p&gt;</content><author><name></name></author><summary type="html">1 You want to hash 2D grid positions Maybe you want to model positions as std pairs (x, y). Now you want to hash them but map requires your own custom hash function. Whatever, we can make one. Here is an example. // figuring out the total cells in the path typedef std::pair&amp;lt;int, int&amp;gt; position; struct hash : public std::unary_function&amp;lt;key_t, std::size_t&amp;gt; { std::size_t operator()(const position&amp;amp; k) const { return std::get&amp;lt;0&amp;gt;(k) * 10 + std::get&amp;lt;1&amp;gt;(k) * 1; // silly hash function but it works for grids! } }; std::unordered_map&amp;lt;const position, position, hash,std::equal_to&amp;lt;position&amp;gt;&amp;gt; parents; // so now I can run bfs and do something like parents[next] = current</summary></entry><entry><title type="html">Binary Search Trees</title><link href="http://localhost:4000/jekyll/update/2019/05/03/binary-search-trees.html" rel="alternate" type="text/html" title="Binary Search Trees" /><published>2019-05-03T12:01:36-07:00</published><updated>2019-05-03T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/05/03/binary-search-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/05/03/binary-search-trees.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The binary-search-tree property is the following:
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; be a node in the tree. Let &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; be a node. If &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; was in the left subtree then we must have &lt;script type=&quot;math/tex&quot;&gt;y.key \leq x.key&lt;/script&gt;. Similarly, if &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; is a node in the right subtree then &lt;script type=&quot;math/tex&quot;&gt;y.key \geq x.key&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Example&lt;/b&gt;&lt;br /&gt;
Below is a binary search tree. Every node in the tree maintains the binary search tree property.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 &lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 &lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;9 References:&lt;/b&gt; 
CLRS, 13.0&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The binary-search-tree property is the following: Let be a node in the tree. Let be a node. If was in the left subtree then we must have . Similarly, if is a node in the right subtree then . 2 Example Below is a binary search tree. Every node in the tree maintains the binary search tree property.</summary></entry><entry><title type="html">Binary Tree Rotations</title><link href="http://localhost:4000/jekyll/update/2019/05/02/binary-tree-rotation.html" rel="alternate" type="text/html" title="Binary Tree Rotations" /><published>2019-05-02T12:01:36-07:00</published><updated>2019-05-02T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/05/02/binary-tree-rotation</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/05/02/binary-tree-rotation.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
Rotating a tree is one of the fundamental operations that we perform on binary trees. It is used in balancing trees like Red-Black trees and AVL trees. Rotations maintain the binary search tree property. We have two kinds of rotation, a left rotation and a right rotation described below.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Left Rotation&lt;/b&gt;&lt;br /&gt;
Given a node &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; in a binary search tree &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; with a right child &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;. A left rotation makes &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; the new root of the subtree and &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; its left child. &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;’s left child &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; will be &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;’s right child. &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; stay the same. The colored nodes are affected with the rotation, everything else stays the same.&lt;/p&gt;

&lt;svg width=&quot;800&quot; height=&quot;260&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;571.5&quot; cy=&quot;55.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;566.5&quot; y=&quot;61.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;x&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;524.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;520.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;yellow&quot; fill-opacity=&quot;0.25&quot; cx=&quot;627.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;622.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;y&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;681.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;677.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;blue&quot; fill-opacity=&quot;0.25&quot; cx=&quot;588.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;583.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;yellow&quot; fill-opacity=&quot;0.25&quot; cx=&quot;187.5&quot; cy=&quot;55.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;182.5&quot; y=&quot;61.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;y&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;142.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;137.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;x&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;230.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;226.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;94.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;90.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;blue&quot; fill-opacity=&quot;0.25&quot; cx=&quot;181.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;176.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;text x=&quot;317.5&quot; y=&quot;132.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;&amp;lt;&amp;lt; left rotation&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;588.419,80.274 610.581,112.726&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;610.581,112.726 610.198,103.3 601.94,108.939&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;556.582,81.528 539.418,111.472&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;539.418,111.472 547.735,107.018 539.059,102.045&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;643.587,162.822 665.413,197.178&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;665.413,197.178 665.344,187.744 656.903,193.106&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;614.989,164.767 601.011,195.233&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;601.011,195.233 608.891,190.047 599.802,185.877&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;201.432,82.069 216.568,110.931&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;216.568,110.931 217.281,101.524 208.424,106.168&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;155.011,164.767 168.989,195.233&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;168.989,195.233 170.198,185.877 161.109,190.047&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;127.748,163.623 109.252,196.377&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;109.252,196.377 117.539,191.87 108.832,186.953&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;173.067,81.8 156.933,111.2&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;156.933,111.2 165.165,106.592 156.398,101.781&quot; /&gt;
&lt;/svg&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Proof of Correctness&lt;/b&gt;&lt;br /&gt;
We want to prove the following:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;a left rotation maintains the binary search property&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; be a binary search tree and let the right subtree above be in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt; be the tree resulted after &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; has been left rotated at &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. We want to prove &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt; is a binary search tree. To do so, we need to prove that each node is maintaining the BST property. First, since &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; is a right child of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; then we know that &lt;script type=&quot;math/tex&quot;&gt;x.key \leq y.key&lt;/script&gt;. After the rotation is done, &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is a left child of &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; maintaining the BST property. Similarly, in T, &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is a left child of &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;, so this means that &lt;script type=&quot;math/tex&quot;&gt;b.key \leq y.key&lt;/script&gt; and since the &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; in the right subtree of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, we also know that &lt;script type=&quot;math/tex&quot;&gt;b.key \geq x.key&lt;/script&gt;. After the rotation is done, we see that in &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is a right child of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; maintaining the BST property since &lt;script type=&quot;math/tex&quot;&gt;b.key \geq x.key&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b.key \leq y.key&lt;/script&gt;. Finally we see that &lt;script type=&quot;math/tex&quot;&gt;a.key \leq x.key&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;x.key \leq y.key&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; and so so &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is still maintaining the BST property in &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt;. Similarly, &lt;script type=&quot;math/tex&quot;&gt;c.key \geq y.key&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y.key \geq x.key&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt; and so &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; is still maintaining the BST property in &lt;script type=&quot;math/tex&quot;&gt;T'&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Left Rotation Implementation&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;left_rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we are assuming x has a right child&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// as in the example above, y's left child b becomes x's new right child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// if there is a left child, fix up the parent pointer&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// b's parent is x now&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// since y is the new root then we fix up y's parent pointer&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;c1&quot;&gt;// we should now fix the parent link to point to y unless x was the root itself, then y is the new root&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this means x is the root (no parent pointer)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x is a left child, make y the left child of x's parent&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// x is a right child, make y the right child of x's parent&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// finally, x is now the left child of y and y is its parent&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Right Rotation&lt;/b&gt;&lt;br /&gt;
Similarly, a rotation rotation takes a node &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; with its left child &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; and rotate them so that &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is the parent of &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; is now a right child of &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.&lt;/p&gt;

&lt;svg width=&quot;800&quot; height=&quot;260&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;571.5&quot; cy=&quot;55.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;566.5&quot; y=&quot;61.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;x&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;524.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;520.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;yellow&quot; fill-opacity=&quot;0.25&quot; cx=&quot;627.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;622.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;y&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;681.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;677.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;blue&quot; fill-opacity=&quot;0.25&quot; cx=&quot;588.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;583.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;yellow&quot; fill-opacity=&quot;0.25&quot; cx=&quot;187.5&quot; cy=&quot;55.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;182.5&quot; y=&quot;61.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;y&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;142.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;137.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;x&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;230.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;226.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;c&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;94.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;90.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;a&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;blue&quot; fill-opacity=&quot;0.25&quot; cx=&quot;181.5&quot; cy=&quot;222.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;176.5&quot; y=&quot;228.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;b&lt;/text&gt;
	&lt;text x=&quot;317.5&quot; y=&quot;132.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;right rotation &amp;gt;&amp;gt;&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;588.419,80.274 610.581,112.726&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;610.581,112.726 610.198,103.3 601.94,108.939&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;556.582,81.528 539.418,111.472&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;539.418,111.472 547.735,107.018 539.059,102.045&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;643.587,162.822 665.413,197.178&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;665.413,197.178 665.344,187.744 656.903,193.106&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;614.989,164.767 601.011,195.233&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;601.011,195.233 608.891,190.047 599.802,185.877&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;201.432,82.069 216.568,110.931&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;216.568,110.931 217.281,101.524 208.424,106.168&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;155.011,164.767 168.989,195.233&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;168.989,195.233 170.198,185.877 161.109,190.047&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;127.748,163.623 109.252,196.377&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;109.252,196.377 117.539,191.87 108.832,186.953&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;173.067,81.8 156.933,111.2&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;156.933,111.2 165.165,106.592 156.398,101.781&quot; /&gt;
&lt;/svg&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Right Rotation Implementation&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;right_rotate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we are assuming y has a left child x&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// as in the example above,x's right child becomes y's left child&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// fix up the parent pointer&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// since x is the new root then we fix up x's parent pointer&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	
	&lt;span class=&quot;c1&quot;&gt;// we should now fix the parent link to point to x unless y was the root itself, then y is the new root&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// this means y is the root (no parent pointer)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// y is a left child, make x the left child of y's parent&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// y is a right child, make x the right child of y's parent&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// finally, y is now the right child of x and x is its parent&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Running Time:&lt;/b&gt; 
Since we’re performing a constant number of link changes then the runtime is &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;8 Detailed Implementation:&lt;/b&gt; 
https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/red-black-tree.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;9 References:&lt;/b&gt; 
CLRS, 13.2 Rotations&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction Rotating a tree is one of the fundamental operations that we perform on binary trees. It is used in balancing trees like Red-Black trees and AVL trees. Rotations maintain the binary search tree property. We have two kinds of rotation, a left rotation and a right rotation described below. 2 Left Rotation Given a node in a binary search tree with a right child . A left rotation makes the new root of the subtree and its left child. ’s left child will be ’s right child. and stay the same. The colored nodes are affected with the rotation, everything else stays the same.</summary></entry><entry><title type="html">AVL Trees</title><link href="http://localhost:4000/jekyll/update/2019/05/01/avl-trees.html" rel="alternate" type="text/html" title="AVL Trees" /><published>2019-05-01T12:01:36-07:00</published><updated>2019-05-01T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/05/01/avl-trees</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/05/01/avl-trees.html">&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;&lt;br /&gt;
Let’s define some important terms:
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Height of a node&lt;/i&gt;: &lt;br /&gt;
longest path from the node to a leaf. To compute the height, we simply take the maximum height of the left and right children and add 1.
&lt;br /&gt;
&lt;br /&gt;
&lt;i&gt;Height of a binary search tree&lt;/i&gt;: &lt;br /&gt;
is the length of the longest path from the root to a leaf.
&lt;br /&gt;
&lt;br /&gt;
A tree is &lt;i&gt;balanced&lt;/i&gt; if if its height is &lt;script type=&quot;math/tex&quot;&gt;\theta(\log(n))&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 AVL Trees&lt;/b&gt;&lt;br /&gt;
AVL trees are binary trees and where the heights of left and right children of every node differ by at most +/-1. Based on this, we claim that&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AVL trees are blanaced.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;i&gt;Proof:&lt;/i&gt;&lt;br /&gt;
We should consider all possible trees. In the best case all nodes have the difference in height between the left and right children is 0. In this case the height of the tree is &lt;script type=&quot;math/tex&quot;&gt;\theta(\log(n))&lt;/script&gt;
&lt;br /&gt;&lt;br /&gt;
In the worst case, every node’s children heights differ by exactly 1. Without the loss of generality assume that the right sub-tree has height 1 more than the left subtree for every node.
&lt;br /&gt;&lt;br /&gt;
Define &lt;script type=&quot;math/tex&quot;&gt;N_h&lt;/script&gt; to be the mininum number of nodes in an AVL tree of height &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt;. Since we know that the height of the left subtree and the right differ by 1, then we can define &lt;script type=&quot;math/tex&quot;&gt;N_h&lt;/script&gt; recursively as follows:
&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
$$N_h = 1 + N_{h-1} + N_{h-2}$$ 
&lt;/center&gt;
&lt;p&gt;This is very similar to Fibonacci, in fact:&lt;/p&gt;
&lt;center&gt;
$$
  \begin{align*}
  	N_h &amp;amp;= 1 + N_{h-1} + N_{h-2} \\
  	&amp;amp;&amp;gt; N_{h-1} + N_{h-2} \\
	&amp;amp;&amp;gt; F_h \\
	&amp;amp;= \frac{\phi^h}{\sqrt{5}} 
  \end{align*}
$$
&lt;/center&gt;
&lt;p&gt;Solving for &lt;script type=&quot;math/tex&quot;&gt;h&lt;/script&gt; which is what we want to bound:&lt;/p&gt;
&lt;center&gt;
$$
  \begin{align*}
  	\log_{\phi}(N_h) &amp;amp;&amp;gt; \log_{\phi}(\frac{\phi^h}{\sqrt{5}}) \\
	h &amp;amp;&amp;lt; 1.440\log(N_h)
  \end{align*}
$$
&lt;/center&gt;
&lt;p&gt;Therefore, AVL trees are balanced as we wanted to show.
&lt;br /&gt;
Note: There is also another way to solve the recurrence besides using Fibonacci. Note that:&lt;/p&gt;
&lt;center&gt;
$$
  \begin{align*}
  $N_h &amp;amp;= 1 + N_{h-1} + N_{h-2} \\
  	&amp;amp;&amp;gt; 1 + 2N_{h-2} \\
  	&amp;amp;&amp;gt; 2N_{h-2} \\
	&amp;amp;= \theta(2^{h/2}) \\
	h &amp;amp;&amp;lt; 2\log(N_h)
  \end{align*}
$$
&lt;/center&gt;
&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Mainting the AVL tree property&lt;/b&gt;&lt;br /&gt;
To insert in an AVL tree, we just insert like we do in a binary search tree. After that we need to fix up the tree to maintain its AVL property. To do so, we use &lt;a href=&quot;https://strncat.github.io/jekyll/update/2019/05/02/binary-tree-rotation.html&quot;&gt;rotations&lt;/a&gt; but there are multiple cases to handle.
&lt;br /&gt;
&lt;br /&gt;
Assume we have the following tree on the left. We define the height of a nil node to be -1. We want to insert the node 13. We insert the way we do in a binary search tree to get the tree on the right:&lt;/p&gt;

&lt;svg width=&quot;800&quot; height=&quot;450&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;621.5&quot; cy=&quot;55.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;597.5&quot; y=&quot;61.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;11 (3)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;553.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;534.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;5 (1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;red&quot; fill-opacity=&quot;0.25&quot; cx=&quot;688.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;664.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;23 (2)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;613.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;589.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;13 (0)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;658.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;634.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;17 (1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;173.5&quot; cy=&quot;55.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;149.5&quot; y=&quot;61.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;11 (2)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;100.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;81.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;5 (1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;237.5&quot; cy=&quot;137.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;213.5&quot; y=&quot;143.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;23 (1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;64.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;45.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;3 (0)&lt;/text&gt;
	&lt;text x=&quot;349.5&quot; y=&quot;132.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;---(13)---&amp;gt;&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;213.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;189.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;17 (0)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; cx=&quot;506.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;487.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;3 (0)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;582.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;554.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;34.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;6.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;100.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;72.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;141.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;113.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;680.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;652.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;727.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;699.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;543.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;515.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;471.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;443.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;284.5&quot; cy=&quot;228.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;256.5&quot; y=&quot;234.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;173.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;145.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;247.5&quot; cy=&quot;316.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;219.5&quot; y=&quot;322.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;582.5&quot; cy=&quot;401.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;554.5&quot; y=&quot;407.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;ellipse stroke=&quot;black&quot; stroke-width=&quot;1&quot; fill=&quot;gray&quot; fill-opacity=&quot;0.25&quot; cx=&quot;648.5&quot; cy=&quot;403.5&quot; rx=&quot;30&quot; ry=&quot;30&quot; /&gt;
	&lt;text x=&quot;620.5&quot; y=&quot;409.5&quot; font-family=&quot;Times New Roman&quot; font-size=&quot;20&quot;&gt;Nil(-1)&lt;/text&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;640.482,78.731 669.518,114.269&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;669.518,114.269 668.328,104.91 660.585,111.237&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;602.35,78.593 572.65,114.407&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;572.65,114.407 581.606,111.441 573.908,105.058&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;679.107,165.992 667.893,200.008&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;667.893,200.008 675.146,193.976 665.649,190.845&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;191.958,79.149 219.042,113.851&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;219.042,113.851 218.061,104.468 210.178,110.62&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;89.464,165.396 75.536,200.604&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;75.536,200.604 83.128,195.004 73.829,191.325&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;153.552,77.907 120.448,115.093&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;120.448,115.093 129.502,112.442 122.033,105.793&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;229.85,166.508 221.15,199.492&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;221.15,199.492 228.025,193.031 218.356,190.481&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;562.609,166.084 573.391,199.916&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;573.391,199.916 575.726,190.776 566.198,193.812&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;644.841,255.21 627.159,289.79&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;627.159,289.79 635.253,284.943 626.349,280.39&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;539.733,164.155 520.267,201.845&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;520.267,201.845 528.38,197.032 519.495,192.443&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;54.82,256.895 44.18,288.105&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;44.18,288.105 51.494,282.146 42.029,278.919&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;54.82,256.895 44.18,288.105&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;44.18,288.105 51.494,282.146 42.029,278.919&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;75.859,256.266 89.141,288.734&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;89.141,288.734 90.74,279.436 81.484,283.222&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;112.823,164.852 129.177,201.148&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;129.177,201.148 130.449,191.8 121.332,195.908&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;700.318,165.074 715.682,200.926&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;715.682,200.926 717.127,191.603 707.935,195.542&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;665.776,257.604 673.224,287.396&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;673.224,287.396 676.134,278.422 666.433,280.847&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;495.413,256.376 482.587,288.624&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;482.587,288.624 490.19,283.038 480.898,279.342&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;518.128,256.155 531.872,288.845&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;531.872,288.845 533.381,279.532 524.162,283.408&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;251.267,164.155 270.733,201.845&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;270.733,201.845 271.505,192.443 262.62,197.032&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;224.312,256.484 236.688,288.516&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;236.688,288.516 238.469,279.252 229.141,282.856&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;201.086,255.811 185.914,289.189&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;185.914,289.189 193.776,283.975 184.673,279.837&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;624.697,344.332 637.303,375.668&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;637.303,375.668 638.956,366.38 629.679,370.112&quot; /&gt;
	&lt;polygon stroke=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;603.221,344.684 592.779,373.316&quot; /&gt;
	&lt;polygon fill=&quot;black&quot; stroke-width=&quot;1&quot; points=&quot;592.779,373.316 600.217,367.513 590.823,364.087&quot; /&gt;
&lt;/svg&gt;

&lt;p&gt;We go up the tree to find the first node where it violates the AVL property meanning that the height of the left and right children differ by more than 1. The first node is 23.&lt;/p&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Running Time:&lt;/b&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;fix_up&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// assume the current node inserted was x&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;// the idea is to go up the tree, searching for the first violating node&lt;/span&gt;
    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Detailed Implementation:&lt;/b&gt; 
-&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 References:&lt;/b&gt; 
https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-6-avl-trees-avl-sort/&lt;/p&gt;</content><author><name></name></author><summary type="html">1 Introduction Let’s define some important terms: Height of a node: longest path from the node to a leaf. To compute the height, we simply take the maximum height of the left and right children and add 1. Height of a binary search tree: is the length of the longest path from the root to a leaf. A tree is balanced if if its height is .</summary></entry><entry><title type="html">C Bits</title><link href="http://localhost:4000/jekyll/update/2019/04/24/c-bits.html" rel="alternate" type="text/html" title="C Bits" /><published>2019-04-24T12:01:36-07:00</published><updated>2019-04-24T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/04/24/c-bits</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/04/24/c-bits.html">&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 sizeof&lt;/b&gt;&lt;br /&gt;
sizeof is determind at compiled time. So&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot; data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// returns 1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;!------------------------------------------------------------------------------------&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">1 sizeof sizeof is determind at compiled time. So int a[3] = {1,2,3}; char *p = a; printf(&quot;%d\n&quot;, sizeof(p)); // returns 1</summary></entry></feed>