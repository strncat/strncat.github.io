<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Breadth First Search | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Breadth First Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="1 Introduction Dijkstra solves the single source shortest weighted path problem in a weighted graph with non-negative edge weights. But what if we have multiple sources and we want to find the shortest distance to ANY of the sources? We can also use Dijkstra! 2 Example Say we have the following grid and want to find the distance from any cell to a cell that has “1”. 0001 0011 0110 We can just run Dijkstra with the modification that we have many sources initially in the queue with distance 0. After running the modified Dijkstra, we’ll get the following array of distances! 3210 2101 1001 3 Algorithm void multibfs() { Initialize a priorty queue q and all the sources Initialize a distance array with INF for all nodes while (q is not empty) { node u = q.top() // pop a node from the queue // for each neighbor, in the above example (4 directions top, bottom, right, left) for every neighbor v of u { if (distance[v] &gt; distance[u] + 1) { distance[v] = distance[u] + 1; // in c++ we don&#39;t have a decrease key but there is a workaround! check the full implementation q.decrease_key(distance[v], v); } } } // distances now have the short distances } 4 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/multiple-source-bfs.cpp" />
<meta property="og:description" content="1 Introduction Dijkstra solves the single source shortest weighted path problem in a weighted graph with non-negative edge weights. But what if we have multiple sources and we want to find the shortest distance to ANY of the sources? We can also use Dijkstra! 2 Example Say we have the following grid and want to find the distance from any cell to a cell that has “1”. 0001 0011 0110 We can just run Dijkstra with the modification that we have many sources initially in the queue with distance 0. After running the modified Dijkstra, we’ll get the following array of distances! 3210 2101 1001 3 Algorithm void multibfs() { Initialize a priorty queue q and all the sources Initialize a distance array with INF for all nodes while (q is not empty) { node u = q.top() // pop a node from the queue // for each neighbor, in the above example (4 directions top, bottom, right, left) for every neighbor v of u { if (distance[v] &gt; distance[u] + 1) { distance[v] = distance[u] + 1; // in c++ we don&#39;t have a decrease key but there is a workaround! check the full implementation q.decrease_key(distance[v], v); } } } // distances now have the short distances } 4 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/multiple-source-bfs.cpp" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/06/20/bfs.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/06/20/bfs.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-06-20T12:01:36-07:00" />
<script type="application/ld+json">
{"description":"1 Introduction Dijkstra solves the single source shortest weighted path problem in a weighted graph with non-negative edge weights. But what if we have multiple sources and we want to find the shortest distance to ANY of the sources? We can also use Dijkstra! 2 Example Say we have the following grid and want to find the distance from any cell to a cell that has “1”. 0001 0011 0110 We can just run Dijkstra with the modification that we have many sources initially in the queue with distance 0. After running the modified Dijkstra, we’ll get the following array of distances! 3210 2101 1001 3 Algorithm void multibfs() { Initialize a priorty queue q and all the sources Initialize a distance array with INF for all nodes while (q is not empty) { node u = q.top() // pop a node from the queue // for each neighbor, in the above example (4 directions top, bottom, right, left) for every neighbor v of u { if (distance[v] &gt; distance[u] + 1) { distance[v] = distance[u] + 1; // in c++ we don&#39;t have a decrease key but there is a workaround! check the full implementation q.decrease_key(distance[v], v); } } } // distances now have the short distances } 4 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/multiple-source-bfs.cpp","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/06/20/bfs.html","headline":"Breadth First Search","dateModified":"2019-06-20T12:01:36-07:00","datePublished":"2019-06-20T12:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/06/20/bfs.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Breadth First Search</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-06-20T12:01:36-07:00" itemprop="datePublished">Jun 20, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><b>1 Introduction</b>
<br />
Dijkstra solves the single source shortest weighted path problem in a weighted graph with non-negative edge weights. But what if we have multiple sources and we want to find the shortest distance to ANY of the sources? We can also use Dijkstra!
<br />
<br />
<!------------------------------------------------------------------------------------>
<b>2 Example</b>
<br />
Say we have the following grid and want to find the distance from any cell to a cell that has “1”.</p>
<table>
	<tr><td>0</td><td>0</td><td>0</td><td>1</td></tr>
    <tr><td>0</td><td>0</td><td>1</td><td>1</td></tr>
    <tr><td>0</td><td>1</td><td>1</td><td>0</td></tr>
</table>
<p>We can just run Dijkstra with the modification that we have many sources initially in the queue with distance 0.
After running the modified Dijkstra, we’ll get the following array of distances!</p>
<table>
	<tr><td>3</td><td>2</td><td>1</td><td>0</td></tr>
    <tr><td>2</td><td>1</td><td>0</td><td>1</td></tr>
    <tr><td>1</td><td>0</td><td>0</td><td>1</td></tr>
</table>
<!------------------------------------------------------------------------------------>
<p><b>3 Algorithm</b>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">multibfs</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Initialize</span> <span class="n">a</span> <span class="n">priorty</span> <span class="n">queue</span> <span class="n">q</span> <span class="n">and</span> <span class="n">all</span> <span class="n">the</span> <span class="n">sources</span>
    <span class="n">Initialize</span> <span class="n">a</span> <span class="n">distance</span> <span class="n">array</span> <span class="n">with</span> <span class="n">INF</span> <span class="k">for</span> <span class="n">all</span> <span class="n">nodes</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">q</span> <span class="n">is</span> <span class="n">not</span> <span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">top</span><span class="p">()</span>
        <span class="c1">// pop a node from the queue</span>
        <span class="c1">// for each neighbor, in the above example (4 directions top, bottom, right, left)</span>
        <span class="k">for</span> <span class="n">every</span> <span class="n">neighbor</span> <span class="n">v</span> <span class="n">of</span> <span class="n">u</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="c1">// in c++ we don't have a decrease key but there is a workaround! check the full implementation</span>
                <span class="n">q</span><span class="p">.</span><span class="n">decrease_key</span><span class="p">(</span><span class="n">distance</span><span class="p">[</span><span class="n">v</span><span class="p">],</span> <span class="n">v</span><span class="p">);</span> 
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
	<span class="c1">// distances now have the short distances</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>4 Full Implementation:</b> 
https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/shortest-paths/multiple-source-bfs.cpp</p>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html</p>


  </div><a class="u-url" href="/jekyll/update/2019/06/20/bfs.html" hidden></a>
</article>

      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello.</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
