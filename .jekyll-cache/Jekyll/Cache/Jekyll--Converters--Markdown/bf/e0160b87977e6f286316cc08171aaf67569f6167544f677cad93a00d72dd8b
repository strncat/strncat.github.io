I"rf<p><img src="http://localhost:4000/assets/trees/binary-search-trees/binary-search-tree.png" width="100%" />
A binary search tree is a binary tree that maintains the binary-search-tree property for every node in the tree. The <b>binary-search-tree property</b> states that given a node \(x\) in the tree, every node in the left subtree has a key less than \(x\)’s key and every node in the right subtree has a key greater than \(x\)’s key.
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Motivation&lt;/h3&gt;
But why invent another data structure? Let's take a look at sorted arrays. We can search a sorted array for keys in just $$O(\log(n))$$ time with binary search. However, inserting and deleting elements takes $$O(n)$$ time. Similarly, while inserting elements in a linked list takes only $$O(1)$$ time, searching a linked list takes $$O(n)$$ time in the worst case. Can we do better with binary search trees? yes!
<br /><br />
The binary search tree property is really great at allowing us to insert/search and delete in just $$O(h)$$ time since we can eliminate a branch at every single step. Moreover, if the tree is balanced, the height will only be $$O(\log(n))$$ where is $$n$$ is the number of nodes. Overall, this is a much better data structure for dynamic data than both arrays and linked lists!
<br />
<br />
<!------------------------------------------------------------------------------------>
<h4><b>In Order Walk&lt;/h3&gt;
Another great property of binary search trees is that an in order walk of the tree results in getting all the keys sorted. 
<!---------------------->

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">in_order_walk</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">in_order_walk</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
    <span class="n">print</span> <span class="n">key</span>
    <span class="nf">in_order_walk</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<!---------------------->
Proving that it takes $$O(n)$$ time to perform the in order walk is such a great way to practice the substitution method. (TODO: add proof)
<br />
<br />
<!------------------------------------------------------------------------------------>
<h4><b>Search&lt;/h3&gt;
Similar to the in-order walk, we can simply perform a search by using the following
<!---------------------->

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">tree</span><span class="o">*</span> <span class="nf">search</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">!=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<br />
<!------------------------------------------------------------------------------------>
<h4><b>Minimum, Maximum, Predecessor and Successor&lt;/h3&gt;
Similarly, we can find the minimum and maximum by traversing all the way to the left and all the way to the right respectively. For example to find the successor of a node $$x$$, we have two cases:
- If $$x$$ has a right subtree, then the most left element (tree minimum) of the right subtree is the successor. 
- If $$x$$ doesn't have a right subtree, then the next element would be the first ancestor such that $$x$$ is a left child of it. 
<!---------------------->

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">tree</span><span class="o">*</span> <span class="nf">successor</span><span class="p">(</span><span class="n">tree</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span>  <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">tree_minimum</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="c1">// otherwise, find the closest parent where t is a left child</span>
    <span class="n">tree</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<br />
 <!------------------------------------------------------------------------------------>
 <h4><b>Insert&lt;/h3&gt;
Inserting a node into a binary search tree is pretty simple. We need to follow the following steps:
- Create a new node and assign both the left and right pointers to NULL.
- Similar to search, descend in the tree with pointer $$current$$ based on the key value, while keeping a trailing pointer $$p$$ to its parent. Once we hit NULL, we know that the $$p$$ will be the parent of our node.
The figure below illustrates the process:
<img src="http://localhost:4000/assets/trees/binary-search-trees/insert.png" width="100%" />
<!---------------------->

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">tree</span> <span class="o">**</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// create a new node x</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">current</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">x</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// x is now the root!</span>
        <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
 <span class="p">}</span></code></pre></figure>

<br />
<!------------------------------------------------------------------------------------>
<h4><b>Delete&lt;/h3&gt;
Before discussing delete, we'll present a helper function that we will use in deleting a node in a binary search three. <i>transplant</i> replaces a subtree rooted at $$x$$ with another subtree rooted at $$v$$, illustrated below, 
<img src="http://localhost:4000/assets/trees/binary-search-trees/transplant.png" width="100%" />

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// replace subtree u with subtree v</span>
<span class="kt">void</span> <span class="nf">transplant</span><span class="p">(</span><span class="n">tree</span> <span class="o">**</span><span class="n">t</span><span class="p">,</span> <span class="n">tree</span> <span class="o">*</span><span class="n">u</span><span class="p">,</span> <span class="n">tree</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">u</span><span class="p">.</span><span class="n">parent</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is the root </span>
        <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is a left child</span>
        <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">u</span> <span class="o">==</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">u</span><span class="p">.</span><span class="n">parent</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// fix v's parent pointer</span>
        <span class="n">v</span><span class="p">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">u</span><span class="p">.</span><span class="n">parent</span>
    <span class="p">}</span>
 <span class="p">}</span></code></pre></figure>


Now, suppose we're about to delete node $$x$$ and that are given a pointer to it
We have four different cases that we need to handle:
- $$x$$ has no children. We then can simply delete that node and return. This case could be handled implicitly in the next case. 
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-1.png" width="100%" />

- $$x$$ has only one child. We then just transplant its child at $$x$$'s parent and remove $$x$$.
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-2.png" width="100%" />

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// one child case</span>
<span class="c1">// delete node x if x has only one child</span>
<span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// no left child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1">// replace x with its right child</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is a left child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1">// replace x with its left child</span>
<span class="p">}</span>
<span class="c1">// we're good to remove x's memory using "free" or "delete" or whatever we need</span></code></pre></figure>


- $$x$$ has two children. The idea here is that the successor of $$x$$ will take $$x$$'s place to maintain the binary search tree property and then we can just delete $$x$$. We do know that the successor is the most left child (minimum node) in $$x$$'s right subtree. Let $$s$$ be the successor of $$x$$. It is also important to note that $$s$$ can't have left children since it is the most left node by definition. We now break deleting $$x$$ into two sub-cases:

(1) $$s$$ is the right child of $$x$$.  In this case, we transplant $$s$$ at $$x$$'s parent. We also move $$x$$'s left subtree to be $$s$$'s left subtree. We then we remove $$x$$. 
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-3.png" width="100%" />

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// two children first sub-case (s is a right child of x)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s is x's immediate right child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// replace x with s</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> <span class="c1">// s's left subtree = x's left subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
<span class="p">}</span></code></pre></figure>

<br />
(2) $$s$$ is in the left subtree of $$x$$'s right child. In this case, it's a little more complicated. We first want to replace $$s$$ (21 in the example) with its right subtree (25 in the example) (remember $$s$$ can't have a left subtree). We then assign $$x$$'s right subtree to be $$s$$'s right subtree. So now the subtree 29 is the right child of 21. Finally just like in the earlier case, simply replace $$x$$ with its right subtree. In this example, it means to replace 19 with 21!
<img src="http://localhost:4000/assets/trees/binary-search-trees/delete-4.png" width="100%" />

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// two children second sub-case (s is not right child of x)</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s is not x's immediate right child</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">right</span><span class="p">);</span> <span class="c1">// replace s with its right subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span> <span class="c1">// s's right subtree = x's right subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
<span class="p">}</span>
<span class="c1">// repeat steps from above to replace x with its right child (s)</span>
<span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// replace x with s</span>
<span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> <span class="c1">// s's left subtree is now x's left subtree</span>
<span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span></code></pre></figure>

<br />
Finally putting everything together in one place:

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">delete</span><span class="p">(</span><span class="n">tree</span> <span class="o">**</span><span class="n">t</span><span class="p">,</span> <span class="n">tree</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// one child case</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// no left child</span>
        <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">)</span> <span class="c1">// replace x with its right child</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// u is a left child</span>
        <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">.</span><span class="n">left</span><span class="p">)</span> <span class="c1">// replace x with its left child</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// two children second sub-case (s is not right child of x)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">right</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// s is not x's immediate right child</span>
        <span class="n">transplant</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">right</span><span class="p">);</span> <span class="c1">// replace s with its right subtree</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span> <span class="c1">// s's right subtree = x's right subtree</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
    <span class="p">}</span>
    <span class="n">transplant</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// replace x with s</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span> <span class="c1">// s's left subtree is now x's left subtree</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// we also fix its parent pointer </span>
<span class="p">}</span></code></pre></figure>

<br />
<!------------------------------------------------------------------------------------>
<h4><b>Implementation&lt;/h3&gt;
<a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/binary-search-tree.cpp">Source Code</a>
<!------------------------------------------------------------------------------------>
<h4><b>References&lt;/h3&gt;
CLRS





















</b></h4></b></h4></b></h4></b></h4></b></h4></b></h4></b></h4></b></h4>
:ET