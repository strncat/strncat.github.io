<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-03-29T20:53:43-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strcat’s notebook</title><subtitle>Hello.</subtitle><entry><title type="html">10154 - Weights and Measures</title><link href="http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures.html" rel="alternate" type="text/html" title="10154 - Weights and Measures" /><published>2019-03-29T12:01:36-07:00</published><updated>2019-03-29T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/29/10154-weights-and-measures.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry><entry><title type="html">10069 - Distinct Subsequences</title><link href="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html" rel="alternate" type="text/html" title="10069 - Distinct Subsequences" /><published>2019-03-27T12:01:36-07:00</published><updated>2019-03-27T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/27/10069-distinct-subsequences.html">&lt;p&gt;&lt;b&gt;Solution&lt;/b&gt;
&lt;br /&gt;
To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”.
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
 c[p] = \sum_i\left\{\begin{array}{@{}lr@{}}
        \sum_{j &amp;lt; i}c[p_0...p_{i-1}] &amp;amp; \text{if }x_i = p_i\\
        0                       &amp;amp; \text{otherwise} 
        \end{array}\right\}
$$
&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Why does this work?&lt;/b&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be a string and let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be the string we want to count the occurences of in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;. Let &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; be the length of &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. Assume that we know the optimal count of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and suppose toward a contradiction that the count of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n}&lt;/script&gt; is not optimal. Since there are more ocurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt;, then naturally this means that there are more ocurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n}&lt;/script&gt;. This is a contradiction because we assumed that the number of occurrences of &lt;script type=&quot;math/tex&quot;&gt;p_0...p_{n-1}&lt;/script&gt; is optimal. Therefore our solution must be optimal.
&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Implementation Details&lt;/b&gt;
&lt;br /&gt;
Base Case: Let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be a string and let &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; be the string that we are looking for. We initialize an array &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; to store 1 if we see &lt;script type=&quot;math/tex&quot;&gt;p[0]&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; otherwise, we store 0.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;From this point, we iterate through &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; starting at index &lt;script type=&quot;math/tex&quot;&gt;i=1&lt;/script&gt; and apply the above recurrence. At each step we need row “i-1” to produce row “i”. Instead of maintaining two arrays or a two dimensional array, we simply maintain a sum variable to keep track of the sum of the previous row and also reset the cells as we go. 
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// starting matching p[i] at i&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;bignum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;j&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;b&gt;Example&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;g&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;i=0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;i=2&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;</content><author><name></name></author><summary type="html">Solution To come up with a dynamic programming solution, we ask the question, given that we know the optimal count to the string “ba” in “babgbag”. How can we use this solution to find the optimal count for “bag”. We simply iterate through the string and whenever we see the letter “g”, then the number of “bag”s seen so far would be the number of “ba”s seen so far before the current “g”. The total number of ocurrences of “bag” is then the sum of all the “ba”s seen before each “g”. $$ c[p] = \sum_i\left\{\begin{array}{@{}lr@{}} \sum_{j &amp;lt; i}c[p_0...p_{i-1}] &amp;amp; \text{if }x_i = p_i\\ 0 &amp;amp; \text{otherwise} \end{array}\right\} $$ Why does this work? Let be a string and let be the string we want to count the occurences of in . Let be the length of . Assume that we know the optimal count of in and suppose toward a contradiction that the count of is not optimal. Since there are more ocurrences of , then naturally this means that there are more ocurrences of . This is a contradiction because we assumed that the number of occurrences of is optimal. Therefore our solution must be optimal. Implementation Details Base Case: Let be a string and let be the string that we are looking for. We initialize an array to store 1 if we see in otherwise, we store 0.</summary></entry><entry><title type="html">10003 - Cutting Sticks</title><link href="http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks.html" rel="alternate" type="text/html" title="10003 - Cutting Sticks" /><published>2019-03-25T12:01:36-07:00</published><updated>2019-03-25T12:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2019/03/25/10003-cutting-sticks.html">&lt;p&gt;Given that we have an optimal value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. Then we know that we must have the following:
&lt;br /&gt;&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$
&lt;/div&gt;
&lt;p&gt;Why is this true?
Imagine that we know the last cut we made in an optimal solution was a cut at position &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; but &lt;script type=&quot;math/tex&quot;&gt;opt[i,m]&lt;/script&gt; wasn’t the optimal solution for a cut of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt;. Then we can use the new lower value for a stick of length &lt;script type=&quot;math/tex&quot;&gt;m-i&lt;/script&gt; and derive even a lower value for &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; which is a contradiction since we already assumed that &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; is an optimal vlue for a stick of length &lt;script type=&quot;math/tex&quot;&gt;j-i&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;
Suppose we have the cuts &lt;script type=&quot;math/tex&quot;&gt;c_0,c_1,c_2,...c_n&lt;/script&gt;. Then for any stick of length &lt;script type=&quot;math/tex&quot;&gt;c_i-c_{i-1}&lt;/script&gt;, there are no possible cuts possible and therefore, the optimal cut cost is simply 0.
&lt;br /&gt;
&lt;br /&gt;
Note that we don’t need to compute any subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;i &gt; j&lt;/script&gt; since a stick has a positive length. Also note in order to compute subproblem &lt;script type=&quot;math/tex&quot;&gt;opt[i,j]&lt;/script&gt;, we need to compute &lt;script type=&quot;math/tex&quot;&gt;opt[i,k]&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;opt[k,j]&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Inline-style: 
&lt;img src=&quot;https://github.com/strncat/strncat.github.io/blob/master/_posts/img.jpeg&quot; alt=&quot;alt text&quot; title=&quot;Logo Title Text 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;</content><author><name></name></author><summary type="html">Given that we have an optimal value for a stick of length . Then we know that we must have the following: $$ opt[i,j] = \min_i{opt[i,k]+opt[k,j]} + j-i $$ Why is this true? Imagine that we know the last cut we made in an optimal solution was a cut at position but wasn’t the optimal solution for a cut of length . Then we can use the new lower value for a stick of length and derive even a lower value for which is a contradiction since we already assumed that is an optimal vlue for a stick of length . Suppose we have the cuts . Then for any stick of length , there are no possible cuts possible and therefore, the optimal cut cost is simply 0. Note that we don’t need to compute any subproblem where since a stick has a positive length. Also note in order to compute subproblem , we need to compute and .</summary></entry></feed>