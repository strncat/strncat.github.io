<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Bellman-Ford’s Shortest Paths | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Bellman-Ford’s Shortest Paths" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Hello" />
<meta property="og:description" content="Hello" />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/04/04/bellman-ford.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/04/04/bellman-ford.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-04T07:01:36-07:00" />
<script type="application/ld+json">
{"description":"Hello","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/04/04/bellman-ford.html","headline":"Bellman-Ford’s Shortest Paths","dateModified":"2019-04-04T07:01:36-07:00","datePublished":"2019-04-04T07:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/04/04/bellman-ford.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Bellman-Ford&#39;s Shortest Paths</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-04-04T07:01:36-07:00" itemprop="datePublished">Apr 4, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <!--
<svg width="800" height="600" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="140.5" cy="193.5" rx="30" ry="30"/>
	<text x="136.5" y="199.5" font-family="Times New Roman" font-size="20">s</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="291.5" cy="104.5" rx="30" ry="30"/>
	<text x="287.5" y="110.5" font-family="Times New Roman" font-size="20">a</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="489.5" cy="104.5" rx="30" ry="30"/>
	<text x="484.5" y="110.5" font-family="Times New Roman" font-size="20">b</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="634.5" cy="200.5" rx="30" ry="30"/>
	<text x="631.5" y="206.5" font-family="Times New Roman" font-size="20">t</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="291.5" cy="279.5" rx="30" ry="30"/>
	<text x="287.5" y="285.5" font-family="Times New Roman" font-size="20">c</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="489.5" cy="279.5" rx="30" ry="30"/>
	<text x="484.5" y="285.5" font-family="Times New Roman" font-size="20">d</text>
	<polygon stroke="black" stroke-width="1" points="166.345,178.267 265.655,119.733"/>
	<text x="220.5" y="170.5" font-family="Times New Roman" font-size="20">6</text>
	<polygon stroke="black" stroke-width="1" points="166.569,208.347 265.431,264.653"/>
	<text x="201.5" y="257.5" font-family="Times New Roman" font-size="20">4</text>
	<polygon stroke="black" stroke-width="1" points="321.5,104.5 459.5,104.5"/>
	<text x="382.5" y="125.5" font-family="Times New Roman" font-size="20">-3</text>
	<polygon stroke="black" stroke-width="1" points="609.486,183.939 514.514,121.061"/>
	<text x="567.5" y="143.5" font-family="Times New Roman" font-size="20">-4</text>
	<polygon stroke="black" stroke-width="1" points="321.5,279.5 459.5,279.5"/>
	<text x="385.5" y="300.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="515.844,265.147 608.156,214.853"/>
	<text x="547.5" y="230.5" font-family="Times New Roman" font-size="20">2</text>
</svg>
-->

<p><img src="http://localhost:4000/assets/bellman/1.png" width="100%" />
<b>0 References</b><br />
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>1 Introduction</b>
<br />
Let <script type="math/tex">G=(V,E)</script> be a weighted graph with <script type="math/tex">V</script> vertices and <script type="math/tex">E</script> edges. We already discussed Dijkstra’s algorithm to find the shortest paths in <script type="math/tex">O(n\log(n)+m)</script> time. Dijkstra is fast and works great but unfortunately it doesn’t handle negative edge weights. Therefore, we now turn to discuss Bellman Ford’s algorithm.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>2 Bellman-Ford</b>
<br />
Bellman-Ford is a dynamic programming algorithm to find the shortest paths in a graph <script type="math/tex">G</script> from a given source vertex <script type="math/tex">s</script>. Since it’s a dynamic programming algorithm then this means that we must have some recursive substructure where a solution to the problem includes solutions within it to smaller subproblems.
<br /><br />
Let <script type="math/tex">D[v,i]</script> be the length of the shortest path from <script type="math/tex">s</script> to some vertex <script type="math/tex">v</script> whose number of edges is at most <script type="math/tex">i</script>. Given that we know <script type="math/tex">D[v,i]</script> for all <script type="math/tex">v \in V</script>, what can we say about <script type="math/tex">D[v,i+1]</script>? In other words, given that we know the shortest path from <script type="math/tex">s</script> to any vertex in <script type="math/tex">v</script> with at most <script type="math/tex">i</script> edges, what can we say about the length of the shortest path from <script type="math/tex">s</script> to some vertex <script type="math/tex">v</script> with at most <script type="math/tex">i+1</script> edges? Let’s think about this before looking at the answer. Bellman-Ford definitely wasn’t easy for me to think about.
<br /><br />
<img src="http://localhost:4000/assets/bellman/2.png" width="100%" />
Consider the graph above and let’s assume that we already know all the shortest paths of at most 2 edges from <script type="math/tex">s</script> to any vertex in <script type="math/tex">G</script>. So for example we know that <script type="math/tex">D[a,2]=6</script>, <script type="math/tex">D[b,2]=8</script>, <script type="math/tex">D[c,2]=4</script> and <script type="math/tex">D[t,2]=7</script>. So now we know the shortest distance from <script type="math/tex">s</script> to <script type="math/tex">t</script> of at most two edges is 7. Can we get a shorter path by considering any path that uses 3 edges? Yes!!! we can use the shortest path from <script type="math/tex">s</script> to <script type="math/tex">b</script> instead of length 8 and then take in <script type="math/tex">(b,t)=-4</script> to get a shorter path of length 4. In other words, forget about the path <script type="math/tex">s->c->t</script> and go through <script type="math/tex">s->a->b->t</script>. How can we put this together formally? 
<br /><br />
Give a vertex <script type="math/tex">v \in V</script>. To find <script type="math/tex">D[v,i+1]</script>, we need to see if for any vertex <script type="math/tex">u \in V</script>, the length of the shortest path from <script type="math/tex">s</script> to <script type="math/tex">u</script> of at most <script type="math/tex">i</script> edges (in other words <script type="math/tex">D[u, i]</script>) plus <script type="math/tex">w(u,v)</script> has a lower value than we currently have in <script type="math/tex">D[v,i]</script>. More formally,</p>
<div center="">
$$
\begin{align*}
 D[v,i+1] =\min \Big\{ \begin{array}{@{}lr@{}}
        D[v, i]\\
        \min_{\{u,v\}\in E} D[u,i] + w(u,v) \\
        \end{array}
\end{align*}
$$
</div>
<p>With the base case that for <script type="math/tex">i = 0</script>, <script type="math/tex">D[s,0]=0</script> and <script type="math/tex">D[v,0]=\infty</script> for all <script type="math/tex">v \in V-\{s\}</script>. 
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>3 Bellman-Ford and Dijkstra</b>
<br />
So what is the relationship between Bellman-Ford and Dijkstra? are they connected in any way? Let’s think about this. We know that  in every iteration of Dijkstra’s algorithm, we pick the node with the smallest estimate and then check all immediate neighbors to see whether there is a shorter path that goes through any of the neighbors. Dijkstra smartly picks the right vertex in every iteration. However, in Bellman-Ford, we just check all of vertices every single iteration! so it’s slower but now we can find the shortest paths in graphs with negative edges.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>4 Implementation</b>
<br /></p>

<p><br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>5 Example</b><br /></p>

<p>We initialize the following forests <script type="math/tex">\{a\}, \{b\}, \{c\}, \{d\}, \{e\}, \{f\}</script>. We also sort the edges by non-decreasing weight and proceed to merge our forests. Assume the sorted order is the following: <script type="math/tex">\{a,b\}, \{b,f\}, \{a,f\}, \{e,d\}, \{c,e\}, \{b,c\}, \{c,f\}, \{f,e\}, \{c,d\}</script>
<br /><br />
<i>Iteration 0</i><br />
The first edge to consider is either <script type="math/tex">\{a,b\}</script>. Since <script type="math/tex">a</script> and <script type="math/tex">b</script> are not in the same set, we add the edge to the MST and combine both <script type="math/tex">a</script> and <script type="math/tex">b</script>.</p>

<p><i>Iteration 1</i><br />
We next consider  <script type="math/tex">\{b,f\}</script>. Since <script type="math/tex">b</script> and <script type="math/tex">f</script> are not in the same set, we add the edge to the MST and combine both <script type="math/tex">b</script> and <script type="math/tex">f</script>. So now we have the following forests: <script type="math/tex">\{a, b, f\}, \{c\}, \{d\}, \{e\}</script></p>

<p><i>Iteration 2</i><br />
We next consider  <script type="math/tex">\{a,f\}</script>. Since <script type="math/tex">a</script> and <script type="math/tex">f</script> are in the same set, we don’t combine the nodes and don’t add the edge to the MST.</p>

<p>At the end of the algorithm, the minimum spanning tree is the following tree:</p>

<p><br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>6 Proof of Correctness</b><br /></p>

<table>
  <tbody>
    <tr>
      <td>Theorem: Kruskal will correctly find a minimum spanning tree</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> <br />
<b>Inductive Hypothesis: </b>After adding the <script type="math/tex">t</script>‘th edge, there exists an MST with the edges added so far.
<br /></p>

<p><b>Base Case: </b> After adding the 0’th edge, there exists an MST with the edges added so far.
<br />
<br />
<b>Inductive Step:</b> Suppose the inductive hypothesis holds for <script type="math/tex">t</script>. Let <script type="math/tex">S</script> be the set containing the edges added so far and so there is an MST extending them by the inductive hypothesis. Kruskal adds the next edge that combines two trees <script type="math/tex">T_1</script> and <script type="math/tex">T_2</script> Consider the cut <script type="math/tex">T_1</script> and <script type="math/tex">V-T_1</script>. This cut respects <script type="math/tex">S</script>. By the Lemma above, that edge is safe to add. Therefore, there is still an MST extending the new set of edges.
<br />
<br />
<b>Conclusion:</b> After adding the <script type="math/tex">n-1</script>‘st edge, there exists an MST with the edges added so far. At this point we have reached all vertices and the <script type="math/tex">n-1</script> edges we have is an MST.<script type="math/tex">\blacksquare</script>
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>6 Running Time:</b> <br />
Assume we have <script type="math/tex">n</script> vertices and <script type="math/tex">m</script> edges. First of all, sorting the edges will take time <script type="math/tex">O(m\log(m)) = m\log(n^2) = O(m\log(n))</script>. If radixSort can be utilized then we can do this step in time <script type="math/tex">O(m)</script>. 
<br /><br />
We then have <script type="math/tex">n</script> calls to makeSet, <script type="math/tex">2m</script> calls to find and <script type="math/tex">n</script> calls to union. These operations run in amortized time <script type="math/tex">O(\alpha(n))</script> where <script type="math/tex">\alpha(n)</script> is the inverse Ackerman function and <script type="math/tex">\alpha(n) \leq 4</script> provided that <script type="math/tex">n</script> is smaller than the number of atoms in the universe.
<br /><br />
Therefore, the total time is just <script type="math/tex">O(m\log(n))</script> which is similar to Prim if we use a Red Black Tree and closer to <script type="math/tex">O(m)</script> if we use radixSort.
<br />
<br /></p>
<hr />

<!------------------------------------------------------------------------------------>
<p><br />
<b>7 Full Implementation:</b>
<br />
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/shortest-paths/bellman-ford.cpp
<br />
<br /></p>


  </div><a class="u-url" href="/jekyll/update/2019/04/04/bellman-ford.html" hidden></a>
</article>

		
	 
    	 
		 
		 
      </div>
	  
	  
	  
	 
    </main>
	
	
	 

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
