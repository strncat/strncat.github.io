<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-08-22T14:06:28-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">The Master Theorem</title><link href="http://localhost:4000/jekyll/update/2020/07/18/master-theorem.html" rel="alternate" type="text/html" title="The Master Theorem" /><published>2020-07-18T07:01:36-07:00</published><updated>2020-07-18T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/07/18/master-theorem</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/07/18/master-theorem.html"><![CDATA[<p>In this note, I want to revisit the master theorem along with its proof outline as I’ve learned it in CS161 at Stanford (Professor Mary Wootters).
<br />
<br /></p>
<h4><b>The Master Theorem</b></h4>
<p>Let $T(n) = aT(\frac{n}{b})+O(n^d)$ be a recurrence where $a \geq 1$ and $b \geq 1$. Then,</p>
<div center="">
$$
\begin{align*}
 T(n) = \Bigg \{ \begin{array}{@{}lr@{}}
                     O(n^d\log(n))  \ \text{ if } a = b^d,\\
                     O(n^d) \ \ \quad \quad \text{ if } a &lt; b^d, \\
					 O(n^{\log_b(a)}) \quad \text{ if } a &gt; b^d
        \end{array}
\end{align*}
$$
</div>
<p>If this recurrence represents the running time of an algorithm then,</p>
<ul>
  <li>$a$ is the number of subproblems.</li>
  <li>$b$ is the factor by which the input is decreasing at each level of the recursion.</li>
  <li>$n^d$ is the total time needed to create the subproblems and combine their solutions. 
<br />
<br />
<!-----------------------------------------------------------------------------------></li>
</ul>
<h4><b>Example</b></h4>
<p>We can apply the master theorem on many recurrences. For example, if we’re given,</p>
<div center="">
$$
\begin{align*}
 T(n) = 4T(\frac{n}{2}) + (n).
\end{align*}
$$
</div>
<p>We can quickly see that we have $a = 4$, $b = 2$ and $d = 1$. Therefore, $a &gt; b^d$ and so by using the master theorem, we can see that $T(n) = O(n^{\log_2(4)}) = O(n^2)$.
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Intuition</b></h4>
<p>Why do we have 3 cases and what’s the intuition behind each case? To see this, we discuss three examples, one for each case, starting with case 2.
<br />
<br />
<b>Case 2:</b></p>
<div center="">
$$
\begin{align*}
T(n) &amp;= T(\frac{n}{2}) + n. \quad T(1) = 1.
\end{align*}
$$
</div>
<p>Clearly by the master theorem (case 2), the solution should be $O(n)$. Intuitively, we’re reducing the size of each subproblem by half at each level of the recursion and at the same time, the decrease in the number of subproblem is more than the increase in the number of subproblems. So, the work is dominated by the top level of the recursion tree.
<img src="http://localhost:4000/assets/analysis/master-theorem/1.png" width="100%" />
To be precise, we sum all the work done across all levels and use the geometric series $\sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}$.</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= \sum_{t=0}^{\log(n)} \frac{n}{2^t} \\
&amp;= n\sum_{t=0}^{\log(n)} \big(\frac{1}{2}\big)^t \\
&amp;= n\big(\frac{1/2^{\log(n)+1} - 1}{1/2 - 1}\big) \\
&amp;= -2n\big(1/2^{\log(n)+1} - 1\big) \\
&amp;= -2n\big(\frac{1}{2 (2^{\log(n)})} - 1\big) \\
&amp;= -2n\big(\frac{1}{2n} - 1\big) \\
&amp;= 2n - 1 \\
&amp;= O(n).
\end{align*}
$$
</div>
<p><br />
<br />
<b>Case 3:</b></p>
<div center="">
$$
\begin{align*}
T(n) &amp;= 4T(\frac{n}{2}) + n. \quad T(1) = 1.
\end{align*}
$$
</div>
<p>Again by the master theorem (case 3), the solution should be $O(n^2)$. Intuitively, we’re reducing the size of each subproblem by half at each level of the recursion but at the same time, the number of subproblems is actually increasing by a lot more! So, the work is dominated by the bottom level of recursion tree. Drawing only the first three levels, you can see, the bottom level will carry most of the work
<img src="http://localhost:4000/assets/analysis/master-theorem/2.png" width="100%" />
To be precise, we sum all the work done across all levels and use the geometric series $\sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}$.</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= \sum_{t=0}^{\log(n)} 4^t\frac{n}{2^t} \\
T(n) &amp;= n\sum_{t=0}^{\log(n)} 2^t \\
&amp;= n\big(\frac{2^{\log(n)+1} - 1}{2 - 1}\big) \\
&amp;= n\big(2^{\log(n)+1} - 1\big) \\
&amp;= n\big(2(2^{\log(n)}) - 1\big) \\
&amp;= n\big(2n - 1\big) \\
&amp;= O(n^2).
\end{align*}
$$
</div>
<p><br />
<br />
<b>Case 1:</b></p>
<div center="">
$$
\begin{align*}
T(n) &amp;= 2T(\frac{n}{2}) + n. \quad T(1) = 1.
\end{align*}
$$
</div>
<p>By the master theorem (case 1), the solution should be $O(\log(n))$. Intuitively, we’re reducing the size of the problem by half at each level of the recursion and at the same time, we’re doubling the number of subproblems (balanced case). So, at each level, we have the same amount of work. If we draw only the first three levels, you’ll notice that at each level, we’re doing precisely $n$ total amount of work.
<img src="http://localhost:4000/assets/analysis/master-theorem/3.png" width="100%" />
To make this formal, we sum all the work done across all levels,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= \sum_{t=0}^{\log(n)} 2^t\frac{n}{2^t} = n\sum_{t=0}^{\log(n)} 1 = n\log(n).
\end{align*}
$$
</div>
<p><br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Proof Outline</b></h4>
<p>Why is the master theorem correct? Let’s take a look at the recurrence again,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= aT(\frac{n}{b})+O(n^d) \\
&amp;= aT(\frac{n}{b}) + cn^d.
\end{align*}
$$
</div>
<p>We will assume that $T(1) = 1$ for simplicity. To solve the recurrence, we will use the recursion tree method similar exactly to what we did for <a href="https://strncat.github.io/jekyll/update/2019/07/18/merge-sort-analysis.html">Mergesort</a>. Let’s build the same table that we built for Mergesort to calculate the amount of work done per each level of recursion and get the following,
<br />
<br />
<img src="http://localhost:4000/assets/analysis/master-theorem/summary.png" width="100%" />
<br />
<br />
All we need to do now is to sum the amount of work done for all the levels in the table. We see that,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= \sum_{t=0}^{\log_b(n)} a^t c(\frac{n}{b^t})^d \\
&amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t.
\end{align*}
$$
</div>
<p>So now we can handle each case. <br />
<b>Case 1:</b> $a = b^d$</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{b^d}{b^d})^t \\
&amp;= cn^d \sum_{t=0}^{\log_b(n)} 1 \\
&amp;= cn^d (\log_b(n) + 1) \\
&amp;= cn^d (\frac{\log(n)}{\log(b)} + 1) \\
&amp;= O(n^d\log(n)).
\end{align*}
$$
</div>
<p><br />
<b>Case 2:</b> $a &lt; b^d$</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t
\end{align*}
$$
</div>
<p>We note in the above sum that $\frac{a}{b^d} &lt; 1$. We can then use the geometric series,</p>
<div center="">
$$
\begin{align*}
\sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}.
\end{align*}
$$
</div>
<p>When $|x| &lt; 1$ and the summation is infinite, this sum approaches $\frac{1}{1-x}$. So, $\sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t$ is bounded by $\frac{1}{1-a/b^d}$ which is some constant that doesn’t depend on $n$. Therefore,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t \\
&amp;= O(n^d)
\end{align*}
$$
</div>
<p><br />
<b>Case 3:</b> $a &gt; b^d$</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t
\end{align*}
$$
</div>
<p>We note in the above sum that $\frac{a}{b^d} &gt; 1$. We can then use the geometric series again,</p>
<div center="">
$$
\begin{align*}
\sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}.
\end{align*}
$$
</div>
<p>When $|x| &gt; 1$ and the summation is infinite, this sum approaches the last term in the series. So, $\sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t$ is bounded by $(a/b^d)^{\log_b(b)}$. Therefore,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t \\
&amp;= cn^d\big(\frac{a}{b^d}\big)^{\log_b(n)} \\
&amp;= cn^d\big(b^{\log_b(\frac{a}{b^d})}\big)^{\log_b(n)} \\
&amp;= cn^d\big(b^{\log_b(n)}\big)^{\log_b(\frac{a}{b^d})} \\
&amp;= cn^d\big(n\big)^{\log_b(\frac{a}{b^d})} \\
&amp;= cn^d(n)^{\log_b(a) - \log_b(b^d)} \\
&amp;= cn^d(n)^{\log_b(a) - d} \\
&amp;= c(n)^{d + \log_b(a) - d} \\
&amp;= cn^{\log_b(a)} \\
&amp; = O(n^{\log_b(a)})
\end{align*}
$$
</div>
<p><br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
  <li><a href="http://web.stanford.edu/class/cs161/schedule.html">Stanford CS161</a></li>
  <li>CLRS</li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this note, I want to revisit the master theorem along with its proof outline as I’ve learned it in CS161 at Stanford (Professor Mary Wootters). The Master Theorem Let $T(n) = aT(\frac{n}{b})+O(n^d)$ be a recurrence where $a \geq 1$ and $b \geq 1$. Then, $$ \begin{align*} T(n) = \Bigg \{ \begin{array}{@{}lr@{}} O(n^d\log(n)) \ \text{ if } a = b^d,\\ O(n^d) \ \ \quad \quad \text{ if } a &lt; b^d, \\ O(n^{\log_b(a)}) \quad \text{ if } a &gt; b^d \end{array} \end{align*} $$ If this recurrence represents the running time of an algorithm then, $a$ is the number of subproblems. $b$ is the factor by which the input is decreasing at each level of the recursion. $n^d$ is the total time needed to create the subproblems and combine their solutions. Example We can apply the master theorem on many recurrences. For example, if we’re given, $$ \begin{align*} T(n) = 4T(\frac{n}{2}) + (n). \end{align*} $$ We can quickly see that we have $a = 4$, $b = 2$ and $d = 1$. Therefore, $a &gt; b^d$ and so by using the master theorem, we can see that $T(n) = O(n^{\log_2(4)}) = O(n^2)$. Intuition Why do we have 3 cases and what’s the intuition behind each case? To see this, we discuss three examples, one for each case, starting with case 2. Case 2: $$ \begin{align*} T(n) &amp;= T(\frac{n}{2}) + n. \quad T(1) = 1. \end{align*} $$ Clearly by the master theorem (case 2), the solution should be $O(n)$. Intuitively, we’re reducing the size of each subproblem by half at each level of the recursion and at the same time, the decrease in the number of subproblem is more than the increase in the number of subproblems. So, the work is dominated by the top level of the recursion tree. To be precise, we sum all the work done across all levels and use the geometric series $\sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}$. $$ \begin{align*} T(n) &amp;= \sum_{t=0}^{\log(n)} \frac{n}{2^t} \\ &amp;= n\sum_{t=0}^{\log(n)} \big(\frac{1}{2}\big)^t \\ &amp;= n\big(\frac{1/2^{\log(n)+1} - 1}{1/2 - 1}\big) \\ &amp;= -2n\big(1/2^{\log(n)+1} - 1\big) \\ &amp;= -2n\big(\frac{1}{2 (2^{\log(n)})} - 1\big) \\ &amp;= -2n\big(\frac{1}{2n} - 1\big) \\ &amp;= 2n - 1 \\ &amp;= O(n). \end{align*} $$ Case 3: $$ \begin{align*} T(n) &amp;= 4T(\frac{n}{2}) + n. \quad T(1) = 1. \end{align*} $$ Again by the master theorem (case 3), the solution should be $O(n^2)$. Intuitively, we’re reducing the size of each subproblem by half at each level of the recursion but at the same time, the number of subproblems is actually increasing by a lot more! So, the work is dominated by the bottom level of recursion tree. Drawing only the first three levels, you can see, the bottom level will carry most of the work To be precise, we sum all the work done across all levels and use the geometric series $\sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}$. $$ \begin{align*} T(n) &amp;= \sum_{t=0}^{\log(n)} 4^t\frac{n}{2^t} \\ T(n) &amp;= n\sum_{t=0}^{\log(n)} 2^t \\ &amp;= n\big(\frac{2^{\log(n)+1} - 1}{2 - 1}\big) \\ &amp;= n\big(2^{\log(n)+1} - 1\big) \\ &amp;= n\big(2(2^{\log(n)}) - 1\big) \\ &amp;= n\big(2n - 1\big) \\ &amp;= O(n^2). \end{align*} $$ Case 1: $$ \begin{align*} T(n) &amp;= 2T(\frac{n}{2}) + n. \quad T(1) = 1. \end{align*} $$ By the master theorem (case 1), the solution should be $O(\log(n))$. Intuitively, we’re reducing the size of the problem by half at each level of the recursion and at the same time, we’re doubling the number of subproblems (balanced case). So, at each level, we have the same amount of work. If we draw only the first three levels, you’ll notice that at each level, we’re doing precisely $n$ total amount of work. To make this formal, we sum all the work done across all levels, $$ \begin{align*} T(n) &amp;= \sum_{t=0}^{\log(n)} 2^t\frac{n}{2^t} = n\sum_{t=0}^{\log(n)} 1 = n\log(n). \end{align*} $$ Proof Outline Why is the master theorem correct? Let’s take a look at the recurrence again, $$ \begin{align*} T(n) &amp;= aT(\frac{n}{b})+O(n^d) \\ &amp;= aT(\frac{n}{b}) + cn^d. \end{align*} $$ We will assume that $T(1) = 1$ for simplicity. To solve the recurrence, we will use the recursion tree method similar exactly to what we did for Mergesort. Let’s build the same table that we built for Mergesort to calculate the amount of work done per each level of recursion and get the following, All we need to do now is to sum the amount of work done for all the levels in the table. We see that, $$ \begin{align*} T(n) &amp;= \sum_{t=0}^{\log_b(n)} a^t c(\frac{n}{b^t})^d \\ &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t. \end{align*} $$ So now we can handle each case. Case 1: $a = b^d$ $$ \begin{align*} T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{b^d}{b^d})^t \\ &amp;= cn^d \sum_{t=0}^{\log_b(n)} 1 \\ &amp;= cn^d (\log_b(n) + 1) \\ &amp;= cn^d (\frac{\log(n)}{\log(b)} + 1) \\ &amp;= O(n^d\log(n)). \end{align*} $$ Case 2: $a &lt; b^d$ $$ \begin{align*} T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t \end{align*} $$ We note in the above sum that $\frac{a}{b^d} &lt; 1$. We can then use the geometric series, $$ \begin{align*} \sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}. \end{align*} $$ When $|x| &lt; 1$ and the summation is infinite, this sum approaches $\frac{1}{1-x}$. So, $\sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t$ is bounded by $\frac{1}{1-a/b^d}$ which is some constant that doesn’t depend on $n$. Therefore, $$ \begin{align*} T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t \\ &amp;= O(n^d) \end{align*} $$ Case 3: $a &gt; b^d$ $$ \begin{align*} T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t \end{align*} $$ We note in the above sum that $\frac{a}{b^d} &gt; 1$. We can then use the geometric series again, $$ \begin{align*} \sum_{t=0}^{N}x^t = \frac{x^{N+1} - 1}{x - 1}. \end{align*} $$ When $|x| &gt; 1$ and the summation is infinite, this sum approaches the last term in the series. So, $\sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t$ is bounded by $(a/b^d)^{\log_b(b)}$. Therefore, $$ \begin{align*} T(n) &amp;= cn^d \sum_{t=0}^{\log_b(n)} (\frac{a}{b^d})^t \\ &amp;= cn^d\big(\frac{a}{b^d}\big)^{\log_b(n)} \\ &amp;= cn^d\big(b^{\log_b(\frac{a}{b^d})}\big)^{\log_b(n)} \\ &amp;= cn^d\big(b^{\log_b(n)}\big)^{\log_b(\frac{a}{b^d})} \\ &amp;= cn^d\big(n\big)^{\log_b(\frac{a}{b^d})} \\ &amp;= cn^d(n)^{\log_b(a) - \log_b(b^d)} \\ &amp;= cn^d(n)^{\log_b(a) - d} \\ &amp;= c(n)^{d + \log_b(a) - d} \\ &amp;= cn^{\log_b(a)} \\ &amp; = O(n^{\log_b(a)}) \end{align*} $$ References Stanford CS161 CLRS]]></summary></entry><entry><title type="html">Topological Sort (Kahn)</title><link href="http://localhost:4000/jekyll/update/2020/07/06/topological-sort-kahn.html" rel="alternate" type="text/html" title="Topological Sort (Kahn)" /><published>2020-07-06T07:01:36-07:00</published><updated>2020-07-06T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/07/06/topological-sort-kahn</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/07/06/topological-sort-kahn.html"><![CDATA[<p>Let $G = (V, E)$ be a directed acyclic graph consisting of $V$ vertices and $E$ edges. Topological sort is an ordering of the vertices of the graph such that for any given vertices $u, v \in V$, if $(u,v) \in E$, then $u$ must come before $v$ in the ordering. We have already developed an algorithm for topological sort using depth first search <a href="https://strncat.github.io/jekyll/update/2019/07/10/topological-sort.html">here</a>. In this article, we will explore another topological sort algorithm, Kahn’s algorithm. 
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Kahn's Algorithm</b></h4>
<p>Kahn’s algorithm is extremely intuitive. What are we trying to achieve with topological sort? If we have two vertices/tasks $u$ and $v$ where task $u$ is a perquisite or required to be done before task $v$, then we want to output $u$ before $v$. This dependency is represented with an edge $(u,v)$.</p>

<p><img src="http://localhost:4000/assets/graphs/topological-sort/kahn1.png" alt="my photo" /></p>

<p><b>The in-degree of a vertex</b><br />
This edge contributes to the in-degree of vertex $v$ and out-degree of vertex $u$. The in-degree of a vertex is the number of incoming edges into the vertex. The out-degree of a vertex is the number of edges leaving the vertex. In Kahn’s algorithm, we’re interested in the in-degree of each vertex. In the above example, $v$ has an in-degree of 1.
<br />
<br />
<b>How does Kahn utilizes the in-degree of a vertex?</b><br />
Intuitively, if we have a vertex with in-degree $=0$, then we know that this vertex has no incoming edges. This means that this vertex (task) can be processed/started because it has no dependencies. Therefore, we can just output or add this vertex to the sorted output! This is the whole idea of Kahn’s algorithm. 
<br />
<br />
<b>What if we don’t have a vertex with in-degree 0?</b><br />
Since the graph is a DAG (no cycles), then it must have at least one node with in-degree $=0$.
<br />
<br />
<b>What happens when we don’t have any more vertices with in-degree $=0$?</b><br />
<img src="http://localhost:4000/assets/graphs/topological-sort/kahn2.png" alt="my photo" />
When we add a vertex to the sorted output, we need to decrement the in-degree count of all its neighbors. In the example above, once we add $u$ to the sorted output, we need to decrement the in-degree of $v$. This will lead to $v$ having an in-degree 0. At this point, we need to also add $v$ to the sorted output and decrement its neighbors.
<br />
<br />
<b>How do we do the above?</b><br />
We maintain a queue to hold the nodes with in-degree 0 that haven’t been added to the sorted output yet. Every time we pop a vertex from this queue, we do two things:</p>
<ul>
  <li>Add this node to the sorted output.</li>
  <li>Go through its neighbors, decrement their indegree and push any neighbor with in-degree 0 to the queue.
<br />
<br /></li>
</ul>

<p><b>What if the graph has a cycle?</b><br />
<img src="http://localhost:4000/assets/graphs/topological-sort/kahn3.png" alt="my photo" />
If the graph has a cycle, then we will have a situation where multiple vertices won’t reach an indegree of zero ever. That’s totally fine. We only need to check that the sorted output at the end has the same number of vertices in the graph. If that’s not the case, then we know the graph has a cycle and we just return an error.
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>Let’s go through a full example of running Kahn’s algorithm based on the description we gave above. (TODO)
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Correctness Proof</b></h4>
<p>How do we prove that Kahn’s algorithm actually returns a correctly sorted vertices? (TODO)
<br />
<br />
<!----------------------------------------------------------------------------------------></p>
<h4><b>Implementation</b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">kahn</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="o">&amp;</span><span class="n">g</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">in_degree</span><span class="p">(</span><span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">;</span>

    <span class="c1">// compute the in-degree of each vertex in O(E+V)</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// push the vertices of in-degree 0</span>
    <span class="c1">// if this is a DAG, then we must have some vertex with in-degree=0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">u</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">in_degree</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ordered_vertices</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">q</span><span class="p">.</span><span class="n">front</span><span class="p">();</span> <span class="c1">// some vertex with in-degree = 0</span>
        <span class="n">q</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
        <span class="n">ordered_vertices</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>

        <span class="c1">// decrease the in-degree of all neighbors</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
            <span class="c1">// push a vertex with no more dependencies on the queue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">in_degree</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">q</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">neighbor</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// cycle check</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ordered_vertices</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">g</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"cycle!!!!!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// print or return ordered_vertices</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/graphs/topological-sort/topological-sort-kahn.cpp">Source Code</a>
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Running Time</b></h4>
<p>We compute the in-degree of all vertices in time $O(E+V)$. The while loop runs in time $O(E+V)$ since we push and pop a vertex with indegree-0 once. We also loop through the edges of that vertex only once. The total complexity remains at $O(E+V)$.
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p>geeks-for-geeks
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Let $G = (V, E)$ be a directed acyclic graph consisting of $V$ vertices and $E$ edges. Topological sort is an ordering of the vertices of the graph such that for any given vertices $u, v \in V$, if $(u,v) \in E$, then $u$ must come before $v$ in the ordering. We have already developed an algorithm for topological sort using depth first search here. In this article, we will explore another topological sort algorithm, Kahn’s algorithm. Kahn's Algorithm Kahn’s algorithm is extremely intuitive. What are we trying to achieve with topological sort? If we have two vertices/tasks $u$ and $v$ where task $u$ is a perquisite or required to be done before task $v$, then we want to output $u$ before $v$. This dependency is represented with an edge $(u,v)$.]]></summary></entry><entry><title type="html">Strategy</title><link href="http://localhost:4000/jekyll/update/2020/05/24/strategy.html" rel="alternate" type="text/html" title="Strategy" /><published>2020-05-24T09:01:36-07:00</published><updated>2020-05-24T09:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/24/strategy</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/24/strategy.html"><![CDATA[<p>Strategy is a pattern that uses delegation. “In the Strategy pattern, an object delegates a specific request to an object that represents a strategy for carrying out the request. The purpose is “to change the behavior of an object by changing the objects to which it delegates requests.” 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Motivation</b></h4>
<p>Suppose we want to output the shortest distance in a graph. We have several ways. Breadth First Search and Dijkstra are two ways. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>This is an extremely simple example to see how delegation might work. Suppose we have a view with a simple button. When the button is pressed, we move to another view. In the first view controller we have the following:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">ViewController</span><span class="o">:</span> <span class="n">UIViewController</span><span class="p">,</span> <span class="n">SubViewControllerDelegate</span> <span class="p">{</span>
    <span class="k">override</span> <span class="n">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
        <span class="n">let</span> <span class="n">button</span> <span class="o">=</span> <span class="n">UIButton</span><span class="p">(</span><span class="n">frame</span><span class="o">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">width</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">height</span><span class="o">:</span> <span class="mi">50</span><span class="p">))</span>
        <span class="n">button</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">.</span><span class="n">green</span>
        <span class="n">button</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">"Press"</span><span class="p">,</span> <span class="k">for</span><span class="o">:</span> <span class="p">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">button</span><span class="p">.</span><span class="n">addTarget</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">action</span><span class="o">:</span> <span class="err">#</span><span class="n">selector</span><span class="p">(</span><span class="n">pressed</span><span class="p">),</span> <span class="k">for</span><span class="o">:</span> <span class="p">.</span><span class="n">touchUpInside</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">button</span><span class="p">)</span>
    <span class="p">}</span>
	<span class="err">@</span><span class="n">objc</span> <span class="n">func</span> <span class="n">pressed</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// when the button is pressed, move to AnotherViewController</span>
        <span class="n">let</span> <span class="n">another</span> <span class="o">=</span> <span class="n">AnotherViewController</span><span class="p">()</span>
        <span class="n">another</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span> <span class="c1">// we are the delegate of another, another is the host object</span>
        <span class="n">self</span><span class="p">.</span><span class="n">present</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">animated</span><span class="o">:</span> <span class="nb">true</span><span class="p">,</span> <span class="n">completion</span><span class="o">:</span> <span class="n">nil</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the second view controller, we have another button. This time when we press the button, we want to let the first view controller know that it’s been pressed. To do so, we create a weak delegate that lives in this view controller. We then inform the delegate of whatever message we’d like the first view controller to know about. In this example, we want to let the first view controller that the user had pressed our button.</p>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
  <li><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns</a></li>
  <li><a href="https://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">Cocoa Design Patterns (Book)</a></li>
  <li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html">Cocoa Design Patterns (Apple Docs)</a></li>
  <li><a href="https://www.raywenderlich.com/1941154-fundamental-ios-design-patterns/lessons/18">Fundamental iOS Design Patterns</a>
<br />
<br /></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Strategy is a pattern that uses delegation. “In the Strategy pattern, an object delegates a specific request to an object that represents a strategy for carrying out the request. The purpose is “to change the behavior of an object by changing the objects to which it delegates requests.” Motivation Suppose we want to output the shortest distance in a graph. We have several ways. Breadth First Search and Dijkstra are two ways. Example This is an extremely simple example to see how delegation might work. Suppose we have a view with a simple button. When the button is pressed, we move to another view. In the first view controller we have the following: class ViewController: UIViewController, SubViewControllerDelegate { override func viewDidLoad() { super.viewDidLoad() let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 50)) button.backgroundColor = .green button.setTitle("Press", for: .normal) button.addTarget(self, action: #selector(pressed), for: .touchUpInside) self.view.addSubview(button) } @objc func pressed() { // when the button is pressed, move to AnotherViewController let another = AnotherViewController() another.delegate = self // we are the delegate of another, another is the host object self.present(sub, animated: true, completion: nil) } } In the second view controller, we have another button. This time when we press the button, we want to let the first view controller know that it’s been pressed. To do so, we create a weak delegate that lives in this view controller. We then inform the delegate of whatever message we’d like the first view controller to know about. In this example, we want to let the first view controller that the user had pressed our button.]]></summary></entry><entry><title type="html">Ghram</title><link href="http://localhost:4000/jekyll/update/2020/05/23/convex-hull-graham.html" rel="alternate" type="text/html" title="Ghram" /><published>2020-05-23T09:01:36-07:00</published><updated>2020-05-23T09:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/23/convex-hull-graham</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/23/convex-hull-graham.html"><![CDATA[<p>A polygon is a piecewise-linear, closed curve in the plane. That is, it is a curve ending on itself that is formed by a sequence of straight-line segments, called the sides of the polygon. A point joining two consecutive sides is a vertex of the poly- gon. If the polygon is simple, as we shall generally assume, it does not cross itself. The set of points in the plane enclosed by a simple polygon forms the interior of the polygon, the set of points on the polygon itself forms its boundary, and the set of points surrounding the polygon forms its exterior. A simple polygon is convex if, given any two points on its boundary or in its interior, all points on the line segment drawn between them are contained in the polygon’s boundary or interior. A vertex of a convex polygon cannot be expressed as a convex combination of any two distinct points on the boundary or in the interior of the polygon.</p>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Sweep Line</b></h4>
<p><img src="http://localhost:4000/assets/geometry/any-segment-intersection/sweep-line.png" width="100%" />
Sweep Line  is a common technique used often in computational geometry where we imagine a vertical line going through the set of objects we’re interested in. The sweep line sweeps through one dimension that we chooses. This dimension is treated as a dimension of time. For example, in the figure above, the x-axis is our time line. The vertical line sweeps through the line segments to check whether any two segments intersect. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Algorithm</b></h4>
<p>The algorithm will maintain two sets of data.</p>

<ul>
  <li>The first set, $S$, is the sorted list of start and end points, also called the <b>event points</b>.</li>
  <li>The second set is $T$, the <b>sweep-line status</b>. $T$ will hold the ordered segments currently intersecting the current sweep line.
<img src="http://localhost:4000/assets/geometry/any-segment-intersection/T.png" width="100%" /></li>
</ul>

<p>The algorithm then iterates through the event-points or $S$. There two cases only:</p>

<ul>
  <li>
    <p>The point is a start point of some segment $t$. We will add the segment to the <b>sweep-line-status</b> and then check if $t$ intersects the segment below it or the segment above it. If the answer is yes, then we’re done. If not, we continue processing the next point.</p>
  </li>
  <li>
    <p>The point is an end point of some segment “r”. We will check if the segments below $r$ and above $r$ intersect and, then we will remove $r$ from the sweep-line-status.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
  </li>
</ul>
<h4><b>Pseudocode</b></h4>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p>CLRS Chapter 33
<br />
<a href="https://cs.stackexchange.com/questions/124027/in-determining-whether-any-segments-intersect-why-there-must-be-some-sweep-wher">Proof</a></p>

<p><br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[A polygon is a piecewise-linear, closed curve in the plane. That is, it is a curve ending on itself that is formed by a sequence of straight-line segments, called the sides of the polygon. A point joining two consecutive sides is a vertex of the poly- gon. If the polygon is simple, as we shall generally assume, it does not cross itself. The set of points in the plane enclosed by a simple polygon forms the interior of the polygon, the set of points on the polygon itself forms its boundary, and the set of points surrounding the polygon forms its exterior. A simple polygon is convex if, given any two points on its boundary or in its interior, all points on the line segment drawn between them are contained in the polygon’s boundary or interior. A vertex of a convex polygon cannot be expressed as a convex combination of any two distinct points on the boundary or in the interior of the polygon.]]></summary></entry><entry><title type="html">Quickselect</title><link href="http://localhost:4000/jekyll/update/2020/05/23/quickselect.html" rel="alternate" type="text/html" title="Quickselect" /><published>2020-05-23T08:01:36-07:00</published><updated>2020-05-23T08:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/23/quickselect</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/23/quickselect.html"><![CDATA[<p><img src="http://localhost:4000/assets/randomized/quickselect/intro.png" width="100%" />
Given an array with $n$ elements. We can find the minimum element or maximum element in $O(n)$ time by doing a linear scan and keeping track of the minimum and maximum elements seen so far. What if we want to find the median element or the $k$th smallest element in general? One approach could be to sort the array in $O(n\log(n))$ time and extracting the $k$th smallest element in $O(1)$ time. Is there a faster way? Fortunately, yes! Quickselect is a randomized algorithm that can find the $k$th smallest element in just $O(n)$ expected time. Moreover, with some smart modification to how we select the pivot, we can achieve a worst-case running time of only $O(n)$ time.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Algorithm</b></h4>
<p>Quickselect turns out to be just a slight modification on quicksort which is described <a href="https://strncat.github.io/jekyll/update/2020/05/21/quicksort.html">here</a>! As a reminder, in quicksort, we start by picking a random pivot,</p>

<p><img src="http://localhost:4000/assets/randomized/quickselect/1.png" width="100%" /></p>

<p>and then we partition the array around the pivot (in this case, 2).</p>

<p><img src="http://localhost:4000/assets/randomized/quickselect/2.png" width="100%" /></p>

<p>We then repeat the same process of picking a pivot in each half and then partitioning around the pivots until the array is sorted. However, in quickselect, we’re only interested in finding the $k$th smallest element! The $k$th smallest element can only exist in either the left or the right half. Therefore, we can just search the appropriate half and simply throw away the other half. So, what can the pivot tell us about which half to search?</p>

<p><img src="http://localhost:4000/assets/randomized/quickselect/3.png" width="100%" /></p>

<p>Suppose we’re interested in finding the 2nd smallest element which is 2 in the example above. Naturally, the pivot divides the array into two halves. The left half is less than the pivot and the right half is greater than the pivot. If we let the size of the left array be $L$, then the pivot is the $L+1$th smallest element. Therefore, we can check if $k == L+1$ to determine if the pivot itself is the $k$th smallest element. In the above example, $k = 2$ and $L + 1 = 2$ and we conclude the search and return the pivot.
<br />
<br />
Suppose instead we were searching for the smallest element in the array, $k = 1$. We know from earlier that the pivot is the $L+1$th smallest element. Since $k &lt; L+1$, this means that the $k$th smallest element is in the left half. So, we call quickselect again on the left half.
<br />
<br />
Finally, suppose we’re looking for the 5th smallest element, $k = 5$. This time $k &gt; L+1$ and so we must search the right half. Do you search for the $k$th smallest element in the right half? No. Since we’re eliminating both the left array and the pivot, then our new search must look for the $k-(L+1) = (k-L-1)$th smallest element in the right half instead. 
<br />
<br />
To summarize, there are three cases:</p>
<ul>
  <li>If $k$ is equal to $L + 1$, then we’re done and we return the pivot.</li>
  <li>If $k$ is less than $L + 1$, then we call quickselect on the left half, searching for the $k$th smallest element.</li>
  <li>If $k$ was greater than $L+1$, then we call quickselect on the right half, but this time searching for the $(k - L - 1)$ smallest element.
<br />
<br />
<!------------------------------------------------------------------------------------></li>
</ul>
<h4><b>Implementation</b></h4>
<p>The following is an in-place implementation of quickselect.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">quickselect</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// if we only have 3 elements, just sort</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">-</span> <span class="n">first</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">partial_sort</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">first</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">last</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">first</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// else, partition the array around a random pivot</span>
    <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">randomized_partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>


    <span class="kt">int</span> <span class="n">left_length</span> <span class="o">=</span> <span class="n">p</span> <span class="o">-</span> <span class="n">first</span><span class="p">;</span>

    <span class="c1">// we lucked out, we're exactly at the kth element</span>
    <span class="c1">// remember that indexing start at 0 and so we want k-1</span>
    <span class="c1">// also we return the kth element starting at position first and not 0</span>
    <span class="c1">// so we have take that into account when we return the element</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">left_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">first</span><span class="o">+</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// otherwise, we either search the left half or the right half</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="n">left_length</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">quickselect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">quickselect</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">k</span><span class="o">-</span><span class="n">left_length</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/randomized/quick-select.cpp">Full Implementation</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Correctness of quickselect</b></h4>
<p>TODO.
Here is a proof by strong induction: <a href="http://web.stanford.edu/class/cs161/Lectures/Lecture4/CS161_handout_lecture4.pdf">here</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Worst case analysis</b></h4>
<p>In the worst-case, we’re always choosing a pivot such that our kth element ends up in the larger half. Not only that, but our choice of pivot is always either the smallest or largest element and so in each iteration, the number of elements decrease by only one element. Therefore, we have the following recurrence,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= T(n-1) + O(n).
\end{align*}
$$
</div>
<p>Remember that the $O(n)$ part is due to partition. This recurrence has the solution, $T(n) = O(n^2)$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Best case analysis</b></h4>
<p>In the best-case, we’re always choosing a pivot that divides the array in the middle and so we have the following recurrence,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= T(n/2) + O(n).
\end{align*}
$$
</div>
<p>This recurrence has the solution, $T(n) = O(n)$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Expected case analysis</b></h4>
<p>The expected running time of quickselect turns out to be $O(n)$.<br />
Proof: TODO: (basically section 9.2 in CLRS (not easy though))
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Can quickselect run in linear time in the worst case?</b></h4>
<p>So far, we’ve seen that quickselect runs in $O(n^2)$ in the worst case. Could we do something so that quickselect actually runs in linear time in the worst case? The answer is yes! we can modify the way we select the pivot to guarantee a linear runtime in the worst-case! (TODO: 9.3 in CLRS)
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
  <li>CLRS Chapter 9</li>
  <li><a href="http://web.stanford.edu/class/cs161/Lectures/Lecture4/Lecture4-compressed.pdf">CS161 Stanford</a>
<br />
<br /></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Given an array with $n$ elements. We can find the minimum element or maximum element in $O(n)$ time by doing a linear scan and keeping track of the minimum and maximum elements seen so far. What if we want to find the median element or the $k$th smallest element in general? One approach could be to sort the array in $O(n\log(n))$ time and extracting the $k$th smallest element in $O(1)$ time. Is there a faster way? Fortunately, yes! Quickselect is a randomized algorithm that can find the $k$th smallest element in just $O(n)$ expected time. Moreover, with some smart modification to how we select the pivot, we can achieve a worst-case running time of only $O(n)$ time. Algorithm Quickselect turns out to be just a slight modification on quicksort which is described here! As a reminder, in quicksort, we start by picking a random pivot,]]></summary></entry><entry><title type="html">Quicksort</title><link href="http://localhost:4000/jekyll/update/2020/05/21/quicksort.html" rel="alternate" type="text/html" title="Quicksort" /><published>2020-05-21T08:01:36-07:00</published><updated>2020-05-21T08:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/21/quicksort</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/21/quicksort.html"><![CDATA[<p><img src="http://localhost:4000/assets/randomized/quicksort/intro.png" width="100%" />
Given an array with $n$ elements. Quicksort is a fabulous divide-and-conquer sorting algorithm with a worst-case running time of $O(n^2)$ and an expected running time of $O(n\log(n))$. The main technique or idea used in quicksort is choosing a pivot, and then partitioning the elements around this pivot.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">quicksort</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">partition</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span> <span class="cm">/* partition index */</span>
        <span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">quicksort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>

<p>Here, we have an unsorted array of 6 elements.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/1.png" width="100%" /></p>

<p>Suppose the first random pivot was 3.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/2.png" width="100%" /></p>

<p>We will partition the array such that all the elements less than or equal to 3 will be on the left and all the elements larger than 3 will be on the right. At this point, we have two new subproblems, the left and right subarrays. We recursively call quicksort on each half.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/3.png" width="100%" /></p>

<p>Next, suppose the next random pivot was 2 for the left subarray and 5 for the right subarray.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/4.png" width="100%" /></p>

<p>We repeat the same process of partitioning around each pivot.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/5.png" width="100%" /></p>

<p>We now call quicksort again on each new subarray, highlighted in blue.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/6.png" width="100%" /></p>

<p>The base case of the recursion is reaching an array of size 1 ($first &lt; last$ is not true). In this case, we do nothing since an array of size 1 is already sorted. So, it’s time to combine all these smaller solutions in one array. However, unlike Mergesort, we’re doing all the partitioning work in place and so naturally we’re done.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/7.png" width="100%" />
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Partition</b></h4>

<p>The most critical or the only thing we really do in Quicksort is partitioning the array around a chosen pivot. There isn’t anything cuter than partition. The implementation trick to partition is to move the pivot to the end of the array. So, for the above example, we will swap 3 and 4 and set the pivot to be the last index of the array.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/p1.png" width="100%" /></p>

<p>We will also keep track of an index, $i$, to iterate through the array. At each iteration, we will compare the element at index $i$ with the the pivot. The trick to partition is keeping track of another index, \(write{\_}index\). Whenever we see an element that is less than the pivot, we swap it with the element at \(write{\_}index\) and increment \(write{\_}index\). The intuition here is that we want all the elements less than the pivot to be stored below \(write{\_}index\). 
<br />
<br />
Initially, $i=0$ and \(write {\_} index =0\). We compare $array[i=0]=6$ to the pivot, 3. Since 6 is not smaller, we just increment $i$.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/p2.png" width="100%" /></p>

<p>Next, we have $i=1$ and \(write{\_}index =0\). We compare $array[i=1]=2$ to the pivot, 3. 2 is smaller so we swap 2 and 6 and then increment both \(write{\_}index\) to 1 and $i$ to 2.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/p3.png" width="100%" /></p>

<p>Notice below that 2 and 6 are now swapped. \(array[write{\_}index = 1] = 6\) and $array[i = 1] = 1$. 1 is also smaller than 3 so we swap 6 and 1 and increment both $i$ and \(write{\_}index\).</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/p4.png" width="100%" /></p>

<p>You can see below that the elements before \(write{\_}index\) are indeed smaller than the pivot. We repeat the same process of comparing the current element at $i$ to the pivot. 4 is not smaller than 3 so we just increment $i$.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/p5.png" width="100%" /></p>

<p>We repeat the above process until we reach the pivot and we stop. The very last thing we want to do is to place the pivot back in its correct place. We swap the pivot with the element at \(write{\_}index\).</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/p6.png" width="100%" /></p>

<p>The write_index is now our real pivot that we want to return to quicksort.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/p7.png" width="100%" /></p>

<!------------------------------------------------------------------------------------>
<h4><b>Implementation</b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">partition</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">random_pivot</span> <span class="o">=</span> <span class="n">rand</span><span class="p">()</span> <span class="o">%</span> <span class="p">(</span><span class="n">last</span><span class="o">+</span><span class="mi">1</span><span class="o">-</span><span class="n">first</span><span class="p">)</span> <span class="o">+</span> <span class="n">first</span><span class="p">;</span>

    <span class="c1">// move the pivot to the end of the array</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">random_pivot</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">last</span><span class="p">]);</span>
    <span class="kt">int</span> <span class="n">pivot</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">write_index</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>                                                      
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">a</span><span class="p">[</span><span class="n">pivot</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
            <span class="n">write_index</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">swap</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">pivot</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="n">write_index</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">write_index</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/sorting/quick-sort.c">Quicksort in C</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Correctness of partition</b></h4>
<p>The proof is done with a standard loop invariant. For partition above, we want to establish the following invariant:
<br />
<br />
For any index $k$ in the array:</p>
<ul>
  <li>If \(write{\_}index \leq k \leq i\), then $array[k] \leq array[pivot]$. (Remember we’ve already said any element below \(write{\_}index\) is less than the pivot).</li>
  <li>If \(i &lt; k \leq pivot - 1\), then $array[k] \leq array[pivot]$.</li>
  <li>If \(i == pivot\), then \(array[k] = array[pivot]\).</li>
</ul>

<p><br />
Proof is in CLRS ;)
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Worst-case running time analysis</b></h4>
<p>What’s the worst possible input to quicksort? Suppose we always pick the pivot to be the largest or the smallest element in the array. Then, we will have two subproblems, one of size $n-1$ elements and the other of size $0$. We know partition runs in linear time. If $T(n)$ was the total time it takes to run quicksort then,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= T(n-1) + T(0) + O(n) \\
T(n) &amp;= T(n-1) + O(n).
\end{align*}
$$
</div>
<p>This recurrence has the solution $T(n)=O(n^2)$ which is the worst-case running time of quicksort. Intuitively, if we always choose either the smallest or the largest index as a pivot, then we will be making \(O(n)\) calls to partition. Partition takes linear time and so the total running time will be $O(n^2)$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Best running time analysis</b></h4>
<p>How good can quicksort be? Suppose that the pivot is always chosen to be the middle element in the array. Then our recurrence would look like the following,</p>
<div center="">
$$
\begin{align*}
T(n) &amp;= 2T(n/2) + O(n).
\end{align*}
$$
</div>
<p>By the master theorem, the solution is $T(n) = O(n\log(n))$. Intuitively, if we always partition the array around the middle element, we will need to make $O(\log(n))$ calls to partition and therefore, we get $O(n\log(n))$ as the overall runtime.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Expected running time analysis</b></h4>
<p>This analysis depends on the important idea that quicksort is dominated by the number of comparisons it makes while partitioning the array (proof in CLRS). Moreover,</p>

<table>
  <tbody>
    <tr>
      <td>for any given pair of elements, $x$ and $y$. We know that $x$ and $y$ are compared at most once during quicksort.</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> $x$ and $y$ are only ever compared if one of them is chosen as a pivot. Moreover, once we do the comparison, the pivot will be excluded from all future calls to partition and so $x$ and $y$ will not be compared to each other again.
<br />
<img src="http://localhost:4000/assets/randomized/quicksort/a1.png" width="100%" /></p>

<p>So, how do we count the number of comparisons quicksort makes? Let $A = \{z_1, z_2, …, z_n\}$ be an array of distinct elements, such that $z_i$ is the $i$th smallest element. Let $X$ be the total number of comparisons quicksort makes and let $X_{ij}$ be an indicator random variable such that,</p>
<div center="">
$$
\begin{align*}
X_{ij} = \Big\{ \begin{array}{@{}lr@{}}
        1 \quad \text{ if } x_i \text{ is compared to } x_j \\
        0 \quad \text{ otherwise} \\
        \end{array}
\end{align*}
$$
</div>
<p>Since we make at most one comparison between each pair, we can write $X$ as follows</p>
<div center="">
$$
\begin{align*}
X = \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} X_{ij}
\end{align*}
$$
</div>
<p>We are interested however in the expected number of comparisons. Therefore, we take the expectation of both sides to see that,</p>
<div center="">
$$
\begin{align*}
E[X] &amp;= E[\sum_{i=1}^{n-1} \sum_{j=i+1}{n} X_{ij}] \\
&amp;= \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} E[X_{ij}] \quad \text { (linearity of expectation)}  \\
&amp;= \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} P(X_{ij}=1) \quad \text { (expectation of an indicator random variable)} \\
\end{align*}
$$
</div>

<p><u>How to compute $P(X_{ij}=1)$? </u>
<br />
Let $Z_{ij} = \{z_i,…,z_j\}$ be the set of elements between $z_i$ and $z_j$ inclusive.</p>

<p><img src="http://localhost:4000/assets/randomized/quicksort/a2.png" width="100%" /></p>

<p><u>What is the significance of $Z_{ij}$ to the probability of $x_i$ and $x_j$ being compared?</u>
<br />
Suppose we pick a pivot that’s not in $Z_{ij}$, then this event doesn’t affect the chance of $z_i$ and $z_j$ being compared. However, if the choice of pivot was from the set $Z_{ij}$ then we have two cases:</p>
<ul>
  <li>If the pivot was $z_i$ or $z_j$ then the $z_i$ and $z_j$ will be compared.</li>
  <li>If the pivot was any other element in $Z_{ij}$, then $z_i$ and $z_j$ will be partitioned in separate halfs and will never be compared.
Based on the above, only two choices out of $j-i+1$ choices will lead to having $z_i$ and $z_j$ be compared. Therefore,</li>
</ul>
<div center="">
$$
\begin{align*}
P(X_{ij} = 1) &amp;= \frac{2}{j - i + 1}
\end{align*}
$$
</div>
<p>Apply this back in the previous expectation,</p>
<div center="">
$$
\begin{align*}
E[X] &amp;= \sum_{i=1}^{n-1} \sum_{j=i+1}^{n} P(X_{ij}=1) \\
&amp;= \sum_{i=1}^{n-1} \sum_{j=i+1}^{n}  \frac{2}{j - i + 1} \\
&amp;= \sum_{i=1}^{n-1} \sum_{k=1}^{n-i}  \frac{2}{k + 1} \quad (\text{let } k = j - i) \\
\end{align*}
$$
</div>

<p>Using the harmonic series,</p>
<div center="">
$$
\begin{align*}
H_n = 1 + \frac{1}{2} + \frac{1}{3} + ... + \frac{1}{n} = \sum_{k=1}^{n} \frac{1}{k} = \ln(n) + O(1)
\end{align*}
$$
</div>
<p>We can further simplify the expectation to be</p>
<div center="">
$$
\begin{align*}
E[X] &amp;= \sum_{i=1}^{n-1} \sum_{k=1}^{n-i}  \frac{2}{k + 1} \\
&amp;\leq \sum_{i=1}^{n-1} \sum_{k=1}^{n}  \frac{2}{k} \quad \text { (CLRS's bag of tricks)}\\
&amp;= \sum_{i=1}^{n-1} O(\log(n)) \quad \text { (Harmonic series above) } \\
&amp;=O(n\log(n)) \\
\end{align*}
$$
</div>
<p>Thus, the expected running time of quick sort is $O(n\log(n))$ when the elements are distinct. 
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
  <li>CLRS Chapter 7</li>
  <li><a href="http://web.stanford.edu/class/cs161/Lectures/Lecture5/Lecture5-compressed.pdf">CS161 Stanford</a>
<br />
<br /></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Given an array with $n$ elements. Quicksort is a fabulous divide-and-conquer sorting algorithm with a worst-case running time of $O(n^2)$ and an expected running time of $O(n\log(n))$. The main technique or idea used in quicksort is choosing a pivot, and then partitioning the elements around this pivot.]]></summary></entry><entry><title type="html">Singleton</title><link href="http://localhost:4000/jekyll/update/2020/05/19/singleton.html" rel="alternate" type="text/html" title="Singleton" /><published>2020-05-19T09:01:36-07:00</published><updated>2020-05-19T09:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/19/singleton</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/19/singleton.html"><![CDATA[<p>This one is pretty straightforward. The singleton design pattern is used whenever there is a class where only one object is allowed to exist at any time. <i>UIApplication</i> is one example that uses this pattern.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>It is pretty straightforward as well to make a class with only one instance of itself. One way to do it is to create a static variable to hold the object and declare init to be private.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">public</span> <span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">let</span> <span class="n">shared</span> <span class="o">=</span> <span class="n">Singleton</span><span class="p">()</span>
    <span class="k">private</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
  <li><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns</a></li>
  <li><a href="https://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">Cocoa Design Patterns (Book)</a></li>
  <li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html">Cocoa Design Patterns (Apple Docs)</a></li>
  <li><a href="https://www.raywenderlich.com/1941154-fundamental-ios-design-patterns/lessons/18">Fundamental iOS Design Patterns</a>
<br />
<br /></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This one is pretty straightforward. The singleton design pattern is used whenever there is a class where only one object is allowed to exist at any time. UIApplication is one example that uses this pattern. Example It is pretty straightforward as well to make a class with only one instance of itself. One way to do it is to create a static variable to hold the object and declare init to be private. public class Singleton { public static let shared = Singleton() private init() { } } References Design Patterns Cocoa Design Patterns (Book) Cocoa Design Patterns (Apple Docs) Fundamental iOS Design Patterns]]></summary></entry><entry><title type="html">Delegation</title><link href="http://localhost:4000/jekyll/update/2020/05/17/delegation.html" rel="alternate" type="text/html" title="Delegation" /><published>2020-05-17T09:01:36-07:00</published><updated>2020-05-17T09:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/17/delegation</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/17/delegation.html"><![CDATA[<p>The definition that made most sense was from <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html">developer.apple.com</a>. “Delegation is a mechanism by which a host object embeds a weak reference to another object (its delegate) and periodically sends messages to the delegate when it requires its input for a task.” 
<br />
<br />
For example, <i>NSWindow</i> has a weak reference to its delegate object, <i>delegate</i>, which conforms to the protocol <i>NSWindowDelegate</i>. <i>NSWindowDelegate</i> defines a set of optional methods that the delegate can implement to respond to various messages sent by the window object. Since the methods are optional, <i>NSWindow</i> will check if its delegate implemented them by calling respondToSelector. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Motivation</b></h4>
<p>Why delegation? why can’t we use inheritance instead? Delegation reduces coupling between classes. There is no need for our object to subclass <i>NSWindow</i> in order to define additional behavior. We just become a delegate of <i>NSWindow</i> to receive all the critical messages we’re interested in and then define our own custom behaviors on top of it.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Example</b></h4>
<p>This is an extremely simple example to see how delegation might work. Suppose we have a view with a simple button. When the button is pressed, we move to another view. In the first view controller we have the following:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">ViewController</span><span class="o">:</span> <span class="n">UIViewController</span><span class="p">,</span> <span class="n">SubViewControllerDelegate</span> <span class="p">{</span>
    <span class="k">override</span> <span class="n">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
        <span class="n">let</span> <span class="n">button</span> <span class="o">=</span> <span class="n">UIButton</span><span class="p">(</span><span class="n">frame</span><span class="o">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">width</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">height</span><span class="o">:</span> <span class="mi">50</span><span class="p">))</span>
        <span class="n">button</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">.</span><span class="n">green</span>
        <span class="n">button</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">"Press"</span><span class="p">,</span> <span class="k">for</span><span class="o">:</span> <span class="p">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">button</span><span class="p">.</span><span class="n">addTarget</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">action</span><span class="o">:</span> <span class="err">#</span><span class="n">selector</span><span class="p">(</span><span class="n">pressed</span><span class="p">),</span> <span class="k">for</span><span class="o">:</span> <span class="p">.</span><span class="n">touchUpInside</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">button</span><span class="p">)</span>
    <span class="p">}</span>
	<span class="err">@</span><span class="n">objc</span> <span class="n">func</span> <span class="n">pressed</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// when the button is pressed, move to AnotherViewController</span>
        <span class="n">let</span> <span class="n">host</span> <span class="o">=</span> <span class="n">HostViewController</span><span class="p">()</span>
        <span class="n">host</span><span class="p">.</span><span class="n">delegate</span> <span class="o">=</span> <span class="n">self</span> <span class="c1">// we are the delegate of host</span>
        <span class="n">self</span><span class="p">.</span><span class="n">present</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">animated</span><span class="o">:</span> <span class="nb">true</span><span class="p">,</span> <span class="n">completion</span><span class="o">:</span> <span class="n">nil</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>In the second view controller (host), we have a button. When we press the button, we want to let the first view controller know that it’s been pressed. To do so, we create a weak delegate reference that lives with us, the host controller. This delegate must conform to a protocol that we design. <i>someMessage</i> is the way we want to communicate with the delegate.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">public</span> <span class="n">protocol</span> <span class="n">HostViewControllerDelegate</span><span class="o">:</span> <span class="k">class</span> <span class="p">{</span>
    <span class="n">func</span> <span class="n">someMessage</span><span class="p">(</span><span class="n">_</span> <span class="n">message</span><span class="o">:</span> <span class="n">String</span><span class="p">)</span>
<span class="p">}</span></code></pre></figure>

<p>The delegate will implement <i>someMessage</i>. The host will then call <i>someMessage</i> on the delegate to pass it a message that says “hey, the button has been pressed!!”.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">class</span> <span class="nc">HostViewController</span><span class="o">:</span> <span class="n">UIViewController</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">weak</span> <span class="n">var</span> <span class="n">delegate</span><span class="o">:</span> <span class="n">HostViewControllerDelegate</span><span class="o">?</span> <span class="c1">// our delegate</span>

    <span class="k">override</span> <span class="n">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">let</span> <span class="n">button</span> <span class="o">=</span> <span class="n">UIButton</span><span class="p">(</span><span class="n">frame</span><span class="o">:</span> <span class="n">CGRect</span><span class="p">(</span><span class="n">x</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">y</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">width</span><span class="o">:</span> <span class="mi">100</span><span class="p">,</span> <span class="n">height</span><span class="o">:</span> <span class="mi">50</span><span class="p">))</span>
        <span class="n">button</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="p">.</span><span class="n">red</span>
        <span class="n">button</span><span class="p">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s">"World"</span><span class="p">,</span> <span class="k">for</span><span class="o">:</span> <span class="p">.</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">button</span><span class="p">.</span><span class="n">addTarget</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">action</span><span class="o">:</span> <span class="err">#</span><span class="n">selector</span><span class="p">(</span><span class="n">pressed</span><span class="p">),</span> <span class="k">for</span><span class="o">:</span> <span class="p">.</span><span class="n">touchUpInside</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">addSubview</span><span class="p">(</span><span class="n">button</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="err">@</span><span class="n">objc</span> <span class="n">func</span> <span class="n">pressed</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">delegate</span><span class="o">?</span><span class="p">.</span><span class="n">someMessage</span><span class="p">(</span><span class="s">"hey, the button has been pressed!!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<ul>
  <li><a href="https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612">Design Patterns</a></li>
  <li><a href="https://www.amazon.com/Cocoa-Design-Patterns-Erik-Buck/dp/0321535022">Cocoa Design Patterns (Book)</a></li>
  <li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaFundamentals/CocoaDesignPatterns/CocoaDesignPatterns.html">Cocoa Design Patterns (Apple Docs)</a>
<br />
<br /></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[The definition that made most sense was from developer.apple.com. “Delegation is a mechanism by which a host object embeds a weak reference to another object (its delegate) and periodically sends messages to the delegate when it requires its input for a task.” For example, NSWindow has a weak reference to its delegate object, delegate, which conforms to the protocol NSWindowDelegate. NSWindowDelegate defines a set of optional methods that the delegate can implement to respond to various messages sent by the window object. Since the methods are optional, NSWindow will check if its delegate implemented them by calling respondToSelector. Motivation Why delegation? why can’t we use inheritance instead? Delegation reduces coupling between classes. There is no need for our object to subclass NSWindow in order to define additional behavior. We just become a delegate of NSWindow to receive all the critical messages we’re interested in and then define our own custom behaviors on top of it. Example This is an extremely simple example to see how delegation might work. Suppose we have a view with a simple button. When the button is pressed, we move to another view. In the first view controller we have the following: class ViewController: UIViewController, SubViewControllerDelegate { override func viewDidLoad() { super.viewDidLoad() let button = UIButton(frame: CGRect(x: 100, y: 100, width: 100, height: 50)) button.backgroundColor = .green button.setTitle("Press", for: .normal) button.addTarget(self, action: #selector(pressed), for: .touchUpInside) self.view.addSubview(button) } @objc func pressed() { // when the button is pressed, move to AnotherViewController let host = HostViewController() host.delegate = self // we are the delegate of host self.present(sub, animated: true, completion: nil) } }]]></summary></entry><entry><title type="html">Any Pair of Segments Intersection</title><link href="http://localhost:4000/jekyll/update/2020/05/15/any-pair-of-segments-intersection.html" rel="alternate" type="text/html" title="Any Pair of Segments Intersection" /><published>2020-05-15T09:01:36-07:00</published><updated>2020-05-15T09:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/15/any-pair-of-segments-intersection</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/15/any-pair-of-segments-intersection.html"><![CDATA[<p><img src="http://localhost:4000/assets/geometry/any-segment-intersection/intro.png" width="100%" />
We’ve looked at how to check if <a href="https://strncat.github.io/jekyll/update/2020/04/08/line-segment-intersection.html">two segments intersect</a> in just $O(1)$ time. Now, suppose we have a set of line segments and we want to know if any two segments in this set intersect. How can we do that?
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Sweep Line</b></h4>
<p><img src="http://localhost:4000/assets/geometry/any-segment-intersection/sweep-line.png" width="100%" />
Sweep Line  is a common technique used often in computational geometry where we imagine a vertical line going through the set of objects we’re interested in. The sweep line sweeps through one dimension that we chooses. This dimension is treated as a dimension of time. For example, in the figure above, the x-axis is our time line. The vertical line sweeps through the line segments to check whether any two segments intersect. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Basics</b></h4>
<p>First, we’ll assume that no three points intersect at a single point and that we don’t have vertical line segments. Second, instead of talking about line segments, we’ll just talk about the individual points that make up these segments. We’ll label the start point of a segment with “s” and the end point of a segment with “e”. If we have $n$ segments, we will have $2n$ points. Finally, we’ll sort these points by their x-coordinate. In case of ties, we’ll place the “start” points before the “end” points. If we still have ties, we’ll put the points with the lower y-coordinate first. Our dimension of time here is the x-coordinate and we will sweep from left to right.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Big Idea</b></h4>
<p><img src="http://localhost:4000/assets/geometry/any-segment-intersection/big-idea.png" width="100%" />
Naively, we would spend $O(n^2)$ time to check if any pair intersects by literally checking all possible intersections. CLRS presents a very smart algorithm that is based on one big idea. 
<br />
<br />
Sort the segment points and sweep through the points from left to right, stopping to evaluate the sweep line at every segment point. Suppose we know that a pair of segments intersect. The big idea is that we are guaranteed to have the two line segments be <b>consecutive at some sweep line</b>. In the figure above, the line segments intersect at $p$ and they are consecutive at the sweep line $x$. This is a huge idea! why? Because now we can just sweep through the points from left to right. When we evaluate a point, we only need to check the segment right below it or the segment right above it for a possible intersection! This means that the running time is dominated by the sort which runs in $O(n\log(n))$. 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Proof</b></h4>
<p>If we have two segments $a$ and $b$ intersecting at some point $p$. Why must the segments be consecutive at some sweep line? 
<br />
<br />
Suppose we are at some sweep line $x$, let $T$ be the set of segments intersecting $x$. Let $\succeq_x$ be a relation on $T$. We say $a \succeq_x b$ if both $a$ and $b$ intersect $x$ and the intersection of $a$ with $x$ is higher than the intersection of $b$ with $x$. The below figure shows segments $a$, $b$ and $c$ intersecting sweep line $x$.</p>

<p><img src="http://localhost:4000/assets/geometry/any-segment-intersection/big-idea-proof-1.png" width="100%" /></p>

<p>$\succeq_x$ is <b>total preorder</b>. This is because for any two segments $a, b \in T$, either $a \succeq_x b$ or $b \succeq_x a$ or both and so $\succeq_x$ is a total order. Furthermore, if we have a third segment $c \in T$ such that $a \succeq_x c$ and $c \succeq_x b$ then we must have $a \succeq_x b$ and so $\succeq_x$ is transitive. 
<br />
<br />
When we pass the intersection point $p$, the segments $a$ and $b$ reverse their order in the total preorder. Before the intersection, we had $a \succeq b$ and after the intersection, we have $b \succeq a$. Furthermore, since no three lines intersect at the same point then we must have some sweep $x$ where $a$ and $b$ are consecutive. We basically want to prove there is some empty triangle bounded by $a, b$ and $x$ which will imply that $a$ and $b$ are consecutive in the total preorder $\succeq_x$. 
<br />
<br />
<i>Proof:</i> Suppose the triangle isn’t empty and pick the right most intersection point with the triangle to the left of $p$, call it $q$. We know $p != q$ because of the assumption that we don’t have three segments intersecting at the same point. We know the $x$-coordinate of $q$ is less than $p$ by assumption. We can construct an empty triangle defined by the the sweep line at $q, a$ and $b$. Therefore, $a$ and $b$ will be consecutive in the total preorder $\succeq_x$. $\blacksquare$
<br />
<br />
There is another more intuitive way to think about this. We have two cases. We either have no segment points besides $a$ and $b$ before we hit $p$ which will imply that $a$ and $b$ are consecutive in the total preorder of the sweep line that hits the latest segment start of $a$ and $b$. (left case in the figure). Or we do have some segment $c$ but because of the precondition that no three segments intersect at $p$ then we must hit the end point of $c$ before $p$ and so $a$ and $b$ will be consecutive after that point (middle case). Someone might ask, what if we don’t hit the end point of $c$ first and $c$ continues? This is the third case in the figure which is just misleading, because in this case, we will discover $p^{\prime}$ first instead and return true!
<img src="http://localhost:4000/assets/geometry/any-segment-intersection/big-idea-proof-2.png" width="100%" /> 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Algorithm</b></h4>
<p>The algorithm will maintain two sets of data.</p>

<ul>
  <li>The first set, $S$, is the sorted list of start and end points, also called the <b>event points</b>.</li>
  <li>The second set is $T$, the <b>sweep-line status</b>. $T$ will hold the ordered segments currently intersecting the current sweep line.
<img src="http://localhost:4000/assets/geometry/any-segment-intersection/T.png" width="100%" /></li>
</ul>

<p>The algorithm then iterates through the event-points or $S$. There two cases only:</p>

<ul>
  <li>
    <p>The point is a start point of some segment $t$. We will add the segment to the <b>sweep-line-status</b> and then check if $t$ intersects the segment below it or the segment above it. If the answer is yes, then we’re done. If not, we continue processing the next point.</p>
  </li>
  <li>
    <p>The point is an end point of some segment “r”. We will check if the segments below $r$ and above $r$ intersect and, then we will remove $r$ from the sweep-line-status.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
  </li>
</ul>
<h4><b>Pseudocode</b></h4>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// S is a set of n segments</span>
<span class="n">any_segments_intersect</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Assume or rearrange S to have 2n points (the start and end points of each segment)</span>
    <span class="c1">// Sort the points in S by their x-coordinate, breaking ties by putting</span>
    <span class="c1">// start points before end points and then lower y-coordinate first</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">set</span><span class="p">()</span> <span class="c1">// sweep-line-status</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">each</span> <span class="n">point</span> <span class="n">p</span> <span class="n">in</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="n">is</span> <span class="n">a</span> <span class="n">start</span> <span class="n">point</span> <span class="n">of</span> <span class="n">some</span> <span class="n">segment</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">insert</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">there</span> <span class="n">is</span> <span class="n">a</span> <span class="n">segment</span> <span class="n">above</span> <span class="n">e</span> <span class="n">and</span> <span class="n">it</span> <span class="n">intersects</span> <span class="n">e</span> <span class="n">OR</span>
                <span class="n">or</span> <span class="n">there</span> <span class="n">is</span> <span class="n">a</span> <span class="n">segment</span> <span class="n">below</span> <span class="n">e</span> <span class="n">and</span> <span class="n">it</span> <span class="n">intersects</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// p is an end point</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">there</span> <span class="n">is</span> <span class="n">a</span> <span class="n">segment</span> <span class="n">above</span> <span class="n">e</span> <span class="n">and</span> <span class="n">there</span> <span class="n">is</span> <span class="n">a</span> <span class="n">segment</span> <span class="n">below</span> <span class="n">e</span> <span class="n">AND</span>
                <span class="n">both</span> <span class="n">of</span> <span class="n">these</span> <span class="n">segments</span> <span class="n">intersect</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Delete</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Proof</b></h4>
<p>But why does any of the above work? Is this magic? kind of. To prove the correctness of the algorithm we need to prove</p>

<table>
  <tbody>
    <tr>
      <td>any_segments_intersect(S) returns true if and only if there is an intersection among the segments in $S$.</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i>
<br />
\((\Rightarrow)\): If <i>any_segments_intersect</i> returns true, then it is clear from the algorithm above that it can only return true if an intersection passes so we’re good.</p>

<p>\((\Leftarrow)\): If there is an intersection, we’ll prove that <i>any_segments_intersect</i> finds it. Suppose we have an intersection and let $p$ be the left most intersection with the lowest y-coordinate. Let $a$ and $b$ be the intersecting segments. We know from the previous proof that no three segments can intersect at $p$ and so $a$ and $b$ will be consecutive at some sweep line $x$. We also know that there is some segment start or end point $q$ that intersects $x$. We have three cases:</p>

<ul>
  <li>
    <p>Case 1: We already have either $a$ or $b$ in $T$ and then we hit the start of $a$ or $b$ and so the first if-statement catches this.</p>
  </li>
  <li>
    <p>Case 2: We hit the end point of some segment $c$ and so the second if-statement catches this case. We compare $a$ and $b$ and delete $c$.</p>
  </li>
  <li>
    <p>Case 3: We didn’t process the sweep line $x$ at $q$ because we’ve already hit $p^{\prime}$ before! (this must be the case because $c$ must either end before $p$ hits $a$ or $b$ before $p$ since we can’t have 3 points intersecting at $p$)</p>
  </li>
</ul>

<p><img src="http://localhost:4000/assets/geometry/any-segment-intersection/big-idea-proof-2.png" width="100%" /></p>

<p>Therefore, if there is an intersection point, then <i>any_segments_intersect</i> must return true. $\blacksquare$.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Implementation</b></h4>
<p>TODO
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p>CLRS Chapter 33
<br />
<a href="https://cs.stackexchange.com/questions/124027/in-determining-whether-any-segments-intersect-why-there-must-be-some-sweep-wher">Proof</a></p>

<p><br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[We’ve looked at how to check if two segments intersect in just $O(1)$ time. Now, suppose we have a set of line segments and we want to know if any two segments in this set intersect. How can we do that? Sweep Line Sweep Line is a common technique used often in computational geometry where we imagine a vertical line going through the set of objects we’re interested in. The sweep line sweeps through one dimension that we chooses. This dimension is treated as a dimension of time. For example, in the figure above, the x-axis is our time line. The vertical line sweeps through the line segments to check whether any two segments intersect. Basics First, we’ll assume that no three points intersect at a single point and that we don’t have vertical line segments. Second, instead of talking about line segments, we’ll just talk about the individual points that make up these segments. We’ll label the start point of a segment with “s” and the end point of a segment with “e”. If we have $n$ segments, we will have $2n$ points. Finally, we’ll sort these points by their x-coordinate. In case of ties, we’ll place the “start” points before the “end” points. If we still have ties, we’ll put the points with the lower y-coordinate first. Our dimension of time here is the x-coordinate and we will sweep from left to right. Big Idea Naively, we would spend $O(n^2)$ time to check if any pair intersects by literally checking all possible intersections. CLRS presents a very smart algorithm that is based on one big idea. Sort the segment points and sweep through the points from left to right, stopping to evaluate the sweep line at every segment point. Suppose we know that a pair of segments intersect. The big idea is that we are guaranteed to have the two line segments be consecutive at some sweep line. In the figure above, the line segments intersect at $p$ and they are consecutive at the sweep line $x$. This is a huge idea! why? Because now we can just sweep through the points from left to right. When we evaluate a point, we only need to check the segment right below it or the segment right above it for a possible intersection! This means that the running time is dominated by the sort which runs in $O(n\log(n))$. Proof If we have two segments $a$ and $b$ intersecting at some point $p$. Why must the segments be consecutive at some sweep line? Suppose we are at some sweep line $x$, let $T$ be the set of segments intersecting $x$. Let $\succeq_x$ be a relation on $T$. We say $a \succeq_x b$ if both $a$ and $b$ intersect $x$ and the intersection of $a$ with $x$ is higher than the intersection of $b$ with $x$. The below figure shows segments $a$, $b$ and $c$ intersecting sweep line $x$.]]></summary></entry><entry><title type="html">Coin Change</title><link href="http://localhost:4000/jekyll/update/2020/05/10/coin-change.html" rel="alternate" type="text/html" title="Coin Change" /><published>2020-05-10T07:01:36-07:00</published><updated>2020-05-10T07:01:36-07:00</updated><id>http://localhost:4000/jekyll/update/2020/05/10/coin-change</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2020/05/10/coin-change.html"><![CDATA[<p><img src="http://localhost:4000/assets/dynamic-programming/coin-change/coin-change.png" width="100%" />
Suppose we’re given a bill of value $n=5$. We’re also given unlimited amount of coins. The possible coin values are 1, 2 and 5. What is the total number of ways of changing the bill into coins? We can exchange it for 5 coins of value 1. We can also exchange it for 3 coins of value 1 and 1 coin of value 2. Here are total possible ways:
<img src="http://localhost:4000/assets/dynamic-programming/coin-change/change.png" width="100%" />
How can we design an algorithm to solve this problem?
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Method 1</b></h4>
<p>One way to count the number of ways to make change is to iterate through the coins and use each coin as a  starting point:</p>
<ul>
  <li>Start with a coin of value 5, then make change for $n-5$.</li>
  <li>Start with a coin of value 2, then make change for $n-2$.</li>
  <li>Start with a coin of value 1, then make change for $n-1$.</li>
</ul>

<p>When do we stop?</p>

<ul>
  <li>When the amount is negative, meaning this is not a valid combination.</li>
  <li>When the amount is zero which means that we have arrived at a valid solution.</li>
</ul>

<p>This is illustrated below with amount = 4 and coins 1, 2 and 5:
<img src="http://localhost:4000/assets/dynamic-programming/coin-change/method1-before.png" width="100%" /></p>

<p>The solutions are highlighted in yellow. One thing we immediately notice is that we have duplicates! we’re finding (1,1,2), (1,2,1) and (2,1,1) as valid solutions. How can we fix this? The simplest way to fix this issue is to restrict the coins in the next iteration to coins  that are less than our current coin. For example if our current coin is 2, then we only try out coins 1 and 2 at the next level. So our steps will now be:</p>

<ul>
  <li>Start with a coin of value 5, then make change for $n-5$ with coins (1,2,5).</li>
  <li>Start with a coin of value 2, then make change for $n-2$ with coins (1,2).</li>
  <li>Start with a coin of value 1, then make change for $n-1$ with coins (1).</li>
</ul>

<p>This is illustrated below.</p>

<p><img src="http://localhost:4000/assets/dynamic-programming/coin-change/method1-after.png" width="100%" /></p>

<p>Implementation wise, we can pass an index to keep track of which coins we are allowed to use at the next level of recursion.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">long</span> <span class="nf">make_change_recursive_alt</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// used coins = exact amount</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// not the right combination of coins</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// recurse again but with the largest coin = coins[i]</span>
        <span class="c1">// this way we don't count duplicates</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">make_change_recursive_alt</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">total</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Method 2</b></h4>
<p>Another way to think about this problem is to divide the solutions into two sets. Fix a coin of choice, $c$, and then divide the set of solutions into solutions that use the coin $c$ and solutions that don’t use $c$. For amount 4 and coin “2”, we have 1 way that doesn’t use coin “2” and 2 different ways that does use it.
<img src="http://localhost:4000/assets/dynamic-programming/coin-change/method2-coin.png" width="100%" /></p>

<p>Let $K[c,n]$ be the total number of ways to make change for amount $n$ and coins $c$. Fix a coin $c_i$ from the set $c$. We will have,</p>
<div center="">
$$
\begin{align*}
K[c,n] = K[c-{c_i},n] + K[c, x-c_i].
\end{align*}
$$
</div>
<p>The following implementation is based on the above recurrence. Just like previously, in order not to run into duplicate solutions, we make sure to have the sequence of coins in some pre set order and then use an index to keep track of which coins we’re allowed to use in the next iteration.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">long</span> <span class="nf">make_change_recursive</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// used coins = exact amount</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// not the right combination of coins</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// ran out of coins</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// either use the coin c[n-1] or don't</span>
    <span class="k">return</span> <span class="n">make_change_recursive</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">amount</span><span class="p">)</span> <span class="o">+</span> <span class="c1">// don't use this coin</span>
    <span class="n">make_change_recursive</span><span class="p">(</span><span class="n">coins</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">amount</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// use the coin</span>
<span class="p">}</span></code></pre></figure>

<p>However, for $n$ coins, this solution still takes $O(2^n)$ time and is not efficient.
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Method 3: Dynamic Programming</b></h4>
<p><img src="http://localhost:4000/assets/dynamic-programming/coin-change/substructure.png" width="100%" />
Suppose we know the solution to a problem we’re solving. An optimal substructure means that the solution will contain solutions to smaller subproblems. Does this apply to the coin change problem? Yes! we just came up with a beautiful recurrence in the recursive solution above. Let $K[c,n]$ be the total number of ways to make change for amount $n$ and coins $c$. Fix a coin $c_i$ from the set $c$. We will have,</p>
<div center="">
$$
\begin{align*}
K[c,n] = K[c-{c_i},n] + K[c, n-c_i].
\end{align*}
$$
</div>

<p>Both subproblems are independent of each other and both are smaller in size than the original problem.</p>

<ul>
  <li>The first subproblem, $K[c-{c_i},n]$, has one fewer coin.</li>
  <li>The second subproblem, $K[c,n-{c_i}]$, has a smaller amount.</li>
</ul>

<p>This is exactly what we need to implement a dynamic programming algorithm. The only thing left is to define the base case. For this particular problem:</p>

<ul>
  <li>$K[c,0] = 1$. The number of ways to make change for any zero amount is 1.</li>
  <li>$K[0,n] = 1$ where $n &gt; 0$. The number of ways to make change for any amount greater than zero using zero coins is 0.</li>
</ul>

<p>It is also important just like in the recursive structure, to take care of the duplicates issue. We need to keep track of which coins we’re allowed to use.</p>
<table>
	<tr>
		<td>amount/coins</td>
		<td>0</td>
		<td>1</td>
		<td>2</td>
		<td>3</td>
		<td>4</td>
		<td>5</td>
	</tr>
	<tr>
		<td>0</td>
		<td>1</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>
		<td>0</td>	
		<td>0</td>			
	</tr>
	<tr>
		<td>{1}</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
		<td>1</td>
	</tr>
	<tr>
		<td>{1,2}</td>
		<td>1</td>
		<td>1</td>
		<td>2</td>
		<td>2</td>
		<td>3</td>
		<td>3</td>
	</tr>
	<tr>
		<td>{1,2,5}</td>
		<td>1</td>
		<td>2</td>
		<td>2</td>
		<td>2</td>
		<td>3</td>
		<td>4</td>
	</tr>
</table>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">make_change_2d</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">dp</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// base case for amount = 0, there is 1 way to make change</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// otherwise the total number of ways to make change is zero for any amount &gt; 0 with zero coins</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">MAX_AMOUNT</span><span class="p">;</span> <span class="n">amount</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">amount</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each coin</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">MAX_AMOUNT</span><span class="p">;</span> <span class="n">amount</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each amount</span>
            <span class="c1">// dp[n][amount] = dp[n-1][amount] + dp[n][amount-c[n]]</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">amount</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">amount</span><span class="p">];</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&gt;=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">amount</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">amount</span><span class="o">-</span><span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>For amount $n$ and $m$ coins, The runtime is \(O(nm)\).
<br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Method 4: Optimized Dynamic Programming</b></h4>
<p>The previous method is great and optimal. We could however reduce the storage requirement from 2D to only 1D. If you pay attention to the recursive structure, you’ll see that each row only depends on the previous row. So what we could do is just over write the current row onto the previous row until we reach the final answer in the last row.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// bottom up with less memory</span>
<span class="kt">void</span> <span class="nf">make_change_1d</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">coins</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">dp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// base case</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">coins</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each coin</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">amount</span> <span class="o">=</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">amount</span> <span class="o">&lt;=</span> <span class="n">MAX_AMOUNT</span><span class="p">;</span> <span class="n">amount</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for each amount, m needs to be &gt;= c[i], start from c[i]</span>
            <span class="n">dp</span><span class="p">[</span><span class="n">amount</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">amount</span> <span class="o">-</span> <span class="n">coins</span><span class="p">[</span><span class="n">i</span><span class="p">]];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!-----------------------------------------------------------------------------------></p>
<h4><b>Proof of Correctness</b></h4>
<p>TODO?</p>

<!-- 

<i>Proof:</i> <br>
Suppose that we have a bill of size $$n$$ and suppose that we have unbounded copies of $$c$$ coins available to us. Now suppose that we know that the number of ways to make change is $K[c,n]$. Fix a coin $c_i$. If We claim that $K[c-{c_i},n]$ is the number of ways to make change and that one of the solutions contains one coin of value $c_i$ for some natural number $i$. We claim that $K[W] - v_k$ is an optimal value for a knapsack of size $$W - x_k$$. That is, $$K[W - x_k] = K[W] - v_k$$.
<br><br>
We will prove our claim by contradiction. Suppose that $$K[W] - v_k$$ is not an optimal value and that the optimal value is $$T^{\prime}$$. Since we know that the optimal solution to the knapsack of size $$W$$ contains a copy of item $$x_k$$, we can therefore add $$x_k$$ to $$K[W - x_k]$$ to obtain an optimal value $$T^{\prime} + v_k$$. But $$T^{\prime} + v_k >  K[W] - v_k + v_k = K[W]$$. This is a contradiction since we assumed that $$K[W]$$ is an optimal value. Therefore, $$K[W] - v_k$$ must be an optimal value for a knapsack of size $$W - x_k$$. $$\blacksquare$$

-->

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Practice Problems</b></h4>
<ul>
  <li><a href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;page=show_problem&amp;problem=2078">11137 - Ingenuous Cubrency</a> 
<br />
<br />
<!------------------------------------------------------------------------------------></li>
</ul>
<h4><b>References</b></h4>
<ul>
  <li>(Method 2) <a href="https://www.geeksforgeeks.org/coin-change-dp-7/">GeeksforGeeks</a> 
<br />
<br /></li>
</ul>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[Suppose we’re given a bill of value $n=5$. We’re also given unlimited amount of coins. The possible coin values are 1, 2 and 5. What is the total number of ways of changing the bill into coins? We can exchange it for 5 coins of value 1. We can also exchange it for 3 coins of value 1 and 1 coin of value 2. Here are total possible ways: How can we design an algorithm to solve this problem? Method 1 One way to count the number of ways to make change is to iterate through the coins and use each coin as a starting point: Start with a coin of value 5, then make change for $n-5$. Start with a coin of value 2, then make change for $n-2$. Start with a coin of value 1, then make change for $n-1$.]]></summary></entry></feed>