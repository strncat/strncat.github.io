---
layout: post
title:  "Tries"
date:   2019-07-06 12:01:36 -0700
categories: jekyll update
mathjax: true
---
<b>0 References</b><br>
- Algorithms by Robert Sedgwick and Kevin Wayne
<br>
- http://web.stanford.edu/class/cs166/
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>1 Introduction</b>
<br>
Given $$k$$ strings of total length $$m$$ and a string pattern $$p$$ of length $$n$$. We want to find all the strings that start with $$p$$. The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take $$O(nm)$$. However, suppose that we now we have many more patterns, then this approach this will be really slow. So how can we make it faster?
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>2 The Tries Data Structure</b>
<br>
<img src="{{ site.url }}/assets/trie/1.png" width="80%">
<br>
The trie (pronounced "try") data structure is an efficient data structure that can help us achieve a faster running time when searching for prefixes.
<br><br>
Each node in a trie represents one character. Each node also has only one parent. However it has $$R$$ pointers or children where $$R$$ is the alphabet size. So for the example above each node (circle) has 26 pointers even though many of these pointers might be just null pointers. For example the $$a$$ node has 26 pointers of which only 2 are used to point at letters $$k$$ and $$t$$.
<br><br>
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>3 Example</b>
<br>
Let's explore the graph above. We will start from $$s$$ and add as soon as we see $$a$$ we'll recursively call $$a$$ again. The start time for $$s$$ is 0 and the start time for $$a$$ is 1.

![my photo]({{ site.url }}/assets/dfs/1.png)

Next we will recursively visit $$c$$, $$e$$ and $$d$$. They will have start times 2, 3 and 4 respectively.

![my photo]({{ site.url }}/assets/dfs/2.png)


At this point, there will be no more vertices to traverse and so node 
$$d$$ is now finished with time 5, followed by $$e$$, $$c$$ and then $$a$$.

![my photo]({{ site.url }}/assets/dfs/3.png)

Finally, we will traverse node $$b$$ with start time 9 and finish time 10. Node $$s$$ will now be done with finish time $$11$$.

![my photo]({{ site.url }}/assets/dfs/4.png)
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>4 Implementation</b>
<br>
{% highlight c++ %}
int dfs(int v, int current_time,
        std::vector<std::vector<int>>& graph,
        std::vector<std::pair<int,int>> &times,
        std::vector<int> &visited) {

    times[v].first = current_time++; // seeing v for the first time
    visited[0] = true;
    for (int i = 0; i < graph[v].size(); i++) {
        int u = graph[v][i];
        if (visited[u] == false) {
            current_time = dfs(u, current_time, graph, times, visited);
            current_time++;
        }
    }
    times[v].second = current_time; // v is done bye forever
    return current_time;
}
{% endhighlight %}
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>6 Running Time</b>
<br>
Similar to the analysis of breadth first search. We visit each vertex once only. That's $$O(V)$$ time. Therefore, we also visit the adjacency list of each vertex at most once and that's $$O(E)$$. Therefore, the total time is $$O(V+E)$$.
<br>
<br>
<hr>
<!------------------------------------------------------------------------------------>
<br>
<b>7 Full Implementation:</b> 
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/depth-first-search
<br>
<br>


