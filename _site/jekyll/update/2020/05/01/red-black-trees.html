<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Red Black Trees</title>
  <link rel="stylesheet" href="/assets/css/nemo-theme.css">
  <!-- MathJax if you want math -->
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
  <div class="container">
    <nav class="sidebar">
      <!-- You can generate links here manually, or use site.pages or a _data file -->
      <h2>Contents</h2>
      <ul>
        <li><a href="/">Home</a></li>
        <li><a href="/about/">About</a></li>
        <li><a href="/jekyll/update/2024/07/11/linear-algebra.html">Linear Algebra</a></li>
        <li><a href="/jekyll/update/2024/12/05/abstract-algebra.html">Abstract Algebra</a></li>
        <li><a href="/jekyll/update/2025/01/03/number-theory.html">Number Theory</a></li>
        <li><a href="/jekyll/update/2024/07/09/realanalysis.html">Real Analysis</a></li>
        <!-- Add more links as needed -->
      </ul>
    </nav>
    <main class="content">
		<header class="content-header">
		        nemo's notebook
		      </header>
      <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Red Black Trees</h1>
    <!--
    <p class="post-meta">
      <time class="dt-published" datetime="2020-05-01T12:01:36-07:00" itemprop="datePublished">May 1, 2020
      </time></p>
     -->
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="http://localhost:4000/assets/trees/red-black-trees/red-black-tree.png" width="100%" />
We previously discussed binary search trees and how the binary search tree property allows us to do tree operations such as insert and delete in just \(O(h)\) time. However, if the tree height is of order \(O(n)\), then we end up with a worse data structure than just a linked list or a sorted array. What we need is a guarantee that the height is \(O(\log(n))\). How can we achieve this?
<br /><br />
A red-black tree is a binary search tree that is balanced. By only adding one extra bit to store the color of the node (red or black) and some restrictions on how to insert and delete nodes, we can have a balanced binary search tree that guarantees the height to be \(O(\log(n))\). 
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Red-black tree specifications</b></h4>
<p>A red-black tree must satisfy the following properties:</p>
<ul>
  <li>Every node is either red or black.</li>
  <li>The root is black.</li>
  <li>Every leaf node is black.</li>
  <li>If a node is red, then its children are black.</li>
  <li>The number of black nodes must be the same across all simple paths from any node to a leaf node.
<br />
<br />
<!------------------------------------------------------------------------------------></li>
</ul>
<h4><b>Why are red-black trees balanced?</b></h4>
<p>Why do the above properties guarantee anything about the tree being balanced? Intuitively, just restricting the number of black nodes to be the same across all simple paths means that we will have a balanced tree. The red nodes are there to give us some buffer. We could have extra “red” nodes but not a lot in order to keep the height at \(O(\log(n))\). 
<br /><br />
To show a formal proof, we first need to define the black height of a node. Let \(bh(x)\) be the <b>black height</b> of a node. \(bh(x)\) is number of black nodes from a node \(x\) to a leaf but <i>not including \(x\) itself</i>. In the above tree, we see that the black height of the root is 2 as every simple path includes exactly 2 black nodes. To show that the height is at most \(O(\log(n))\), we want to prove somehow that we have “enough” internal nodes at every node such that the height can’t exceed \(O(\log(n))\). Formally, we’ll prove</p>

<table>
  <tbody>
    <tr>
      <td>Given a red-black tree $t$ and a node \(x\) in \(t\), The subtree rooted at \(x\)  contains at least \(2^{bh(x)}-1\) internal nodes (including x itself)</td>
    </tr>
  </tbody>
</table>

<p>Looking at the figure below, we see in the first figure we have \(bh(root)=3\) and we have at least \(2^{3}-1=7\) nodes. In the second figure, we have \(bh(root)=2\) and at least \(2^2-1=3\) internal nodes. Similarly, in the third figure, we have \(2^2-1\) internal nodes.
<img src="http://localhost:4000/assets/trees/red-black-trees/internal-nodes.png" width="100%" /></p>

<p>Proof: By Induction on the height of \(x\). For the base case, consider when the height is 0, then we know that \(x\) is NIL. Therefore, \(2^{bh(x)} - 1 = 1 - 1 = 0\). For the inductive step, suppose \(x\) has some positive height &gt; 0 and has two internal children (why 2?). Each child must have either \(bh(x)-1\) or \(bh(x)\) black height depending on its color. If \(x\) was red, then both children must be black and the black height of both children is  \(bh(x)\). If \(x\) was black, then both its children must have black height \(bh(x)-1\). Since the height of both children is less than \(x\), then we can apply the inductive hypothesis and conclude that each child must have at least \(2^{bh(x)-1}-1\) internal nodes. Therefore, \(x\) has at least \(1 + 2^{bh(x)-1} - 1 + 2^{bh(x)-1} - 1 = 2^{bh(x)} -1\) internal nodes which completes the proof. \(\blacksquare\) 
<br />
<br />
To prove that the height of the tree is at most \(O(\log(n))\), . The next thing we want to use is the fact that every red node in a red-black tree must have black children. Therefore, half the nodes on any path must be black. Therefore, if the height of the tree is \(h\) then we must have \(bh(root) \geq h/2\). Using what we proved earlier, we see that</p>
<div center="">
$$
\begin{align*}
n &amp;\geq 2^{bh(root))} - 1 \text{ (using the earlier lemma we proved) }\\
n &amp;\geq 2^{h/2} - 1  \text { (using the fact that red nodes must have black children) }\\ 
\log(n-1) &amp;\geq h/2 \\
h/2 &amp;\leq \log(n-1) \\
h &amp;\leq 2\log(n-1). \blacksquare
\end{align*}
$$
</div>

<!------------------------------------------------------------------------------------>
<h4><b>Rotations</b></h4>
<p>Operations on red-black trees such as insert and delete modify the tree such that we might violate the red-black tree properties. To restore these properties we perform an essential operation called a rotation. Rotations maintain the binary search property. More on rotations are 
<a href="https://strncat.github.io/jekyll/update/2019/05/02/binary-tree-rotation.html">here</a>.
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Insert</b></h4>
<p>Just like <a href="https://strncat.github.io/jekyll/update/2020/04/28/binary-search-trees.html">inserting a node into a binary search tree</a>, we just find an appropriate place to insert it such that we don’t violate the binary search property. Since all leaf nodes must be black, we create a special dummy node and color it black. We call it SNIL, just to differentiate it from NIL (dumb?).<br />
<!----------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">Tree</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">z</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="p">(</span><span class="n">d</span><span class="p">);</span> <span class="c1">// create a new node</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">x</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
    <span class="n">Node</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">SNIL</span><span class="p">;</span> <span class="c1">// potenial parent</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">SNIL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="n">SNIL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// tree was empty</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">z</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// left child</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">z</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">SNIL</span><span class="p">;</span> <span class="c1">// new for red-black-trees</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">SNIL</span><span class="p">;</span> <span class="c1">// new for red-black-trees</span>
    <span class="n">z</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span> <span class="c1">// new for red-black-trees</span>
    <span class="n">insertFixUp</span><span class="p">(</span><span class="n">z</span><span class="p">);</span> <span class="c1">// new for red-black-trees</span>
<span class="p">}</span></code></pre></figure>

<p>Also note that we color the node red by default. Red nodes allow for some room in the definition of a “balanced tree”. We still be okay. If the parent of the node is black, then all is fine. However if we choose to color it black then we immediately violate the property that the number of black nodes must be the same across all simple paths. 
<br />
<br />
In general, there are two main violations that could happen. This could be our very first node which the root and the root must be black. The parent of the node might be red and red nodes are not allowed to have red children.</p>

<p>TODO: EACH CASE :)
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Delete</b></h4>
<p>TODO
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Implementation</b></h4>
<p><a href="https://github.com/strncat/algorithms-and-data-structures/blob/master/trees/red-black-tree.cpp">Source Code</a>
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p>CLRS</p>


  </div>
<!-- stupid ads<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
/*
var disqus_config = function () {
this.page.url = /jekyll/update/2020/05/01/red-black-trees.html;  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier =  /jekyll/update/2020/05/01/red-black-trees; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};
*/
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://strncat-github-io.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
-->
  <a class="u-url" href="/jekyll/update/2020/05/01/red-black-trees.html" hidden></a>
</article>

    </main>
  </div>

</body>
</html>