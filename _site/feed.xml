<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://strncat.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://strncat.github.io/" rel="alternate" type="text/html" /><updated>2019-07-15T21:49:07-07:00</updated><id>https://strncat.github.io/feed.xml</id><title type="html">strncat’s notebook</title><subtitle>Hello</subtitle><entry><title type="html">Priority Queues</title><link href="https://strncat.github.io/jekyll/update/2019/07/15/priority-queues.html" rel="alternate" type="text/html" title="Priority Queues" /><published>2019-07-15T07:01:36-07:00</published><updated>2019-07-15T07:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/15/priority-queues</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/15/priority-queues.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are notes on chapter 6 in CLRS.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose you list of jobs with priorities and you want to execute the jobs in the order of their priorities. This list however keeps changing. For example new jobs get inserted frequently. One idea is to just sort the list in &lt;script type=&quot;math/tex&quot;&gt;O(nlog(n))&lt;/script&gt; which is the lower bound for any comparison based algorithm. However, when a new job gets added we will have to spend &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time to insert it in its correct place. This works but can we do better? are there other ideas that we can use that are better than &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Aren’t heaps and priority queues the same?? Let’s look at CLRS’s definition. “A priority queue is a data structure for maintaining a set &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; of elements each with an associated value called a key”. So we have a set of objects and each object has a key. The keys  rather than the object are stored in the heap. So a priority queue is just a data structure that utilizes the heap data structure. A priority queue must support the following operations:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Extracting the maximum element&lt;/li&gt;
  &lt;li&gt;Increase Key&lt;/li&gt;
  &lt;li&gt;Insert Key&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">0 References These are notes on chapter 6 in CLRS. 1 Introduction Suppose you list of jobs with priorities and you want to execute the jobs in the order of their priorities. This list however keeps changing. For example new jobs get inserted frequently. One idea is to just sort the list in which is the lower bound for any comparison based algorithm. However, when a new job gets added we will have to spend time to insert it in its correct place. This works but can we do better? are there other ideas that we can use that are better than time.</summary></entry><entry><title type="html">Ford-Fulkerson’s Maximum Flow</title><link href="https://strncat.github.io/jekyll/update/2019/07/14/ford-fulkerson.html" rel="alternate" type="text/html" title="Ford-Fulkerson's Maximum Flow" /><published>2019-07-14T07:01:36-07:00</published><updated>2019-07-14T07:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/14/ford-fulkerson</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/14/ford-fulkerson.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are notes on chapter 26 in CLRS.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Suppose we want to ship iPhones from San Francisco to New York City because we have a current shortage of iPhones in NYC. We want to ship as many units as possible. Everything needs to be shipped by Ground. We have different routes of different capacities. We want to find the maximum number of iPhones we can ship to NYC. How can we model and solve can this problem? We’ll discuss the Ford-Fulkerson’s method but in order to describe it we have to set the stage and define a number of definitions.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Flow Networks&lt;/b&gt;
&lt;img src=&quot;https://strncat.github.io/assets/flow/1.png&quot; width=&quot;100%&quot; /&gt;
A flow network &lt;script type=&quot;math/tex&quot;&gt;G=(V,E)&lt;/script&gt; is a directed graph where &lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;We have two distinguished vertices, the source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and the sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;Each edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; has a non-negative capacity &lt;script type=&quot;math/tex&quot;&gt;c(u,v) \geq 0&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If we have edge &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; then we must have &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;For any vertex &lt;script type=&quot;math/tex&quot;&gt;v \in V&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;(v,v) \not\in E&lt;/script&gt;. &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;(u,v) \not\in E&lt;/script&gt;, then we can assume that &lt;script type=&quot;math/tex&quot;&gt;c(u,v)=0&lt;/script&gt;.&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is connected and so &lt;script type=&quot;math/tex&quot;&gt;|E| \geq |V| - 1&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 What is Flow?&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;f(u,v)&lt;/script&gt; be the flow from vertex &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; to vertex &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;. A &lt;b&gt;flow&lt;/b&gt; is a real valued function &lt;script type=&quot;math/tex&quot;&gt;f : V \times V \rightarrow \mathbb{R}&lt;/script&gt; that satisfies:&lt;br /&gt;
(1) &lt;b&gt;Capacity constraint:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u, v \in V&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
0 \leq f(u,v) \leq c(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the flow on every edge must not exceed its capacity.
&lt;br /&gt;&lt;br /&gt;
(2) &lt;b&gt;Flow Conservation:&lt;/b&gt; For all &lt;script type=&quot;math/tex&quot;&gt;u \in V - \{s,t\}&lt;/script&gt;, we require&lt;/p&gt;
&lt;div center=&quot;&quot;&gt;
$$
\begin{align*}
\sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v)
\end{align*}
$$
&lt;/div&gt;
&lt;p&gt;In other words, the total flow coming into &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is equal to the total flow leaving &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 The Maximum Flow Problem&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;!--
Let $$|f|$$ be the flow value defined as
&lt;div center&gt;
$$
\begin{align*}
|f| = \sum_{v \in V}f(s,v) = \sum_{v \in V} f(v,s)
\end{align*}
$$
&lt;/div&gt;
In other words, the flow value is the total flow coming out of the source minus the total flow coming into the source. 
--&gt;

&lt;p&gt;In the maximum-flow problem we are given a flow network &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; with a source vertex &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and a sink vertex &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; and we are asked to find the maximum flow in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 The Residual Graph&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 The Ford-Fulkerson’s Method&lt;/b&gt;
&lt;br /&gt;&lt;br /&gt;
Now that we defined everything needed, we can talk about how Fold-Fulkerson solves this problem! yay! Intuitively, Ford-Fulkerson starts with &lt;script type=&quot;math/tex&quot;&gt;f(u,v)=0&lt;/script&gt; for all &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt; and incrementally increases the flow value. It does so by finding an augmenting path in the residual network &lt;script type=&quot;math/tex&quot;&gt;G_f&lt;/script&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are notes on chapter 26 in CLRS. 1 Introduction Suppose we want to ship iPhones from San Francisco to New York City because we have a current shortage of iPhones in NYC. We want to ship as many units as possible. Everything needs to be shipped by Ground. We have different routes of different capacities. We want to find the maximum number of iPhones we can ship to NYC. How can we model and solve can this problem? We’ll discuss the Ford-Fulkerson’s method but in order to describe it we have to set the stage and define a number of definitions. 2 Flow Networks A flow network is a directed graph where We have two distinguished vertices, the source vertex and the sink vertex . Each edge has a non-negative capacity . If we have edge then we must have . For any vertex , . If , then we can assume that . is connected and so . 3 What is Flow? Let be the flow from vertex to vertex . A flow is a real valued function that satisfies: (1) Capacity constraint: For all , we require $$ \begin{align*} 0 \leq f(u,v) \leq c(u,v) \end{align*} $$ In other words, the flow on every edge must not exceed its capacity. (2) Flow Conservation: For all , we require $$ \begin{align*} \sum_{v \in V}f(v,u) = \sum_{v \in V} f(u,v) \end{align*} $$ In other words, the total flow coming into is equal to the total flow leaving . 4 The Maximum Flow Problem</summary></entry><entry><title type="html">Binary Heaps</title><link href="https://strncat.github.io/jekyll/update/2019/07/12/binary-heaps.html" rel="alternate" type="text/html" title="Binary Heaps" /><published>2019-07-12T07:01:36-07:00</published><updated>2019-07-12T07:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/12/binary-heaps</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/12/binary-heaps.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are notes on chapter 6 in CLRS.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 The Heap Data Structure&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;https://strncat.github.io/assets/heaps/1.png&quot; width=&quot;100%&quot; /&gt;
The heap data structure is an array &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; that can be viewed an almost complete binary tree. Each node in the tree is represented by an element in the array. &lt;script type=&quot;math/tex&quot;&gt;A[1]&lt;/script&gt; is the root of the tree which is 7 in the above graph.
&lt;br /&gt;&lt;br /&gt;
Because the heap is based on a complete binary tree, the height of a heap of &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; elements is therefore &lt;script type=&quot;math/tex&quot;&gt;\Theta(n)&lt;/script&gt; (we know that the height of a complete binary tree is &lt;script type=&quot;math/tex&quot;&gt;\Theta(n)&lt;/script&gt;). As a reminder, the height of a node is the longest path down from the node  to a leaf and the height of the tree is the height of the root of the tree. This observation is crucial in proving that many operations on heaps run in &lt;script type=&quot;math/tex&quot;&gt;O(\log(n))&lt;/script&gt; time! yay
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Finding the Parent, Left and Right Children &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let’s see how we can find the parent, left and right children of a node.&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;parent&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// we know that i/2 is rounded down so we don't need to floor&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2*i;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 2*i+1&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Given an element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt;. Its parent is located at &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor i/2 \rfloor]&lt;/script&gt;. For example the parent of 2 (index 7) is &lt;script type=&quot;math/tex&quot;&gt;A[\lfloor 7/2 \rfloor]=A[3]=11&lt;/script&gt;. The left child is &lt;script type=&quot;math/tex&quot;&gt;A[2i]&lt;/script&gt; and the right child is &lt;script type=&quot;math/tex&quot;&gt;A[2i+1]&lt;/script&gt;. For example the right child of 13 (index 2) is &lt;script type=&quot;math/tex&quot;&gt;A[2*2 + 1] = A[5] = 3&lt;/script&gt;.&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 The Heap Property &lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;There are two kinds of binary heaps, min heaps and max heaps. Depending on the heap type the array must satisfy a &lt;b&gt;heap property&lt;/b&gt; which is for any given element &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; we have:&lt;/p&gt;

&lt;p&gt;If this is a max-heap:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A[parent(i)] \geq A[i]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;If this is a min-heap:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A[parent(i)] \leq A[i]&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;The heap property is crucial. Because of it, we know that the root of the heap must be the smallest or the largest element in the heap and therefore, extracting the minimum or the maximum depending on the heap type can be done in constant time!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Maintaining the Heap Property&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Let’s assume that we’re given an index &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; might be smaller than its children. We will assume that both children of &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; maintain the heap property. How do fix the heap to maintain the heap property?
&lt;br /&gt;&lt;br /&gt;
In the max-heap case, we start with checking that &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; is greater than both its children. If this is not the case, then we swap &lt;script type=&quot;math/tex&quot;&gt;A[i]&lt;/script&gt; with the larger of the two children. We then recursively call the function on the largest element that we just swapped. Let’s look at a simple implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1) check if the left child is greater&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (2) check if the right child is greater&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// if one of the children is greater, swap it&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// with i and then call heapify again on the child&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we swapped with&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;max_heapify&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;largest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;The crucial question now is how long does max_heapify take? Well, in the worst case, we will down all the way to a leaf and so the runtime is &lt;script type=&quot;math/tex&quot;&gt;O(h)&lt;/script&gt; which is &lt;script type=&quot;math/tex&quot;&gt;O(log(n))&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Building a Heap&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Hello&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Heapsort&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Hello&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are notes on chapter 6 in CLRS. 1 The Heap Data Structure The heap data structure is an array that can be viewed an almost complete binary tree. Each node in the tree is represented by an element in the array. is the root of the tree which is 7 in the above graph. Because the heap is based on a complete binary tree, the height of a heap of elements is therefore (we know that the height of a complete binary tree is ). As a reminder, the height of a node is the longest path down from the node to a leaf and the height of the tree is the height of the root of the tree. This observation is crucial in proving that many operations on heaps run in time! yay 2 Finding the Parent, Left and Right Children Let’s see how we can find the parent, left and right children of a node.</summary></entry><entry><title type="html">Fenwick Trees</title><link href="https://strncat.github.io/jekyll/update/2019/07/11/fenwick-trees.html" rel="alternate" type="text/html" title="Fenwick Trees" /><published>2019-07-11T07:01:36-07:00</published><updated>2019-07-11T07:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/11/fenwick-trees</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/11/fenwick-trees.html">&lt;p&gt;&lt;img src=&quot;https://strncat.github.io/assets/bellman/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
(1) 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
K
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Bellman-Ford&lt;/b&gt;
&lt;br /&gt;
K&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References (1) 1 Introduction K 2 Bellman-Ford K</summary></entry><entry><title type="html">Topological Sort</title><link href="https://strncat.github.io/jekyll/update/2019/07/10/topological-sort.html" rel="alternate" type="text/html" title="Topological Sort" /><published>2019-07-10T12:01:36-07:00</published><updated>2019-07-10T12:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/10/topological-sort</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/10/topological-sort.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Let &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt; be a directed acyclic graph consisting of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges. Topological Sort is an ordering of the vertices of the graph such that for any given vertices &lt;script type=&quot;math/tex&quot;&gt;u \in V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v \in V&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;(u,v) \in E&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; must come before &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in the ordering.
&lt;br /&gt;&lt;br /&gt;
In other words, we might have some dependency graph of classes and their prerequisites and we would like to find an ordering of the classes such that if class &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is a prerequisite to class &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; comes before &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; in the sorted list.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Revisiting Depth First Search&lt;/b&gt;
&lt;br /&gt;
Let’s take a look at the depth first search code again. When we see a node for the first time, we mark its start time. When we are done processing the node, then mark its finish time. It’s very important to notice here that we only mark a node as finished after we have called DFS on all of its children and their descendants. Intuitively, this means that once we mark a node finished, then it’s impossible for this node to have unvisited neighbors and so this means that all the descendants of this node will have a lower finish time than the node it self!! (we’ll prove this). Therefore, we can utilize this idea by pushing the nodes whenever we’re done processing them into the front of a linked list or a stack and end up with the sorted vertices as required!&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// mark the start time for v&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// mark the finish time for v&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we can push the nodes here onto a stack!!! yay&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;https://strncat.github.io/assets/topo/1.png&quot; alt=&quot;my photo&quot; /&gt;
Let’s explore the graph above with dfs again to see how the start and finish times are set again. We will start from &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; (arbitrarily chosen), mark its start time as zero and visit &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;. We will mark &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;’s start time and then recursively call DFS on &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;. We will set its start time. At this point, we don’t have more neighbors and so we mark its finish time as well. When we come back, &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; won’t have more neighbors and so we will mark its finish time. We do the same thing with &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; and we’ll end up with the graph below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strncat.github.io/assets/topo/2.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next we will start from &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and visit &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; and mark both their start and finish times. Finally we will visit &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; and mark its times as well.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strncat.github.io/assets/topo/3.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notice how if we ordered the nodes by their finishing times (&lt;script type=&quot;math/tex&quot;&gt;a, c, b, f, e, d&lt;/script&gt;) descendingly then we’ll have a valid ordering of the nodes. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Proof of Correctness&lt;/b&gt;
&lt;br /&gt;
The first time I saw Topological Sort I didn’t believe. It seemed strange to just be able to sort the vertices by just doing a DFS. What do we need to show to prove that topological sort works? what is the intuition here? Let’s think about this. We need to prove that for any two vertices &lt;script type=&quot;math/tex&quot;&gt;a \in V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b \in V&lt;/script&gt;, if there is an edge from &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; to be &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; will come before &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; in the sorted output. 
&lt;br /&gt;&lt;br /&gt;
How do we prove this? Well we know that topological sort relies on the finishing times of vertices and we know that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;’s finishing time gets marked after its children and so this means that we want to prove that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;’s finishing time is greater than &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;’s finishing time. So to summarize, we really want to prove the following claim: For any two vertices &lt;script type=&quot;math/tex&quot;&gt;a \in V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;b \in V&lt;/script&gt;, if there is an edge from &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;’s finishing time is greater than &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;’s finishing time.&lt;/p&gt;

&lt;p&gt;In order to prove the above claim we will use a theorem calling the Parenthesis Theorem from CLRS (proof in CLRS). The parenthesis theorem claims that in a depth first search of a graph &lt;script type=&quot;math/tex&quot;&gt;G = (V,E)&lt;/script&gt; and for any vertices &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, exactly one of the following conditions holds:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;the intervals [u.start_time, u.finish_time] and [v.start_time, v.finish_time] are disjoint and neither &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is a descendant of the other in the depth-first forest.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [u.start_time, u.finish_time] is contained within the interval [v.start_time, v.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; in the depth-first tree.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [v.start_time, v.finish_time] is contained within the interval [u.start_time, u.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;u&lt;/script&gt; in the depth-first tree.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Proof: TODO!&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Now we are ready to prove our earlier claim.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Let &lt;script type=&quot;math/tex&quot;&gt;G = (V,E)&lt;/script&gt; be a directed acyclic graph. For any two vertices &lt;script type=&quot;math/tex&quot;&gt;a, b \in V&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;(a,b) \in E&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;.finish_time &amp;gt; &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt;.finish_time.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof:&lt;br /&gt;
Let’s consider the DFS tree generated after running DFS and let’s apply the Parenthesis Theorem. According to the theorem one of three conditions must hold:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [a.start_time, a.finish_time] is contained within the interval [b.start_time, b.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; in the depth-first tree. We claim that this case is impossible because by assumption, we know that &lt;script type=&quot;math/tex&quot;&gt;(a,b) \in E&lt;/script&gt; and so if &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is descendant of &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; must have a cycle. This is a contradiction since &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; is acyclic.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the interval [b.start_time, b.finish_time] is contained within the interval [a.start_time, a.finish_time] and &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is a descendant of &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; in the depth-first tree. This immediately shows that &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b.finish_time &lt; a.finish_time %]]&gt;&lt;/script&gt; as we wanted to show.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;the intervals [a.start_time, a.finish_time] and [b.start_time, b.finish_time] are disjoint and neither &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; is a descendant of the other in the depth-first forest. In this case, we claim that we must have explored &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; first before &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;. Because if we have explored &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; first then we would have explored &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; since &lt;script type=&quot;math/tex&quot;&gt;(a,b) \in E&lt;/script&gt; and so we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b.finish_time &lt; a.finish_time %]]&gt;&lt;/script&gt; as required. Beautiful isn’t it?&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We conclude from all three cases that we must have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
b.finish_time &lt; a.finish_time %]]&gt;&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;\blacksquare&lt;/script&gt; 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Simple Implementation&lt;/b&gt;
&lt;br /&gt;
Let’s rewrite DFS to push the nodes onto a stack and let’s forget about the start and finishing times since we only care about returning an ordering of the vertices in this specific case. Let’s call this version topological sort! Here is a simple implementation:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// node is done, we can push it on the ordered stack&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;topological_sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// perform dfs until there are no more unvisited nodes&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;top&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
It is just DFS! so the total time is &lt;script type=&quot;math/tex&quot;&gt;O(V+E)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt;
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/topological-search
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction Let be a directed acyclic graph consisting of vertices and edges. Topological Sort is an ordering of the vertices of the graph such that for any given vertices and , if , then must come before in the ordering. In other words, we might have some dependency graph of classes and their prerequisites and we would like to find an ordering of the classes such that if class is a prerequisite to class , then comes before in the sorted list. 2 Revisiting Depth First Search Let’s take a look at the depth first search code again. When we see a node for the first time, we mark its start time. When we are done processing the node, then mark its finish time. It’s very important to notice here that we only mark a node as finished after we have called DFS on all of its children and their descendants. Intuitively, this means that once we mark a node finished, then it’s impossible for this node to have unvisited neighbors and so this means that all the descendants of this node will have a lower finish time than the node it self!! (we’ll prove this). Therefore, we can utilize this idea by pushing the nodes whenever we’re done processing them into the front of a linked list or a stack and end up with the sorted vertices as required! int dfs(int v, int current_time, std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph, std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; &amp;amp;times, std::vector&amp;lt;int&amp;gt; &amp;amp;visited) { times[v].first = current_time++; // mark the start time for v visited[0] = true; for (int i = 0; i &amp;lt; graph[v].size(); i++) { int u = graph[v][i]; if (visited[u] == false) { current_time = dfs(u, current_time, graph, times, visited); current_time++; } } times[v].second = current_time; // mark the finish time for v // we can push the nodes here onto a stack!!! yay return current_time; } 3 Example Let’s explore the graph above with dfs again to see how the start and finish times are set again. We will start from (arbitrarily chosen), mark its start time as zero and visit . We will mark ’s start time and then recursively call DFS on . We will set its start time. At this point, we don’t have more neighbors and so we mark its finish time as well. When we come back, won’t have more neighbors and so we will mark its finish time. We do the same thing with and we’ll end up with the graph below.</summary></entry><entry><title type="html">Cycles in Graphs</title><link href="https://strncat.github.io/jekyll/update/2019/07/09/cycles.html" rel="alternate" type="text/html" title="Cycles in Graphs" /><published>2019-07-09T12:01:36-07:00</published><updated>2019-07-09T12:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/09/cycles</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/09/cycles.html">&lt;!--
&lt;b&gt;0 References&lt;/b&gt;&lt;br&gt;
?
&lt;br&gt;
&lt;br&gt;
&lt;hr&gt;
&lt;br&gt;
--&gt;

&lt;p&gt;&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;https://strncat.github.io/assets/cycle/1.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We are given a graph &lt;script type=&quot;math/tex&quot;&gt;G = (V,E)&lt;/script&gt; and we want to know if there exists a cycle in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Undirected Graphs&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
This is extremely simple. We already keep track of nodes visited so far. If it happens during our search that we come across a visited node then we’re done! there must exists a cycle otherwise, we won’t ever re-visit any vertex in &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt;. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Directed Graph&lt;/b&gt;
&lt;br /&gt;
If we think about this case carefully, we’ll see that it’s simple. Let’s think of this in terms of the tree generated by DFS.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Implementation&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;black&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;g&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;gray&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// CYCLE&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;color&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;white&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ordered&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// node is done, we can push it on the ordered stack&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation&lt;/b&gt;
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/cycles
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Patricia Tries</title><link href="https://strncat.github.io/jekyll/update/2019/07/08/patricia-trie.html" rel="alternate" type="text/html" title="Patricia Tries" /><published>2019-07-08T12:01:36-07:00</published><updated>2019-07-08T12:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/08/patricia-trie</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/08/patricia-trie.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs166/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Now that we have seen the &lt;a href=&quot;/jekyll/update/2019/07/06/tries.html&quot;&gt;trie&lt;/a&gt; data structure, let’s look at a more efficient solution to the problem we discussed before. As a reminder, we are given &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and a string pattern &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. We want to find all the strings that match  &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. With a regular trie we solved it with &lt;script type=&quot;math/tex&quot;&gt;\langle O(m),O(n) \rangle&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; is the preprocessing step of building the trie out of all the strings we’re given. The &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time is the look up time for each pattern of length &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. Can we make it faster?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 The Patricia Trie Data Structure&lt;/b&gt;
&lt;br /&gt;
Give the trie below:
&lt;img src=&quot;https://strncat.github.io/assets/trie/3.png&quot; width=&quot;100%&quot; /&gt;
In a Patricia trie we instead merge any node (with the exception of the root) that has only one child with its parent. Let’s look at the result.
&lt;img src=&quot;https://strncat.github.io/assets/trie/4.png&quot; width=&quot;100%&quot; /&gt;
That’s it! This trie is called a Patricia trie! we basically merge internal nodes that have one child only into their parents to optimize the space needed to store all keys.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Properties of Patricia Tries&lt;/b&gt;
&lt;br /&gt;
Can we upper bound the number of nodes in a Patricia trie? Yes!&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Claim: the number of nodes in a Patricia trie with &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; words is &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt; nodes&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Proof:&lt;br /&gt;
We know that we have at most &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; nodes that mark the end of a valid word in a patricia trie. Let’s remove all internal nodes so now we have &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; clusters and let’s add the internal nodes one at a time. Each internal node added will combine two clusters together. This will mean there are &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt; internal nodes total. (If not then an internal node will end up having only one child which is a contradiction). Therefore, the total number of nodes is &lt;script type=&quot;math/tex&quot;&gt;O(k)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Search&lt;/b&gt;
&lt;br /&gt;
S
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
How long does search takes? oh only the length of the key or pattern!! so &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Insert&lt;/b&gt;
&lt;br /&gt;
S
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So insert takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time as well!
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
W
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt; 
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References http://web.stanford.edu/class/cs166/ 1 Introduction Now that we have seen the trie data structure, let’s look at a more efficient solution to the problem we discussed before. As a reminder, we are given strings of total length and a string pattern of length . We want to find all the strings that match . With a regular trie we solved it with time where is the preprocessing step of building the trie out of all the strings we’re given. The time is the look up time for each pattern of length . Can we make it faster? 2 The Patricia Trie Data Structure Give the trie below: In a Patricia trie we instead merge any node (with the exception of the root) that has only one child with its parent. Let’s look at the result. That’s it! This trie is called a Patricia trie! we basically merge internal nodes that have one child only into their parents to optimize the space needed to store all keys. 3 Properties of Patricia Tries Can we upper bound the number of nodes in a Patricia trie? Yes!</summary></entry><entry><title type="html">Suffix Trees</title><link href="https://strncat.github.io/jekyll/update/2019/07/07/suffix-trees.html" rel="alternate" type="text/html" title="Suffix Trees" /><published>2019-07-07T12:01:36-07:00</published><updated>2019-07-07T12:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/07/suffix-trees</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/07/suffix-trees.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Algorithms on Strings, Trees, and Sequences by Dan Gusfeild
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 The Trie Data Structure&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;img src=&quot;https://strncat.github.io/assets/trie/1.png&quot; width=&quot;100%&quot; /&gt;
Hello
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Search&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Hello&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Insert&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
&lt;br /&gt;
Hello
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt; 
&lt;br /&gt;
&lt;br /&gt;
Hello
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References Algorithms on Strings, Trees, and Sequences by Dan Gusfeild 1 Introduction</summary></entry><entry><title type="html">Tries (Prefix Trees)</title><link href="https://strncat.github.io/jekyll/update/2019/07/06/tries.html" rel="alternate" type="text/html" title="Tries (Prefix Trees)" /><published>2019-07-06T12:01:36-07:00</published><updated>2019-07-06T12:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/06/tries</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/06/tries.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Algorithms by Robert Sedgwick and Kevin Wayne
&lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;http://web.stanford.edu/class/cs166/
&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
Consider the following problem: Given &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; strings of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; and a string pattern &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; of length &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt;. We want to find all the strings that match  &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt;. The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; time. However, suppose that we now we have &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; patterns, then this approach will take &lt;script type=&quot;math/tex&quot;&gt;O(mr)&lt;/script&gt; time which is really slow, especially if we’re displaying auto-complete live results to the user as they type their queries. In the RMQ notation, we will write &lt;script type=&quot;math/tex&quot;&gt;\langle O(1), O(mr)\rangle&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;O(1)&lt;/script&gt; is the preprocessing time and &lt;script type=&quot;math/tex&quot;&gt;O(mr)&lt;/script&gt; is the query time. So how can we make it faster?
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 The Trie Data Structure&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;https://strncat.github.io/assets/trie/1.png&quot; width=&quot;100%&quot; /&gt;
&lt;br /&gt;
The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider.
&lt;br /&gt;
Let’s start with studying some properties of tries:
&lt;br /&gt;&lt;br /&gt;
&amp;lt;&amp;gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &lt;br /&gt;
&amp;lt;&amp;gt; Each node will have &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; pointers or children where &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is the alphabet size. &lt;br /&gt;
&amp;lt;&amp;gt; Edges represent letters. For example, the root node has one edge (&lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;) to the node below.&lt;br /&gt;
&amp;lt;&amp;gt; Each node also has only one parent.&lt;br /&gt;
&lt;br /&gt;
Let’s look at what a trie really looks like:
&lt;br /&gt;
&lt;img src=&quot;https://strncat.github.io/assets/trie/2.png&quot; width=&quot;100%&quot; /&gt;
You can see above, the root has only &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; edge/link. From &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, we can traverse to either &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;. From &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; we can add &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;t&lt;/script&gt; only and from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; we can add &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; or &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; and so on.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Prefix Search&lt;/b&gt;
&lt;br /&gt;
How do we search for prefixes now? given a pattern &lt;script type=&quot;math/tex&quot;&gt;p&lt;/script&gt; we want to output all possible matches. We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word.
&lt;br /&gt;
Let’s look at search first:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// null pointer&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// not found&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// move to the child&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// prefix match: print all possible matches&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;words_with_prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// no matches&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;front&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c_str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// total matches&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// collect matches recursively from all branches&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// save them in q&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;queue&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue.
&lt;br /&gt;
How long does search takes? oh only the length of the key or pattern!! so &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt;!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Insert&lt;/b&gt;
&lt;br /&gt;
To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter.
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// word exists&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// increment word count&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;word&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'a'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
             &lt;span class=&quot;c1&quot;&gt;// this letter doesn't exist, create it&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// this letter has a link already, follow it along&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;children&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;index&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// mark the last node, this is the end of our word&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// this is a marker of an end to a valid word&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;marker&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;So insert takes &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time as well!
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;5 Delete&lt;/b&gt;
&lt;br /&gt;
To be added.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Longest Prefix&lt;/b&gt;
&lt;br /&gt;
To be added
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;b&gt;7 Running Time&lt;/b&gt;
&lt;br /&gt;
We mentioned above that insert and search both take &lt;script type=&quot;math/tex&quot;&gt;O(n)&lt;/script&gt; time where &lt;script type=&quot;math/tex&quot;&gt;n&lt;/script&gt; is the length of the pattern. How long does it take to build a trie to represent all words of total length &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;? We need to make &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; insertions each of which will take &lt;script type=&quot;math/tex&quot;&gt;O(&lt;/script&gt;size of each word&lt;script type=&quot;math/tex&quot;&gt;)&lt;/script&gt;. Since the total length of all words is &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt;, then the total time is &lt;script type=&quot;math/tex&quot;&gt;O(m)&lt;/script&gt; which happens only once initially. Therefore, in the RMQ notation we will have &lt;script type=&quot;math/tex&quot;&gt;\langle O(m), O(n) \rangle&lt;/script&gt; which is a lot better than the naive solution. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;8 Full Implementation:&lt;/b&gt; 
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References Algorithms by Robert Sedgwick and Kevin Wayne http://web.stanford.edu/class/cs166/ 1 Introduction Consider the following problem: Given strings of total length and a string pattern of length . We want to find all the strings that match . The simplest solution would be to look at all strings and compare each string with the pattern we have. This will take time. However, suppose that we now we have patterns, then this approach will take time which is really slow, especially if we’re displaying auto-complete live results to the user as they type their queries. In the RMQ notation, we will write where is the preprocessing time and is the query time. So how can we make it faster? 2 The Trie Data Structure The trie (pronounced “try”) data structure is an efficient data structure that can help us achieve a faster running time when searching for keys. In the picture above, we can form the words (words end with colored nodes): cake, cakes, cat, civil and cider. Let’s start with studying some properties of tries: &amp;lt;&amp;gt; Each node indicates whether it is the end of a valid word or not. In the above example, colored nodes represent valid words. &amp;lt;&amp;gt; Each node will have pointers or children where is the alphabet size. &amp;lt;&amp;gt; Edges represent letters. For example, the root node has one edge () to the node below. &amp;lt;&amp;gt; Each node also has only one parent. Let’s look at what a trie really looks like: You can see above, the root has only edge/link. From , we can traverse to either or . From we can add or only and from we can add or and so on. 3 Prefix Search How do we search for prefixes now? given a pattern we want to output all possible matches. We just traverse down the root and keep matching until we reach the last character of the prefix we’re searching. If we want an exact match then we check if the node has a marker to indicate that it ends a valid word and return true if it does. But if we want to print all possible matches then we can take this node we’re currently on and then just do a simple depth first search down every branch to collect every possible word. Let’s look at search first: node* search(std::string word) { long m = word.length(); node *current = root; for (int i = 0; i &amp;lt; m; i++) { int index = word[i] - 'a'; if (!current-&amp;gt;children[index]) { // null pointer return NULL; // not found } // move to the child current = current-&amp;gt;children[index]; } return current; } Search is simple. We just traverse down the root and stop when we’re done matching every character in the prefix. Next, we’ll look at word_with_prefix: // prefix match: print all possible matches int words_with_prefix(std::string prefix) { node *current = search(prefix); if (current == NULL) { return 0; } // no matches std::queue&amp;lt;std::string&amp;gt; q; collect(current, prefix, q); while (!q.empty()) { printf(&quot;%s\n&quot;, q.front().c_str()); q.pop(); } return current-&amp;gt;value; // total matches } Here, we utilize search and then pass a queue to collect which will fill the queue with all matches. Next we’ll look at collect: // collect matches recursively from all branches // save them in q void collect(node *current, std::string prefix, std::queue&amp;lt;std::string&amp;gt; &amp;amp;q) { if (current == NULL) { return; } if (current-&amp;gt;marker) { q.push(prefix); } for (int i = 0; i &amp;lt; SIZE; i++) { if (current-&amp;gt;children[i] != NULL) { char c = i + 'a'; collect(current-&amp;gt;children[i], prefix + c, q); } } } Here we will perform a depth first search on the tree rooted at current. As we go down each path, we will collect the characters in the string prefix. Once we’re at a leaf node and its value (marker) is not 0, meaning it’s a valid word, then we will push it on the queue. How long does search takes? oh only the length of the key or pattern!! so ! 4 Insert To insert a key we follow a similar process. We start at the root and we also start at the beginning of the key to be inserted. If the letter we’re on has already a link in the root then we follow it a long and move to the next letter as well. If the link is null then we create a new node for that letter. void insert(std::string word) { if (search(word)) { // word exists return; } int length = (int) word.length(); node *current = root; current-&amp;gt;value++; // increment word count for (int i = 0; i &amp;lt; length; i++) { int index = word[i] - 'a'; if (!current-&amp;gt;children[index]) { // this letter doesn't exist, create it current-&amp;gt;children[index] = new node(); } // this letter has a link already, follow it along current = current-&amp;gt;children[index]; current-&amp;gt;value++; } // mark the last node, this is the end of our word // this is a marker of an end to a valid word current-&amp;gt;marker = true; } So insert takes time as well! 5 Delete To be added. 6 Longest Prefix To be added 7 Running Time We mentioned above that insert and search both take time where is the length of the pattern. How long does it take to build a trie to represent all words of total length ? We need to make insertions each of which will take size of each word. Since the total length of all words is , then the total time is which happens only once initially. Therefore, in the RMQ notation we will have which is a lot better than the naive solution. 8 Full Implementation: https://github.com/strncat/algorithms-and-data-structures/tree/master/strings/trie.cpp</summary></entry><entry><title type="html">Depth First Search</title><link href="https://strncat.github.io/jekyll/update/2019/07/05/dfs.html" rel="alternate" type="text/html" title="Depth First Search" /><published>2019-07-05T12:01:36-07:00</published><updated>2019-07-05T12:01:36-07:00</updated><id>https://strncat.github.io/jekyll/update/2019/07/05/dfs</id><content type="html" xml:base="https://strncat.github.io/jekyll/update/2019/07/05/dfs.html">&lt;p&gt;&lt;b&gt;0 References&lt;/b&gt;&lt;br /&gt;
These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;1 Introduction&lt;/b&gt;
&lt;br /&gt;
&lt;img src=&quot;https://strncat.github.io/assets/dfs/0.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Depth first search like breadth first search is an algorithm used to explore a graph. Let &lt;script type=&quot;math/tex&quot;&gt;G = (V, E)&lt;/script&gt; be a graph consisting of &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; vertices and &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; edges and let &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; be the source vertex where we will start the traversal from. Depth first search explores the graph from the root as deep as possible until there are no more vertices to visit and then resumes the search again from a different branch.
&lt;br /&gt;&lt;br /&gt;
In a depth first search, we typically keep track of the time we first discovered a vertex and also the time we finished processing a vertex (after we look at all its neighbors). This information will help later in topologically sorting a graph. 
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;2 Data Structures&lt;/b&gt;
&lt;br /&gt;
To perform a depth first search, we will maintain the following data structures:
&lt;br /&gt;
(2) A set or an array that keeps track of the visited nodes. Remember that &lt;script type=&quot;math/tex&quot;&gt;G&lt;/script&gt; might contain cycles and so we want to make sure that we explore each node once.
&lt;br /&gt;&lt;br /&gt;
(1) A stack. We want to explore the nodes closest to &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; first. Since we’re insterested in going as deep as possible, a stack will be the ideal data structures. Note that we can just eliminate the use of an explicit stack by using recursion (implicit stack) as we’ll be doing in the implementation below.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;3 Example&lt;/b&gt;
&lt;br /&gt;
Let’s explore the graph above. We will start from &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; and as soon as we see &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; we’ll recursively call dfs again. The start time for &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; is 0 and the start time for &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; is 1.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strncat.github.io/assets/dfs/1.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next we will recursively visit &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt;. They will have start times 2, 3 and 4 respectively.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strncat.github.io/assets/dfs/2.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, there will be no more vertices to traverse and so node 
&lt;script type=&quot;math/tex&quot;&gt;d&lt;/script&gt; is now finished with time 5, followed by &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;c&lt;/script&gt; and then &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strncat.github.io/assets/dfs/3.png&quot; alt=&quot;my photo&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, we will traverse node &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; with start time 9 and finish time 10. Node &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt; will now be done with finish time &lt;script type=&quot;math/tex&quot;&gt;11&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://strncat.github.io/assets/dfs/4.png&quot; alt=&quot;my photo&quot; /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;4 Implementation&lt;/b&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-c--&quot; data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pair&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// seeing v for the first time&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;][&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dfs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;graph&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;visited&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;times&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// v is done bye forever&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;current_time&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;6 Running Time&lt;/b&gt;
&lt;br /&gt;
Similar to the analysis of breadth first search. We visit each vertex once only. That’s &lt;script type=&quot;math/tex&quot;&gt;O(V)&lt;/script&gt; time. Therefore, we also visit the adjacency list of each vertex at most once and that’s &lt;script type=&quot;math/tex&quot;&gt;O(E)&lt;/script&gt; time. Therefore, the total time is &lt;script type=&quot;math/tex&quot;&gt;O(V+E)&lt;/script&gt;.
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!------------------------------------------------------------------------------------&gt;
&lt;p&gt;&lt;br /&gt;
&lt;b&gt;7 Full Implementation:&lt;/b&gt;
&lt;br /&gt;
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/depth-first-search
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">0 References These are just my class notes from following http://web.stanford.edu/class/cs161/schedule.html 1 Introduction</summary></entry></feed>