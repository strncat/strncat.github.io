<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.0 -->
<title>Prim’s Minimum Spanning Tree | strncat’s notebook</title>
<meta name="generator" content="Jekyll v3.7.4" />
<meta property="og:title" content="Prim’s Minimum Spanning Tree" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="b c d e f a 4 7 2 6 5 1 2 3 1 1 Introduction Let be undirected, weighted graph with vertices and edges. A minimum spanning tree is a tree that connects all the vertices in of minimal cost. Prim greedily finds the minimum spanning tree by growing a tree. what start from a vertex and then we pick the cheapest edge out of that vertex. We keep adding cheap edges such that we don’t create a cycle until we cover all the vertices in . Even though we will only analyze the efficient implementation of Prim, it is very useful to look at the naive implementation because it is more intuitive." />
<meta property="og:description" content="b c d e f a 4 7 2 6 5 1 2 3 1 1 Introduction Let be undirected, weighted graph with vertices and edges. A minimum spanning tree is a tree that connects all the vertices in of minimal cost. Prim greedily finds the minimum spanning tree by growing a tree. what start from a vertex and then we pick the cheapest edge out of that vertex. We keep adding cheap edges such that we don’t create a cycle until we cover all the vertices in . Even though we will only analyze the efficient implementation of Prim, it is very useful to look at the naive implementation because it is more intuitive." />
<link rel="canonical" href="http://localhost:4000/jekyll/update/2019/04/02/prim.html" />
<meta property="og:url" content="http://localhost:4000/jekyll/update/2019/04/02/prim.html" />
<meta property="og:site_name" content="strncat’s notebook" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-04-02T12:01:36-07:00" />
<script type="application/ld+json">
{"description":"b c d e f a 4 7 2 6 5 1 2 3 1 1 Introduction Let be undirected, weighted graph with vertices and edges. A minimum spanning tree is a tree that connects all the vertices in of minimal cost. Prim greedily finds the minimum spanning tree by growing a tree. what start from a vertex and then we pick the cheapest edge out of that vertex. We keep adding cheap edges such that we don’t create a cycle until we cover all the vertices in . Even though we will only analyze the efficient implementation of Prim, it is very useful to look at the naive implementation because it is more intuitive.","@type":"BlogPosting","url":"http://localhost:4000/jekyll/update/2019/04/02/prim.html","headline":"Prim’s Minimum Spanning Tree","dateModified":"2019-04-02T12:01:36-07:00","datePublished":"2019-04-02T12:01:36-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/jekyll/update/2019/04/02/prim.html"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="strncat's notebook" />
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
>
</script>
<script
  type="text/javascript"
  charset="utf-8"
  src="https://vincenttam.github.io/javascripts/MathJaxLocal.js"
>
</script>


</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">strncat&#39;s notebook</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">about</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Prim&#39;s Minimum Spanning Tree</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-04-02T12:01:36-07:00" itemprop="datePublished">Apr 2, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <svg width="800" height="250" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="294.5" cy="68.5" rx="30" ry="30" />
	<text x="289.5" y="74.5" font-family="Times New Roman" font-size="20">b</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="498.5" cy="68.5" rx="30" ry="30" />
	<text x="494.5" y="74.5" font-family="Times New Roman" font-size="20">c</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="664.5" cy="147.5" rx="30" ry="30" />
	<text x="659.5" y="153.5" font-family="Times New Roman" font-size="20">d</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="498.5" cy="218.5" rx="30" ry="30" />
	<text x="494.5" y="224.5" font-family="Times New Roman" font-size="20">e</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="294.5" cy="218.5" rx="30" ry="30" />
	<text x="291.5" y="224.5" font-family="Times New Roman" font-size="20">f</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="137.5" cy="159.5" rx="30" ry="30" />
	<text x="133.5" y="165.5" font-family="Times New Roman" font-size="20">a</text>
	<polygon stroke="black" stroke-width="1" points="324.5,68.5 468.5,68.5" />
	<text x="391.5" y="89.5" font-family="Times New Roman" font-size="20">4</text>
	<polygon stroke="black" stroke-width="1" points="525.589,81.392 637.411,134.608" />
	<text x="586.5" y="98.5" font-family="Times New Roman" font-size="20">7</text>
	<polygon stroke="black" stroke-width="1" points="636.917,159.298 526.083,206.702" />
	<text x="566.5" y="173.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="468.5,218.5 324.5,218.5" />
	<text x="391.5" y="209.5" font-family="Times New Roman" font-size="20">6</text>
	<polygon stroke="black" stroke-width="1" points="318.67,200.728 474.33,86.272" />
	<text x="401.5" y="164.5" font-family="Times New Roman" font-size="20">5</text>
	<polygon stroke="black" stroke-width="1" points="163.455,144.456 268.545,83.544" />
	<text x="220.5" y="135.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="165.583,170.053 266.417,207.947" />
	<text x="201.5" y="210.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="498.5,188.5 498.5,98.5" />
	<text x="503.5" y="149.5" font-family="Times New Roman" font-size="20">3</text>
	<polygon stroke="black" stroke-width="1" points="294.5,188.5 294.5,98.5" />
	<text x="299.5" y="149.5" font-family="Times New Roman" font-size="20">1</text>
</svg>
<p><b>1 Introduction</b><br />
Let <script type="math/tex">G=(V,E)</script> be undirected, weighted graph with <script type="math/tex">V</script> vertices and <script type="math/tex">E</script> edges. A minimum spanning tree is a tree that connects all the vertices in <script type="math/tex">V</script> of minimal cost. Prim greedily finds the minimum spanning tree by growing a tree. what start from a vertex and then we pick the cheapest edge out of that vertex. We keep adding cheap edges such that we don’t create a cycle until we cover all the vertices in <script type="math/tex">V</script>. Even though we will only analyze the efficient implementation of Prim, it is very useful to look at the naive implementation because it is more intuitive.</p>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>2.1 Algorithm (slow naive version)</b>
<br /></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">We</span> <span class="n">can</span> <span class="n">start</span> <span class="n">from</span> <span class="n">any</span> <span class="n">node</span> <span class="n">s</span><span class="p">.</span>
<span class="n">pick</span> <span class="n">the</span> <span class="n">lightest</span> <span class="n">node</span> <span class="n">coming</span> <span class="n">out</span> <span class="n">of</span> <span class="n">s</span><span class="p">.</span>
<span class="n">MST</span> <span class="o">=</span> <span class="p">[{</span><span class="n">s</span><span class="p">,</span><span class="n">u</span><span class="p">}]</span>
<span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">s</span><span class="p">,</span><span class="n">u</span><span class="p">}</span>
<span class="k">while</span> <span class="o">|</span><span class="n">visited</span><span class="o">|</span> <span class="o">&lt;</span> <span class="o">|</span><span class="n">V</span><span class="o">|</span> <span class="p">{</span>
	<span class="n">pick</span> <span class="n">the</span> <span class="n">cheapest</span> <span class="n">edge</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">}</span> <span class="n">in</span> <span class="n">E</span> <span class="n">so</span> <span class="n">that</span><span class="o">:</span>
		<span class="n">x</span> <span class="n">is</span> <span class="n">in</span> <span class="n">visited</span>
		<span class="n">y</span> <span class="n">is</span> <span class="n">not</span> <span class="n">in</span> <span class="n">visited</span>
	<span class="n">add</span> <span class="p">{</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">}</span> <span class="n">to</span> <span class="n">MST</span>
	<span class="n">add</span> <span class="n">y</span> <span class="n">to</span> <span class="n">visited</span> 
<span class="p">}</span>
<span class="k">return</span> <span class="n">MST</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>2.2 Algorithm (fast, used for the remaining of these notes)</b>
<br />
This smart implementation is basically Dijkstra! The only difference is the update condition. In Dijkstra, we take into account the whole path cost while in Prim we only care about the edge weight itself!</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">Set</span> <span class="n">all</span> <span class="n">vertices</span> <span class="n">to</span> <span class="n">unreached</span>
<span class="n">k</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">infinity</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">V</span>
<span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">all</span> <span class="n">v</span> <span class="n">in</span> <span class="n">V</span>
<span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">there</span> <span class="n">are</span> <span class="n">unreached</span> <span class="n">nodes</span> <span class="p">{</span>
	<span class="n">pick</span> <span class="n">the</span> <span class="n">unreached</span> <span class="n">node</span> <span class="n">u</span> <span class="n">with</span> <span class="n">the</span> <span class="n">smallest</span> <span class="n">key</span> <span class="n">k</span><span class="p">[</span><span class="n">u</span><span class="p">].</span>
	<span class="k">for</span> <span class="n">each</span> <span class="n">neighbor</span> <span class="n">v</span> <span class="n">of</span> <span class="n">u</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// The is the only difference between Prim and Dijkstra</span>
			<span class="n">k</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
			<span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">Mark</span> <span class="n">u</span> <span class="n">as</span> <span class="n">reached</span> <span class="n">and</span> <span class="n">add</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">u</span><span class="p">],</span><span class="n">u</span><span class="p">)</span> <span class="n">to</span> <span class="n">MST</span>
	<span class="c1">// This edge is safe to add and won't rule out success, proof below!</span>
	<span class="c1">// in the actual implementation, we don't add the source vertex since p[u] is -1!</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>3 Example</b><br /></p>

<p>very similar to Dijkstra, we maintain a set of unreached nodes <script type="math/tex">\{a, b, c, d, e, f\}</script>. We then assign <script type="math/tex">k[v] = \infty</script> for all nodes. For the start node, we update its key to zero. <script type="math/tex">k[a] = 0</script>.
<br /><br />
<i>Iteration 0</i><br />
We extract the minimum unreached node <script type="math/tex">a</script>. We we now update each neighbor according to the algorithm. After updating each neightbor we get the following the values. Also, after updating all neighbors, we mark <script type="math/tex">a</script> as reached.</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract <script type="math/tex">a</script>)</td>
      <td>0</td>
      <td>1</td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><i>Iteration 1</i><br />
We extract the minimum again from the unreached nodes. This time we extract <script type="math/tex">b</script>. We update all the neighbors and at the end of this iteration, we mark <script type="math/tex">b</script> as sure and <script type="math/tex">\{b,a\}</script></p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract <script type="math/tex">a</script>)</td>
      <td>0</td>
      <td>1</td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td>2</td>
    </tr>
    <tr>
      <td>1 (extract <script type="math/tex">b</script>) add <script type="math/tex">\{b,a\}</script></td>
      <td>0</td>
      <td>1</td>
      <td>4</td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p><i>Final iterations</i><br />
We continue with the same process. We extract the node <script type="math/tex">f</script> and update its neighbors. We then mark it as reached and add <script type="math/tex">\{f,b\}</script> to our MST. We next extract <script type="math/tex">c</script> and update the neighbors again. We then mark <script type="math/tex">c</script> as reached add <script type="math/tex">\{a,b\}</script> to our MST. The rest of iterations are in the following table:</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>a</th>
      <th>b</th>
      <th>c</th>
      <th>d</th>
      <th>e</th>
      <th>f</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0 (extract <script type="math/tex">a</script>)</td>
      <td>0</td>
      <td>1</td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td>2</td>
    </tr>
    <tr>
      <td>1 (extract <script type="math/tex">b</script>) add <script type="math/tex">\{b,a\}</script></td>
      <td>0</td>
      <td>1</td>
      <td>4</td>
      <td><script type="math/tex">\infty</script></td>
      <td><script type="math/tex">\infty</script></td>
      <td>1</td>
    </tr>
    <tr>
      <td>2 (extract <script type="math/tex">f</script>) add <script type="math/tex">\{f,b\}</script></td>
      <td>0</td>
      <td>1</td>
      <td>4</td>
      <td><script type="math/tex">\infty</script></td>
      <td>6</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3 (extract <script type="math/tex">c</script>) add <script type="math/tex">\{c,b\}</script></td>
      <td>0</td>
      <td>1</td>
      <td>4</td>
      <td>7</td>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3 (extract <script type="math/tex">e</script>) add <script type="math/tex">\{e,c\}</script></td>
      <td>0</td>
      <td>1</td>
      <td>4</td>
      <td>2</td>
      <td>3</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3 (extract <script type="math/tex">d</script>) add <script type="math/tex">\{d,e\}</script></td>
      <td>0</td>
      <td>1</td>
      <td>4</td>
      <td>2</td>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>The final minimum spanning tree is the following tree:</p>
<svg width="800" height="250" version="1.1" xmlns="http://www.w3.org/2000/svg">
	<ellipse stroke="black" stroke-width="1" fill="none" cx="294.5" cy="68.5" rx="30" ry="30" />
	<text x="289.5" y="74.5" font-family="Times New Roman" font-size="20">b</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="498.5" cy="68.5" rx="30" ry="30" />
	<text x="494.5" y="74.5" font-family="Times New Roman" font-size="20">c</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="664.5" cy="147.5" rx="30" ry="30" />
	<text x="659.5" y="153.5" font-family="Times New Roman" font-size="20">d</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="498.5" cy="218.5" rx="30" ry="30" />
	<text x="494.5" y="224.5" font-family="Times New Roman" font-size="20">e</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="294.5" cy="218.5" rx="30" ry="30" />
	<text x="291.5" y="224.5" font-family="Times New Roman" font-size="20">f</text>
	<ellipse stroke="black" stroke-width="1" fill="none" cx="137.5" cy="159.5" rx="30" ry="30" />
	<text x="133.5" y="165.5" font-family="Times New Roman" font-size="20">a</text>
	<polygon stroke="black" stroke-width="1" points="324.5,68.5 468.5,68.5" />
	<text x="391.5" y="89.5" font-family="Times New Roman" font-size="20">4</text>
	<polygon stroke="black" stroke-width="1" points="636.917,159.298 526.083,206.702" />
	<text x="566.5" y="173.5" font-family="Times New Roman" font-size="20">2</text>
	<polygon stroke="black" stroke-width="1" points="163.455,144.456 268.545,83.544" />
	<text x="220.5" y="135.5" font-family="Times New Roman" font-size="20">1</text>
	<polygon stroke="black" stroke-width="1" points="498.5,188.5 498.5,98.5" />
	<text x="503.5" y="149.5" font-family="Times New Roman" font-size="20">3</text>
	<polygon stroke="black" stroke-width="1" points="294.5,188.5 294.5,98.5" />
	<text x="299.5" y="149.5" font-family="Times New Roman" font-size="20">1</text>
</svg>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>4 Proof of Correctness</b><br />
Why does this algorithm find a minimum spanning tree? Before we can answer that, let’s define some terms and prove some lemma that will be useful in the main proof. Let <script type="math/tex">G=(V,E)</script> be the graph below and let <script type="math/tex">S</script> be the set of yellow edges in <script type="math/tex">G</script>.</p>

<p><img src="http://localhost:4000/assets/cut.png" alt="my photo" /></p>

<ul>
  <li>A <b>cut</b> is a partition of the vertices into two non-empty parts. the red line (cut) partitions <script type="math/tex">G</script> into <script type="math/tex">\{a,b,f,e\}</script> and <script type="math/tex">\{c,d\}</script>.</li>
  <li>A cut <b>respects</b> <script type="math/tex">S</script> if no edges in <script type="math/tex">S</script> cross the cut. None of the yellow edges cross the red cut.</li>
  <li>An edge crossing the cut is called <b>light</b> if it has the smallest weight of any edge crossing the cut. In this case, <script type="math/tex">\{e,d\}</script> is a light edge.</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>Lemma: Let <script type="math/tex">S</script> be a set of edges and consider a cut that respects <script type="math/tex">S</script>. Suppose there is an MST containing <script type="math/tex">S</script>. Let <script type="math/tex">\{u,v\}</script> be a light edge. Then there is an MST containing <script type="math/tex">S \cup \{u,v\}</script></td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> Let <script type="math/tex">S</script> be a set of edges and and consider a cut that respects <script type="math/tex">S</script>. Let <script type="math/tex">T</script> be an MST containing <script type="math/tex">S</script>. Let <script type="math/tex">\{u,v\}</script> be a light edge. There are two cases. <br />
Case 1: <script type="math/tex">\{u,v\}</script> is in <script type="math/tex">T</script>, then we’re done. <br />
Case 2: <script type="math/tex">\{u,v\}</script> is not in <script type="math/tex">T</script>. By the definition of MST, adding <script type="math/tex">\{u,v\}</script> will create a cycle in <script type="math/tex">T</script>. Since the sets resulting from the cut must be non-empty. This means that we must have an edge that crosses the cut in <script type="math/tex">T</script>. Let that edge be <script type="math/tex">\{x,y\}</script>. Consider replacing <script type="math/tex">\{u,v\}</script> with <script type="math/tex">\{x,y\}</script> to produce the new tree <script type="math/tex">T'</script>. <script type="math/tex">T</script> is still an MST since we deleted <script type="math/tex">\{x,y\}</script>. <script type="math/tex">T'</script> has also a cost of at most the cost of <script type="math/tex">T</script> since {u,v} is a light edge. Therefore, <script type="math/tex">T'</script> is an MST which includes both <script type="math/tex">\{u,v\}</script> and <script type="math/tex">S</script> which is what we wanted to show. <script type="math/tex">\blacksquare</script>
<br /></p>

<table>
  <tbody>
    <tr>
      <td>Theorem: Prim will correctly find a minimum spanning tree</td>
    </tr>
  </tbody>
</table>

<p><i>Proof:</i> <br />
<b>Inductive Hypothesis: </b>After adding the <script type="math/tex">t</script>‘th edge, there exists an MST with the edges added so far.
<br /></p>

<p><b>Base Case: </b> After adding the 0’th edge, there exists an MST with the edges added so far.
<br />
<br />
<b>Inductive Step:</b> Suppose the inductive hypothesis holds for <script type="math/tex">t</script>. Let <script type="math/tex">S</script> be the set containing the edges added so far and so there is an MST extending them by the inductive hypothesis. Consider the cut <script type="math/tex">S</script> and <script type="math/tex">V-S</script>. This cut respects <script type="math/tex">S</script>. Prim adds the lightest edge crossing this cut. By the Lemma above that edge is safe to add. Therefore, there is still an MST extending the new set of edges.
<br />
<br />
<b>Conclusion:</b> After adding the <script type="math/tex">n-1</script>‘st edge, there exists an MST with the edges added so far. At this point we have reached all vertices and the <script type="math/tex">n-1</script> edges we have is an MST.<script type="math/tex">\blacksquare</script>
<br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
<b>5 Running Time:</b> <br />
The analysis is exactly like Dijkstra!. What are we doing in this algorithm? For each vertex in the unreached list, we <br />
(1) find the minimum vertex. <br />
(2) remove that vertex. <br />
(3) update all neighbors with lower key values if possible.<br />
<br />
Therefore we see that if we have <script type="math/tex">n</script> vertices and <script type="math/tex">m</script> edges:</p>
<div center="">
$$
\begin{align*}
TotalTime &amp;= \sum_{u \in V} \big\{ T(findMin) + \big(\sum_{v \in u.neighbors} T(updateKey)\big) + T(removeMin) \big\} \\
&amp;= n(T(findMin) + T(removeMin)) + m(T(updateKey))

\end{align*}
$$
</div>
<p>Now it is clear that it really depends on how we implement the list that holds the not-sure nodes. Let’s consider different data structures</p>
<ul>
  <li>Arrays
    <ul>
      <li>findMin will run in <script type="math/tex">O(n)</script></li>
      <li>RemoveMin will run in <script type="math/tex">O(n)</script></li>
      <li>UpdateKey will run in <script type="math/tex">O(1)</script><br />
Therefore, the total time will be <script type="math/tex">O(n(2n) + m) = O(n^2 + m) = O(n^2)</script></li>
    </ul>
  </li>
  <li>Red Black Tree
    <ul>
      <li>findMin will run in <script type="math/tex">O(\log(n))</script></li>
      <li>RemoveMin will run in <script type="math/tex">O(\log(n))</script></li>
      <li>UpdateKey will run in <script type="math/tex">O(\log(n))</script><br />
Therefore, the total time will be <script type="math/tex">O(n\log(n) + m\log(n)) = O((n+m)\log(n))</script>. <br />
Notice here, if the graph is dense, meaning that <script type="math/tex">m=O(n^2)</script>, then this is worse than arrays! if it’s sparse, then it’s better.</li>
    </ul>
  </li>
  <li>Fibonacci Heaps
    <ul>
      <li>findMin will run in <script type="math/tex">O(1)</script>, amortized time.</li>
      <li>RemoveMin will run in <script type="math/tex">O(\log(n))</script>, amortized time.</li>
      <li>UpdateKey will run in <script type="math/tex">O(1)</script>, amortized time.<br />
Therefore, the total time will be <script type="math/tex">O(n\log(n) + m)</script>, amortized time. <br />
<br />
<!------------------------------------------------------------------------------------></li>
    </ul>
  </li>
</ul>
<hr />

<p><br />
<b>6 Detailed Implementation:</b> <br />
https://github.com/strncat/algorithms-and-data-structures/tree/master/graphs/minimum-spanning-trees/prim</p>

<p><br />
<!------------------------------------------------------------------------------------></p>
<hr />

<p><br />
References: These notes are based on the awesome lecture notes from http://web.stanford.edu/class/cs161/schedule.html</p>


  </div><a class="u-url" href="/jekyll/update/2019/04/02/prim.html" hidden></a>
</article>

      </div>
    </main>

    <!--<footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">strncat&#39;s notebook</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">strncat&#39;s notebook</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Hello.</p>
      </div>
    </div>

  </div>

</footer>
-->

  </body>

</html>
