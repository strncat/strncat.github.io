<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-01-16T16:13:44-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">nemo’s notebook</title><subtitle>personal study notes</subtitle><entry><title type="html">Project Euler: 35 Circular Primes</title><link href="http://localhost:4000/jekyll/update/2025/01/15/project-euler-35-circular-primes.html" rel="alternate" type="text/html" title="Project Euler: 35 Circular Primes" /><published>2025-01-15T00:01:36-08:00</published><updated>2025-01-15T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/15/project-euler-35-circular-primes</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/15/project-euler-35-circular-primes.html"><![CDATA[<p>A prime is circular if all rotations of the digits are prime. For example, the rotations of 197 are 197, 971 and 719. All of the rotations are prime numbers so 197 is a circular prime. In this problem, we want to find the number of circular primes below 1 million. To start, we need a method to check if a number is prime. We can re-use the sieve method we did for problem 7 and generate all prime numbers under 1 million.
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">prime</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">prime_numbers</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">prime</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">prime</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">prime_numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>The next thing we want to do is to generate all possible rotations of a given a number. To do so, consider the number \(p=197\). The umber of digits in 197 is \(n = 3\) so we have a total of 3 rotations (197, 719, 971). to generate these, iterate 3 times where in each iteration, extract and remove the last digit and then multiply it by \(10^{n-1}\) and add it back again to \(p\). In this example, the last digit is 7. We will then add \(7 \times (10^{n-1}) = 7 \times 100 = 700\) to \(19\) to get \(719\).
<br />
<br />
Another example is 1793. We will extract 3 and remove it by dividing by 10 to get 179. We then will add \(3 \times 1000 = 3000\) to \(179\) to get \(3179\) which is the next rotation of \(1793\). In the next iteration, we will again extract \(9\) and add \(9000\) to \(317\) to generate the next rotation \(9317\). At any point of time during these iterations, if a rotation happens to be non-prime, then we exit and return false in
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">count_digits</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">n</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">d</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="nf">is_circular</span><span class="p">(</span><span class="kt">int</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// we want to rotate the digits n times where n is the number of digits</span>
    <span class="c1">// so 197 -&gt; 719 -&gt; 971</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">count_digits</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">p</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span> <span class="c1">// save the last digit d</span>
        <span class="n">p</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// git rid of d in p</span>
        <span class="n">p</span> <span class="o">+=</span> <span class="n">d</span><span class="o">*</span><span class="n">m</span><span class="p">;</span> <span class="c1">// add the last digit*m to p</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prime</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// not a circular number</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p>Finally, we can call this method to check again the primes we generated earlier. I did try using an optimization where I save the rotations in a map in order to avoid generating them again but that didn’t save much time and made the code look more complicated so I removed it. The entire naive solution rain in 0.0094 seconds time on my M1 mac.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">sieve</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// There are 4 primes &lt; 10</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">prime_numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// prime_numbers[4] = 11</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">prime_numbers</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_circular</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"total count = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=35">Project Euler - 35</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[A prime is circular if all rotations of the digits are prime. For example, the rotations of 197 are 197, 971 and 719. All of the rotations are prime numbers so 197 is a circular prime. In this problem, we want to find the number of circular primes below 1 million. To start, we need a method to check if a number is prime. We can re-use the sieve method we did for problem 7 and generate all prime numbers under 1 million. int prime[N]; std::vector&lt;int&gt; prime_numbers; void sieve() { // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { prime[i] = 1; } prime[0] = prime[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (prime[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { prime[i] = 0; } } } for (int i = 0; i &lt; N; i++) { if (prime[i]) { prime_numbers.push_back(i); } } } The next thing we want to do is to generate all possible rotations of a given a number. To do so, consider the number \(p=197\). The umber of digits in 197 is \(n = 3\) so we have a total of 3 rotations (197, 719, 971). to generate these, iterate 3 times where in each iteration, extract and remove the last digit and then multiply it by \(10^{n-1}\) and add it back again to \(p\). In this example, the last digit is 7. We will then add \(7 \times (10^{n-1}) = 7 \times 100 = 700\) to \(19\) to get \(719\). Another example is 1793. We will extract 3 and remove it by dividing by 10 to get 179. We then will add \(3 \times 1000 = 3000\) to \(179\) to get \(3179\) which is the next rotation of \(1793\). In the next iteration, we will again extract \(9\) and add \(9000\) to \(317\) to generate the next rotation \(9317\). At any point of time during these iterations, if a rotation happens to be non-prime, then we exit and return false in int count_digits(int n) { int d = 0; while (n &gt; 0) { n /= 10; d++; } return d; } bool is_circular(int p) { // we want to rotate the digits n times where n is the number of digits // so 197 -&gt; 719 -&gt; 971 int n = count_digits(p); int m = pow(10, n-1); for (int i = 0; i &lt; n; i++) { int d = p%10; // save the last digit d p /= 10; // git rid of d in p p += d*m; // add the last digit*m to p if (!prime[p]) { return false; // not a circular number } } return true; } Finally, we can call this method to check again the primes we generated earlier. I did try using an optimization where I save the rotations in a map in order to avoid generating them again but that didn’t save much time and made the code look more complicated so I removed it. The entire naive solution rain in 0.0094 seconds time on my M1 mac. sieve(); int count = 4; // There are 4 primes &lt; 10 for (int i = 4; i &lt; prime_numbers.size(); i++) { // prime_numbers[4] = 11 int p = prime_numbers[i]; if (is_circular(p)) { count++; } } printf("total count = %d\n", count); References Project Euler - 35]]></summary></entry><entry><title type="html">Project Euler: 34 Digit Factorials</title><link href="http://localhost:4000/jekyll/update/2025/01/14/project-euler-34-digit-factorials.html" rel="alternate" type="text/html" title="Project Euler: 34 Digit Factorials" /><published>2025-01-14T00:01:36-08:00</published><updated>2025-01-14T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/14/project-euler-34-digit-factorials</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/14/project-euler-34-digit-factorials.html"><![CDATA[<p>In this one, we want the sum of all numbers such that each number’s digit factorials add up to the number itself. For example</p>
<div>
	$$
	\begin{align*}
	 145 = 1! + 4! + 5!
	\end{align*}
	$$
</div>
<p>We are told not to include the trivial cases \(1! = 1\) and \(2! = 2\) since they are not sums. We are also not given any upper bound. As a guess, we can observe that \(9! * 10 = 3628800\). So a number consisting of 10 digits will at most be 3628800. I tried this upper limit and it was fine. One thing we want to do is to pre-calculate the factorials for all digits a head of time in</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">f</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">calc_factorial</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>The rest is all simple</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">calc_factorial</span><span class="p">();</span>
    <span class="c1">// 9! * 10 = 3628800</span>
    <span class="c1">// 0! + 0! + 0! + 1! + 1! = 2</span>
    <span class="kt">int</span> <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">3628800</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">num</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">d</span><span class="p">];</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=34">Project Euler - 34</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this one, we want the sum of all numbers such that each number’s digit factorials add up to the number itself. For example $$ \begin{align*} 145 = 1! + 4! + 5! \end{align*} $$ We are told not to include the trivial cases \(1! = 1\) and \(2! = 2\) since they are not sums. We are also not given any upper bound. As a guess, we can observe that \(9! * 10 = 3628800\). So a number consisting of 10 digits will at most be 3628800. I tried this upper limit and it was fine. One thing we want to do is to pre-calculate the factorials for all digits a head of time in int f[10]; void calc_factorial() { f[0] = 1; f[1] = 1; for (int i = 2; i &lt; 10; i++) { f[i] = i * f[i-1]; } } The rest is all simple int main(int argc, const char * argv[]) { calc_factorial(); // 9! * 10 = 3628800 // 0! + 0! + 0! + 1! + 1! = 2 int total_sum = 0; for (long long n = 3; n &lt;= 3628800; n++) { long long sum = 0; long long num = n; while (num &gt; 0 &amp;&amp; sum &lt;= n) { int d = num%10; int p = f[d]; sum += p; num /= 10; } if (sum == n) { total_sum += sum; } } printf("%d\n", total_sum); return 0; } References Project Euler - 34]]></summary></entry><entry><title type="html">Project Euler: 30 Digit Fifth Powers</title><link href="http://localhost:4000/jekyll/update/2025/01/13/project-euler-30-digit-fifth-powers.html" rel="alternate" type="text/html" title="Project Euler: 30 Digit Fifth Powers" /><published>2025-01-13T00:01:36-08:00</published><updated>2025-01-13T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/13/project-euler-30-digit-fifth-powers</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/13/project-euler-30-digit-fifth-powers.html"><![CDATA[<p>This was not bad! the minimum number that can be written as a sum of its 5th digits powers is</p>
<div>
	$$
	\begin{align*}
	 2 = 0^5 + 0^5 + 0^5 + 1^5 + 1^5.
	\end{align*}
	$$
</div>
<p>while the maximum number that can be written as a sum of its 5th digits powers is</p>
<div>
	$$
	\begin{align*}
	 295245 = 9^5 + 9^5 + 9^5 + 9^5 + 9^5.
	\end{align*}
	$$
</div>
<p>So let’s check all the numbers in this range</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">// 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 5*9^5 = 295,245</span>
<span class="c1">// 0^5 + 0^5 + 0^5 + 1^5 + 1^5 = 2</span>
<span class="kt">int</span> <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">295245</span><span class="p">;</span> <span class="n">n</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">num</span><span class="o">%</span><span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pow</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">p</span><span class="p">;</span>
        <span class="n">num</span> <span class="o">/=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">==</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=30">Project Euler - 30</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This was not bad! the minimum number that can be written as a sum of its 5th digits powers is $$ \begin{align*} 2 = 0^5 + 0^5 + 0^5 + 1^5 + 1^5. \end{align*} $$ while the maximum number that can be written as a sum of its 5th digits powers is $$ \begin{align*} 295245 = 9^5 + 9^5 + 9^5 + 9^5 + 9^5. \end{align*} $$ So let’s check all the numbers in this range // 9^5 + 9^5 + 9^5 + 9^5 + 9^5 = 5*9^5 = 295,245 // 0^5 + 0^5 + 0^5 + 1^5 + 1^5 = 2 int total_sum = 0; for (int n = 2; n &lt;= 295245; n++) { long sum = 0; int num = n; while (num &gt; 0 &amp;&amp; sum &lt;= n) { int d = num%10; int p = pow(d, 5); sum += p; num /= 10; } if (sum == n) { total_sum += sum; } } printf("%d\n", total_sum); References Project Euler - 30]]></summary></entry><entry><title type="html">Project Euler: 28 Number Spiral Diagonals</title><link href="http://localhost:4000/jekyll/update/2025/01/12/project-euler-28-number-spiral-diagonals.html" rel="alternate" type="text/html" title="Project Euler: 28 Number Spiral Diagonals" /><published>2025-01-12T00:01:36-08:00</published><updated>2025-01-12T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/12/project-euler-28-number-spiral-diagonals</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/12/project-euler-28-number-spiral-diagonals.html"><![CDATA[<p>My first solution was just to sum the numbers across the diagonals after breaking them into 4 parts.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/1.png" width="90%" class="center" /></p>
<p>We can come up with a formula for the yellow cells for example by observing that the difference between the cells follow a pattern.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/2.png" width="80%" class="center" /></p>
<p>You can see above that the difference between the cells keeps increasing by 8 each time we move up. Similarly, we can find that the other 3 parts follow a similar pattern. For example, we can see that the difference between the cells below also increases by 8. The only difference between the green cells and the yellow cells is that the initial difference here is 9 while it was 7 for the yellow cells.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/3.png" width="80%" class="center" /></p>
<p>Similarly, the difference between the blue cells also increase by 8 but the initial difference is 3 here.</p>
<p style="text-align:center;"><img src="http://localhost:4000/assets/competitive-programming/project-euler/28/4.png" width="80%" class="center" /></p>
<p>So we can come up with the following function that takes the initial cell value and the initial difference and then returns the total sum. Since the grid is \(1001 \times 10001\), then each quadrant will contain 500 cells.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">sum_quadrant</span><span class="p">(</span><span class="kt">int</span> <span class="n">cell</span><span class="p">,</span> <span class="kt">int</span> <span class="n">diff</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">add</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">500</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">cell</span><span class="p">;</span> <span class="c1">// add the cell value</span>
        <span class="n">cell</span> <span class="o">+=</span> <span class="n">diff</span><span class="p">;</span> <span class="c1">// cell value will increase by the diff</span>
        <span class="n">diff</span> <span class="o">+=</span> <span class="n">add</span><span class="p">;</span> <span class="c1">// the diff will increase by 8 each iteration</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
We now can use the above method to print the total.
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">long</span> <span class="n">total_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">);</span> <span class="c1">// Top Left Diagonal</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span> <span class="c1">// Top Right Diagonal</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span> <span class="c1">// Bottom Right Diagonal</span>
<span class="n">total_sum</span> <span class="o">+=</span> <span class="n">sum_quadrant</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span> <span class="c1">// Bottom Left Diagonal</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%ld</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span></code></pre></figure>

<p><br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>Closed Formula</b></h4>
<p>Of course my naive solution was too basic and it seems that there is a closed formula for this … I have yet to do it! [TODO]
<br />
<br /></p>
<hr />

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=27">Project Euler - 27</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[My first solution was just to sum the numbers across the diagonals after breaking them into 4 parts. We can come up with a formula for the yellow cells for example by observing that the difference between the cells follow a pattern. You can see above that the difference between the cells keeps increasing by 8 each time we move up. Similarly, we can find that the other 3 parts follow a similar pattern. For example, we can see that the difference between the cells below also increases by 8. The only difference between the green cells and the yellow cells is that the initial difference here is 9 while it was 7 for the yellow cells. Similarly, the difference between the blue cells also increase by 8 but the initial difference is 3 here. So we can come up with the following function that takes the initial cell value and the initial difference and then returns the total sum. Since the grid is \(1001 \times 10001\), then each quadrant will contain 500 cells. int sum_quadrant(int cell, int diff) { int add = 8, sum = 0; for (int i = 1; i &lt;= 500; i++) { sum += cell; // add the cell value cell += diff; // cell value will increase by the diff diff += add; // the diff will increase by 8 each iteration } return sum; } We now can use the above method to print the total. long total_sum = 0; total_sum += sum_quadrant(7, 14); // Top Left Diagonal total_sum += sum_quadrant(9, 16); // Top Right Diagonal total_sum += sum_quadrant(3, 10); // Bottom Right Diagonal total_sum += sum_quadrant(5, 12); // Bottom Left Diagonal printf("%ld\n", total_sum + 1); Closed Formula Of course my naive solution was too basic and it seems that there is a closed formula for this … I have yet to do it! [TODO] References Project Euler - 27]]></summary></entry><entry><title type="html">Project Euler: 27 Quadratic Primes</title><link href="http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes.html" rel="alternate" type="text/html" title="Project Euler: 27 Quadratic Primes" /><published>2025-01-11T00:01:36-08:00</published><updated>2025-01-11T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/11/project-euler-27-quadratic-primes.html"><![CDATA[<p>I was so scared when I read the problem description! so I was shocked when I just got this on the first try. Admittedly, my solution is just the naive solution but it was fast enough. Basically we want to know \(a\) and \(b\) that will make the equation \(f(n) = n^2 + an + b\) produce the longest sequence of prime numbers. To do so, we need a fast way to check whether a number is prime. For that we can just borrow the sieve algorithm we implemented for problem 7.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><br />
After this, it is pretty straight forward. Just check all possible the values for \(a\) and \(b\). Both variables will range from -999 to 999.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">sieve</span><span class="p">();</span>
<span class="kt">int</span> <span class="n">max_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">max_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">;</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">a</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="o">-</span><span class="mi">999</span><span class="p">;</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">b</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// f(n) = n^2 + an + b</span>
        <span class="c1">// f(0) = b is the initial value</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">fn</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">primes</span><span class="p">[</span><span class="n">fn</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">count</span><span class="o">++</span><span class="p">;</span>
            <span class="n">n</span><span class="o">++</span><span class="p">;</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">n</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">max_count</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">max_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
            <span class="n">max_a</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="n">max_b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"a = %d, b = %d, a*b = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max_a</span><span class="p">,</span> <span class="n">max_b</span><span class="p">,</span> <span class="n">max_a</span> <span class="o">*</span> <span class="n">max_b</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=27">Project Euler - 27</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I was so scared when I read the problem description! so I was shocked when I just got this on the first try. Admittedly, my solution is just the naive solution but it was fast enough. Basically we want to know \(a\) and \(b\) that will make the equation \(f(n) = n^2 + an + b\) produce the longest sequence of prime numbers. To do so, we need a fast way to check whether a number is prime. For that we can just borrow the sieve algorithm we implemented for problem 7. void sieve() { int s[N]; // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { primes[i] = 1; } s[0] = s[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (primes[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { primes[i] = 0; } } } } After this, it is pretty straight forward. Just check all possible the values for \(a\) and \(b\). Both variables will range from -999 to 999. sieve(); int max_count = 0, max_a = 0, max_b = 0; for (int a = -999; a &lt; 1000; a++) { for (int b = -999; b &lt; 1000; b++) { // f(n) = n^2 + an + b // f(0) = b is the initial value int n = 0; int fn = b; int count = 0; while (primes[fn]) { count++; n++; fn = n*n + a*n + b; } if (count &gt; max_count) { max_count = count; max_a = a; max_b = b; } } } printf("a = %d, b = %d, a*b = %d\n", max_a, max_b, max_a * max_b); References Project Euler - 27]]></summary></entry><entry><title type="html">Project Euler: 7 10001st Prime</title><link href="http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime.html" rel="alternate" type="text/html" title="Project Euler: 7 10001st Prime" /><published>2025-01-10T00:01:36-08:00</published><updated>2025-01-10T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/10/project-euler-07-10001st-prime.html"><![CDATA[<p>This is just Sieve’s algorithm to find all primes until we reach the 10001st prime. I don’t know know if there is a faster algorithm to do this.
In Sieve’s algorithm, we mark all numbers up to our limit \(N\) as potential primes. Then starting at 2, we mark all multiples of 2 as non prime. When we’re done, we move to the next potenial prime and repeat the same process.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define N 1000000
</span><span class="kt">int</span> <span class="n">primes</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="kt">void</span> <span class="nf">sieve</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
    <span class="c1">// mark all numbers as potential primes</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">// mark all multiples of p as not prime</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">primes</span><span class="p">[</span><span class="n">index</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// the 10001st prime is primes[10000]</span>
<span class="p">}</span></code></pre></figure>

<p><br />
This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm).
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=7">Project Euler - 07</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[This is just Sieve’s algorithm to find all primes until we reach the 10001st prime. I don’t know know if there is a faster algorithm to do this. In Sieve’s algorithm, we mark all numbers up to our limit \(N\) as potential primes. Then starting at 2, we mark all multiples of 2 as non prime. When we’re done, we move to the next potenial prime and repeat the same process. #define N 1000000 int primes[N]; void sieve() { int s[N]; // mark all numbers as potential primes for (int i = 0; i &lt; N; i++) { s[i] = 1; } s[0] = s[1] = 0; int limit = sqrt(N); for (int p = 2; p &lt;= limit; p++) { if (s[p]) { // mark all multiples of p as not prime for (int i = p*p; i &lt; N; i += p) { s[i] = 0; } } } int index = 0; for (int i = 0; i &lt; N; i++) { if (s[i] == 1) { primes[index++] = i; } } // the 10001st prime is primes[10000] } This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm). References Project Euler - 07]]></summary></entry><entry><title type="html">Project Euler: 8 Largest Product in a Series</title><link href="http://localhost:4000/jekyll/update/2025/01/09/project-euler-08-largest-product-in-a-series.html" rel="alternate" type="text/html" title="Project Euler: 8 Largest Product in a Series" /><published>2025-01-09T00:01:36-08:00</published><updated>2025-01-09T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/09/project-euler-08-largest-product-in-a-series</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/09/project-euler-08-largest-product-in-a-series.html"><![CDATA[<p>I did this the naive way of just iterating through the numbers and calculating the product of 13 numbers from every possible position, so the product starting at position 0, 1, 2 etc.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"</span><span class="p">;</span>

<span class="c1">// Find the thirteen adjacent digits in the 1000-digit number that have the greatest product.</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="kt">int</span> <span class="n">max_product</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">()</span><span class="o">-</span><span class="mi">13</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">product</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">13</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">product</span> <span class="o">*=</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">]</span><span class="o">-</span><span class="sc">'0'</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">product</span> <span class="o">&gt;</span> <span class="n">max_product</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">max_product</span> <span class="o">=</span> <span class="n">product</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"max product = %llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">max_product</span><span class="p">);</span></code></pre></figure>

<p><br />
This isn’t the best solution to this problem. One solution I’ve seen is tokenizing this string on “0” because any product that involves zero will not be the maximum product and you are better off starting at the position right after 0. So now you have \(n\) substrings with no zeros. You can now multiply the first 13 digits and then in each subsequent iteration, you will either have to reset the product since you’ve arrived at a new substring or you will need to multiply by the new number and divide by the first very digit (sliding window kind of algorithm).
<br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=8">Project Euler - 08</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[I did this the naive way of just iterating through the numbers and calculating the product of 13 numbers from every possible position, so the product starting at position 0, 1, 2 etc. std::string s = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";]]></summary></entry><entry><title type="html">Project Euler: 15 Lattice Paths</title><link href="http://localhost:4000/jekyll/update/2025/01/08/project-euler-15-lattice-paths.html" rel="alternate" type="text/html" title="Project Euler: 15 Lattice Paths" /><published>2025-01-08T00:01:36-08:00</published><updated>2025-01-08T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/08/project-euler-15-lattice-paths</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/08/project-euler-15-lattice-paths.html"><![CDATA[<p>We have a grid of size \(20 \times 20\). We can reach the last step in 40 exactly steps. 20 of these steps must be down steps and the other 20 must be right steps. So we have a sequence of 40 steps total and we want to find all possible sequences of these steps. Suppose we first chose the down steps in the configuration below</p>
<div>
<table style="max-width: 500px; margin: 20px auto;">
  <tr>
    <td>1</td>
    <td>2</td>
    <td>3</td>
	<td>4</td>
	<td>5</td>
    <td>6</td>
    <td>7</td>
    <td>8</td>
	<td>9</td>
	<td>10</td>
    <td>11</td>
    <td>12</td>
	<td>13</td>
    <td>14</td>
    <td>15</td>
    <td>16</td>
	<td>...</td>
  </tr>
  <tr>
    <td>D</td>
    <td> </td>
    <td>D</td>
	<td>D</td>
	<td> </td>
    <td> </td>
    <td>D</td>
    <td>D</td>
	<td> </td>
	<td>D</td>
    <td> </td>
    <td>D</td>
	<td>D</td>
    <td> </td>
    <td>D</td>
    <td>D</td>
	<td>...</td>
  </tr>
</table>
</div>
<p>So steps 1,3,4,7,8 … all are down steps. Then, automatically we know that the rest of the steps are just right steps. So once we determine the right steps, we’re done. The remaining steps will be down steps. So we’re only choosing 20 of the 40 steps. The number of ways to choose 20 steps out of 40 is given by the binomial coefficient.</p>
<div>
	$$
	\begin{align*}
	\binom{40}{20} = \frac{40!}{20!20!}
	\end{align*}
	$$
</div>
<!------------------------------------------------------------------------------------>
<h4><b>A Dynamic Programming Solution</b></h4>
<p>Another way to do this problem is with dynamic programming. Why do it this way? maybe just to practice? Suppose we’re at very last step. We could have come from the step above or the step to the left. Let ways\([i][j]\) be a matrix representing the numbers. So the number of the ways to generate the sequence of 40 steps is the sum of all ways if came from a step above plus all the ways if we came from a step on the left. Therefore, we naturally have a recurrence that we can implement below</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ways</span><span class="p">[</span><span class="mi">25</span><span class="p">][</span><span class="mi">25</span><span class="p">];</span>
<span class="n">memset</span><span class="p">(</span><span class="n">ways</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ways</span><span class="p">));</span>
<span class="n">ways</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">ways</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">ways</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">ways</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"reach(21,21) in %llu steps</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">ways</span><span class="p">[</span><span class="mi">21</span><span class="p">][</span><span class="mi">21</span><span class="p">]);</span></code></pre></figure>

<p><br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=16">Project Euler - 16</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[We have a grid of size \(20 \times 20\). We can reach the last step in 40 exactly steps. 20 of these steps must be down steps and the other 20 must be right steps. So we have a sequence of 40 steps total and we want to find all possible sequences of these steps. Suppose we first chose the down steps in the configuration below 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 ... D D D D D D D D D D ... So steps 1,3,4,7,8 … all are down steps. Then, automatically we know that the rest of the steps are just right steps. So once we determine the right steps, we’re done. The remaining steps will be down steps. So we’re only choosing 20 of the 40 steps. The number of ways to choose 20 steps out of 40 is given by the binomial coefficient. $$ \begin{align*} \binom{40}{20} = \frac{40!}{20!20!} \end{align*} $$ A Dynamic Programming Solution Another way to do this problem is with dynamic programming. Why do it this way? maybe just to practice? Suppose we’re at very last step. We could have come from the step above or the step to the left. Let ways\([i][j]\) be a matrix representing the numbers. So the number of the ways to generate the sequence of 40 steps is the sum of all ways if came from a step above plus all the ways if we came from a step on the left. Therefore, we naturally have a recurrence that we can implement below unsigned long long ways[25][25]; memset(ways, 0, sizeof(ways)); ways[0][0] = 0; ways[1][0] = 1; ways[0][1] = 0; for (int i = 1; i &lt; 25; i++) { for (int j = 1; j &lt; 25; j++) { ways[i][j] = ways[i-1][j] + ways[i][j-1]; } } printf("reach(21,21) in %llu steps\n", ways[21][21]); References Project Euler - 16]]></summary></entry><entry><title type="html">Project Euler: 16 Power Digit Sum</title><link href="http://localhost:4000/jekyll/update/2025/01/07/project-euler-16-power-digit-sum.html" rel="alternate" type="text/html" title="Project Euler: 16 Power Digit Sum" /><published>2025-01-07T00:01:36-08:00</published><updated>2025-01-07T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/07/project-euler-16-power-digit-sum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/07/project-euler-16-power-digit-sum.html"><![CDATA[<p>In this one, we want to find the sum of the digits of \(2^{1000}\). I did this naively where I just multiply by 2 every iteration until we reach \(2^{1000}\). Of course to do so in c\(++\), we need to use arrays. Let <i>s</i> hold the result and initialize to 2. Then
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="p">],</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">memset</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="p">));</span>
<span class="n">s</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// multiply 2</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="n">carry</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">carry</span><span class="p">;</span>
        <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
Finally, we just need to sum the digits
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=16">Project Euler - 16</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this one, we want to find the sum of the digits of \(2^{1000}\). I did this naively where I just multiply by 2 every iteration until we reach \(2^{1000}\). Of course to do so in c\(++\), we need to use arrays. Let s hold the result and initialize to 2. Then int s[N], carry = 0; memset(s, 0, sizeof(s)); s[N-1] = 2; for (int m = 1; m &lt; 1000; m++) { // multiply 2 int i = N-1; for (; i &gt;= 0; i--) { int sum = s[i] * 2; s[i] = (sum + carry) % 10; carry = sum / 10; } s[i] += carry; carry = 0; } } Finally, we just need to sum the digits int sum = 0; for (int i = 0; i &lt; N; i++) { sum += s[i]; } printf("sum = %d\n", sum); References Project Euler - 16]]></summary></entry><entry><title type="html">Project Euler: 20 Factorial Digit Sum</title><link href="http://localhost:4000/jekyll/update/2025/01/06/project-euler-20-factorial-digit-sum.html" rel="alternate" type="text/html" title="Project Euler: 20 Factorial Digit Sum" /><published>2025-01-06T00:01:36-08:00</published><updated>2025-01-06T00:01:36-08:00</updated><id>http://localhost:4000/jekyll/update/2025/01/06/project-euler-20-factorial-digit-sum</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2025/01/06/project-euler-20-factorial-digit-sum.html"><![CDATA[<p>In this one, we want to find the sum of all the digits in the number \(100!\). I did this naively where I just calculate</p>
<div>
	$$
	\begin{align*}
	 100! = 100 \times 99 \times 98 \times ... \times 1
	\end{align*}
	$$
</div>
<p>But of course at least in c\(++\), we’ll need an array to hold the sum. Let <i>result</i> be the array that will hold the final outcome. Before iterating, we’ll store \(24 = 4 \times 3 \times 2 \times 1\) in <i>result</i>. The choice here is arbitrary. We’ll save the least significant digit at index 0. So in <i>result</i>, index 0 will hold the digit 4 and index 1 will hold the digit 2. We’ll also use an array \(a\) that will hold the number we’re going to multiply with. So for example \(a\) will be 5 in the next iteration since we want to calculate \(24 \times 5\). Then at each iteration we’ll do the following</p>
<ul>
	<li>Copy the array <i>result</i> into array \(b\).</li>
	<li>Add one to array \(a\).</li>
	<li>Multiply arrays \(a\) and \(b\) and save the outcome in <i>result</i>.</li>
</ul>
<!------------------------------------------------------------------------------------>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">;</span> <span class="n">num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// copy result to b</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">add_one</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
    <span class="n">multiply</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
The implementation of adding 1 to an array is pretty straight forward
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">add_one</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">an</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// least significant digit is at index 0</span>
    <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">an</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sum</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
We then have the implementation of multiply. This one needed a little more work but eventually it wasn’t too bad.
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">an</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bn</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// an + bn</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// least significant digit is at index 0</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">an</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">bn</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">product</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="kt">int</span> <span class="n">position</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">carry_position</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">product</span> <span class="o">+</span> <span class="n">result</span><span class="p">[</span><span class="n">position</span><span class="p">];</span>
            <span class="n">result</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">result</span><span class="p">[</span><span class="n">carry_position</span><span class="p">]</span> <span class="o">+=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<!------------------------------------------------------------------------------------>
<p><br />
Finally, we just need to sum the digits
<br />
<!------------------------------------------------------------------------------------></p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">sum</span> <span class="o">+=</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"sum = %d</span><span class="se">\n</span><span class="s">, "</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span></code></pre></figure>

<p><br />
<br />
<!------------------------------------------------------------------------------------></p>
<h4><b>References</b></h4>
<p><a href="https://projecteuler.net/problem=20">Project Euler - 20</a>
<br />
<br /></p>]]></content><author><name></name></author><category term="jekyll" /><category term="update" /><summary type="html"><![CDATA[In this one, we want to find the sum of all the digits in the number \(100!\). I did this naively where I just calculate $$ \begin{align*} 100! = 100 \times 99 \times 98 \times ... \times 1 \end{align*} $$ But of course at least in c\(++\), we’ll need an array to hold the sum. Let result be the array that will hold the final outcome. Before iterating, we’ll store \(24 = 4 \times 3 \times 2 \times 1\) in result. The choice here is arbitrary. We’ll save the least significant digit at index 0. So in result, index 0 will hold the digit 4 and index 1 will hold the digit 2. We’ll also use an array \(a\) that will hold the number we’re going to multiply with. So for example \(a\) will be 5 in the next iteration since we want to calculate \(24 \times 5\). Then at each iteration we’ll do the following Copy the array result into array \(b\). Add one to array \(a\). Multiply arrays \(a\) and \(b\) and save the outcome in result. for (int num = 5; num &lt;= 100; num++) { // copy result to b for (int i = 0; i &lt; N; i++) { b[i] = result[i]; } add_one(a, N); multiply(a, N, b, N, result); } The implementation of adding 1 to an array is pretty straight forward void add_one(int *a, int an) { // least significant digit is at index 0 a[0] += 1; for (int i = 0; i &lt; an; i++) { int sum = a[i]; if (sum &lt; 10) { break; } a[i] = sum % 10; a[i+1] += sum / 10; } } We then have the implementation of multiply. This one needed a little more work but eventually it wasn’t too bad. void multiply(int *a, int an, int *b, int bn, int *result) { for (int i = 0; i &lt; N; i++) { // an + bn result[i] = 0; } // least significant digit is at index 0 for (int i = 0; i &lt; an; i++) { for (int j = 0; j &lt; bn; j++) { int product = a[i] * b[j]; int position = i + j; int carry_position = i + j + 1; int sum = product + result[position]; result[position] = sum % 10; result[carry_position] += sum / 10; } } } Finally, we just need to sum the digits int sum = 0; for (int i = N-1; i &gt;= 0; i--) { sum += result[i]; } printf("sum = %d\n, ", sum); References Project Euler - 20]]></summary></entry></feed>